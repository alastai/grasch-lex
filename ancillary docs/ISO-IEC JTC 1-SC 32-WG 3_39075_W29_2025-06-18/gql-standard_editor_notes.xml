<EditorNotes>
<!--
1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
-->
<!-- ======================================= -->
<!-- Current PPs and LOs, not yet resolved   -->
<!-- ======================================= -->
<!--
   This is a list of all problems in the corresponding
   document that are not yet resolved.co

Possible
Problem
Number   Category
======= ==========

GQL-000  (pseudo-PP showing Editor's Notes convention)

GQL-004        *Opportunity*
GQL-005        *Opportunity*
GQL-011        *Opportunity*
GQL-012        *Opportunity*
GQL-017        *Opportunity*
GQL-025        *Opportunity*
GQL-030        *Opportunity*
GQL-032        *Opportunity*
GQL-034        *Opportunity*
GQL-035        *Opportunity*
GQL-036        *Opportunity*
GQL-044        *Opportunity*
GQL-052        *Opportunity*
GQL-053        *Opportunity*
GQL-054        *Opportunity*
GQL-055        *Opportunity*
GQL-056        *Opportunity*
GQL-057        *Opportunity*
GQL-161        *Opportunity*
GQL-162        *Opportunity*
GQL-163        *Opportunity*
GQL-168        *Opportunity*
GQL-169        *Opportunity*
GQL-176        *Opportunity*
GQL-177        *Opportunity*
GQL-181        *Opportunity*
GQL-185        *Opportunity*
GQL-186        *Opportunity*
GQL-194        *Opportunity*
GQL-196        *Opportunity*
GQL-197        *Opportunity*
GQL-212        *Opportunity*
GQL-213        *Opportunity*
GQL-217        *Opportunity*
GQL-218        *Opportunity*
GQL-221        *Opportunity*
GQL-222        *Opportunity*
GQL-223        *Opportunity*
GQL-224        *Opportunity*
GQL-225        *Opportunity*
GQL-226        *Opportunity*
GQL-227        *Opportunity*
GQL-229        *Opportunity*
GQL-231        *Opportunity*
GQL-233        *Opportunity*
GQL-234        *Opportunity*
GQL-235        *Opportunity*
GQL-237        *Opportunity*
GQL-241        *Opportunity*
GQL-242        *Opportunity*
GQL-243        *Opportunity*
GQL-244        *Opportunity*
GQL-245        *Opportunity*
GQL-246        *Opportunity*
GQL-247        *Opportunity*
GQL-248        *Opportunity*
GQL-250        *Opportunity*
GQL-279        *Opportunity*
GQL-281        *Opportunity*
GQL-282        *Opportunity*
GQL-283        *Opportunity*
GQL-285        *Opportunity*
GQL-288        *Opportunity*
GQL-301        *Opportunity*
GQL-304        *Opportunity*
GQL-306        *Opportunity*
GQL-308        *Opportunity*
GQL-309        *Opportunity*
GQL-310        *Opportunity*
GQL-319        *Opportunity*
GQL-325        *Opportunity*
GQL-328        *Opportunity*
GQL-329        *Opportunity*
GQL-330        *Opportunity*
GQL-336        *Opportunity*
GQL-340        *Opportunity*
GQL-341        *Opportunity*
GQL-342        *Opportunity*
GQL-343        *Opportunity*
GQL-344        *Opportunity*
GQL-345        *Opportunity*
GQL-346        *Opportunity*
GQL-347        *Opportunity*
GQL-348        *Opportunity*
GQL-349        *Opportunity*
GQL-350        *Opportunity*
GQL-353        *Opportunity*
GQL-354        *Opportunity*
GQL-355        *Opportunity*
GQL-356        *Opportunity*
GQL-358        *Opportunity*
GQL-359        *Opportunity*
GQL-362        *Opportunity*
GQL-364        *Opportunity*
GQL-365        *Opportunity*
GQL-366        *Opportunity*
GQL-367        *Opportunity*
GQL-368        *Opportunity*
GQL-369        *Opportunity*
GQL-370        *Opportunity*
GQL-371        *Opportunity*
GQL-373        *Opportunity*
GQL-374        *Opportunity*
GQL-375        *Opportunity*
GQL-376        *Opportunity*
GQL-377        *Opportunity*
GQL-378        *Opportunity*
GQL-379        *Opportunity*
GQL-380        *Opportunity*
GQL-381        *Opportunity*
GQL-382        *Opportunity*
GQL-383        *Opportunity*
GQL-388      *Minor Technical*
GQL-390      *Minor Technical*
GQL-392      *Minor Editorial*
GQL-393      *Minor Editorial*
GQL-394        *Opportunity*
GQL-395        *Opportunity*
GQL-396        *Opportunity*
GQL-397        *Opportunity*
GQL-398        *Opportunity*
GQL-399        *Opportunity*
GQL-400        *Opportunity*
GQL-401        *Opportunity*
GQL-402        *Opportunity*
GQL-406      *Minor Technical*
GQL-413        *Opportunity*
GQL-414        *Opportunity*
GQL-415      *Major Technical*
GQL-416      *Major Technical*
GQL-417      *Major Technical*
GQL-418        *Opportunity*
GQL-419        *Opportunity*
GQL-420        *Opportunity*
GQL-421        *Opportunity*
GQL-422        *Opportunity*
GQL-423      *Minor Technical*
GQL-425      *Minor Technical*
GQL-428      *Minor Technical*
GQL-429        *Opportunity*
GQL-432        *Opportunity*
GQL-433        *Opportunity*
GQL-434        *Opportunity*
GQL-436        *Opportunity*
GQL-437        *Opportunity*
GQL-438      *Major Technical*
GQL-440      *Minor Technical*
GQL-441      *Minor Technical*
GQL-442      *Minor Technical*
GQL-443        *Opportunity*
GQL-444     **Major Technical**
GQL-445        *Opportunity*
GQL-446        *Opportunity*
GQL-447        *Opportunity*
GQL-448        *Opportunity*
GQL-449        *Opportunity*

GQL-           *Opportunity*
GQL-        **Major Technical**
GQL-         *Minor Technical*
GQL-        **Major Editorial**
GQL-         *Minor Editorial*

======= Largest GQL Possible Problem number *** GQL-449 *** ========
=========== This is the end of the problem number list =============

-->


<!-- This is a template for Major Technical Possible Problems
     ========================================================

<PP id="PPgql" number="GQL-" severity="major" realm="technical">

<brief area="Area of functionality">One-line summary of Possible Problem</brief>

<reference><specref ref="gql_"/>. !! If no appropriate reference, then use: No specific location. !!
</reference>

<noteAt>!! If there are no Notes, then use: None. !!
</noteAt>

<source>!! Always give source. !!
</source>

<problem>

<para>
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>
-->

<!-- This is a template for minor technical Possible Problems
     ========================================================

<PP id="PPgql" number="GQL-" severity="minor" realm="technical">

<brief area="Area of functionality">One-line summary of Possible Problem</brief>

<reference><specref ref="gql_"/>. !! If no appropriate reference, then use: No specific location. !!
</reference>

<noteAt>!! If there are no Notes, then use: None. !!
</noteAt>

<source>!! Always give source. !!
</source>

<problem>

<para>
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>
-->

<!-- This is a template for Major Editorial Possible Problems
     ========================================================

<PP id="PPgql" number="GQL-" severity="major" realm="editorial">

<brief area="Area of functionality">One-line summary of Possible Problem</brief>

<reference><specref ref="gql_"/>. !! If no appropriate reference, then use: No specific location. !!
</reference>

<noteAt>!! If there are no Notes, then use: None. !!
</noteAt>

<source>!! Always give source. !!
</source>

<problem>

<para>
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>
-->

<!-- This is a template for minor editorial Possible Problems
     ========================================================

<PP id="PPgql" number="GQL-" severity="minor" realm="editorial">

<brief area="Area of functionality">One-line summary of Possible Problem</brief>

<reference><specref ref="gql_"/>. !! If no appropriate reference, then use: No specific location. !!
</reference>

<noteAt>!! If there are no Notes, then use: None. !!
</noteAt>

<source>!! Always give source. !!
</source>

<problem>

<para>
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>
-->

<!-- This is a template for Language Opportunities
     =============================================

<LO id="PPgql" number="GQL-" 
    kind="!! One of: new_feat port_feat feat_ext port_ext improv"
    size="!! One of: XS S M L XL">

<brief area="Area of functionality">One-line summary of Language Opportunity</brief>

<reference><specref ref="gql_"/>. !! If no appropriate reference, then use: No specific location. !!
</reference>

<noteAt>!! If there are no Notes, then use: None. !!
</noteAt>

<source>!! Always give source. !!
</source>

<since>!! Optional give date LO first created. !!
</since>

<problem>

<para>
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>
-->


<!--
    ============================================================================
-->

<comment>Not a real PP; merely documenting the Editor's Note convention</comment>
<PP id="PPgql000" number="GQL-000" severity="major" realm="technical">

<brief area="General">Editor<apos/>s Note convention</brief>

<reference>No specific location.
</reference>

<source>Your humble Editors.
</source>

<problem>

<para>In the body of the Working Draft, there occasionally appears a point that requires particular
attention, highlighted thus:
</para>

<para>Text of the problem.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<LO id="PPgql003" number="GQL-003" kind="new_feat" size="XL">

<brief area="System and execution model">Host language bindings
</brief>

<reference><specref ref="gql_conc_prcmd_procs"/>, <specref ref="gql_named_procedure_call"/>.
</reference>

<noteAt><specref ref="gql_PP003_procs"/>, <specref ref="gql_PP003_call"/>.
</noteAt>

<source>Editors, WG3:OHD-042, WG3:GYD-031.
</source>

<problem>

<para>It is a language opportunity to provide an annex, probably informative, that defines 
host language bindings that realize the abstract API defined in this document
for at least one widely used programming language <eg/> Java, C++, or Python).
This should include calling GQL procedures from the host language and
calling functions and/or procedures, which are written in this or another host language, 
from within GQL.
</para>

<para>Doing so will validate that the specification of the abstract API is complete and
sufficiently well-defined to enable language bindings to be defined.
</para>

</problem>

</LO>


<LO id="PPgql004" number="GQL-004" kind="new_feat" size="XL">

<brief area="Schema and metadata model">Information schema
</brief>

<comment>Editorial: Stefan Plantikow 2021-03-02 Converted to LO</comment>
<reference><specref ref="gql_ddl"/>.
</reference>

<noteAt><specref ref="gql_ddl"/>, <specref ref="gql_PP004"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The GQL schema and meta-graph need to be defined together with the statements to manipulate
it.
</para>

</problem>

</LO>


<LO id="PPgql005" number="GQL-005" kind="new_feat" size="XL">

<brief area="System and execution model">Security model
</brief>

<comment>Editorial: Stefan Plantikow 2021-03-02 Converted to LO</comment>
<reference>All Access Rule sections.
</reference>

<noteAt>None.
</noteAt>

<source>Editors, WG3:W12-012, WG3:BER-040R3.
</source>

<problem>

<para>The Security Model for GQL and related concepts such as roles need to be defined.
</para>

</problem>

</LO>


<LO id="PPgql011" number="GQL-011" kind="improv" size="L">

<brief area="Specification mechanics">Concept of deterministic predicates and 
expressions
</brief>

<reference><specref ref="gql_lexical"/>.
</reference>

<noteAt><specref ref="gql_PP011_2"/>,
<specref ref="gql_PP011_3"/>,
<specref ref="gql_PP011_4"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<comment>Editorial: Stefan Plantikow 2021-04-26 Converted to LO</comment>

<para>SQL pays a lot of attention as to whether an expression is deterministic or not, as this has
consequences for its use in constraints.
If GQL is to have a schema for graphs that includes constraints, then this will also need
considerable attention.
</para>

</problem>

</LO>


<LO id="PPgql012" number="GQL-012" kind="feat_ext" size="L">

<brief area="Data types and expressions">Full collation support
</brief>

<reference><specref ref="gql_comp"/>, <specref ref="gql_equality_ops"/>,
<specref ref="gql_ordering_ops"/>.
</reference>

<noteAt><specref ref="SQL_diff20"/>, <specref ref="SQL_diff18"/>, <specref ref="SQL_diff19"/>.
</noteAt>

<source>Editors, WG3:W21-058.
</source>

<problem>

<para>Consider explicit support for additional collations other than UCS_BASIC and UNICODE
(<eg/> case insensitive variants, use of alternative collation tables).
</para>
</problem>

</LO>


<LO id="PPgql017" number="GQL-017" kind="feat_ext" size="M">

<brief area="Data types and expressions">Improved aggregation support
</brief>

<comment>Editorial: Stefan Plantikow 2021-03-02 Reworded</comment>
<reference><specref ref="gql_stm_return"/>, <specref ref="gql_select"/>,
<specref ref="gql_group_by"/>, <specref ref="gql_aggregate_func"/>,
<specref ref="gql_valexpprim"/>.
</reference>

<noteAt><specref ref="gql_PP017_af"/>, <specref ref="gql_PP017_return"/>,
<specref ref="gql_PP017_select"/>, <specref ref="gql_PP017_group_by"/>,
<specref ref="gql_PP017_group_by"/>, <specref ref="gql_PP017_tab"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Aggregation would benefit from being improved for the needs of GQL:
</para>

<ulist>

<item>Revisit the set of provided aggregation functions in light of existing products and market
needs (<eg/> add <mono>TIMES</mono> or graph-specific aggregation functions).
</item>

<item>Provide means to better control how aggregation functions behave on empty inputs (no
rows), <eg/> by allowing the user to specify a default value or default failure behavior for
aggregation on empty inputs.
</item>

<comment>Editorial: Stefan Plantikow, 2022-12-19 WG3:W24-009 539. P00-WG3-081</comment>
<item>Allow aggregation to scope over whole subqueries (partition by), possibly taking advantage
of using fixed variables as implicit grouping keys and supporting the evaluation of aggregation
functions over the incoming working table in every statement.
</item>

</ulist>

<para>See also <PPref ref="PPgql186"/>.
</para>

</problem>

</LO>


<LO id="PPgql025" number="GQL-025" kind="improv" size="S">

<brief area="Pattern matching">Define path pattern union using left recursion
</brief>

<reference><specref ref="gql_path_pattern_expr"/>.
</reference>

<noteAt><specref ref="gql_bne034_3"/>.
</noteAt>

<source>WG3:SXM-052.
</source>

<problem>

<para>Path pattern union is not defined using left recursion.
SXM-052 believed that it should be possible to support left recursion but declined to do
so for expediency.
It is a Language Opportunity to support left recursion.
</para>

<para>Linked to <ExtPPref ref="PPpgq019" standard="9075" part="16"/>.
</para>

</problem>

</LO>


<LO id="PPgql030" number="GQL-030" kind="feat_ext" size="M">

<brief area="System and execution model">Session-level control over auto-commit
</brief>

<reference><specref ref="gql_conc_tx_demarcation"/>, and others.
</reference>

<noteAt><specref ref="gql_PP030"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Currently transaction demarcation is defined such that any failure
within a GQL-request procedure will cause a rollback attempt.
Rollback on failure may not be the best option here.
Consider an application that has multiple procedure invocations within a transaction context
where the first N procedures succeed but procedure n+1 fails.
It would be preferable to decide in the application logic whether to commit or rollback,
<eg/> by using a session level configuration mechanism or by providing options to
transaction demarcation commands.
</para>

</problem>

</LO>


<LO id="PPgql032" number="GQL-032" kind="new_feat" size="L">

<brief area="Data types and expressions">Regular expressions
</brief>

<comment>Editorial: Stefan Plantikow 2021-03-02 Reworded</comment>
<reference><specref ref="gql_charstrfunc"/> and <specref ref="gql_bytestrfunc"/>.
</reference>

<noteAt><specref ref="gql_PP032_sql"/>, <specref ref="gql_PP032_cypher"/>,
<specref ref="gql_PP032_exclude"/>, and <specref ref="gql_PP032_bs"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>SQL, Cypher, and possibly other property graph query languages have various styles of
regular expression substring functions as well as other possibly relevant string value functions
that GQL currently is missing.
It is a Language Opportunity to add functionality equivalent to at least that of SQL to GQL.
</para>

</problem>

</LO>


<LO id="PPgql034" number="GQL-034" kind="feat_ext" size="S">

<brief area="Pattern matching">Macro names as <BNF name="simplified primary"/>s
in <BNF name="simplified path pattern expression"/>s
</brief>

<reference><specref ref="gql_simpl_path_patt_expr"/>.
</reference>

<noteAt><specref ref="gql_mmx060_2"/>.
</noteAt>

<source>WG3:MMX-060.
</source>

<problem>

<para>It has been proposed that a macro name may be a <BNF name="simplified primary"/> in
a <BNF name="simplified path pattern expression"/>.
</para>

<para>Linked to <ExtPPref ref="PPpgq035" standard="9075" part="16"/>.
</para>

</problem>

</LO>


<LO id="PPgql035" number="GQL-035" kind="new_feat" size="M">

<brief area="Data model and catalog">TTL and auto-delete of graph elements
</brief>

<reference><specref ref="gql_insert"/>.
</reference>

<noteAt><specref ref="gql_PP035_insert"/>.
</noteAt>

<source>WG3:MMX-047.
</source>

<problem>

<para>Discussion paper WG3:MMX-047 suggests the addition of a <quote>Time To Live</quote> option,
which would require specified graph elements be deleted after a certain time to save storage 
space.
</para>

</problem>

</LO>


<LO id="PPgql036" number="GQL-036" kind="feat_ext" size="M">

<brief area="Pattern matching">Nested quantifier support</brief>

<reference><specref ref="gql_path_pattern_expr"/>.
</reference>

<noteAt><specref ref="gql_PP036"/>.
</noteAt>

<source>WG3:W01-014.
</source>

<problem>

<para>It may be possible to permit nested quantifiers.
WG3:W01-014 contained a discussion of a way to support aggregates at different depths of 
aggregation if there are nested quantifiers.
</para>

<para>Linked to <ExtPPref ref="PPpgq036" standard="9075" part="16"/>.
</para>

</problem>

</LO>


<LO id="PPgql044" number="GQL-044" kind="feat_ext" size="S">

<brief area="Pattern matching">Implicit join of unconditional singletons</brief>

<reference><specref ref="gql_eval_path_pattern_expr"/>.
</reference>

<noteAt><specref ref="gql_w04009_10"/>.
</noteAt>

<source>WG3:W04-009R1.
</source>

<problem>

<para>It may be possible to enforce implicit joins of unconditional singletons
exposed by a <BNF name="path concatenation"/> as part of the GRs for
<BNF name="path concatenation"/>.
This was discussed in a SQL/PG ad hoc meeting on September 8, 2020.
It was decided not to attempt that change as part of WG3:W04-009R1, leaving it as a future
possibility.
</para>

<para>Linked to <ExtPPref ref="PPpgq047" standard="9075" part="16"/>.
</para>

</problem>

</LO>


<LO id="PPgql052" number="GQL-052" kind="new_feat" size="L">

<brief area="Pattern matching">MATCH CHEAPEST</brief>

<reference><specref ref="gql_path_pattern_prefix"/>.
</reference>

<noteAt><specref ref="gql_w04009_15"/>.
</noteAt>

<source>WG3:W04-009R1.
</source>

<problem>

<para>The ability to specify <quote>cheapest</quote> queries (analogous to <kw>SHORTEST</kw>
but minimizing the sum of costs along a path) is desirable.
</para>

<para>Linked to <ExtPPref ref="PPpgq052" standard="9075" part="16"/>.
</para>

</problem>

</LO>


<LO id="PPgql053" number="GQL-053" kind="feat_ext" size="M">

<brief area="Pattern matching">MATCH SHORTEST WITH TIES</brief>

<reference><specref ref="gql_path_pattern_prefix"/>.
</reference>

<noteAt><specref ref="gql_w04009_16"/>.
</noteAt>

<source>WG3:W04-009R1.
</source>

<problem>

<para>In addition to <kw>SHORTEST</kw> <kw>GROUP</kw>, it has been proposed to
support <kw>SHORTEST</kw> [ <sym>k</sym> ] WITH TIES, with the semantics to
return the first <sym>k</sym> matches (where <sym>k</sym> defaults to 1) when sorting matches in
ascending order on number of edges, and also return any matches that have the same number of edges
as the last of the <sym>k</sym> matches.
This is the semantics of WITH TIES in <extref standard="9075" part="02" ref="fnd_qexp"/> in 
SQL/Foundation.
</para>

<para>Linked to <ExtPPref ref="PPpgq053" standard="9075" part="16"/>.
</para>

</problem>

</LO>


<LO id="PPgql054" number="GQL-054" kind="feat_ext" size="M">

<brief area="Pattern matching">Nested selectors with recursion</brief>

<reference>No specific location.
</reference>

<noteAt>No specific location.
</noteAt>

<source>WG3:W04-009R1, WG3:W09-031.
</source>

<problem>

<para>WG3:W04-009R1 believed it should be possible to support nested selectors using
recursion but did not undertake that.
It is a Language Opportunity to support nested selectors.
</para>

<para>Linked to <ExtPPref ref="PPpgq054" standard="9075" part="16"/>.
</para>

</problem>

</LO>


<LO id="PPgql055" number="GQL-055" kind="feat_ext" size="M">

<brief area="Pattern matching">Selectors with quantifiers with a finite upper bound</brief>

<reference>No specific location.
</reference>

<noteAt>No specific location.
</noteAt>

<source>WG3:W04-009R1, WG3:W09-031.
</source>

<problem>

<para>WG3:W04-009R1 believed it should be possible to support selectors within
quantifiers with a finite upper bound, but did not undertake that.
(This comment applies to a static upper bound, not dynamic, since we are forbidding multiple
selectors within a restrictor.)
It is a Language Opportunity to support selectors within quantifiers with a finite upper bound.
</para>

<para>Linked to <ExtPPref ref="PPpgq055" standard="9075" part="16"/>.
</para>

</problem>

</LO>


<LO id="PPgql056" number="GQL-056" kind="improv" size="S">

<brief area="Pattern matching">Generalized definition of left and right boundary variable</brief>

<reference><specref ref="gql_path_pattern_prefix"/>.
</reference>

<noteAt><specref ref="gql_w04009_19"/>.
</noteAt>

<source>WG3:W04-009R1.
</source>

<problem>

<para>With more work, it is possible to recognize when a node variable is declared uniformly in
the first or the last position in every operand of a <BNF name="path pattern union"/>.
However, WG3:W04-009R1 declined to make the effort because it is easy for the user to factor out
such a node pattern.
For example, instead of
</para>
<code>(X) -> (Y) | (X) -> (Z)
</code>
<para>the user can write
</para>
<code>(X) ( -> (Y) | -> (Z))
</code>
<para>Thus, a more general definition of right or left boundary variable is possible.
</para>

<para>Linked to <ExtPPref ref="PPpgq056" standard="9075" part="16"/>.
</para>

</problem>

</LO>


<LO id="PPgql057" number="GQL-057" kind="improv" size="S">

<brief area="Pattern matching">Overridable default path pattern prefix in KEEP</brief>


<reference><specref ref="gql_graph_pattern"/>.
</reference>

<noteAt><specref ref="gql_w04009_12"/>.
</noteAt>

<source>WG3:W04-009R1, WG3:W09-031.
</source>

<problem>

<para>It has been suggested that it might be possible to treat the
<BNF name="path pattern prefix"/> specified in <BNF name="keep clause"/> as merely providing
a default <BNF name="path pattern prefix"/> rather than a mandatory one for each
<BNF name="path pattern"/>.
Whereas nested <BNF name="path pattern prefix"/> is prohibited, this may be
a feasible avenue of growth.
On the other hand, perhaps a less definitive verb than <kw>KEEP</kw> may be appropriate when
specifying a default <BNF name="path pattern prefix"/>.
</para>

<para>Linked to <ExtPPref ref="PPpgq049" standard="9075" part="16"/>.
</para>

</problem>

</LO>


<LO id="PPgql161" number="GQL-161" kind="feat_ext" size="S">

<brief area="Statements and clauses">Improved LIMIT</brief>

<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference><specref ref="gql_limit"/>.
</reference>

<noteAt><specref ref="gql_PP161"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Additional, commonly supported subclauses of <BNF name="limit clause"/> should be added.
</para>

</problem>

</LO>


<LO id="PPgql162" number="GQL-162" kind="feat_ext" size="S">

<brief area="Statements and clauses">Improved OFFSET</brief>

<comment>Editorial: Stefan Plantikow 2021-03-02 Created fir editors' notes</comment>
<reference><specref ref="gql_offset"/>.
</reference>

<noteAt><specref ref="gql_PP162"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Additional, commonly supported subclauses of <BNF name="offset clause"/> should be added.
</para>

</problem>

</LO>


<LO id="PPgql163" number="GQL-163" kind="new_feat" size="M">

<brief area="Statements and clauses">ORDER BY support for WITH TIES, PARTITION BY,
WITH [ GROUP ] OFFSET, and WITH [ GROUP ] ORDINALITY
</brief>


<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference> <specref ref="gql_order_by_and_page"/>.
</reference>

<noteAt><specref ref="gql_PP163"/>.
</noteAt>

<source>Editors, WG3:W15-020, WG3:GYD-031.
</source>

<problem>

<para>Additional support for PARTITION BY, WITH TIES, WITH [ GROUP ] OFFSET, and 
WITH [ GROUP ] ORDINALITY should be considered.
</para>

</problem>

</LO>


<LO id="PPgql168" number="GQL-168" kind="feat_ext" size="S">

<brief area="Procedures">Standalone calls</brief>


<comment>Editorial: Stefan Plantikow 2021-03-02 Create for editors' notes</comment>
<reference><specref ref="gql_stm_proc_call"/>.
</reference>

<noteAt><specref ref="gql_PP168"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Stand-alone calls need to be added (standalone calls are short-hand syntax for just calling
a single GQL-procedure).
</para>

</problem>

</LO>


<LO id="PPgql169" number="GQL-169" kind="feat_ext" size="S">

<brief area="Statements and clauses">Optional WHERE clause support where feasible</brief>

<reference><specref ref="gql_stm_proc_call"/>.
</reference>

<noteAt><specref ref="gql_PP169"/>, <specref ref="gql_PP169_2"/>,
<specref ref="gql_PP169_4"/>, <specref ref="gql_PP169_5"/>, <specref ref="gql_PP169_6"/>,
<specref ref="gql_PP169_9"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The addition of optional <BNF name="where clause"/>s should be considered throughout the
document.
</para>

</problem>

</LO>



<LO id="PPgql176" number="GQL-176" kind="feat_ext" size="M">

<brief area="Data types and expressions">Additional numeric value functions
</brief>

<reference><specref ref="gql_numvalfunc"/>.
</reference>

<noteAt><specref ref="gql_PP176_1"/>, <specref ref="gql_PP176_2"/>, <specref ref="gql_PP176_3"/>,
<specref ref="gql_PP176_4"/>, <specref ref="gql_PP176_5"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<comment>Editorial: Stefan Plantikow 2021-04-26 Converted LO</comment>

<para>It needs to be decided which additional numeric value functions should be included.
</para>

</problem>

</LO>


<LO id="PPgql177" number="GQL-177" kind="feat_ext" size="M">

<brief area="Data types and expressions">Additional predicates
</brief>


<reference><specref ref="gql_pred"/>.
</reference>

<noteAt><specref ref="gql_PP177_1"/>, <specref ref="gql_PP177_2"/>, <specref ref="gql_PP177_3"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<comment>Editorial: Stefan Plantikow 2021-04-26 Converted to LO</comment>

<para>It needs to be decided which additional predicates should be included.
</para>

</problem>

</LO>


<LO id="PPgql181" number="GQL-181" kind="feat_ext" size="S">

<brief area="Pattern matching">Relax selector occurrence in alternatives
</brief>


<reference>No specific location.
</reference>

<noteAt>No specific location.
</noteAt>

<source>WG3:W08-018, WG3:W09-031.
</source>

<problem>

<para>WG3:W08-018 prohibited a selector contained in a <BNF name="path pattern union"/> or
<BNF name="path multiset alternation"/> <symdef>PU</symdef>, but believed that if <sym>PU</sym> is
at the <quote>top</quote> of a path pattern, and a selector is at the <quote>top</quote> of
an operand of <sym>PU</sym>, then this scenario does not violate compositionality.
It is a Language Opportunity to permit this scenario.
</para>

<para>Linked to <ExtPPref ref="PPpgq060" standard="9075" part="16"/>.
</para>

</problem>

</LO>


<LO id="PPgql185" number="GQL-185" kind="new_feat" size="XL">

<brief area="Data model and catalog">System-versioned graph
</brief>


<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference><specref ref="gql_conc_temporal"/>.
</reference>

<noteAt><specref ref="gql_PP185"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<comment>WG3:UTC-117</comment>
<para>Support for system-versioned graphs should be added.
Such support should consider using the 9075 <quote>period</quote> terminology rather than
the 8601 <quote>interval</quote> terminology.
</para>

</problem>

</LO>


<LO id="PPgql186" number="GQL-186" kind="feat_ext" size="L">

<brief area="Procedures">Grouped procedure calls
</brief>


<reference><specref ref="gql_stm_proc_call"/>, <specref ref="gql_aggregate_func"/>.
</reference>

<noteAt><specref ref="gql_PP186_2"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Support for grouped procedure calls needs to be specified.
A grouped procedure call invokes a procedure for each partition of the binding table and combines
(concatenates) all results received.
Partitions may be determined by a user-specified grouping key or perhaps sets of grouping keys.
</para>

<para>See also <PPref ref="PPgql017"/>.
</para>

</problem>

<solution>

<para>A possible solution might all a syntactic form like:
</para>

<code>
CALL proc(args) PER key YIELD results
</code>

<para>or perhaps rely on per-query block partitioning:
</para>

<code>
PER key
<ellipsis/>
CALL proc(args) YIELD results
<ellipsis/>
</code>

</solution>

</LO>


<LO id="PPgql194" number="GQL-194" kind="feat_ext" size="S">

<brief area="Pattern matching">Subpath variable projection and handling
</brief>

<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference><specref ref="gql_graph_pattern"/>,
<specref ref="gql_machinery_graph_pattern_matching"/>.
</reference>

<noteAt><specref ref="gql_w22053_1"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Projection and handling of subpath variables needs to be specified.
</para>

</problem>

</LO>


<LO id="PPgql196" number="GQL-196" kind="feat_ext" size="M">

<brief area="Data types and expressions">Additional date time functions from Cypher
</brief>


<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference><specref ref="gql_datevalfunc"/>.
</reference>

<noteAt><specref ref="gql_PP196"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Cypher contains additional datetime functions.
It is a Language Opportunity to add equivalent functionality to GQL.
</para>

</problem>

</LO>


<LO id="PPgql197" number="GQL-197" kind="feat_ext" size="M">

<brief area="Data types and expressions">Additional duration functions from Cypher
</brief>
<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference><specref ref="gql_durvalfunc"/>.
</reference>

<noteAt><specref ref="gql_PP197"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Cypher contains additional duration functions.
It is a Language Opportunity to add equivalent functionality to GQL.
</para>

</problem>

</LO>


<LO id="PPgql212" number="GQL-212" kind="feat_ext" size="S">

<brief area="Pattern matching">Additional synonyms for undirected edge patterns
</brief>

<reference><specref ref="gql_path_pattern_expr"/>.
</reference>

<noteAt><specref ref="gql_w09017"/>.
</noteAt>

<source>WG3:W09-017, WG3:W09-036.
</source>

<problem>

<para>In the BNF for <BNF name="full edge any direction"/>, the delimiter
tokens &lt;~[ ]~&gt; have been suggested as a synonym for -[ ]- as part of <feature code="GH02"/>.
The synonym for the <BNF name="abbreviated edge pattern"/> - (<BNF name="minus sign"/>)
would then be &lt;~&gt;, the synonym for <BNF name="simplified defaulting any direction"/> would
use the delimiter tokens &lt;~/ /~&gt; and the synonym for
<BNF name="simplified override any direction"/> would use the tokens &lt;~ and &gt; surrounding
a label as originally proposed in WG3:MMX-060.
These synonyms might be considered to make the table of edge patterns more harmonious and
internally consistent.
</para>

<para>Linked to <ExtPPref ref="PPpgq062" standard="9075" part="16"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql213" number="GQL-213" kind="new_feat" size="M">

<brief area="Data types and expressions">Regular expression operators from SQL
</brief>
<reference><specref ref="gql_pred"/>.
</reference>

<source>WG3:W10-017.
</source>

<problem>

<para>SQL/Foundation defines five operators that use XQuery regular expression syntax:
</para>
<code>
  LIKE_REGEX
  OCCURRENCES_REGEX
  POSITION_REGEX
  SUBSTRING_REGEX
  TRANSLATE_REGEX
</code>

<para>These REGEX operators could be very useful and should be considered.
</para>

</problem>

</LO>


<LO id="PPgql217" number="GQL-217" kind="feat_ext" size="S">

<brief area="Data types and expressions">IEEE 754 floating point literals for Infinity and NaN
</brief>

<reference><specref ref="gql_conc_numeric"/>.
</reference>

<noteAt><specref ref="gql_PP217"/>.
</noteAt>

<source>WG3:W12-029.
</source>

<problem>

<para>Support for approximate numeric types that are compatible with the arithmetic formats for
which ISO/IEC 60559:2020/IEEE 754:2019 defines interchange formats should be added.
This needs to include provisions for infinity values and literals, NaN values and literals,
rounding, casting, error handling, data types, the modification of existing operations, and related
conformance features.
</para>

</problem>

<solution>

<para>None provided but see paper WG3:W11-015 for a discussion.
</para>

</solution>

</LO>


<LO id="PPgql218" number="GQL-218" kind="improv" size="S">

<brief area="Data types and expressions">Reconsider allowed behavior on loss of non-zero bytes due
to truncation
</brief>

<reference><specref ref="gql_conc_numeric"/>.
</reference>

<source>WG3:W12-029.
</source>

<problem>

<para>In SQL, it is <impDef annex="no" code="None"/> whether the loss of non-zero bytes due
to truncation raises an exception or not.
This should be reconsidered by GQL.
</para>

</problem>

</LO>


<LO id="PPgql221" number="GQL-221" kind="feat_ext" size="XS">

<brief area="Cast">Cast BOOLEAN to INT
</brief>

<reference><specref ref="gql_cast_spec"/>.
</reference>

<source>WG3:W13-012
</source>

<problem>

<para>Many programming languages support converting boolean types to numerics
where <bool>True</bool> converts to 1 (one) and <bool>False</bool> converts to 0 (zero).
Such conversions could be useful to GQL users.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql222" number="GQL-222" kind="feat_ext" size="S">

<brief area="Cast">Explicit type conversion functions
</brief>

<reference><specref ref="gql_cast_spec"/>.
</reference>

<source>WG3:W13-012
</source>

<problem>

<para>Many databases and programming languages include individual type conversion functions
such as:
</para>

<ulist>

<item>toBoolean
</item>

<item>toInteger
</item>

<item>toFloat
</item>

<item>toString
</item>

</ulist>

<para>If there is a need at some point to add individual conversion functions to GQL,
they could be specified as syntactic transformations to the appropriate <kw>CAST</kw> function.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql223" number="GQL-223" kind="feat_ext" size="S">

<brief area="Cast">Temporal CAST with explicit FORMAT option
</brief>

<reference><specref ref="gql_cast_spec"/>.
</reference>

<source>WG3:W13-012
</source>

<problem>

<para>In <docref ref="ISO9075-2_2023"/>, <BNF name="cast specification"/> includes an optional
FORMAT <BNF name="cast template" standard="9075" part="02"/> that allows a user to
provide a format when converting a datetime to a character string.
A similar capability could be useful in GQL.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql224" number="GQL-224" kind="feat_ext" size="M">

<brief area="Cast">Error trapping in CAST
</brief>

<reference><specref ref="gql_cast_spec"/>.
</reference>

<source>WG3:W13-012
</source>

<problem>

<para>In a <kw>CAST</kw> expression, it could be useful to specify what the result should be if
the <kw>CAST</kw> would otherwise raise an exception.
For example:
</para>

<code><kw>CAST</kw> (<string>abc</string> AS INT ON EXCEPTION NULL)</code>
<code><kw>CAST</kw> (<string>abc</string> AS INT ON EXCEPTION 0)</code>
<code><kw>CAST</kw> (a.prop1 AS INT ON EXCEPTION a.prop2)</code>

<para>An ON EXCEPTION capability would be particularly useful when loading large volumes of data.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql225" number="GQL-225" kind="feat_ext" size="M">

<brief area="Cast">Cast between byte strings and character strings
</brief>

<reference><specref ref="gql_cast_spec"/>.
</reference>

<source>WG3:W13-012
</source>

<problem>

<para><BNF name="cast specification"/> does not currently support converting byte strings to
character strings or character strings to byte strings (using some well-known encoding).
Such a capability might be useful.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql226" number="GQL-226" kind="feat_ext" size="S">

<brief area="Cast">Temporal component extraction in CAST
</brief>

<reference><specref ref="gql_cast_spec"/>.
</reference>

<noteAt>None.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The ability to extract individual time scale components from temporal instances and duration
would be useful and might be used to simplify the specification of <BNF name="cast specification"/>.
SQL has an EXTRACT function that satisfies a similar need and openCypher in its CIP2015-08-06 Date
and Time specification has defined the ability to extract all individual time scale components.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql227" number="GQL-227" kind="feat_ext" size="S">

<brief area="DDL">Cascading DROP SCHEMA
</brief>

<reference><specref ref="gql_drop_schema"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W13-024.
</source>

<since>2021-07-21
</since>

<problem>

<para><BNF name="drop schema statement"/> only allows dropping a schema if it does not contain any
catalog object.
More user convenience could potentially be added to the <BNF name="drop schema statement"/> by
including a new option for cascading drop statements or by developing a general invalidation
model for catalog objects.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql229" number="GQL-229" kind="new_feat" size="L">

<brief area="Pattern matching">Pattern macros
</brief>

<reference>No specific location.
</reference>

<source>WG3:W15-018.
</source>

<problem>

<para>Pattern Macros could provide powerful capabilities for GQL Users by providing
a multi-use template.
A Pattern Macro could be created in several places:
</para>

<ulist>

<item>As a preamble to a single query that lasts for the life of the query.
</item>

<item>As a catalog object that can be created, used in multiple queries, and lasts until
explicitly dropped.
</item>

</ulist>

<para>This capability should be considered for a future GQL version.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql231" number="GQL-231" kind="feat_ext" size="S">

<brief area="Pattern matching">Alternative syntax for testing source and destination
</brief>

<reference><specref ref="gql_src_dest_pred"/>.
</reference>

<noteAt>No specific location.
</noteAt>

<source>WG3:W15-022.
</source>

<problem>

<para>The <BNF name="source/destination predicate"/> is expressed as a predicate about the node,
while it is most often used to pose questions about the edge.
If an alternative form of these predicates was available that put the edge as the first operand,
this predicate would be more useful in combination with <BNF name="simple case"/>.
</para>

<para>Linked to <ExtPPref ref="PPpgq071" standard="9075" part="16"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql233" number="GQL-233" kind="feat_ext" size="M">

<brief area="Pattern matching">Handle desynchronized lists
</brief>

<reference><specref ref="gql_app_bind_eval_expr"/>.
</reference>

<noteAt><specref ref="gql_w13018_1"/>.
</noteAt>

<source>WG3:MMX-035r2, WG3:W13-018.
</source>

<problem>

<para>The bindings of a group reference flatten nested lists.
This may be acceptable for SQL aggregates, which have no support for nested groupings,
but may be inadequate to fully capture the semantics of a group reference in a graph pattern.
MMX-035r2 section 4.1 <quote>Desynchronized lists</quote> pointed out a problem with reducing
group variables to lists: two lists may be interleaved, but the reduction to separate lists can
lose this information.
The example given is
</para>

<code>
(   (A:Person) -[:SPOUSE]-> ()
  | (B:Person) -[:FRIEND]-> () ){3}
</code>

<para>A solution may find matches to A and B in any order.
With separate lists of matches of A and B, it will not be easy to reconstruct the precise
sequence of interleaved matches to A and B.
</para>

<para>A similar problem can arise with nested quantifiers.
MMX-035r2 section 4.2 <quote>Nested quantifiers</quote> gives this example:
</para>

<code>
( (C1:CORP) (-[:TRANSFERS]->(B:BANK))*
  -[:TRANSFERS]-> (C2:CORP) )*
</code>

<para>With this pattern, there can be 0 or more bindings to B between any two consecutive
bindings to C1 and C2.
With just independent lists of matches to C1, B and C2, it will not be easy to determine which
bindings to B lie between which bindings to C1 and C2.
</para>

<para>Linked to <ExtPPref ref="PPpgq069" standard="9075" part="16"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql234" number="GQL-234" kind="feat_ext" size="M">

<brief area="Statements and clauses">Composite queries (<eg/> set operations) on graphs
</brief>

<reference><specref ref="gql_stm_comp_query_expr"/>.
</reference>

<source>WG3:W15-017.
</source>

<problem>

<para><specref ref="gql_stm_comp_query_expr"/>, General Rules are written to compose the binding
tables generated by pairs of queries.
There might be a benefit in expanding the GRs to also support operations directly on graphs such
that GQL gains the capability to do, <eg/> union of graphs.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql235" number="GQL-235" kind="new_feat" size="M">

<brief area="Data model and catalog">Constant values in the GQL-catalog
</brief>

<reference>No specific location.
</reference>

<source>WG3:W16-038.
</source>

<problem>

<para>The ability to create, reference, and drop constants as catalog objects could be
very useful when constructing GQL queries.
This capability should be considered for a future GQL version.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>
</solution>

</LO>


<LO id="PPgql237" number="GQL-237" kind="new_feat" size="M">

<brief area="Data model and catalog">Query catalog graphs by metadata
</brief>

<reference>No specific location.
</reference>

<source>WG3:W16-041.
</source>

<problem>

<para>The ability to query a catalog to identify graphs with particular characteristics
would be useful.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>
</solution>

</LO>


<LO id="PPgql241" number="GQL-241" kind="new_feat" size="XL">

<brief area="Data model and catalog">First class properties
</brief>

<reference><specref ref="gql_prop_type_set_defn"/>.
</reference>

<source>WG3:W19-019R1.
</source>

<problem>

<para>Several future extensions of the GQL language (See <PPref ref="PPgql241"/>,
<PPref ref="PPgql242"/>, <PPref ref="PPgql243"/>) depend on properties being
directly referenceable as graph elements in their own rights.
Currently properties only exist (from a schema point of view) as members in property type sets
attached to either nodes or edges.
A definition point of a property type as such is needed.
Such a graph element will be necessary for future concept relationships between
properties and, <eg/> other properties, other edges and other nodes than the ones that the
current property set <quote>belongs to</quote>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql242" number="GQL-242" kind="new_feat" size="L">

<brief area="Data model and catalog">First class properties to reify keys with functional
dependencies
</brief>

<reference><specref ref="gql_prop_type_set_defn"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W19-019R1.
</source>

<problem>

<para>Functional dependencies in a more specific manner (minimizing the
need for inferencing in query planning) require explicit concept relationships between
properties (<eg/> keys and non-keys) for dealing with uniqueness and key formation.
See <PPref ref="PPgql241"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql243" number="GQL-243" kind="new_feat" size="L">

<brief area="Data model and catalog">First class properties to reify versioning and timeline
information
</brief>

<reference><specref ref="gql_prop_type_set_defn"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W19-019R1.
</source>

<problem>

<para>Versioning (of both data and metadata) and timeline handling
require explicit concept relationships between properties (<eg/> keys and non-keys) for
dealing with uniqueness and key formation.
See <PPref ref="PPgql241"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql244" number="GQL-244" kind="new_feat" size="L">

<brief area="Data model and catalog">First class properties to map between RDF and LPG
</brief>

<reference><specref ref="gql_prop_type_set_defn"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W19-019R1.
</source>

<problem>

<para>Coexistence between LPG(s) of different breeds and also RDF require meta transformations
between concept systems describing: a source graph type, a <quote>universal</quote> abstract
graph type system and a target graph type.
This requires GQL properties to be directly referenceable as such in combinations with other
graph elements, including other properties, edges and relationships.
See <PPref ref="PPgql241"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql245" number="GQL-245" kind="new_feat" size="XL">

<brief area="System and execution model">Multi-requests
</brief>

<reference>No specific location.
</reference>

<source>WG3:W19-017.
</source>

<problem>

<para>Allowing the bundling of multiple requests into one is useful for reducing network round
trips.
This should include the capability for returning multiple results to the client in one round trip.
</para>

</problem>

<solution>

<para>One possibility is to introduce a new top-level Subclause &lt;GQL-multi-request&gt; next to
<BNF name="GQL-program"/>.
</para>

</solution>

</LO>


<LO id="PPgql246" number="GQL-246" kind="new_feat" size="XL">

<brief area="Data model and catalog">Named procedures
</brief>

<reference>No specific location.
</reference>

<source>WG3:W20-012.
</source>

<problem>

<para>The ability to create and drop named stored procedures is a powerful capability 
when building applications in a GQL database.
This capability should be considered for a future GQL version and should include both
mandatory and optional parameters.
</para>

<para>The last Informal Working Draft that contained a sketch of the functionality
(deleted by W20-012) was 39075_1IWD21-GQL_2022-02, which is available here:
<URI active="yes">https://sd.iso.org/documents/ui/#!/browse/iso/iso-iec-jtc-1/iso-iec-jtc-1-sc-32/iso-iec-jtc-1-sc-32-wg-3/library/6/16656391_LL/16656048_LL/39075_1IWD21-GQL_2022-02.pdf
</URI>
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql247" number="GQL-247" kind="new_feat" size="XL">

<brief area="Data model and catalog">Named queries
</brief>

<reference>No specific location.
</reference>

<source>WG3:W20-012.
</source>

<problem>

<para>The ability to create, invoke, and drop named, stored queries is a powerful
capability when building applications in a GQL database.
This capability should be considered for a future GQL version.
</para>

<para>The last Informal Working Draft that contained a sketch of the functionality
(deleted by W20-012) was 39075_1IWD21-GQL_2022-02, which is available here:
<URI active="yes">https://sd.iso.org/documents/ui/#!/browse/iso/iso-iec-jtc-1/iso-iec-jtc-1-sc-32/iso-iec-jtc-1-sc-32-wg-3/library/6/16656391_LL/16656048_LL/39075_1IWD21-GQL_2022-02.pdf
</URI>
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql248" number="GQL-248" kind="new_feat" size="XL">

<brief area="Data model and catalog">Named functions
</brief>

<reference>No specific location.
</reference>

<source>WG3:W20-013.
</source>

<problem>

<para>The ability to create, call, and drop named, stored functions is a powerful
capability when building applications in a GQL database.
This capability should be considered for a future GQL version and should include both
mandatory and optional parameters.
As part of the consideration, there should be a discussion of whether GQL should support the
definition and/or calling of pure functions, impure functions, or both.
</para>

<para>The last Informal Working Draft that contained a sketch of the functionality
(deleted by W20-013) was 39075_1IWD21-GQL_2022-02, which is available here:
<URI active="yes">https://sd.iso.org/documents/ui/#!/browse/iso/iso-iec-jtc-1/iso-iec-jtc-1-sc-32/iso-iec-jtc-1-sc-32-wg-3/library/6/16656391_LL/16656048_LL/39075_1IWD21-GQL_2022-02.pdf
</URI>
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql250" number="GQL-250" kind="new_feat" size="XL">

<brief area="Data model and catalog">Named subgraphs
</brief>

<reference><specref ref="gql_conc_g"/>.
</reference>

<source>WG3:RKE-040.
</source>

<problem>

<para>GQL should be extended to support subgraphs for the most needed use cases.
</para>

<para>Paper WG3:RKE-046 Subgraphs of property graphs provides some commentary on this topic.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql279" number="GQL-279" kind="feat_ext" size="M">

<brief area="Pattern matching">Subpath variable references
</brief>

<reference><specref ref="gql_graph_patt_var_ref"/>.
</reference>

<noteAt><specref ref="gql_ber031_1"/>.
</noteAt>

<source>WG3:BER-031.
</source>

<problem>

<para>It is a Language Opportunity to support references to subpath variables, for
example, in <BNF name="graphical path length function" standard="9075" part="16"/>, or
a TOTAL_COST function once CHEAPEST is defined.
</para>

<para>Linked to <ExtPPref ref="PPpgq085" standard="9075" part="16"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql281" number="GQL-281" kind="new_feat" size="L">

<brief area="Data types and expressions">IEEE 754 Rounding modes
</brief>

<reference><specref ref="gql_conc_numeric_intro"/>.
</reference>

<source>WG3:BER-026.
</source>

<problem>

<para>There is the opportunity to support the IEEE rounding modes.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql282" number="GQL-282" kind="port_feat" size="M">

<brief area="Data types and expressions">IS BOUND
</brief>

<reference>No specific location.
</reference>

<source>WG3:BER-026.
</source>

<problem>

<para>SQL/PGQ has an IS BOUND predicate to test whether an element variable is bound
(See WG3:W18-028).
This predicate should be considered for GQL as an advanced conformance feature.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql283" number="GQL-283" kind="new_feat" size="L">

<brief area="Data types and expressions">Ordered Set support
</brief>

<reference>No specific location.
</reference>

<source>WG3:BER-038R1.
</source>

<problem>

<para>An ordered set collection type that provides an ordered collection of distinguishable
elements might be useful for GQL users.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql285" number="GQL-285" kind="feat_ext" size="M">

<brief area="Data types and expressions">Additional syntax for edge types
</brief>

<reference>No specific location.
</reference>

<source>WG3:BER-040R3.
</source>

<problem>

<para>Support for additional syntactic forms currently ruled out for
<BNF name="edge reference value type"/> should be considered.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>
</solution>

</LO>


<LO id="PPgql288" number="GQL-288" kind="new_feat" size="L">

<brief area="Statements and clauses">MERGE (MATCH-or-INSERT)
</brief>

<reference>No specific location.
</reference>

<source>WG3:BER-050.
</source>

<problem>

<para>The ability to MERGE an <BNF name="insert graph pattern"/> into an existing graph would be
useful to GQL users.
</para>

<para>See WG3:BER-089, <quote>Thoughts about MERGE</quote>, for a discussion of this topic.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql301" number="GQL-301" kind="feat_ext" size="M">

<brief area="DDL">DROP with CASCADE and RESTRICT
</brief>


<reference><specref ref="gql_drop_graph"/>,
<specref ref="gql_drop_graph_type"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:BER-037.
</source>

<problem>

<para>GQL DROP statements should be extended to support &lt;drop behavior> CASCADE and RESTRICT, 
with RESTRICT specified as the default behavior and CASCADE specified as an optional advanced 
conformance feature.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql304" number="GQL-304" kind="new_feat" size="L">

<brief area="DDL">Syntax support for working with and managing persistent binding tables
</brief>


<reference><specref ref="gql_conc_bt"/>.
</reference>

<source>WG3:W22-031.
</source>

<problem>

<para>It might be useful to allow the user to store a binding table as the result of a query,
rather than necessarily transmitting the final binding table to the client.
</para>

<para>A stored binding table might subsequently be referenced as the original binding
table of another procedure (instead of starting from just the unit binding table).
Storing objects or references to objects might be prohibited, <ie/> a stored binding
table might only be supported with columns of scalar data types.
</para>

</problem>

<solution>

<Alist>

<item>GQL is a graph query language. 
If users would like to work with the persisted tables, they are recommended to use a system that 
supports SQL. 
Implementations that support GQL and SQL can use procedures to facilitate the use case of loading 
a persisted table at the beginning GQL query as the working table as illustrated by
the following example:

<code>
    CALL readTable(<stringd>foo</stringd>) YIELD a,b,c
    MATCH (n) WHERE n.x > c
    <ellipsis/>
</code>

<para>Likewise they can facilitate the use case of persisting a GQL result by calling 
a GQL procedure from SQL even inline as illustrated by the following example:
</para>

<code>
    CREATE TABLE foo (a,b,c) AS (
      USE myGraph
      MATCH (n)-[k:KNOWNS]->(m)
      RETURN n.name AS a, m.name AS b, k.since AS c
    ) WITH DATA
</code>

</item>

<item>If GQL would want to pick specifying persisted tables itself, loading a persisted
table as working table could be achieved, <eg/> with a FROM clause similar to the GQL<apos/>s 
<BNF name="use graph clause"/>:

<code>
    FROM foo
    MATCH (n) WHERE n.x > c
    <ellipsis/>
</code>

<para>For persisting, GQL would require something akin to SQL<apos/>s CREATE TABLE <ellipsis/> AS,
for instance:
</para>

<code>
    CREATE BINDING TABLE foo AS {
      USE myGraph
      MATCH (n)-[k:KNOWNS]->(m)
      RETURN n.name AS a, m.name AS b, k.since AS c
    }
</code>

</item>

</Alist>

</solution>

</LO>


<LO id="PPgql306" number="GQL-306" kind="new_feat" size="XL">

<brief area="Data model and catalog">Procedure libraries
</brief>


<reference>No specific location.
</reference>

<source>WG3:W22-033.
</source>

<problem>

<para>It could be very useful to have a mechanism for inserting a library of procedures, <etc/>
in a GQL schema, along with the ability to reference and execute objects in the library.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql308" number="GQL-308" kind="feat_ext" size="M">

<brief area="Statements and clauses">Path deletion
</brief>

<reference><specref ref="gql_delete"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W22-042.
</source>

<problem>

<para>The ability to delete a path should be considered.
</para>

<para>WG3:W22-042 said that given the lack of consensus on the mental model of the ability to 
delete a path removed this ability.
It went on to say that:
</para>

<para>We can illustrate how this would work with an example. 
Consider the following current working graph:
</para>

<code>
    (:A)-[:S]->(:A)
</code>

<para>To delete all of the graph elements we could execute the following query:
</para>

<code>
    MATCH (m)-[r]->(n)
    DELETE r, m, n
</code>

<para>According to the original definition, the same effect would be achievable with 
a path variable bound to a path of those same three elements:
</para>

<code>
    MATCH p = (:A)-[:S]->(:A)
    DELETE p
</code>

<para>As a path is a sequence of graph elements, the mental model this feature is assuming is that
an instruction to delete a path is equivalent to an instruction to delete its constituent elements. 
A problem with this assumed mental model, however, is that unlike graph elements a path is not 
a persisted object. 
Discussions have shown a lack of consensus on treating the deletion of a path in this way.
For the user attempting to delete the constituent elements of a path, an alternative would be to
acquire a reference to each element and then pass them directly to the 
<BNF name="delete statement"/>. 
This is not feasible, however, with variable-length paths. 
In the future, value functions that return lists of nodes and edges for a given path may be 
introduced. 
In that case, as an example, the following query:
</para>

<code>
    MATCH p = (:A)-[:S]->+(:A)
    DELETE p
</code>

<para>would be re-writable as:
</para>

<code>
MATCH p = (:A)-[:S]->+(:A)
FOR e IN edges(p)
DELETE e
FOR n IN nodes(p)
DELETE n
</code>

<para>where edges and nodes are value functions returning from a path a list of edges and nodes
respectively.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql309" number="GQL-309" kind="feat_ext" size="M">

<brief area="Procedures">Named procedure parameters
</brief>

<reference><specref ref="gql_named_procedure_call"/>.
</reference>

<source>WG3:W22-054.
</source>

<problem>

<para>The ability to specify named parameters in addition to sequentially ordered parameters 
should be considered in future GQL versions.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql310" number="GQL-310" kind="feat_ext" size="M">

<brief area="Procedures">Omitted intermediary optional procedure parameters
</brief>

<reference><specref ref="gql_named_procedure_call"/>.
</reference>

<source>Discussion of WG3:W22-054.
</source>

<problem>

<para>The ability to omit intermediate optional parameters should be considered in future GQL 
versions.
That is the optionality should not be restricted to trailing optional parameters.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql319" number="GQL-319" kind="new_feat" size="L">

<brief area="Data model and catalog">Specify and query metadata of graphs and graph types
</brief>

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W22-034R1.
</source>

<problem>

<para>It could be very useful to be able to specify and query metadata for graphs and graph types.
One way to accomplish this is to have graph labels and properties that are specified when the 
graph and/or graph type is created. 
The graph properties could be accessed through a graph.graphProperty syntax. 
Graph labels would require a <quote>label exists</quote> function. 
Graph properties could be used for information such as graph creation time, a description of the 
graph, <etc/>
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql325" number="GQL-325" kind="new_feat" size="L">

<brief area="DDL">ALTER GRAPH TYPE
</brief>

<reference><specref ref="gql_create_graph"/>, 
<specref ref="gql_create_graph_type"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:OHD-020.
</source>

<problem>

<para>It is potentially beneficial to be able to create a Graph Type with no nodes or edges and
then incrementally expand the Graph Type definition using an ALTER <kw>GRAPH</kw> 
<kw>TYPE</kw> statement. 
It would also be useful to allow <kw>CREATE</kw> <kw>GRAPH</kw> with an inline 
<BNF name="nested graph type specification"/> to be created with an empty 
<BNF name="nested graph type specification"/> and incrementally enhanced with ALTER <kw>GRAPH</kw> 
statements. 
It might also be useful to have explicit syntax such as EMPTY <kw>GRAPH</kw> <kw>TYPE</kw> to 
allow the creation of an empty graph type for when a graph is created.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql328" number="GQL-328" kind="improv" size="L">

<brief area="Data model and catalog">Remove distinction between schema and directory
</brief>

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:OHD-032R1.
</source>

<problem>

<para>The distinction between schema and directory seems unnecessary, or at least somewhat
confusing. 
For instance, since path traversal starts at the current schema rather than some notion of 
current directory, all relative paths must start with ../ to move from the current schema to its 
containing directory.
Could not all be schemas, where one schema can contain other schemas? 
This should allow lifting existing syntax restrictions for the schema reference syntax and 
reduce the number of concepts required for the GQL-catalog.
</para>

<para>Some care would be needed to make it clear that a schema <symdef>S</symdef> contained in
schema <sym>PARENT</sym> is an independent schema, not an extension of <sym>PARENT</sym>.
GQL does not currently implement directory or schema access controls; if and when it does, and 
if this LO is implemented, the notion of a schema TRAVERSAL access right (as opposed to a schema 
READ access right) might be useful.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql329" number="GQL-329" kind="feat_ext" size="M">

<brief area="DDL">Parameter support in CREATE and DROP
</brief>

<reference><specref ref="gql_create_schema"/>, <specref ref="gql_drop_schema"/>,
<specref ref="gql_create_graph"/>, <specref ref="gql_drop_graph"/>,
<specref ref="gql_create_graph_type"/>, <specref ref="gql_drop_graph_type"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:OHD-032R1.
</source>

<problem>

<para>The create and drop schema, graph, and graph type statements might benefit from allowing 
<BNF name="reference parameter specification"/> to specify the schema, graph, or graph type to 
be created or dropped.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql330" number="GQL-330" kind="new_feat" size="XL">

<brief area="Data model and catalog">Graph serialization format
</brief>

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:OHD-033
</source>

<problem>

<para>It is a language opportunity to provide either a normative specification of a graph
serialization format or to provide guidance on graph serialization in a guidance standard.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql336" number="GQL-336" kind="feat_ext" size="S">

<brief area="Transactions">Defaults for implementation-provided transaction access modes
</brief>

<reference><specref ref="gql_conc_tx_isolation"/>
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W23-033
</source>

<problem>

<para>It is a language opportunity to provide some standard specifications for
<BNF name="implementation-defined access mode"/> modeled on the existing SQL specifications.
However, it should also recognize that since the time the SQL specifications were made there are
more recently-defined levels such as Snapshot Isolation or Serializable Snapshot Isolation, or 
other industrially-applied or theoretical variants.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql340" number="GQL-340" kind="new_feat" size="M">

<brief area="Statements and clauses">Re-introduce MANDATORY MATCH
</brief>

<reference><specref ref="gql_match"/>. 
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W23-015.
</source>

<problem>

<para>Some applications (such as recommender systems) require queries involving nodes with unique 
IDs and expect the match statement to always return something to be processed for other queries. 
Consider additional syntax to handle non-matched patterns and provide the user with a powerful
facility to detect semantic errors and failing early in the case of errors, thus avoiding
unnecessary work and providing good diagnostics regarding which pattern failed to match.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql341" number="GQL-341" kind="new_feat" size="L">

<brief area="Schema and metadata model">Integrity constraints (especially keys)</brief>

<reference><specref ref="gql_edge_type_defn"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W24-023.
</source>

<problem>

<para>It would be useful to support referential integrity constraints in some form. 
This could be specified as stand-alone constraints or as minimum cardinalities on edges.
For example, in the edge type (Person)-[LivesIn :LIVES_IN {since DATE}]->(City), it
might be possible to specify that a (Person) must have at least one [LivesIn] edge with
a (City).
</para>

<para>See the paper <quote>PG-Keys: Keys for Property Graphs</quote> 
[<URI>https://dl.acm.org/doi/pdf/10.1145/3448016.3457561</URI>] for useful information on this 
topic.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql342" number="GQL-342" kind="feat_ext" size="L">

<brief area="Schema and metadata model">Allow unions between node types in edge type definitions
</brief>

<reference><specref ref="gql_edge_type_defn"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W24-027.
</source>

<problem>

<para>It could be useful to allow endpoint definitions in an edge type definition to be
patterns that potentially match multiple node type definitions within the graph type.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql343" number="GQL-343" kind="feat_ext" size="M">

<brief area="Data types and expressions">Allow use of element type names in value types
</brief>

<reference><specref ref="gql_edge_type_defn"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W24-027.
</source>

<problem>

<para>It could be useful to allow <BNF name="node reference value expression"/>s and 
<BNF name="edge reference value expression"/>s to resolve to existing node types and 
edge types using node type names and edge type names. 
Such a capability would need to identify a graph type where the node types and edge types 
might be found, either through the graph type of the current working graph or through 
identifying a schema and graph type.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql344" number="GQL-344" kind="improv" size="M">

<brief area="Data types and expressions">Disallow distinct node and edge types with the same name
</brief>

<reference><specref ref="gql_node_type_defn"/> and <specref ref="gql_edge_type_defn"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W24-027.
</source>

<problem>

<para>It could be useful to restrict node type names and edge type names to be in the 
same namespace. 
That is, node type names are unique in the set of node type and edge type names in 
a graph type, and edge type names unique in the set of node type and edge type names in 
a graph type.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql345" number="GQL-345" kind="new_feat" size="S">

<brief area="Data types and expressions">INDEG and OUTDEG functions
</brief>

<reference><specref ref="gql_numvalfunc"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W24-023.
</source>

<problem>

<para>It could be useful to have functions that return the number of edges pointing into 
a node (INDEGREE) and the number of edges pointing out from a node (OUTDEGREE).
Such functions should take into account undirected edges.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql346" number="GQL-346" kind="new_feat" size="M">

<brief area="Data types and expressions">Comparison predicates with more than two argument 
expressions
</brief>

<reference><specref ref="gql_comp"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W24-037.
</source>

<problem>

<para>Comparison predicate rules could be extended in the future to support comparing more than
two value expressions at the same time. 
For instance, how would GQL handle the evaluation of 2&lt;3&lt;1.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql347" number="GQL-347" kind="new_feat" size="L">

<brief area="System and execution model">Returning multiple outcomes when executing multiple
requests
</brief>

<reference><specref ref="gql_program"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W24-024R1.
</source>

<problem>

<para>WG3:W24-009 P00-WG3-077 suggests that it would be useful to allow the bundling of multiple 
requests into one as a way of reducing network round trips. 
This should include the capability for returning multiple results to the client in one round trip.
One possibility is to introduce a new top-level Subclause &lt;GQL-multi-request&gt; next to 
<BNF name="GQL-program"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql348" number="GQL-348" kind="port_ext" size="L">

<brief area="Statements and clauses">SQL-like update syntax
</brief>

<reference><specref ref="gql_dml"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W24-024R1.
</source>

<problem>

<para>WG3:W24-009 P00-WG3-102 suggests that according to the Working Draft<apos/>s philosophy of 
equally supporting an SQL-flavored syntax for easier onboarding of SQL developers, it would be 
beneficial to add data modification statements that are SQL-inspired.
</para>

</problem>

<solution>

<para>Adding syntax that supports, for example:
</para>
<code>
  DELETE v
  FROM personGraph
  MATCH (p:Person)-[v:VOTED_FOR]->(:Person)
    WHERE p.age &lt; 18
</code>
<para>and
</para>
<code>
  UPDATE p
  SET p.teen = TRUE
  FROM personGraph
  MATCH (p:Person) WHERE p.age &lt; 18
</code>
<para>Both examples reuse the FROM clause of the <BNF name="select statement"/>.
</para>

</solution>

</LO>


<LO id="PPgql349" number="GQL-349" kind="improv" size="M">

<brief area="Pattern matching">Testing whether conditional variables are bound
</brief>

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W24-024R1.
</source>

<problem>

<para>GQL could benefit from a predicate checking if a conditional variable is bound. 
One can check it with what is already there, for example, if an element x has property a, one can 
check (x.a=x.a) IS NOT NULL, but this is not a very natural way. 
This could be useful in patterns such as [ (A)? -> [ (B) -> (C) WHERE A.X = B.X+C.X ] -> (D)]{2}. 
In such patterns that appear to be allowed (see also comment WG3:W24-009 P00-WG3-144) one may want 
to test in the WHERE clause whether A is bound.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql350" number="GQL-350" kind="new_feat" size="XL">

<brief area="DDL">ALTER GRAPH TYPE and ALTER GRAPH
</brief>

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W24-024R1, WG3:UTC-084.
</source>

<problem>

<para>Support for ALTER GRAPH TYPE and ALTER GRAPH statements should be considered.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql353" number="GQL-353" kind="feat_ext" size="M">

<brief area="Statements and clauses">Multiple <BNF name="for item"/>s
</brief>

<reference><specref ref="gql_for"/>.
</reference>

<source>WG3:UTC-088.
</source>

<problem>

<para>Consider, in future versions of GQL, looking at the possibility of using multiple
<BNF name="for item"/>s in a <BNF name="for statement"/> while providing more advanced capabilities,
such as handling list of lists or record types within the <BNF name="for item"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql354" number="GQL-354" kind="new_feat" size="M">

<brief area="Data types and expressions">Array indexing
</brief>

<reference>No specific location.
</reference>

<source>WG3:UTC-127R1.
</source>

<problem>

<para>SQL/Foundation defines &lt;array element reference&gt; to return the <symdef>i</symdef>-th
element of an array. 
A similar way of referencing the <sym>i</sym>-th element of a list should be considered.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql355" number="GQL-355" kind="new_feat" size="M">

<brief area="Data types and expressions">LEAST and GREATEST

</brief>
<reference>No specific location.
</reference>

<source>WG3:UTC-127R1.
</source>

<problem>

<para>SQL/Foundation defines GREATEST and LEAST operators.
It needs to be decided if these additional operators should be included.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql356" number="GQL-356" kind="new_feat" size="XL">

<brief area="Specification mechanics">Improve nullability inference by SRs
</brief>

<reference><specref ref="gql_conc_nullability_req"/>.
</reference>

<noteAt><specref ref="PPgql356_1"/>.
</noteAt>

<source>WG3:UTC-051.
</source>

<problem>

<para>Syntax rules determining the declared type of sites should be revisited to improve
and specify (where lacking) the inference of the nullability of those sites.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql358" number="GQL-358" kind="improv" size="XL">

<brief area="Specification mechanics">Reduce use of immediate containment
</brief>

<reference>No specific location.
</reference>

<source>WG3:UTC-106.
</source>

<problem>

<comment>WG3:UTC-106</comment>
<para>The document relies on immediate containment to a great extent.
Experience in SQL suggests that immediate containment is very fragile and therefore to be avoided
if possible.
The document should be swept for instances of immediate containment that could
be replaced by some more robust form of containment.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql359" number="GQL-359" kind="improv" size="L">

<brief area="Editorial">Add more pretty figures and diagrams
</brief>

<reference>No specific location.
</reference>

<source>WG3:UTC-106.
</source>

<problem>

<comment>WG3:UTC-106</comment>
<para>The document could benefit from some additional diagrams to clarify aspects of
the specification.
</para>

<para>The following aspects have been suggested:
</para>

<olist>

<item>There are a lot of things in GQL that could be considered some form of executable
(programs, requests, commands, procedures, function, statements, query, and others).
The document needs a hierarchical diagram laying out the hierarchy of those to make
the concepts accessible to the reader.
</item>

<item>The current execution context, the current request context, and
the current session context seem to form some kind of hierarchy.
It might be nice to have a diagram showing the nesting of these contexts.
</item>

</olist>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql362" number="GQL-362" kind="feat_ext" size="M">

<brief area="Data types and expressions">Relax syntax constraints on value queries
</brief>

<reference><specref ref="gql_valquery"/>.
</reference>

<source>WG3:UTC-064.
</source>

<problem>

<comment>WG3:UTC-064</comment>
<para>The Syntax Rules of  <specref ref="gql_valquery"/> could be made more permissive with regard
to the contained <BNF name="nested query specification"/> to allow for more subqueries that
syntactically guarantee to return a binding table with one column and at most one record.
Paper WG3:UTC-064 has a discussion of cases not covered in Syntax Rules introduced by this paper.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql364" number="GQL-364" kind="new_feat" size="M">

<brief area="Data types and expressions">IS DISTINCT
</brief>

<reference><specref ref="gql_distinct_vals"/>. 
</reference>

<source>WG3:UTC-082R1.
</source>

<problem>

<para>It would be appropriate to consider &lt;distinct predicate&gt; in future versions of GQL.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql365" number="GQL-365" kind="improv" size="M">

<brief area="Editorial">GR classification by possible kinds of side effects 
</brief>

<reference>No specific location
</reference>

<noteAt>None.
</noteAt>

<source>Email from: Stefan Plantikow, 2023-08-23 1327.
</source>

<problem>

<para>Resolution of WG3:CMN-019 P00-USA-351 and P00-USA-353 has removed remaining uses of active 
voice in General Rules.
While alignment with WG3:SD-004 is appropriate, these changes also removed the use of active voice
as a mechanism for indicating which General Rules modify the GQL-environment, GQL-data, or any of 
the major kinds of contexts, <ie/> which General Rules perform side-effects. 
However, being able to easily identify such General Rules seems desirable for the reader.
</para>

</problem>

<solution>

<para>Develop a facility for the further (informative) classification of General rules as 
catalog-modifying, data-modifying, <etc/>
</para>

<para>Classifications should be indicated on the rules (<eg/> by an informative note or some kind 
of tag such as [DATA CHANGE]) as well as in an informative annex listing all rules with the same 
classification.
</para>

<para>Expansion of this facility to certain kinds of SRs (type inference, type requirement, 
rewrite, <ellipsis/>) and CRs (removal of surface syntax) could be considered.
</para>

</solution>

</LO>


<LO id="PPgql366" number="GQL-366" kind="feat_ext" size="M">

<brief area="Data types and expressions">Trimming of all whitespace characters
</brief>

<reference><specref ref="gql_charstrfunc"/>.
</reference>

<noteAt><specref ref="gql_PP366"/>.
</noteAt>

<source>WG3:CMN-024.
</source>

<problem>

<para>By default, the trim functions (TRIM, BTRIM, LTRIM, and RTRIM) remove leading and
trailing space characters.
When data might be copied and pasted, it is easy for a user to include whitespace characters other
than spaces.
While it is possible to specify a trim string that contains all whitespace characters, it is tedious
to do so.
It would be useful to include support for trimming whitespace in GQL.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql367" number="GQL-367" kind="improv" size="XL">

<brief area="Specification mechanics">ANTLR4-compatible grammar
</brief>

<reference>P00-Artifact, bnf.txt
</reference>

<source>WG3:CMN-064
</source>

<problem>

<para>From GQL DIS comment P00-NLD-044, ANTLR4 is a well-known parser generator and there is
already known interest in an ANTLR4 version of the GQL syntax.
(See <URI>https://github.com/TuGraph-family/gql-grammar</URI>).
</para>

<para>An ANTLR4 version of the GQL syntax should be developed and possibly replace
the existing <mono>gql-standard.bnf.txt</mono> artifact.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql368" number="GQL-368" kind="improv" size="M">

<brief area="Specification mechanics">Consider removal of aliasing BNF non-terminal definitions
</brief>

<reference><specref ref="gql_stm_comp_query_stm"/>.
</reference>

<source>WG3:CMN-064.
</source>

<problem>

<para>From GQL DIS comment P00-USA-362, Is any purpose served by a subclause whose
only BNF is:
</para>

<code>
&lt;A&gt; ::= &lt;B&gt;?
</code>

<para>Can we simplify by just deleting one of these two BNF non-terminals?
Note that the SRs and GRs do not add value, they merely pass along the static and
the dynamic information from one BNF non-terminal to the other. 
Perhaps one of these BNF non-terminals can be eliminated and their subclauses consolidated
into one.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql369" number="GQL-369" kind="improv" size="S">

<brief area="Specification mechanics">Consolidation of BNF non-terminals for synonyms
</brief>

<reference>No specific location.
</reference>

<source>WG3:CMN-064.
</source>

<problem>

<para>From GQL DIS comment P00-USA-208, Consolidation of all BNF non-terminals for defining synonyms
(<eg/> <kw>GRAPH</kw> <kw>PROPERTY</kw> and <kw>GRAPH</kw>) in a dedicated Subclause
should be considered and all such synonyms should be used consistently.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql370" number="GQL-370" kind="new_feat" size="XL">

<brief area="Data types and expressions">Native JSON type
</brief>

<reference><specref ref="gql_conc_dt"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:CMN-057R1.
</source>

<problem>

<para>GQL should add a native JSON data type the same way SQL has done. 
It has been objected that JSON originally was for data communication, not data storage. 
However, users have come to expect to store and manipulate JSON values in databases. 
The relationship between GQL<apos/>s native support for nested data using records and list values 
and such a JSON data type needs to be determined.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql371" number="GQL-371" kind="feat_ext" size="L">

<brief area="Data types and expressions">Mixed duration type
</brief>

<reference><specref ref="gql_value_type"/>.
</reference>

<noteAt><specref ref="gql_PP371"/>.
</noteAt>

<source>WG3:CMN-048.
</source>

<problem>

<para>Consider support for a mixed duration type that supports the full breadth of durations found
in ISO 8601 and in current programming languages (such as the upcoming extension currently in
development for ECMA JavaScript).
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql373" number="GQL-373" kind="improv" size="M">

<brief area="Editorial">Improve naming of non-terminals for literals
</brief>

<reference><specref ref="gql_literals"/>.
</reference>

<noteAt><specref ref="gql_LO373"/>.
</noteAt>

<source>WG3:W26-023.
</source>

<problem>

<para>The naming of some literal BNF terms should be reconsidered.
</para>

<para>Why is <BNF name="literal"/> not called &lt;signed literal&gt;. 
Or conversely, why is <BNF name="signed numeric literal"/> not called just 
&lt;numeric literal&gt;. 
Or, why is <BNF name="unsigned literal"/> not called <BNF name="literal"/>. 
What makes the signed the default and unsigned the special case? 
Why does this default not happen for numeric literals?
</para>

<para>In the GQL language, unsigned literals appear to be the more regular case. 
Any literal occurring an expression is generated via <BNF name="unsigned literal"/>. 
<BNF name="literal"/> has only use in rules and in <BNF name="value specification"/> which itself 
has only use in two Conformance Rules (outside its own Subclause).
</para>

<para>In many widely used programming languages numeric literals are unsigned, <cf/>
</para>

<ulist>

<item>C: https://en.cppreference.com/w/c/language/integer_constant
</item>

<item>C++: https://en.cppreference.com/w/cpp/language/integer_literal 
</item>

<item>Haskell:  https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-190002.5 
</item>

<item>Java: https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-IntegerLiteral
</item>

<item>JavaScript: https://262.ecma-international.org/#prod-NumericLiteral 
</item>

<item>Python: https://docs.python.org/3/reference/lexical_analysis.html#numeric-literals
</item>

</ulist>

<para>In other words, it appears to be the widely used norm that a literal is by default 
unsigned and that a signed literal is the special case.
</para>

<para>Note that this comment is solely about the naming of these non-terminals, not about their 
productions.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql374" number="GQL-374" kind="new_feat" size="L">

<brief area="System and execution model">Nested transactions and step-wise request
execution and rollback
</brief>

<reference><specref ref="gql_conc_tx_demarcation"/>.
</reference>

<noteAt><specref ref="gql_LO374"/>.
</noteAt>

<source>WG3:W26-032R1.
</source>

<problem>

<para>In SQL, if a statement terminates with an exception, the transaction will still be active
and not rolled back.
The action of the SQL-statement is rolled back, but prior successful statements
are not rolled back.
It would be beneficial, in a future version of GQL, to introduce the notion of nested transactions,
and a <quote>step-wise</quote> transaction mode that automatically runs each request in
subtransactions.
Hence, in case of failure only statements within a subtransaction would be rolled back.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql375" number="GQL-375" kind="improv" size="M">

<brief area="Ediorial">Split Subclause on literals
</brief>

<reference><specref ref="gql_literals"/>.
</reference>

<noteAt><specref ref="gql_W26_026_1"/>.
</noteAt>

<source>WG3:W26-026R2.
</source>

<problem>

<para>The <specref ref="gql_literals"/> is very long and would benefit from factoring out larger
groups of types (<eg/> numerics, strings, temporals, constructed types).
Similar considerations apply to <specref ref="gql_value_type"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql376" number="GQL-376" kind="new_feat" size="L">

<brief area="Data types and expressions">Partial (half-open) types and width-subtyping of records
</brief>

<reference><specref ref="gql_conc_dt"/>.
</reference>

<noteAt><specref ref="gql_W26_026_2"/>.
</noteAt>

<source>WG3:W26-026R2.
</source>

<problem>

<para>Subtyping in GQL is currently defined in terms of set inclusion. 
Modern type theory has shifted to a model of substitutability instead in order to naturally model 
features such as width-subtyping of records.
</para>

<para>It should be investigated, if GQL<apos/>s combination of set inclusion-subtyping amended 
with optional implicit conversions provided by individual operators and assignability can be
compatibly redefined in terms of substitutability instead. 
The main motivation for this currently is the desire to support width-subtyping of records and, 
possibly, other future <quote>partially open</quote> types (such as <quote>partially open</quote> 
node and edge types).
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql377" number="GQL-377" kind="improv" size="M">

<brief area="Editorial">Clause 3 and Clause 4 term definition clean-up
</brief>

<reference><specref ref="gql_definitions"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W26-035.
</source>

<problem>

<para>There are too many terms in Clause 3.
</para>

<para>Many of these are also defined in Clause 4.
This leads to different definitions of the same term, sometimes because of the restrictions on 
the format of definitions in Clause 3.
</para>

</problem>

<solution>

<para>Terms which are also defined in Clause 4 should generally be eliminated from Clause 3. 
If it is felt absolutely necessary to also have the terms in Clause 3, then the
definition in Clause 4 should be of the form: A <emph>term</emph> is defined in 
<specref ref="gql_definitions"/>, as <emph>definition</emph>. 
Where <emph>term</emph> is the term being defined and <emph>definition</emph> is the definition 
copied from Clause 3. 
The entire sentence should be generated by specific mark-up to avoid divergence of definitions.
</para>

</solution>

</LO>


<LO id="PPgql378" number="GQL-378" kind="new_feat" size="XL">

<brief area="Schema and metadata model">Universal graph type system
</brief>

<reference><specref ref="gql_graph_type"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W26-038R1.
</source>

<problem>

<para>Graph types are defined in <BNF name="create graph type statement"/> and other 
BNF non-terminal contained within.
These encompass concepts such as:
</para>

<ulist>

<item>key label sets,
</item>

<item>element type identification restrictions,
</item>

<item>end-point node types,
</item>

<item>structural consistency matters, and
</item>

<item>property value type consistency matters.
</item>

</ulist>

<para>However, these specifications are within a graph type scope.
In daily use, GQL will make extensive reuse of graph elements, including the constructs
described above, across (possibly) many graph types.
This requires a <quote>universal</quote> abstract graph type system and a target graph type. 
It also requires that GQL properties to be directly referenceable as such in combination with 
other graph elements, including other properties, edges, relationships and graphs.
</para>

<para>This is also the case for other GQL language opportunities. 
See also <PPref ref="PPgql241"/>, <PPref ref="PPgql242"/>, <PPref ref="PPgql243"/>, and 
<PPref ref="PPgql241"/>.
And see also paper WG3:W26-022R1.
</para>

<para>There are some industry and academic papers about such constructs using the terms
<quote>canonical form</quote> and <quote>graph normal form</quote>.
</para>

<figure id="gql_PPgql378_fig" file="gql_PPgql378_fig.svg" padding-after="10pt" width="5.0in">
<figureTitle>Metagraph</figureTitle>
</figure>

<para>The metagraph in <specref ref="gql_PPgql378_fig"/> is the backbone for the coming 
GQL information schema graph, it needs not to be stored as a graph (certainly a good idea though),
the metadata will mostly be generated from the schema syntax and the presentation may be along the 
LPG paradigms.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql379" number="GQL-379" kind="new_feat" size="S">

<brief area="Data types and expressions">Generic length expression
</brief>

<reference><specref ref="gql_numvalfunc"/>.
</reference>

<noteAt><specref ref="gql_PP379"/>.
</noteAt>

<source>WG3:W26-037R3.
</source>

<problem>

<para>Support for a generic <BNF name="length expression"/> LENGTH(<ellipsis/>), in the same spirit
as the <BNF name="cardinality expression"/>, should be considered.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql380" number="GQL-380" kind="new_feat" size="S">

<brief area="Data types and expressions">Node, edge, element set cardinality functions for graphs
</brief>

<reference><specref ref="gql_numvalfunc"/>.
</reference>

<noteAt><specref ref="gql_PP380"/>.
</noteAt>

<source>WG3:W26-037R3.
</source>

<problem>

<para>Support for determining the cardinalities of element, node, and edge sets of graphs
referenced by graph reference values should be added (possibly by expanding the
<BNF name="cardinality expression"/>).
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql381" number="GQL-381" kind="improv" size="S">

<brief area="Specification mechanics">Move GRs for determining the values of literals to SRs
</brief>

<reference><specref ref="gql_literals"/>.
</reference>

<noteAt><specref ref="gql_PP381"/>.
</noteAt>

<source>WG3:W26-023.
</source>

<problem>

<para>The values specified by <BNF name="literal"/>s are currently determined by their 
General Rules. 
Instead, such values should be specified by Syntax Rules and then a corresponding 
General Rule should simply return the specified value of each <BNF name="literal"/> literal>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql382" number="GQL-382" kind="feat_ext" size="S">

<brief area="Data types and expressions">Extend aggregation functions to operate on temporal values
</brief>

<reference><specref ref="gql_aggregate_func"/>.
</reference>

<noteAt><specref ref="gql_PP382"/>.
</noteAt>

<source>WG3:W26-036.
</source>

<problem>

<para>The data aggregation functions <kw>SUM</kw> and <kw>AVG</kw> currently operate only on 
numeric types. 
It would be useful to also be able to apply <kw>SUM</kw> and <kw>AVG</kw> (and other data 
aggregation functions) to temporal duration types.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql383" number="GQL-383" kind="improv" size="XS">

<brief area="Statements and clauses">Relax restrictions on variables bound by LET
</brief>

<reference><specref ref="gql_let"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W27-012R2.
</source>

<problem>

<para><itemref ref="gql_let_btrns"  type="SR"/> in <specref ref="gql_let"/> is overly restrictive
with regards to variable names allowed in scalar subqueries contained in 
a <BNF name="let variable definition"/>. 
It could be beneficial to relax this rule a bit. 
However, it should only be relaxed thus far so that it still serves its purpose.
WG3:W27-012R2 has more discussion.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<PP id="PPgql388" number="GQL-388" severity="minor" realm="editorial">

<brief area="Editorial"><specref ref="gql_procedure_body"/>, 
GR <itemref ref="gql_procedure_body_GR3bi"/> must use the &lt;applySC&gt; markup
</brief>

<reference><specref ref="gql_procedure_body"/>.
</reference>

<noteAt><specref ref="gql_PPgql388"/>.
</noteAt>

<source>Editor.
</source>

<problem>

<para><itemref ref="gql_procedure_body_GR3bi"/> must use the &lt;applySC&gt; markup.
This requires adding a signature to <specref ref="gql_yield"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<PP id="PPgql391" number="GQL-391" severity="major" realm="technical">

<brief area="Data types and expressions">Lack of local type aliases
</brief>

<reference><specref ref="gql_node_type_defn"/>.
</reference>

<noteAt><specref ref="gql_PPgql391"/>.
</noteAt>

<source>LDBC GQL-IP-008.
</source>

<problem>

<para>Explicit type name for node or edge type prevents definition of local type alias, but 
edge spec requires a programmer to know what the alias is, which is hard if the system generates it.
</para>

</problem>

<solution>

<para>Allow aliases for named types, and default aliases to the type name when not supplied.
</para>

</solution>

</PP>


<PP id="PPgql392" number="GQL-392" severity="minor" realm="editorial">

<brief area="Editorial">Invalid use of the term <quote>formal semantics</quote>
</brief>

<reference><specref ref="gql_conc_graph_patt_match_path_patt_match"/>.
</reference>

<noteAt><specref ref="gql_PPgql392_1"/> and <specref ref="gql_PPgql392_2"/>.
</noteAt>

<source>LDBC GQL-IP-009.
</source>

<problem>

<para><specref ref="gql_reject_pb"/> and <specref ref="gql_inf_sets"/> refer to 
<quote>formal semantics</quote>. 
It is not clear what formal semantics means. 
It does not mean the formal semantics as it would be meant conventionally in CS 
(denotational, operational, axiomatic).
</para>

<para>Linked to <ExtPPref ref="PPpgq099" standard="9075" part="16"/>.
</para>

</problem>

<solution>

<para>Edit as follows:
</para>

<para>the <strikethrough>formal semantic</strikethrough> stepwise presentation of the semantics 
specified in <specref ref="gql_eval_path_pattern_expr"/>.
</para>

</solution>

</PP>


<PP id="PPgql393" number="GQL-393" severity="minor" realm="editorial">

<brief area="Editorial">Invalid example in informative note
</brief>

<reference><specref ref="gql_conc_graph_patt_match_path_mode"/>.
</reference>

<noteAt><specref ref="gql_PPgql393"/>.
</noteAt>

<source>LDBC GQL-IP-010.
</source>

<problem>

<para>Pattern in <specref ref="gql_path_mode_hier"/> is inconsistent with the text.
The pattern ()-()-() cannot be matched in a graph ()~[]~().
The pattern ()-[]-() can be. 
Is that what was intended?
</para>

<para>Linked to <ExtPPref ref="PPpgq100" standard="9075" part="16"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<LO id="PPgql394" number="GQL-394" kind="improv" size="L">

<brief area="Data model and catalog">Unify GQL-directory and GQL-schema
</brief>

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>LDBC GQL-IP-001.
</source>

<since>2024-05-05.
</since>

<problem>

<para>Remove the concept of a GQL-schema, and allow GQL-directory to be a root, inner or leaf node 
of the  GQL-catalog hierarchy. 
This would make the usage of a catalog exactly analogous to the usage of a file system. 
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql395" number="GQL-395" kind="improv" size="S">

<brief area="Editorial">Improve figure on GQL-catalog</brief>

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>LDBC GQL-IP-003.
</source>

<since>2024-05-05.
</since>

<problem>

<para>Illustrate relationship between GQL-schema and GQL-data.
Augment informative <specref ref="gql_cat_diag"/> to show the association between primary catalog 
objects and primary data objects.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql396" number="GQL-396" kind="new_feat" size="M">

<brief area="Data model and catalog">Map catalog to IRIs
</brief>

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>LDBC GQL-IP-004.
</source>

<since>2024-05-05.
</since>

<problem>

<para>Define ways of using IRIs to uniquely identify a GQL catalog, such that catalog or data 
objects can have universally unique identifiers.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql397" number="GQL-397" kind="improv" size="M">

<brief area="Editorial">Favor use of <quote>content</quote> over <quote>filler</quote>
</brief>

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>LDBC GQL-IP-006.
</source>

<since>2024-05-05.
</since>

<problem>

<para>Stop saying <quote>filler</quote>, start saying <quote>content</quote>.
<BNF name="node type implied content"/> points the way. 
<quote>Content</quote> is widely used in the LDBC discussions on <eg/> schema. 
Elements are objects with identity and content. 
Labels + properties = content. 
Keys imply the rest of the content. 
Therefore, node types have content types, ditto edge types  they have 
&gt;<ellipsis/> content type>, not &gt;<ellipsis/> filler>. 
Insert patterns have insert content, match patterns have match content, not filler. 
Use these terms in BNF NTs and it will help clarify the meaning and context of these parts of the 
grammar. 
It will also reinforce the point that DDL is type patterns, DML is insert patterns, 
GPML is match patterns. 
</para>

</problem>

<solution>

<para>Replace &lt;<ellipsis/> filler> with 
&lt;<ellipsis/> content type> in BNF non-terminals for element types.
</para>

<para>Replace &lt;<ellipsis/> filler> with 
&lt;<ellipsis/> content> in BNF non-terminals for match and insert patterns. 
</para>

<para>Replace &lt;implied content> with &lt;implied content type>.
</para>

</solution>

</LO>


<LO id="PPgql398" number="GQL-398" kind="improv" size="S">

<brief area="Data model and catalog">Clarify notion of empty catalog
</brief>

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>LDBC GQL-IP-011.
</source>

<since>2024-05-09.
</since>

<problem>

<para>In <specref ref="gql_conc_env_gendescr"/>, the fourth bullet is:
</para>
<ulist>
<item>One GQL-catalog that comprises one GQL-catalog root. 
<emph>A GQL-catalog that comprises only the GQL-catalog root is considered to be empty</emph>.
The GQL-catalog is not required to be empty after the instantiation of the GQL-environment.
</item>
</ulist>
<para>However, in <specref ref="gql_schema_refs"/> we read:
</para>
<olist>
<item>If the <BNF name="schema reference"/> <symdef>SR</symdef> is specified, then the GQL-schema
identified by <sym>SR</sym> is the GQL-schema identified by the immediately contained
<BNF name="absolute catalog schema reference"/> or <BNF name="relative catalog schema reference"/>.
</item>
<item>If the <BNF name="absolute catalog schema reference"/> <symdef>ACSR</symdef> is specified,
then
<para>Case:
</para>
<olist>
<item><emph>If <sym>ACSR</sym> is a <BNF name="solidus"/>, then:</emph>
<olist>
<item><emph>The GQL-catalog root shall be a GQL-schema</emph>.
</item>
<item><emph>The GQL-schema identified by <sym>ACSR</sym> is the GQL-catalog root</emph>.
</item>
</olist>
</item>
</olist>
</item>
</olist>
<para>In <specref ref="gql_conc_env_schema"/>, there is a paragraph:
</para>

<para>A GQL-implementation may automatically populate a GQL-schema upon its creation in
an <impDef code="IW016"/> way.
</para>

<para>Further, one cannot CREATE SCHEMA /. 
But it is possible to refer to a schema AT /.
</para>

<para>Summary: there is nothing to attach an <impDef code="None" annex="no"/> schema to 
a <quote>root schema</quote>. 
The idea of a root schema (a GQL-catalog that is a GQL-schema) is contradicted by the idea that 
a catalog containing only a root is empty.
</para>

</problem>

<solution>

<para>Introduce an <quote>ambient (focused) schema</quote> analogous to the concepts of 
an <quote>ambient (focused) graph</quote>. 
If an implementation conjures up a schema on loading the environment, then such an ambient schema 
should be considered as mutually exclusive of the ability to create or refer to a schema via 
a catalog path (a focused schema). 
An ambient schema may be referred to by  AT CURRENT_SCHEMA but not by AT .
or AT /. 
If there is a catalog, then it should be possible to create a schema [or primary catalog objects, 
as per <PPref ref="PPgql394"/> (GQL-IP 001)] in the root, but not as the root. 
If there is a catalog, then the root should always be present, and it should be a directory.
</para>

</solution>

</LO>


<LO id="PPgql399" number="GQL-399" kind="new_feat" size="L">

<brief area="Specification mechanics">Well-defined GQL variants
</brief>

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>LDBC GQL-IP-012.
</source>

<since>2024-05-09.
</since>

<problem>

<para>Introduce two explicit conformance features:
</para>
<ulist>
<item>GGnn GG03 Without catalog (ambient schema)
</item>
<item>GGmm GG04 With catalog (focused schema)
</item>
</ulist>
<para>At present it is not possible to clearly delineate Core GQL variants, as an implementation 
may conjure up a schema outside a catalog or where it is considered to be the root in some sense).
</para>

<para>This Language Opportunity depends on <PPref ref="PPgql398"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql400" number="GQL-400" kind="new_feat" size="L">

<brief area="Specification mechanics">Define GQL Core language
</brief>

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>LDBC GQL-IP-013.
</source>

<since>2024-05-09.
</since>

<problem>

<para>Introduce term <quote>Core GQL</quote> as synonym for mandatory conformance features.
Introduce human-readable descriptions of permitted Core GQL variants 
(assuming <PPref ref="PPgql398"/> [GQL-IP 011] is agreed), with acronyms
</para>
<para>Core GQL With graph types, With catalog (GG02, GG04)  <bold>Core GQL+TC</bold>
</para>
<para>Core GQL Without graph types, Without catalog (GG01, GG03)  <bold>Core GQL</bold>
</para>
<para>Core GQL With graph types, Without catalog (GG02, GG03)  <bold>Core GQL + T</bold>
</para>
<para>Core GQL Without graph types, With catalog (GG01, GG04)  <bold>Core GQL + C</bold>
</para>

<para>This Language Opportunity depends on <PPref ref="PPgql399"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql401" number="GQL-401" kind="new_feat" size="XL">

<brief area="Statements and clauses">Graph projection and construction</brief>

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>Editor.
</source>

<since>2024-06-09
</since>

<problem>

<para>Initial versions of GQL included the capability for dynamically projecting graphs
without recourse to data-modifying statements.
This baseline functionality enabled graph-returning queries whose result was either
a (new) graph snapshot or a (derived) graph view. 
</para> 

<para>GQL is currently lacking such functionality.
It has been argued that this is a major omission that prevents GQL from being
a fully graph-composable language.
Further, failing to support use cases requiring such a feature, ultimately will negatively impact 
adoption.
</para>

<para>For prototypical designs regarding this feature, consider:
</para>

<ulist>

<item>Early designs made in the context of openCypher:
<URI active="yes">https://git.io/fjmrx</URI>
</item>

<item>CONSTRUCT in SPARQL:
<URI active="yes">https://www.w3.org/TR/sparql11-query/#construct</URI>
</item>

</ulist>

<para>The inclusion of functionality for the dynamic projection of graph snapshots and
graph views should be strongly considered in the next version of GQL.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql402" number="GQL-402" kind="new_feat" size="M">

<brief area="Data types and expressions">String interpolation
</brief>

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>Editor.
</source>

<since>2024-06-10
</since>

<problem>

<para>Many programming languages contain facilities for string interpolation, <ie/>
make it easy to construct a character string value whose content is partially generated
from values of other data types (such as numbers).
</para>

<para>String interpolation is commonly provided via a syntactic approach that is highly
readable and prevents accidental misgeneration of character strings (<ie/> help to avoid so-called
injection attacks). 
Further, string interpolation may play a role in the generation of input to LLMs that is
derived from graph data.
</para>

<para>Addition of a string interpolation facility should be considered for GQL.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<PP id="PPgql403" number="GQL-403" severity="major" realm="technical">

<brief area="Data types and expressions"><specref ref="gql_node_type_defn"/>, 
<itemref ref="gql_node_type_defn_SR_local_node_type_alias" type="SR"/> misses a Syntax Rule
</brief>

<reference><specref ref="gql_node_type_defn"/>.
</reference>

<noteAt><specref ref="gql_PPgql391"/>.
</noteAt>

<source>Neo4j LANGSTAR.
</source>

<problem>

<para><specref ref="gql_node_type_defn"/>, 
<itemref ref="gql_node_type_defn_SR_local_node_type_alias" type="SR"/> misses a rule for 
the case where a <BNF name="node type name"/> is given instead of 
a <BNF name="local node type alias"/>. 
Something like:
</para>

<lbllist>
<lblitem label="b)">If <sym>ANTS</sym> simply contains a <BNF name="node type name"/> 
<symdef>NTN</symdef>, then the local node type alias of <sym>ANTS</sym> is the name specified by 
the <BNF name="identifier"/> that constitutes <sym>NTN</sym>.
</lblitem>
</lbllist>

<para>This is needed for examples like:
</para>

<code>
NODE TYPE Person ({name :: STRING}),

NODE TYPE City ({name :: STRING}),

DIRECTED EDGE TYPE LIVES_IN CONNECTING Person TO City
</code>

<para>to work. 
Such example are given in large number in [WG3:W26-022r2], <eg/> SET-ETN-PE-1 and following. 
Hence, this clearly was intended to work and it is bug in the rules put in by [WG3:W26-022r2].
</para>

<para>Side remark: <BNF name="local node type alias"/> is limited to 
a <BNF name="regular identifier"/> while <BNF name="node type name"/> is not. 
However, <quote>the <emph>local node type alias</emph> of 
a <BNF name="node type specification"/></quote> 
is not a name, <ie/> with any escaping and delimiting removed. 
Hence, this difference between <BNF name="local node type alias"/> and <BNF name="node type name"/> 
does not matter.
</para>

<para>[This is the minimal necessary bug fix to address LEX-61, GQL-IP-008. 
GQL-IP-008 also proposes a relaxation of <specref ref="gql_node_type_defn"/>, 
<itemref ref="gql_node_type_defn_SR_node_type_name" type="SR"/>, concretely the 
removal of <itemref ref="gql_node_type_defn_SR_node_type_alias" type="SR"/>. 
This is beyond [WG3:W26-022r2], hence it is an LO.]
</para>

<para>See also <PPref ref="PPgql391"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<PP id="PPgql406" number="GQL-406" severity="minor" realm="technical">

<brief area="Specification mechanics">Ill-defined use of
<quote>A is B</quote>
</brief>

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>Neo4j LANGSTAR.
</source>

<problem>

<para>Observation: We are using <quote>A is B</quote> in the meaning of <quote>A simply contains 
B and A does not simply contain any C that is not contained in B nor intervening between 
A and B</quote>. 
Note that this meaning works over production rules that can cause the instance tree to branch, 
<eg/> &lt;A> ::= &lt;B> [ &lt;C> ]. 
This meaning of to be is on non-terminal instance level  so to speak.
</para>

<para>However, <specref ref="gql_containment"/>, defines <quote>to be</quote> more strict because 
it requires a production rules &lt;A> ::= &lt;B>, <ie/> that the possibility of a C is already 
ruled out be the grammar. 
The definition does not apply to production rules like &lt;A> ::= &lt;B> [ &lt;C> ]. 
</para>

<para>The defined meaning of <quote>to be</quote> is non-terminal level  so to speak.
</para>

<para>Since no one has complained about this, I wonder if the definition is simply disconnected 
from how it is generally understood. 
This requires finding examples not written by us, though. 
If it demonstrates to be correct, it may be good to adjust the definition.
</para>

<para>If the misunderstanding is just on our part, it would be good it introduce a non-terminal 
instance level <quote>to be</quote> because it is damn useful.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<LO id="PPgql413" number="GQL-413" kind="improv" size="S">

<brief area="Data types and expressions">Relax restrictions on <BNF name="node type specification"/>
</brief>

<reference><specref ref="gql_node_type_defn"/>.
</reference>

<noteAt>None.
</noteAt>

<source>Neo4j LANGSTAR.
</source>

<since>2024-07-15.
</since>

<problem>

<para>LDBC LEX-61 GQL-IP-008 identifiers a missing rule in <specref ref="gql_node_type_defn"/>, 
which is documented as a separate possible problem.
</para>

<para>GQL-IP-008 also proposes a relaxation of <specref ref="gql_node_type_defn"/>, 
<itemref ref="gql_node_type_defn_SR_node_type_name" type="SR"/>, concretely the removal of 
<itemref ref="gql_node_type_defn_SR_node_type_alias" type="SR"/>. 
</para>

<para>This is beyond [WG3:W26-022r2], hence it is an LO.
</para>

<para>See also <PPref ref="PPgql391"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql414" number="GQL-414" kind="feat_ext" size="S">

<brief area="DDL">Syntax short-hand: CREATE GRAPH myGraph
</brief>

<reference><specref ref="gql_create_graph"/>.
</reference>

<noteAt>None.
</noteAt>

<source>Neo4j LANGSTAR.
</source>

<since>2024-07-15
</since>

<problem>

<para>In <specref ref="gql_create_graph"/>, the BNF for <BNF name="open graph type"/> is:
</para>

<grammar discussion="yes">
<BNFdef name="open graph type">
<rhs>
<opt> <BNF name="typed"/> </opt> <kw>ANY</kw> <opt> 
<opt> <kw>PROPERTY</kw> </opt> <kw>GRAPH</kw> </opt>
</rhs>
</BNFdef>
</grammar>

<para>With this BNF, creating an open graph requires a minimal syntax of:
</para>

<code>
<kw>CREATE</kw> <kw>GRAPH</kw> MyGraph <kw>ANY</kw>
</code>

<para>It might be possible to make the entire production optional and add a syntax rule specifying 
that a zero-length <BNF name="open graph type"/> implies ANY. 
This would allow a minimal syntax of:
</para>

<code>
<kw>CREATE</kw> <kw>GRAPH</kw> MyGraph
</code>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<PP id="PPgql415" number="GQL-415" severity="major" realm="technical">

<brief area="Data types and expressions">Ensure type lattice of each base type can be closed by 
union types
</brief>

<reference><specref ref="gql_stat_combo_vts"/>.
</reference>

<noteAt><specref ref="gql_PPgql415"/>.
</noteAt>

<source>Email from Stefan Plantikow, 2024-09-18 13:40.
</source>

<problem>

<para>All value types defined by the standard form a lattice with uniquely defined upper and 
lower bounds for any finite set of value types as well both a top (ANY) and 
a bottom (NOTHING) type. 
However, some of the data types inherited from <SQL/> do not guarantee the existence of 
upper bounds among the types of the same static base type.
</para>

<para>As a consequence of this, static value type combination is currently forced to pick some 
arbitrary type that is not a proper upper bound for certain inputs. 
Further, this design prevents implementations with support for dynamic union types to naturally 
close per-base type sublattices by generating an appropriate dynamic union type via general value 
type combination.
</para>

<para>This unnecessarily complicates and restricts implementations interested in providing 
dynamic union type support. 
A possible solution would be to allow implementations to fail in static value type combination 
where no common upper bound exists for the given inputs in a respective static base type. 
This relaxation of the current regime would then enable general value type combination to close 
the lattice by producing the closed dynamic union type of the inputs.
</para>

<para>This issue in a narrow sense needs to be solved for numeric types.
</para>

<para>More broadly, for certain kinds of types, the current rules of static value type 
combination are unnecessarily broad, forcing the return of base type-specific supertypes where 
a more specific union type would be available in certain implementations. 
This should be reviewed regarding whether the return of union types could be considered 
permissible, too. 
From a quick look at <specref ref="gql_stat_combo_vts"/>, this secondary issue seems to apply to: 
byte string types, character string types, the zoned-ness of temporal instant types, and 
reference value types.
</para>

<para>Both suggested solutions would be backward-compatible.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<PP id="PPgql416" number="GQL-416" severity="major" realm="technical">

<brief area="Conditional statement">Support for conditional updates after NEXT</brief>

<reference><specref ref="gql_conditional_stm"/>.
</reference>

<noteAt><specref ref="gsl_PPgql416"/>.
</noteAt>

<source>WG3:GYD-030.
</source>

<problem>

<para><specref ref="gql_conditional_stm"/>, 
<itemref ref="gql_gql_conditional_stm_SR_restiction" type="SR"/> forbids placing 
a <BNF name="conditional statement"/> immediately after <kw>NEXT</kw> if any of its branches 
is potentially data-modifying. 
This restriction should be lifted.
</para>

<para>See also <PPref ref="PPgql418"/> and <PPref ref="PPgql417"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<PP id="PPgql417" number="GQL-417" severity="major" realm="technical">

<brief area="Data-modifying statements">Deterministic conflict resolution.</brief>

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:GYD-030.
</source>

<problem>

<para>Certain data-modifying statements (<kw>SET</kw>, <kw>REMOVE</kw>, <ellipsis/>) need to 
resolve conflicting updates caused by processing the rows of the incoming working table. 
Currently, conflict resolution of this nature is specified somewhat ad-hoc in the General Rules
of each statement in a way that gives a lot of freedom to implementations but does not provide
deterministic outcomes, hampering portability of queries. 
It should be investigated how the user could be provided with more control over conflict 
resolution (<eg/> via additional syntax for specifying conflict resolution strategies) in a way 
that does not fail to address <PPref ref="PPgql418"/>. 
At a minimum, introducing syntax that causes a runtime exception to be raised when a conflict 
is detected should be provided (<quote>FORCE SET|REMOVE</quote>).
</para>

<para>Resolving this issue is particularly required to support conditional updates after 
<kw>NEXT</kw> (See <PPref ref="PPgql416"/>).
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<LO id="PPgql418" number="GQL-418" 
    kind="improv"
    size="M">

<brief area="Conflicts">Provide general definition of update conflict resolution</brief>

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:GYD-030.
</source>

<since>2024-09-28.
</since>

<problem>

<para>Certain data-modifying statements (<kw>SET</kw>, <kw>REMOVE</kw>, <ellipsis/>) need to 
resolve conflicting updates caused by processing different rows of the incoming working table.
Currently, conflict resolution of this nature is specified somewhat ad hoc in the General Rules 
of each statement. 
It might improve the standard by instead providing a correct definition of (recordable) data 
modification together with any additional required new terminology and specify the rules of 
conflict resolution in a callable subclause. 
Care needs to be taken to specify conflict resolution in a way that meets implementation 
requirements (<eg/> in terms of supported subtransaction isolation) but does not fail to 
address <PPref ref="PPgql417"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql419" number="GQL-419" 
    kind="feat_ext"
    size="S">

<brief area="Conditional statement">Support for discarding branches</brief>

<reference><specref ref="gql_conditional_stm"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:GYD-030.
</source>

<since>2024-09-28.
</since>

<problem>

<para>A <BNF name="conditional statement"/> with support for <quote>discarding</quote> branches 
(<eg/> using a new statement, such as BREAK) should be provided:
</para>

<code>
MATCH (a)
CALL {
  WHEN a.size &lt;> 108 THEN BREAK
  ELSE RETURN a.size AS size
}
RETURN a, size
</code>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql420" number="GQL-420" 
    kind="feat_ext"
    size="S">

<brief area="Conditional statment">Support for &lt;simple conditional statement>s</brief>

<reference><specref ref="gql_conditional_stm"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:GYD-030.
</source>

<since>2024-09-28.
</since>

<problem>

<para>A variant of <BNF name="conditional statement"/> with support for 
&lt;simple conditional statement>s should be provided:
</para>

<code>
CALL {
  COND a.passion
  WHEN <quote>movies</quote>
  THEN
    MATCH (a)-[:HAS]->(m:Movie)
    RETURN <quote>loves movies</quote> AS msg, count(m) AS num
  WHEN <quote>reading</quote>
  THEN
    MATCH (a)-[:HAS]->(b:Book)
    RETURN <quote>loves books</quote> AS msg, count(b) AS num
}
</code>

<para>Such a variant should start by establishing a &lt;conditional statement operand> in order 
to support &lt;simple conditional statement when clause>s in the same style as
a <BNF name="simple case"/>.
</para>

<para>See WG3:GYD-030 for draft changes of how such functionality might be specified.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql421" number="GQL-421" 
    kind="feat_ext"
    size="M">

<brief area="Conditional statement">Support for <quote>match-and-run</quote> branches</brief>

<reference><specref ref="gql_conditional_stm"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:GYD-030.
</source>

<since>2024-09-28.
</since>

<problem>

<para>A variant of <BNF name="conditional statement"/> with support for 
<quote>match-and-run</quote> branches like in the following example should be provided:
</para>

<code>
MATCH (a)
CALL {
  WHEN BINDING (a)-[:HAS]->(b:Movie)
  THEN
    RETURN <quote>has movies</quote> AS msg, count(b) AS num
  WHEN BINDING {
    MATCH (a)
    <ellipsis/>
    MATCH (a)-[:HAS]->(b:Book)
    RETURN *
  }
  THEN
    RETURN <quote>has only books</quote> AS msg, count(b) AS num
}
</code>

<para>Such a variant would provide the ability to use a tabular subquery as the search condition 
of a <BNF name="conditional statement when clause"/> such that:
</para>

<olist>

<item>The search condition is considered <bool>True</bool> if and only if it produces 
at least one row.
</item>

<item>All new binding variables bound at the end of evaluating that search condition are made
available to the <BNF name="conditional statement result"/>, 
<eg/> any successful pattern matches become the incoming working table for the evaluation of 
the branch result.
</item>

</olist>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql422" number="GQL-422" 
    kind="feat_ext"
    size="L">

<brief area="Conditional statement">Support for returning from nested conditionals</brief>

<reference><specref ref="gql_conditional_stm"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:GYD-030.
</source>

<since>2024-09-28.
</since>

<problem>

<para><BNF name="conditional statement"/> with support for returning results from nested 
conditionals should be provided (<eg/> using some form of <quote>jump</quote> labels, such as
<quote>outer</quote> below):
</para>

<code>
outer:
WHEN <ellipsis/> THEN {
  MATCH <ellipsis/>
  CALL {
   THEN <ellipsis/>
     RETURN <ellipsis/> TO outer
   WHEN <ellipsis/>
   THEN <ellipsis/>
     BREAK TO outer
   ELSE
     RETURN <ellipsis/>
  }
  RETURN *
  NEXT
  // keep going (!)
  <ellipsis/>
  RETURN <ellipsis/>
}
</code>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<PP id="PPgql423" number="GQL-423" severity="minor" realm="technical">

<brief area="Specification mechanics">Missing type check</brief>

<reference><specref ref="gql_stm_proc_call"/>.
</reference>

<noteAt><specref ref="gql_PP423"/>.
</noteAt>

<source>Email from: Stefan Plantikow, 2024-10-12 1108.
</source>

<problem>

<para>A <BNF name="named procedure call"/> can in principle return a result of any possible 
result type, not just binding tables. 
This needs to be protected against here as the calling context is not yet ready to handle 
non-tabular returns. 
If this is done, <itemref ref="gql_gql_stm_proc_call_SR_Other" type="SR"/> will become unreachable
and should be removed. 
It may also be appropriate to register an LO for handling non-tabular returns once this problem 
is resolved.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<PP id="PPgql425" number="GQL-425" severity="minor" realm="technical">

<brief area="Specification mechanics">Disallow single underscore as a valid 
<BNF name="regular identifier"/></brief>

<reference><specref ref="gql_token"/>.
</reference>

<noteAt><specref ref="gql_PP425"/>.
</noteAt>

<source>Email from: Stefan Plantikow, 2024-10-24 1210.
</source>

<problem>

<para>The current definition of <BNF name="regular identifier"/> allows the use of 
a single underscore as a valid identifier. 
This is a consequence of adopting Unicode-based identifiers but misaligned with 9075 
which does not allow this.
Further, the use of a single underscore is sometimes adopted for default parameters or 
wildcard variables in certain languages. 
Continuing to allow a single underscore as a valid <BNF name="regular identifier"/> 
prevents such use by future additions to the standard.
</para>

<para>We think this should be corrected.
</para>

<para>A possible solution might be:
</para>

<para>The representative form of a <BNF name="non-delimited identifier"/> shall not 
comprise a sequence of <BNF name="underscore"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<PP id="PPgql428" number="GQL-428" severity="minor" realm="technical">

<brief area="Grammar">Parsing ambiguity</brief>

<reference><specref ref="gql_create_graph_type"/>. 
</reference>

<noteAt><specref ref="gql_PP428"/>.
</noteAt>

<source>Email from: Michael Burbidge, 2025-02-07 2324.
</source>

<problem>

<para>Consider the following example:
<kw>CREATE</kw> <kw>GRAPH</kw> <kw>TYPE</kw> AAA <kw>AS</kw> <kw>COPY</kw> <kw>OF</kw> BBB
Since <kw>TYPE</kw> is a <BNF name="non-reserved word"/> this statement could parse as either

<BNF name="create graph statement"/> (see <specref ref="gql_PP428_1"/>).
</para>

<figure id="gql_PP428_1" file="GQL-PP428-1.png" padding-after="10pt">
<figureTitle>Parse tree as CREATE GRAPH STATEMENT</figureTitle>
</figure>

<para>or

<BNF name="create graph type statement"/> (see <specref ref="gql_PP428_2"/>).
</para>

<figure id="gql_PP428_2" file="GQL-PP428-2.png" padding-after="10pt">
<figureTitle>Parse tree as CREATE GRAPH TYPE STATEMENT</figureTitle>
</figure>

</problem>

<solution>

<para>If <kw>TYPE</kw> was <BNF name="reserved word"/>, then this ambiguity possibly goes away.
</para>

</solution>

</PP>


<LO id="PPgql429" number="GQL-429" 
    kind="new_feat"
    size="S">

<brief area="Artifact">Minimum Syntax artifact</brief>

<reference><specref ref="gql_mand"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:XRH-001 Agenda Item 12.12.
</source>

<since>!! Optional give date LO first created. !!
</since>

<problem>

<para>Consider adding a new digital artifact containing only the absolute minimum syntax.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql432" number="GQL-432" kind="new_feat" size="S">

<brief area="Data types and expressions">Allow optional parameters in
<BNF name="vector value function"/></brief>

<reference><specref ref="gql_vecvalfunc"/>.
</reference>

<noteAt><specref ref="PPgql432_1"/>.
</noteAt>

<source>WG3:POS-011R1
</source>

<since>2025-03-24
</since>

<problem>

<para>The <BNF name="dimension"/> and <BNF name="coordinate type"/> parameters in
the <kw>VECTOR</kw> function could be optional:
</para>

<!-- LINE LENGTH CHECK OFF -->
<code>
<kw>VECTOR</kw> <BNF name="left paren"/> <BNF name="character string value expression"/> [ <BNF name="comma"/>
<BNF name="dimension"/> <BNF name="comma"/> <BNF name="coordinate type"/> ] <BNF name="right paren"/>
</code>
<!-- LINE LENGTH CHECK ON -->

<para>A couple of additional syntax rules would be needed to derive  <BNF name="dimension"/> and 
<BNF name="coordinate type"/> from the <BNF name="character string value expression"/>.
</para>

</problem>

</LO>


<LO id="PPgql433" number="GQL-433" kind="new_feat" size="S">

<brief area="Data types and expressions">Additional metrics for
<BNF name="vector distance function"/></brief>

<reference><specref ref="gql_vecdistfunc"/>.
</reference>

<noteAt><specref ref="PPgql433_1"/>.
</noteAt>

<source>WG3:POS-011R1
</source>

<since>2025-03-24
</since>

<problem>

<para>Support for additional <BNF name="vector distance function"/> metrics, like Jaccard,
could be added.
</para>

</problem>

</LO>


<LO id="PPgql434" number="GQL-434" kind="new_feat" size="M">

<brief area="Data types and expressions">Additional vector operations</brief>

<reference><specref ref="gql_vecvalexp"/>.
</reference>

<noteAt><specref ref="PPgql434_1"/>.
</noteAt>

<source>WG3:POS-011R1
</source>

<since>2025-03-24
</since>

<problem>

<para>Support for additional vector operations, like coordinate-wise
addition, subtraction, multiplication, <etc/>, could be added.
</para>

</problem>

</LO>


<LO id="PPgql436" number="GQL-436" kind="new_feat" size="S">

<brief area="Data types and expressions">Passing of session parameters to
a <BNF name="vector value constructor"/></brief>

<reference><specref ref="gql_vecvalfunc"/>.
</reference>

<noteAt><specref ref="PPgql436_1"/>.
</noteAt>

<source>WG3:POS-011R1
</source>

<since>2025-03-24
</since>

<problem>

<para>It would be useful to support session variables in the vector value constructor. 
For example:
</para>

<code>
LET vec = <kw>VECTOR</kw>($VecString, $VecDim, $VecType)
<kw>INSERT</kw> (:Resume {EmpID: 123, ResumeVec: vec})
</code>

</problem>

</LO>


<LO id="PPgql437" number="GQL-437" kind="improv" size="M">

<brief area="Data types and expressions">Some GQL data types miss sections on supported operations
</brief>

<reference><specref ref="gql_conc_dt"/>.
</reference>

<noteAt><specref ref="PPgql437_1"/>.
</noteAt>

<source>WG3:POS-011R1
</source>

<since>2025-03-24
</since>

<problem>

<para>WG3:POS-011R1 added a section on the operations involving vector types.
The only other GQL data types that have such a section are temporal types.
For consistency, perhaps this information should not be given in a separate subclause.
Another alternative would be to add such sections for other data types.
</para>

</problem>

</LO>


<PP id="PPgql438" number="GQL-438" realm="technical" severity="major">

<brief area="Data types and expressions">Open vector types
</brief>

<reference><specref ref="gql_conc_vt_vec"/>.
</reference>

<noteAt><specref ref="PPgql438_1"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>WG3:POS-011R1 added support for closed vector types but omitted to include support for
open vector types (<ie/> vector types that can contain arbitrary vectors).
A key design principle of GQL is to support both dynamically typed and statically typed
implementations.
However, lack of open vector type support prevents adoption of vectors by dynamically typed
implementations of GQL.
Therefore, open vector type support needs to be added.
</para>

</problem>

</PP>


<PP id="PPgql440" number="GQL-440" realm="technical" severity="minor">

<brief area="Transactions">Clarification on transaction rollback conditions
</brief>

<reference><specref ref="gql_conditions"/>.
</reference>

<noteAt><specref ref="PPgql440_1"/>.
</noteAt>

<source>Email from: Hannes Voigt, 2024-10-25 1203.
</source>

<problem>

<para> Every exception condition for transaction rollback has precedence over every other
exception condition.
However, it is left unspecified what <squote>exception condition for transaction rollback</squote>
refers to.
Is it any exception condition of class 40? Looking at the paper trail suggest this might be
a reasonable interpretation.
This should be clarified.
</para>

</problem>

</PP>


<PP id="PPgql441" number="GQL-441" realm="technical" severity="minor">

<brief area="Transactions">Clarification on transaction rollback conditions
</brief>

<reference><specref ref="gql_conditions"/>.
</reference>

<noteAt><specref ref="PPgql441_1"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Every exception condition for transaction rollback has precedence over every other
exception condition.
However, if an exception condition is raised during application of General Rules, then the current
transaction is aborted.
What should happen in such a situation?
</para>

<olist>

<item>Implicitly a transaction rollback exception is raised.
If this is the case, the actual exception might be dropped (unless attached as a cause in
an implementation that supports causes).
This seems not very desirable for the user.
</item>

<item>No transaction rollback exception is raised.
If this is the case, perhaps transaction rollback exception would be more aptly named
<squote>spurious transaction abort</squote>?
</item>

</olist>

<para>It should be clarified, whether transaction rollback exceptions are to be raised when
another exception condition causes an implicit transaction abort.
</para>

</problem>

</PP>


<PP id="PPgql442" number="GQL-442" realm="technical" severity="minor">

<brief area="Grammar">Remove ambiguity related to closed dynamic union types
</brief>

<reference><specref ref="gql_conditions"/>.
</reference>

<noteAt><specref ref="PPgql442_1"/>.
</noteAt>

<source>Email from: Hannes Voigt, 2024-12-06 0834.
</source>

<problem>

<para>The production for <BNF name="closed dynamic union type"/> if directly expanded to
<BNF name="component type list"/> overlaps with the production for <BNF name="value type"/>.
This is technically taken care of by left normal form derivation.
To clarify the situation, the grammar could be improved by requiring that
each <BNF name="component type list"/> needs to specify at least two component types.
However, this would cause difficulties with the definition of normal forms for closed dynamic
union types, which considers a single component type to be a valid normal form.
</para>

<para>In light of this discussion, the following solutions are suggested:
</para>

<olist>

<item>Prohibit <BNF name="component type list"/>s that specify a single component type 
in user-facing syntax via a new CR, to justify implementations in adjusting their product grammar
accordingly.
</item>

<item>Generally prohibit <BNF name="component type list"/>s that specify a single component type
and clarify that normal forms of dynamic union types are not necessarily dynamic union types.
</item>

</olist>

</problem>

</PP>


<LO id="PPgql443" number="GQL-443" 
    kind="new_feat"
    size="L">

<brief area="Model">Allow an edge to connect to multiple nodes by multiple possibly named 
links</brief>

<reference><specref ref="gql_conc_g_intro"/>, <specref ref="gql_conc_ot_edge"/>, 
<specref ref="gql_insert_graph_pattern"/>, <specref ref="gql_path_pattern_expr"/>,
<specref ref="gql_edge_type_defn"/>.
 18.3.
</reference>

<noteAt>None.
</noteAt>

<source>Email from: Malcom Crow, 2025-03-24 2114. 
</source>

<since>2025-03-26
</since>

<problem>

<para>The literature on the Typed Graph Model includes models where an edge e may be connected to
<emph>sets</emph> O<sub>e</sub> and A<sub>e</sub> of nodes and associated Typed Graph Schema 
proposals (<eg/> Fritz Laux arXiv:2110.00991, 2021). 
Keith Hare has reported that some suggestions have been made in WG3 that N-ary edges might be 
included in a future version of GQL.
</para>

</problem>

<solution>

<para>Rough draft: an open-source implementation of these ideas is in progress.
</para>

<para><specref ref="gql_conc_g_intro"/>: For the dash-headed section beginning 
<quote>A set of zero or  more identifiable edges</quote> read
</para>

<ulist>

<item>A set of zero or more globally identifiable edges. 
Each edge comprises:

<ulist>

<item>An edge label set that comprises a set of zero or more labels. 
A label has a name, which is an identifier that is unique within the edge.
<para>The minimum cardinality of edge label sets is <impDef code="IL001"/>.
</para>
<para>The maximum cardinality of edge label sets is <impDef code="IL001"/>.
</para>
</item>

<item>An edge property set that comprises zero or more properties. 
Each property comprises:

<ulist>

<item>Its name, which is an identifier that uniquely identifies the property within
the edge property set.
<note>The names of edge labels and of edge properties are in separate namespaces. 
That is, a label and a property can have the same name in an edge.
</note>
</item>

<item>Its value, which can be of any supported property value type. 
The maximum cardinality of edge property sets is <impDef code="IL002"/>.
</item>

</ulist>

</item>

<item>Two <mark-inserted>or more (not necessarily different)</mark-inserted> endpoints, 
which are nodes contained inthe same graph.
</item>

<item><mark-inserted>For each endpoint, the indication of whether the association with the edge is 
a directed connection or an undirected connection (which is also called the
directionality of the connection).</mark-inserted>
<para><mark-inserted>Connections may have identifiers (named connections) to discriminate between
connections to endpoints that are both sources, both destinations, and/or of the
same node type.</mark-inserted>
</para>
<para><mark-inserted>Additionally, a directed connection</mark-inserted> identifies one of its 
endpoints as its <mark-inserted>source</mark-inserted>,
and the other as its <mark-inserted>destination</mark-inserted>. 
The direction of a directed <mark-inserted>connection</mark-inserted> is from its
source to its destination. 
If both end points of a directed <mark-inserted>connection</mark-inserted> are identical,
such an edge is a directed loop on a single graph node.
</para>
</item>

</ulist>

</item>

</ulist>

<para><specref ref="gql_conc_ot_edge"/>: For the section beginning
Each edge type comprises, read
Each edge type comprises:
</para>

<ulist>

<item>An edge type label set that comprises a set of zero or more labels. 
A label has a name that is an identifier that is unique within the edge type.
</item>

<item>An edge type property type set that comprises a set of zero or more property types.
<note>See <specref ref="gql_conc_property_types"/>.
</note>
</item>

<item>Two <mark-inserted>or more (not necessarily different)</mark-inserted> end point node types
that are node types contained in the same graph type.
</item>

<item>The indication of whether the <mark-inserted>association between the edge and each end 
point</mark-inserted> is a directed <mark-inserted>connection</mark-inserted> or an undirected 
<mark-inserted>connection</mark-inserted> (which is also called the directionality
of the connection). 
Additionally, a directed <mark-inserted>connection</mark-inserted> identifies one of its 
endpoint node types as its source node type, and the other as its destination node type. 
The direction of a directed edge type is from its source node type to its destination node type.
<note>The names of edge type labels<mark-inserted>, edge type named connections, 
and</mark-inserted> edge type property types are in separate namespaces. 
That is, a label<mark-inserted>, a named connection</mark-inserted> and a property type can have 
the same name in an edge type.
</note>
</item>

</ulist>

<para>A GQL-implementation is permitted to regard two <BNF name="edge type specification"/>s as 
equivalent, if they are either both directed or undirected, have the same endpoint node types, 
<mark-inserted>connection name, </mark-inserted> type label sets and edge type property type sets,
as permitted by the Syntax Rules of <specref ref="gql_edge_type_defn"/>, 
<specref ref="gql_lbl_set_defn"/>, and <specref ref="gql_prop_type_set_defn"/>. 
When two or more <BNF name="edge type specification"/>s are equivalent, the GQL-implementation 
chooses one of these equivalent <BNF name="edge type specification"/>s as the normal form 
representing that equivalence class of <BNF name="edge type specification"/>s. 
The normal form determines the preferred name of the edge type in data type descriptors.
</para>

<para>An edge E in a graph is of an edge type ET (<ie/> is included in ET) if the label set of E 
and the edge type label set of ET are the same, 
<mark-inserted>the edge connection names if any, </mark-inserted>the number of properties of E 
and the number of property types of ET are 
the same, and every property of E is of a property type of ET, and one of the following is true:
</para>

<ulist>

<item>E and ET are directed and the source and destination endpoints of E are of the source and
destination endpoint node types of ET, respectively.
</item>

<item>E and ET are undirected and the binary relation over E and ET that relates each endpoint
in E to each of its endpoint node types in ET is left-total and right-total. 
An edge type is described by the edge type descriptor. 
</item>

</ulist>

<para>The edge type descriptor comprises:
</para>

<ulist>

<item>The declared name of the primary base type of all edge types (EDGEDATA).
</item>

<item>The preferred name of edge types (<impDef code="ID091"/> choice of EDGE or
RELATIONSHIP).
</item>

<item>The set of zero or more labels (also known as an edge type label set). 
A label has a name that is an identifier that is unique within the edge type label set.

<para>The minimum cardinality of edge type label sets is the <impDef code="IL001"/>
minimum cardinality of edge label sets.
</para>

<para>The maximum cardinality of edge type label sets is the <impDef code="IL001"/>
maximum cardinality of edge label sets.
</para>

</item>

<item>The set of zero or more property type descriptors (also known as an edge type property
type set).
<para>The maximum cardinality of edge type property type sets is the <impDef code="IL002"/> maximum 
cardinality of edge property sets.
</para>
</item>

<item><mark-inserted>For each connection, </mark-inserted>

<ulist>

<item><mark-inserted>the name of the connection (which may be empty)</mark-inserted>
</item>

<item>the indication of whether the <mark-inserted>connection</mark-inserted> is directed or 
undirected
</item>

</ulist>

</item>

<item>Case:

<ulist>

<item>If the <mark-inserted>connection</mark-inserted> is directed, then:

<ulist>

<item>The source node type descriptor.
</item>

<item>The destination node type descriptor.
</item>

</ulist>

</item>

<item>If the <mark-inserted>connection</mark-inserted> is undirected, then the set of one or two 
endpoint node type descriptors.
</item>

</ulist>

<note>If the two end point node types of an undirected <mark-inserted>connection</mark-inserted> 
are the same, then the set contains only one endpoint node type descriptor; otherwise, it contains 
two endpoint node type descriptors.
</note>

</item>

</ulist>

<para>Two edge type descriptors describe equal edge types if they contain:
</para>

<ulist>

<item>Equal edge type label sets,
</item>

<item>Equal edge type property type sets,
</item>

<item><mark-inserted>Equal connection names, </mark-inserted>
</item>

<item>Equal indications whether connections are directed or undirected, and
</item>

<item>Case:

<ulist>

<item>If the <mark-inserted>connections</mark-inserted> are directed, then:

<ulist>

<item>Equal source node types and
</item>

<item>Equal destination node types.
</item>

</ulist>

</item>

<item>If the <mark-inserted>connections</mark-inserted> are undirected, then equal sets of 
endpoint node types.
</item>

</ulist>

</item>

</ulist>

<para><specref ref="gql_insert_graph_pattern"/>
</para>

<grammar discussion="yes">

<BNFdef name="insert edge pointing left">
<rhs>
<BNF name="left arrow bracket"/> <opt> <BNF name="insert element pattern filler"/> </opt> 
<BNF name="right bracket minus"/> <opt> <BNF name="identifier"/><BNF name="minus sign"/> </opt>
</rhs>
</BNFdef>

<BNFdef name="insert edge pointing right">
<rhs>
<opt> <BNF name="minus sign"/><BNF name="identifier"/> </opt><BNF name="minus left bracket"/> 
<opt> <BNF name="insert element pattern filler"/> </opt> <BNF name="bracket right arrow"/>
</rhs>
</BNFdef>

<BNFdef name="insert edge undirected">
<rhs>
<opt> <BNF name="tilde"/><BNF name="identifier"/> </opt> <BNF name="tilde left bracket"/> 
<opt> <BNF name="insert element pattern filler"/>  </opt> <BNF name="right bracket tilde"/> 
<opt> <BNF name="identifier"/><BNF name="tilde"/>  </opt>
</rhs>
</BNFdef>

</grammar>

<para>Additional Syntax rule: At most one <BNF name="identifier"/> can be used in the above 
syntax for <BNF name="insert edge undirected"/>.
</para>

<para><specref ref="gql_path_pattern_expr"/>
</para>

<grammar discussion="yes">

<BNFdef name="full edge pointing left">
<rhs>
<BNF name="left arrow bracket"/> <BNF name="element pattern filler"/> 
<BNF name="right bracket minus"/> <opt> <BNF name="identifier"/><BNF name="minus sign"/>  </opt>
</rhs>
</BNFdef>

<BNFdef name="full edge undirected">
<rhs>
<opt><BNF name="tilde"/><BNF name="identifier"/> </opt> <BNF name="tilde left bracket"/> 
<BNF name="element pattern filler"/> <BNF name="right bracket tilde"/>
</rhs>
</BNFdef>

<BNFdef name="full edge pointing right">
<rhs>
<opt> <BNF name="minus sign"/><BNF name="identifier"/>  </opt> <BNF name="minus left bracket"/> 
<BNF name="element pattern filler"/> <BNF name="bracket right arrow"/>
</rhs>
</BNFdef>

<BNFdef name="full edge left or undirected">
<rhs>
<BNF name="left arrow tilde bracket"/> <BNF name="element pattern filler"/> 
<BNF name="right bracket tilde"/> <opt> <BNF name="identifier"/><BNF name="tilde"/> </opt>
</rhs>
</BNFdef>

<BNFdef name="full edge undirected or right">
<rhs>
<opt> <BNF name="tilde"/><BNF name="identifier"/> </opt> <BNF name="tilde left bracket"/> 
<BNF name="element pattern filler"/> <BNF name="bracket tilde right arrow"/>
</rhs>
</BNFdef>

<BNFdef name="full edge any direction">
<rhs>
<opt><BNF name="minus sign"/><BNF name="identifier"/> </opt> <BNF name="minus left bracket"/>
<BNF name="element pattern filler"/><BNF name="right bracket minus"/>
<opt><BNF name="identifier"/><BNF name="minus sign"/> </opt>
</rhs>
</BNFdef>

</grammar>

<para>Additional Syntax rule: At most one <BNF name="identifier"/> can be used in the above syntax
for <BNF name="insert edge undirected"/>.
</para>

<para><specref ref="gql_edge_type_defn"/>
</para>

<para>Should support the following informal syntax:
</para>

<code>
GraphTypeDef = <squote>{</squote>  ElementList <squote>}</squote> .

ElementList = (NodeTypeDetails|EdgeTypeDetails) {Metadata}<footnote>For an edge type CARDINALITY specifies the maximum number of edges that can connect to a given pair of endpoints (default is no limit).</footnote> {<squote>,</squote> ElementList}.

NodeTypeDetails = [Node [TYPE] id] <squote>(</squote> Filler <squote>)</squote>
                | Node [TYPE] Filler [AS id].
                
Filler = [Alias_id] [Labels] [<squote>=></squote> [Labels]][<squote>{</squote>Properties<squote>}</squote>] .

Labels = LABEL id | (LABELS[<squote>:</squote>|IS]) id {<squote>&amp;/></squote> id} .

Properties = (id [<squote>::</squote>|TYPED] Type) {<squote>,</squote> Properties} .

Node = NODE | VERTEX .

EdgeTypeDetails = [Direction Edge [TYPE] id] EdgePattern
                 | Direction Edge [TYPE] (id|Filler) EndPoints.
                 
EndPoints = CONNECTING <squote>(</squote> Connections <squote>)</squote> .

Connections = [FROM Connectors ][WITH Connectors][TO Connectors] .

Connectors = Connector {<squote>,</squote> Connector} .

Connector = [id<squote>=</squote>] Type_id {<squote>|</squote> Type_id } [SET] Metadata .

EdgePattern = <squote>(</squote>NodeTypeRef |Filler<squote>)</squote> <squote>-[</squote>Filler<squote>]-></squote> <squote>(</squote>NodeTypeRef |Filler<squote>)</squote>
            | <squote>(</squote>NodeTypeRef |Filler<squote>)</squote> <squote>&lt;-[</squote> Filler 
<squote>]-</squote> <squote>(</squote>NodeTypeRef |Filler<squote>)</squote> .
            | <squote>(</squote>NodeTypeRef |Filler<squote>)</squote> <squote>~[</squote> Filler 
<squote>]~</squote> <squote>(</squote>NodeTypeRef |Filler<squote>)</squote> .

NodeTypeRef = NodeType_id {Metadata} {<squote>|</squote> NodeType_id {Metadata}<footnote>The <emph>NodeType</emph>_id can refer to a node or edge type. 
MULTIPLICITY specifies the maximum number of connections to a given endpoint (default is no limit).</footnote> }.

Edge = EDGE | RELATIONSHIP .

Direction = DIRECTED | UNDIRECTED .
</code>

</solution>

</LO>

<bar note="Editorial"/>
<PP id="PPgql444" number="GQL-444" severity="major" realm="technical">

<brief area="Specification mechanics">Incomplete numeric data type descriptor</brief>

<reference><specref ref="gql_conc_numeric_intro"/> and <specref ref="gql_value_type"/>.
</reference>

<noteAt>None.
</noteAt>

<source>Jeyhun Karimov (Microsoft)
</source>

<problem>

<para>GQL supports both signed and unsigned exact numeric types with scale 0 (zero) but 
the numeric data type descriptor lacks 
an <quote>indication of whether the numeric type is signed or unsigned</quote>.
</para>

<para>As a workaround, such an indication can be inferred from the preferred name of the type, 
which is included in the descriptor.
</para>

<para>However, relying on being able to infer a secondary characteristic of a type from its 
preferred name is a) brittle and b) very hard to understand for implementers.
</para>

<para>Instead, the <quote>indication of whether the numeric type is signed or unsigned</quote> 
should be added to the descriptor explicitly and the rules in <specref ref="gql_value_type"/> 
should be adjusted accordingly.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>
<endbar/>

<bar note="Editorial"/>
<LO id="PPgql445" number="GQL-445" kind="feat_ext" size="M">

<brief area="Data types and expressions">Relax the diamond inheritance rule</brief>

<reference><specref ref="gql_graph_type"/>.
</reference>

<noteAt>None.
</noteAt>

<source>Stefan Plantikow.
</source>

<since>2025-06-18.
</since>

<problem>

<para><specref ref="gql_graph_type"/>, <itemref ref="gql_graph_type_SR_ets" type="GR"/> currently
reads as follows:
</para>

<olist>
<item>For every <BNF name="edge type specification"/> 
<symdef>OETS</symdef> that is simply contained in <sym>GTSB</sym> and implies <sym>ETS</sym>, 
all of the following shall be true:

<olist>

<item><sym>OETS</sym> is structurally consistent with <sym>ETS</sym>.
</item>

<item><sym>OETS</sym> is structurally endpoint-consistent with <sym>ETS</sym>.
</item>

</olist>

</item>
</olist>

<para>This effectively requires the endpoint node types of an edge subtype to be subtypes of 
the corresponding endpoint node types of each of its direct edge super types.
</para>

<para>This is unnecessarily strict in that it fails to recognize how keyed edge types together 
with conformance <feature code="GG25"/>, effectively bundle multiple edge types into 
one edge type family. 
To provide an analogy from object oriented programming, such an edge type family can be thought of 
as a:
</para>

<code>
class MyEdgeTypeFamily {
   keyLabels: List&lt;String&gt;
   properties: Map&lt;String, PropertyType&gt;

   endpoints: Pair (A, B) | Pair(A, C) | Pair (X, Y) | <ellipsis/>
}
</code>

<para>Applying generally agreed principles of substitution in object-oriented languages, 
a subclass MySubEdgeTypeFamily &lt;: MyEdgeTypeFamily that wants to override 
<quote>endpoints</quote> could narrow its type to any subtype of <quote>endpoints</quote> in 
MyEdgeTypeFamily, such as (A, B) only or (A1 &lt;: A, B) | (A, C1 &lt;: C) <etc/> 
</para>

<para>Further, a subclass of multiple edge type families could narrow the type of 
<quote>endpoints</quote> to any type that is a subtype of the type of <quote>endpoints</quote> of 
each of its direct edge type super families.
</para>

<para><itemref ref="gql_graph_type_SR_ets" type="GR"/> should be adjusted to support this more 
relaxed requirement for implementations that provide <feature code="GG25"/>.
</para>

<para>In order to prevent proliferation of feature codes, it seems acceptable to the author of 
this Language Opportunity to bundle this change with the existing feature, as the proposed 
relaxation of <itemref ref="gql_graph_type_SR_ets" type="GR"/> would allow more graph types
to be valid and hence would not cause backwards compatibility issues.
</para>

<para>In summary:
</para>

<ulist>

<item>Consider adding the terminological concept of an edge type family for a group of edge types
with the same key label set (as can be defined by supporting <feature code="GG25"/>).
</item>

<item>Change <itemref ref="gql_graph_type_SR_ets_b" type="GR"/> to only require 
structural-endpoint consistency with implied <sym>ETS</sym> that are not part of
an edge type family and with at least one implied <sym>ETS</sym> per direct super edge type family,
for implementations that provide <feature code="GG25"/>. 
</item>

</ulist>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql446" number="GQL-446" kind="feat_ext" size="L">

<brief area="Statements and clauses">Extend LET with support for windowing</brief>

<reference><specref ref="gql_let"/>.
</reference>

<noteAt>None.
</noteAt>

<source>Stefan Plantikow.
</source>

<since>2025-06-18.
</since>

<problem>

<para>GQL currently has no support for window functions, however, many of the required ingredients
are beginning to be in place:
</para>

<ulist>

<item><PPref ref="PPgql186"/> already proposes the introduction of partitioned procedure calls.
</item>

<item>The <BNF name="order by and page statement"/> is freely placeable, thus allowing us 
to enforce the in-order processing of the incoming binding table by a subsequent statement.
</item>

</ulist>

<para>What is missing is essentially framing (5 ROWS PRECEDING) and certain window-sensitive 
functions (<eg/> RANK).
</para>

<para>As a possible approach, this LO proposes to extend the <BNF name="let statement"/> with 
support for framing over the incoming binding table as follows:
</para>

<code>
CALL PER &lt;partition key&gt; {
   ORDER BY <BNF name="sort specification"/>
   LET var=expr ALONG ROWS 5 PRECEDING 
   <ellipsis/>
}
</code>

<para>Evaluation semantics would treat all variables from the current working table as 
grouping variables containing the values in the window for the current row and 
corresponding column.
This approach would enable re-use of horizontal aggregation functionality for 
the actual evaluation of aggregates in the window.
</para>

<para>Caveats:
</para>

<ulist>

<item>Due to the rewrites involved in the current specification in LET, 
realizing this approach will likely move the framing feature to variable definitions.
</item>

<item>A full analysis of the <SQL/> windowing capabilities should be performed to ensure possibly 
feature parity of this approach.
</item>

<item>Horizontal aggregation functionality needs to be expanded for this to become practical.
</item>

<item>Window-sensitive expressions like RANK() need to be added, too.

</item>

</ulist>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql447" number="GQL-447"  kind="new_feat" size="M">

<brief area="Area of functionality">Replace current working table</brief>

<reference><specref ref="gql_stm_lin_query_stm"/>.
</reference>

<noteAt>None.
</noteAt>

<source>Stefan Plantikow.
</source>

<since>2025-06-18.
</since>

<problem>

<para>Currently, GQL provides no mechanism for explicitly replacing the current working table with 
a binding table provided by a catalog reference or an expression.
</para>

<para>Available functionality to that end is:
</para>

<ulist>

<item>FINISH, for establishing a unit binding table to start from.
</item>

<item>CALL for unwinding the columns of the result of a procedure call (currently lacking
table support).
</item>

<item>FOR record_var IN table_expression, for iterating over the records of a table.
</item>

</ulist>

<para>Beyond these features, there appears to be a gap for just replacing the current working table.
Possible approaches might be:
</para>

<ulist>

<item>Extend named CALL to also iterate tables (<ie/> solve by FINISH and extending CALL).
</item>

<item>Introduce dedicated syntax for replacing the current working table from a table expression 
(<ie/> solve by a new construct such as FROM table_expression).
</item>

<item>Introduce dedicated syntax for replacing the current record from a record expression 
(<ie/> solve by FINISH, FOR record_var IN table_expression, and a new construct such as
RETURN <BNF name="record expression"/> AS ROW).
</item>

</ulist>

<para>A feature for replacing the current working table with the result of a table expression
should be added.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<LO id="PPgql448" number="GQL-448"  kind="new_feat" size="M">

<brief area=" Statements and clauses">Cross join</brief>

<reference><specref ref="gql_stm_comp_query_expr"/>.
</reference>

<noteAt>None.
</noteAt>

<source>Stefan Plantikow.
</source>

<since>2025-06-18.
</since>

<problem>

<para>GQL has no dedicated statement for expressing full outer cross joins or full outer natural 
joins. 
While CALL can be used to that effect, the required linearization and syntactic duplication of 
subqueries is cumbersome at best.
</para>

<para>Consider adding a new optional statement at the same level of set operations for performing 
cross joins, natural joins and their full outer counter parts to close a gap in 
relational capabilities of GQL.
</para>

<ulist>

<item>{ <ellipsis/> } [ NATURAL | CROSS ] JOIN { <ellipsis/> }
</item>

<item>{<ellipsis/> } OPTIONAL  [ NATURAL | CROSS ] JOIN { <ellipsis/> }
</item>

</ulist>

<para>(NATURAL being the default)
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>
<endbar/>

<!-- ^^^ LAST ENTRY ^^^ -->

<!-- Placed closed PPs and LOs after this line in order of their number attribute!

<comment>Resolved by W10-019R1</comment>
<PP id="PPgql001" number="GQL-001" severity="major" realm="technical">

<comment>Editorial: Stefan Plantikow 2021-03-02 Reworded</comment>
<reference><specref ref="gql_diagnostics"/>.
</reference>

<noteAt><specref ref="gql_diagnostics"/>, <specref ref="gql_PP001"/>, <specref ref="gql_PP001_2"/>,
<specref ref="gql_PP001_3"/>, <specref ref="gql_PP001_4"/>, <specref ref="gql_PP001_5"/>,
<specref ref="gql_PP001_6"/>, <specref ref="gql_PP001_7"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Error Handling and Diagnostics need to be defined, including alignment with class and subclass
codes inherited from SQL.
</para>

</problem>

</PP>


<comment>Resolved editorially</comment>
<PP id="PPgql002" number="GQL-002" severity="major" realm="technical">

<reference>Multiple places in the document.
See editor<apos/>s notes in the text, and although these may not be complete, include:
<ulist>
<item><specref ref="SQL_diff08"/>
</item>
<item><specref ref="SQL_diff15"/>
</item>
<item><specref ref="SQL_diff17"/>
</item>
<item><specref ref="SQL_diff21"/>
</item>
<item><specref ref="SQL_diff22"/>
</item>
<item><specref ref="SQL_diff26"/>
</item>
</ulist>.
</reference>

<problem>

<para>Differences between the rules of GQL and SQL must be evaluated and either eliminated or
explicitly accepted.
</para>

</problem>

<solution>

<para>Differences moved to <specref ref="gql_sql_diffs"/>.
</para>

</solution>

</PP>


<comment>Resolved by WG3:W24-026R2</comment>
<PP id="PPgql006" number="GQL-006" severity="major" realm="technical">

<reference><specref ref="gql_value_type"/>.
</reference>

<noteAt><specref ref="gql_PP006"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The collection data types needed by GQL need to be defined.
</para>

</problem>

</PP>


<comment>Resolved by WG3:UTC-015</comment>
<PP id="PPgql007" number="GQL-007" severity="major" realm="technical">

<comment>Editorial: Stefan Plantikow 2021-03-02 Reworded</comment>
<reference>The chosen type checking modes are expected to have global impact on the document.
</reference>

<noteAt><specref ref="gql_PP007_3"/>, <specref ref="gql_ber036_1"/>, <specref ref="gql_ber036_2"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The type checking mode or modes and applicable coercions of GQL need to be defined.
</para>

<para>Many of the rules derived from SQL make use of the declared and/or specific data types of
BNF terms, results, <etc/>
These rules will need adjustment when the type checking mode or modes and system of GQL is properly
defined and suitable for both schema-free and schema-full scenarios.
It may also be appropriate, to consider separating Type Rules from Static Rules and General Rules.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W22-031</comment>
<PP id="PPgql008" number="GQL-008" severity="major" realm="technical">

<reference><specref ref="gql_values"/>.
</reference>

<noteAt><specref ref="gql_PP008"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The graph-type specific expressions needed by GQL need to be defined.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W21-059</comment>
<LO id="PPgql009" number="GQL-009">

<reference><specref ref="gql_token"/>, <specref ref="gql_character"/>,
<specref ref="gql_literals"/>.
</reference>

<noteAt><specref ref="gql_PP009_1"/>, <specref ref="gql_PP009_2"/>, <specref ref="gql_PP009_3"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Define the Unicode character for each &lt;terminalsymbol&gt; to avoid any ambiguity and use
the Unicode name for the character in the BNF.
</para>

</problem>

</LO>


<comment>Resolved editorially</comment>
<PP id="PPgql010" number="GQL-010" severity="major" realm="technical">

<reference><specref ref="gql_token"/>.
</reference>

<noteAt><specref ref="gql_token"/>.
</noteAt>

<problem>

<para>The Unicode Normalization Form (or Forms) which may be used should be considered.
</para>

</problem>

<solution>

<para>Specification currently includes the set of Unicode Normalization Forms and the places
ehere they are used either explicity or implicitly.
</para>

</solution>

</PP>


<comment>Resolved by WG3:BER-073</comment>
<PP id="PPgql013" number="GQL-013" severity="minor" realm="editorial">

<reference><specref ref="gql_graph_terms_defns"/>.
</reference>

<noteAt><specref ref="gql_PP013_1"/>, <specref ref="gql_PP013_2"/>.
</noteAt>

<source>W10-019R1, W21-023.
</source>

<problem>

<para>The terms and definitions of SQL/PGQ and GQL need to be aligned.
Also, the definitions must be made to conform to the rules the ISO Directives Part 2.
See editorial notes in terms and definitions for more details.
</para>

<para>The definition of <quote>property</quote> has not yet reached consensus.
</para>

<para>Linked to <ExtPPref ref="PPpgq065" standard="9075" part="16"/>.
</para>

<para>Also see <PPref ref="PPgql136"/>.
</para>

</problem>

</PP>


<comment>Resolved by sxm030r3</comment>
<LO id="PPgql014" number="GQL-014">

<reference><specref ref="gql_LO014"/>.
</reference>

<noteAt><specref ref="gql_LO014"/>.
</noteAt>

<problem>

<para>GQL should support bidirectional edges.
</para>

</problem>

</LO>


<comment>Resolved by editorial action before 2019-06-12</comment>
<LO id="PPgql015" number="GQL-015">

<problem>

<para>According to the Directives: "Terms and definitions should preferably be listed according to
the hierarchy of the concepts (i.e. systematic order).
Alphabetical order is the least preferred order.", so a restructuring would be both helpful and
conform better to the Directives
</para>

</problem>

</LO>


<PP id="PPgql016" number="GQL-016" severity="major" realm="technical">

<comment>Editorial: Stefan Plantikow 2021-03-02 Reworded</comment>
<reference><specref ref="gql_val_terms_defns"/>, <specref ref="gql_conc_bt"/>,
<specref ref="gql_conc_btt"/>.
</reference>

<noteAt><specref ref="gql_PP016_term"/>, <specref ref="gql_PP016_main"/>,
<specref ref="gql_PP016_type"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The binding table concept of GQL needs to be refined and reviewed.
</para>

<olist>

<item>Should GQL adopt a model where multiple columns may have the same name?
</item>
<item>Should GQL adopt a model where tables are collections of map?
</item>
<item>Should GQL adopt a model where the order of columns is relevant or not?
</item>
<item>Should GQL adopt a model where rows are considered referenceable objects or not?
</item>
<item>Should GQL support tables with no columns?
</item>
<item>In any event, how should GQL support mapping SQL tables with multiple columns with the same
name into GQL?
</item>

</olist>

</problem>

</PP>


<comment>Resolved as consequence of WG3:W23-037</comment>
<PP id="PPgql018" number="GQL-018" severity="major" realm="technical">

<reference><specref ref="gql_conc_dt"/>, <specref ref="gql_conc_vt_predef"/>.
</reference>

<noteAt><specref ref="gql_PP018_1"/>, <specref ref="gql_PP018_3"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The null value in GQL is currently not included in every data type but treated separately.
This has not yet been reflected fully in the document and requires further discussion.
</para>

</problem>

</PP>


<LO id="PPgql019" number="GQL-019">

<reference><specref ref="gql_PP019"/>.
</reference>

<noteAt><specref ref="gql_PP021"/>.
</noteAt>

<problem>

<para>Align the names of statement classes and types of side effects.
The former are currently borrowed from SQL, the latter from BNE023.
This is unnecessarily complicated.
Suggestion is to switch to side effect based naming.
</para>

</problem>

</LO>


<comment>Resolved editorially</comment>
<LO id="PPgql020" number="GQL-020">

<comment>Editorial: Stefan Plantikow 2021-03-02 Closed in next release</comment>
<source>Editors.
</source>

<problem>

<para>Introduce a session concept and relate it to the authorization identifier currently
associated with the GQL-agent
</para>

</problem>

</LO>


<comment>Resolved by WG3:W22-054</comment>
<PP id="PPgql021" number="GQL-021" severity="major" realm="technical">

<comment>Editorial: Stefan Plantikow 2021-03-02 Reworded</comment>
<reference><specref ref="gql_conc_prcmds_proc_sig"/>,
<specref ref="gql_inline_procedure_call"/>.
</reference>

<noteAt><specref ref="gql_PP021_1"/>, <specref ref="gql_PP021_3"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Procedure signatures and type signatures need to be explicitly declared or inferred
syntactically, and verified by procedure calls and invocations.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-026</comment>
<LO id="PPgql022" number="GQL-022">

<comment>Editorial: Stefan Plantikow 2021-03-02 Reworded</comment>
<reference><specref ref="gql_eval_order"/>.
</reference>

<noteAt><specref ref="gql_PP022"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The rule structure and evaluation order used by GQL should be refined as needed.
Some ideas have been suggested to the editors:
</para>

<olist>

<item>Rename General Rules to Semantic Rules.
</item>

<item>Further split between Syntax Rules, Static (Semantic) Rules, Typing Rules, Dynamic
(Semantic) Rules.
</item>

</olist>

<para>Further discussion is needed.
</para>

</problem>

</LO>


<comment>Resolved by WG3:W22-054</comment>
<LO id="PPgql023" number="GQL-023">

<comment>Editorial: Stefan Plantikow 2021-03-04 Converted to LO</comment>
<reference><specref ref="gql_named_procedure_call"/>.
</reference>

<noteAt><specref ref="gql_PP023"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Decide on support for passing procedures, queries, functions as parameters.
</para>

</problem>

</LO>


<comment>Resolved by WG3:W21-049</comment>
<PP id="PPgql024" number="GQL-024" severity="major" realm="technical">

<reference><specref ref="gql_path_pattern_expr"/>.
</reference>

<noteAt><specref ref="gql_w16034_1"/>, <specref ref="gql_w16034_2"/>,
<specref ref="gql_sxm052_1"/>.
</noteAt>

<source>SXM-052, W16-034R2.
</source>

<problem>

<para>SXM-052 added the BNF for <BNF name="cost clause"/> but did not provide any Syntax Rules
or General Rules for it.
Furthermore, W16-034R2 did not mention it in Concepts.
</para>

<para>Linked to <ExtPPref ref="PPpgq026" standard="9075" part="16"/>.
</para>

</problem>

</PP>


<comment>Resolved by W01-014</comment>
<comment>SXM-052</comment>
<PP id="PPgql026" number="GQL-026" severity="major" realm="technical">

<reference><specref ref="gql_graph_pattern"/>.
</reference>

<noteAt><itemref ref="gql_graph_pattern_2_dist_edge_patt" type="SR"/>.
</noteAt>

<source>SXM-052.
</source>

<problem>

<para>SXM-052 adopted the solution in Language Opportunity PGQ-025 (first proposed in BNE-049r1
section 3.5 "Repeated edge variables"), permitting multiple declarations of edge
variables provided they are all singletons in global scope.
However, this will not permit patterns such as
</para>
<code>
((a) -[e]-&gt; (b))* | (a) -[e]-&gt; (b)
</code>
<para>which was intended to be permitted.
Additional work on permissible and impermissible multiple declarations of edge variables is
required.
</para>

</problem>

</PP>


<comment>Resolved by W01-014</comment>
<comment>SXM-052</comment>
<PP id="PPgql027" number="GQL-027" severity="major" realm="technical">

<reference><specref ref="gql_graph_pattern"/>.
</reference>

<noteAt><itemref ref="gql_graph_pattern_2_dist_node_patt" type="SR"/>.
</noteAt>

<source>SXM-052.
</source>

<problem>

<para>SXM-052 adopted the solution in Language Opportunity PGQ-024 (first proposed in BNE-049r1
section 3.4 <quote>Repeated vertex variables</quote>), permitting multiple declarations of node
variables provided they are all singletons in global scope.
However, this will not permit patterns such as
</para>
<code>
((p) -> (q))* | (p) -> (q)
</code>
<para>which was intended to be permitted (see for example ARK-012 section
6.2 <quote>Quantified patterns</quote>, example 8, item 3, pages 33-34).
Additional work on permissible and impermissible multiple declarations of node variables is
required.
</para>

</problem>

</PP>


<comment>Resolved by W04-009R1</comment>
<PP id="PPgql028" number="GQL-028" severity="major" realm="technical">

<reference><specref ref="gql_graph_pattern"/>.
</reference>

<noteAt><specref ref="gql_bne034_1"/>.
</noteAt>

<source>BNE-034.
</source>

<problem>

<para>Unbounded quantifiers permit an infinite set of results from a <BNF name="graph pattern"/>.
</para>

</problem>

</PP>


<comment>WG3:W23-014</comment>
<LO id="PPgql029" number="GQL-029">

<reference><specref ref="gql_token"/>.
</reference>

<noteAt><specref ref="gql_PP029"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>It is a Language Opportunity to extend the definition of <BNF name="regular identifier"/>s
to use the Unicode XID_Start and XID_Continue instead of the more restricted ID_Start and
ID_Continue.
</para>

</problem>

</LO>


<comment>Resolved by W12-029</comment>
<LO id="PPgql031" number="GQL-031">

<reference><specref ref="gql_value_type"/>.
</reference>

<noteAt><specref ref="SQL_diff027"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<comment>Editorial: Stefan Plantikow 2021-04-26 Reworded</comment>

<comment>Editorial: Stefan Plantikow 2021-03-02 Reworded</comment>
<para>GQL only has limited support for binary strings and only defined some functions that operate
on them.
Further work is needed to complete binary string functionality.
</para>


</problem>

<solution>

<para>Support for binary strings should be expanded.
</para>

</solution>

</LO>


<comment>Resolved by WG3:BER-057</comment>
<PP id="PPgql033" number="GQL-033" severity="minor" realm="technical">

<reference><specref ref="gql_label_expr"/>.
</reference>

<noteAt><specref ref="gql_mmx060_1"/>.
</noteAt>

<source>MMX-060.
</source>

<problem>

<para>Various options for <BNF name="wildcard label"/> were discussed in the SQL/PGQ and
GQL ad hocs.
The paper MMX-031 <quote>Edge patterns revisited</quote>,
section 5.6.2 <quote>Query language support for edges with no label</quote> discussed some
alternatives:
</para>

<para>Asterisk  conflicts with its use as a quantifier (the Kleene star operator)
</para>

<para>Underscore  may be regarded as an identifier by some implementations.
A workaround might be to declare that underscore is a reserved identifier and not available
for use as a label
</para>

<para>Period or dot  should be reserved for possible dot-qualification in simplified syntax
</para>

<para>So, the SQL/PGQ ad hoc settled on percent sign as the best choice.
</para>

<para>In the GQL ad hoc the next week, it was suggested that we might use a reserved word
such as <kw>ANY</kw>.
This would still allow <delimId>ANY</delimId> (a quoted identifier) as a label.
However, other participants said that implementations try to avoid imposing the standards
reserved words on their users.
</para>

<para>It was agreed to propose <BNF name="wildcard label"/> as percent sign
but add this Possible Problem so that the issue can be revisited.
</para>

<para>Linked to <ExtPPref ref="PPpgq034" standard="9075" part="16"/>.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-031</comment>
<PP id="PPgql037" number="GQL-037" severity="minor" realm="technical">

<reference><specref ref="gql_path_pattern_expr"/>.
</reference>

<noteAt><specref ref="gql_PP037"/> (<itemref ref="gql_ev" type="SR"/>).
</noteAt>

<source>Fred Zemke (email 2020-08-03 20:39) re W01-014.
</source>

<problem>

<para>The editor noted that <itemref type="SR" ref="gql_ev"/> has an <quote>element variable</quote>
<emph>contained</emph> in BNF item, <sym>GPVD</sym>.
It is not clear why this is not <quote>&lt;element variable></quote>.
Compare <itemref type="SR" ref="gql_ele_var_1"/>.
We may need to make a distinction between an element variable and an <BNF name="element variable"/>.
</para>

<para>Linked to &gt;ExtPPref ref="PPpgq037" standard="9075" part="16"/>.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W24-027</comment>
<PP id="PPgql038" number="GQL-038" severity="minor" realm="technical">

<reference><specref ref="gql_conc_ot_node"/>, 
<specref ref="gql_conc_ot_edge"/>.
</reference>

<noteAt><specref ref="gql_PP038_1"/>, <specref ref="gql_PP038_2"/>, <specref ref="gql_PP038_3"/>,
<specref ref="gql_PP038_4"/>.
</noteAt>

<source>Email Hannes Voigt, 2020-08-20 15:39.
</source>

<problem>

<para>These sections assume the node/edge type name is part of the node/edge type (descriptor).
This assumption has not been part of the original thinking behind MMX-028r2.
The consequences of this change have not been fully discussed, particularly the consequence on the
definitions of:
When two node/edge type descriptors describe equal node/edge types
When a node/edge type is considered a subtype of another node/edge type
When does the name matter with regards to assignability of values to sites of a given named type,
or when not.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-052R1</comment>
<LO id="PPgql039" number="GQL-039">

<reference><specref ref="gql_token"/>.
</reference>

<noteAt><specref ref="gql_w04009_8"/>.
</noteAt>

<source>W04-009R1.
</source>

<problem>

<para>WG3:W04-009R1 did not do a thorough analysis of whether <kw>KEEP</kw> needs to be
a <BNF name="reserved word"/>.
It is a Language Opportunity to investigate this and possibly make it
a <BNF name="non-reserved word"/>.
</para>

<para>Linked to <ExtPPref ref="PPpgq045" standard="9075" part="16"/>.
</para>

</problem>

</LO>


<comment>Resolved by W20-022</comment>
<PP id="PPgql040" number="GQL-040" severity="major" realm="technical">

<reference><specref ref="gql_token"/>.
</reference>

<noteAt><specref ref="gql_w04009_1"/>.
</noteAt>

<source>W04-009R1.
</source>

<problem>

<para>If we make the <BNF name="path mode"/>s <kw>WALK</kw>, <kw>TRAIL</kw>, <kw>SIMPLE</kw> and
<kw>ACYCLIC</kw> <BNF name="reserved word"/>s, then they can be used in
a <BNF name="simplified path pattern expression"/> to provide fine-grained path mode control
within syntax such as
</para>
<code>-/ TRAIL Like* /-
</code>
<para>WG3:W04-009R1 felt it better to leave them as <BNF name="non-reserved word"/>s so that, in
this example, TRAIL is treated as a label rather than a <BNF name="path mode"/>.
</para>

<para>Linked to <ExtPPref ref="PPpgq038" standard="9075" part="16"/>.
</para>

</problem>

</PP>


<comment>Resolved by W08-018</comment>
<PP id="PPgql041" number="GQL-041" severity="major" realm="technical">

<reference><specref ref="gql_eval_path_pattern_expr"/>.
</reference>

<noteAt><specref ref="gql_w04009_2"/>.
</noteAt>

<source>W04-009R1.
</source>

<problem>

<para>The Syntax Rules proposed in WG3:W04-009R1 would permit the <kw>WHERE</kw>
clause of a <BNF name="parenthesized path pattern expression"/> <symdef>PPPE</symdef> to be
evaluated during the generation of the set of local matches for <sym>PPPE</sym>;
however, WG3:W04-009R1 adhered to a computational model that supported delayed predicate evaluation.
</para>

<para>This was linked to SQL/PGQ PP PGQ-039 which was resolved by W13-018.
The appropriate changes from W13-018 need to be applied to GQL to resolve this issue.
</para>

</problem>

</PP>


<comment>Resolved by W08-018</comment>
<PP id="PPgql042" number="GQL-042" severity="major" realm="technical">

<reference><specref ref="gql_eval_path_pattern_expr"/>.
</reference>

<noteAt><specref ref="gql_w04009_3"/>.
</noteAt>

<source>W04-009R1.
</source>

<problem>

<para>Binding the boundary variables of a selector in stage 1 is only useful if
they can be referenced in the <BNF name="parenthesized path pattern where clause"/> of another
<BNF name="parenthesized path pattern expression"/>, but they cannot.
This binding is defined in case the rules are liberalized as originally proposed in [W03-030]
section 5.1, rather than the restriction adopted in that paper, section 8.1.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W21-050</comment>
<LO id="PPgql043" number="GQL-043">

<reference><specref ref="gql_eval_path_pattern_expr"/>.
</reference>

<noteAt><specref ref="gql_w04009_9"/>.
</noteAt>

<source>W04-009R1.
</source>

<problem>

<para>Perhaps we do not need to define the regular language.
WG3:W04-009R1 refrained from removing it, but suspects that it is not needed.
The author does believe it is useful in an explanatory sense; perhaps it belongs in a Technical
Report or Guide rather than the standard.
</para>

<para>Linked to <ExtPPref ref="PPpgq046" standard="9075" part="16"/>.
</para>

</problem>

</LO>


<comment>Resolved by W08-018</comment>
<LO id="PPgql045" number="GQL-045">

<reference><specref ref="gql_eval_sel_paren_path_pattern_expr"/>.
</reference>

<noteAt><specref ref="gql_w04009_11"/>.
</noteAt>

<source>W04-009R1.
</source>

<problem>

<para>With more work we might be able to support selectors inside quantifiers; the
interface to <specref ref="gql_eval_sel_paren_path_pattern_expr"/> might need to communicate
which specific instance of ellipsis symbol to evaluate.
</para>

</problem>

</LO>


<comment>Resolved by WG3:W21-024R1</comment>
<PP id="PPgql046" number="GQL-046" severity="minor" realm="technical">

<reference><specref ref="gql_path_pattern_expr"/>.
</reference>

<noteAt>Grammar production for <BNF name="parenthesized path pattern expression"/>
<specref ref="gql_bne049R1_2"/>.
</noteAt>

<source>BNE-049R1.
</source>

<problem>

<para>The ability to use square brackets as an alternative to round parentheses for grouping in
path patterns introduces an ambiguity in the grammar where a bare edge pattern followed by a group
(<ellipsis/> - [ <ellipsis/>) looks a lot like the start of an edge pattern
(<ellipsis/> -[ <ellipsis/>), the difference being only whitespace.
</para>

<para>Linked to <ExtPPref ref="PPpgq023" standard="9075" part="16"/>.
</para>

</problem>

<solution>

<para>Remove the alternative that uses <BNF name="left bracket"/> and <BNF name="right bracket"/>,
making the production:
<BNF name="parenthesized path pattern expression"/> ::=
<BNF name="left paren"/> <BNF name="path pattern expression"/>
[ <BNF name="parenthesized path pattern where clause"/> ]
<BNF name="right paren"/>
</para>

</solution>

</PP>


<comment>Resolved by W09-031</comment>
<LO id="PPgql047" number="GQL-047">

<reference><specref ref="gql_graph_pattern"/> and
<specref ref="gql_path_pattern_expr"/>.
</reference>

<noteAt><specref ref="gql_pp047_2"/> and <specref ref="gql_pp047_1"/>.
</noteAt>

<source>Minutes of the W04 meeting (W05-001).
</source>

<problem>

<para>Concern was expressed during the W04 meeting that the semantics of the
<BNF name="graph pattern where clause"/> and the
<BNF name="parenthesized path pattern where clause"/> can lead to radically different results but
for the end user the difference may not be obvious as the distinction is only whether or not they
are enclosed within parentheses.
</para>

<para>The use of a different keyword was suggested as a possible solution.
<kw>HAVING</kw> has been suggested but has met the objection that it has different semantics is
other places.
An alternative, <kw>FILTER</kw>, has also been suggested as having a similar use as a local
<kw>WHERE</kw> clause in <BNF name="aggregate function"/> in SQL/Foundation.
</para>

<para>No conclusion has yet been reached on the desirability of an alternative keyword or on what
that keyword should be.
</para>

</problem>

</LO>


<comment>Resolved by WG3:BER-030</comment>
<PP id="PPgql048" number="GQL-048" severity="major" realm="technical">

<reference><specref ref="gql_path_pattern_expr"/>.
</reference>

<noteAt><specref ref="gql_w04009_5"/>.
</noteAt>

<source>W04-009R1.
</source>

<problem>

<para>The rule that prohibits two successive <BNF name="element pattern"/>s
that are <BNF name="node pattern"/>s in a <BNF name="path concatenation"/> may be over-broad;
for example, we want to allow
</para>
<code>((P) -> (Q)) (R)
</code>

<para>Linked to <ExtPPref ref="PPpgq042" standard="9075" part="16"/>.
</para>

</problem>

</PP>


<comment>Resolved by W08-018</comment>
<PP id="PPgql049" number="GQL-049" severity="major" realm="technical">

<reference><specref ref="gql_path_pattern_expr"/>.
</reference>

<noteAt><specref ref="gql_w04009_6"/>.
</noteAt>

<source>W04-009R1.
</source>

<problem>

<para>The definition of the scope of an <BNF name="element variable"/> should be revisited in the
light of the compromise in WG3:W03-030
section 8.1 <quote>Discussion of WHERE clauses and implicit joins</quote>.
</para>

<para>This was linked to SQL/PGQ PP PGQ-043 which was resolved by W13-018.
The appropriate changes from W13-018 need to be applied to GQL to resolve this issue.
</para>

</problem>

</PP>


<comment>Resolved by W08-018</comment>
<PP id="PPgql058" number="GQL-058" severity="major" realm="technical">

<reference><specref ref="gql_graph_pattern"/>.
</reference>

<noteAt><specref ref="gql_w04009_4"/>.
</noteAt>

<source>W04-009R1.
</source>

<problem>

<para>The formation of equivalence classes in the General Rules in
<specref ref="gql_graph_pattern"/> may not be necessary to support the patterns allowed by the
Syntax Rules.
</para>

</problem>

</PP>


<comment>Resolved by WG3:UTC-123R2</comment>
<PP id="PPgql050" number="GQL-050" severity="major" realm="technical">

<reference><specref ref="gql_path_pattern_expr"/>.
</reference>

<noteAt><specref ref="gql_w04009_7"/>.
</noteAt>

<source>W04-009R1.
</source>

<problem>

<para>WG3:W04-009R1 defined <quote>effectively bounded group variable</quote> but did not use the
definition.
The definition will be used when we define predicates on aggregates, at which time we will want
a Syntax Rules stating that if a group variable <symdef>GV</symdef> is referenced in
a <kw>WHERE</kw> clause, then it shall be effectively bounded, and the reference shall be contained
in an aggregated argument of an <BNF name="aggregate function"/>.
</para>

<para>Was linked to PP PGQ-044 but that was resolved for PGQ by W20-030.
</para>

</problem>

</PP>


<comment>Resolved by WG3:GYD-031</comment>
<LO id="PPgql051" number="GQL-051" kind="feat_ext" size="S">

<brief area="Pattern matching">MATCH clause sequence variable passing</brief>

<reference><specref ref="gql_path_pattern_expr"/>.
</reference>

<noteAt><specref ref="gql_w04009_14"/>.
</noteAt>

<source>WG3:W04-009R1.
</source>

<problem>

<para>WG3:W04-009R1 recognized that a graph query may have a sequence of <kw>MATCH</kw>
clauses, with the bindings of one <kw>MATCH</kw> clause visible in all subsequent 
<kw>MATCH</kw> clauses in the same invocation of
<BNF name="graph table" standard="9075" part="16"/>, and that it should be permissible to
reference such variables in any
<BNF name="parenthesized path pattern where clause"/> simply contained in a subsequent
<kw>MATCH</kw> clause.
The relevance of this LO to GQL needs to be investigated.
</para>

<para>Linked to <ExtPPref ref="PPpgq051" standard="9075" part="16"/>.
</para>

</problem>

</LO>


<comment>Resolved by WG3:W22-053R2</comment>
<LO id="PPgql059" number="GQL-059">

<reference><specref ref="gql_graph_pattern"/>.
</reference>

<noteAt><specref ref="gql_w04009_13"/>.
</noteAt>

<source>W04-009R1.
</source>

<problem>

<para>It has been proposed that unconditional singletons exposed by prior <kw>MATCH</kw>
clauses may also be joined implicitly.
</para>

<para>Linked to <ExtPPref ref="PPpgq050" standard="9075" part="16"/>.
</para>

</problem>

</LO>


<comment>Resolved by W20-022</comment>
<PP id="PPgql060" number="GQL-060" severity="minor" realm="technical">

<reference><specref ref="gql_conc_graph_patt_match"/>.
</reference>

<noteAt><specref ref="gql_w05001"/>, <specref ref="gql_selector_use_6"/>.
</noteAt>

<source>W05-001 &amp; Email Fred Zemke 2020-11-10 04:33.
</source>

<problem>

<para>In the minutes (W05-001), Stephen noted that the terms <quote>selector</quote> and
<quote>restrictor</quote>, which are currently only used in Notes (and one place in the informative
Annex for <unDef/> elements [now removed]) are never defined in the resulting WD.
He said he assumed that this will be done in SQL/PGQ in the Concepts section
<specref ref="gql_conc_graph_patt_match"/>.
In GQL <specref ref="gql_conc_terms"/> might be the place unless an equivalent for SQL/PGQ<apos/>s
<extref ref="pgq_conc_graph_patt_match" standard="9075" part="16"/> is created.
In an email (Fred Zemke 2020-11-10 04:33) to the editor, Fred agreed and asked that this PP be
created to say that <quote>those terms should be defined or replaced</quote>.
</para>

<para>Linked to <ExtPPref ref="PPpgq058" standard="9075" part="16"/>.
</para>

</problem>

</PP>


<comment>Resolved by WG3:UTC-015</comment>
<PP id="PPgql061" number="GQL-061" severity="major" realm="technical">

<reference><specref ref="gql_conc_hier"/>.
</reference>

<noteAt><specref ref="w05020-1"/>, <specref ref="gql_PP061_1"/>, <specref ref="gql_PP061_2"/>,
<specref ref="gql_PP061_3"/>, <specref ref="gql_PP061_4"/>, <specref ref="gql_PP061_5"/>.
</noteAt>

<source>W05-020, W12-029.
</source>

<problem>

<para>W05-020 suggests that the text in this Subclause has not been considered by
WG3 and that consensus agreement is required.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W23-029R1</comment>
<PP id="PPgql062" number="GQL-062" severity="major" realm="technical">

<reference><specref ref="gql_conc_gt"/>.
</reference>

<noteAt><specref ref="w05020-2"/>, <specref ref="w05020-2a"/>, <specref ref="w05020-2b"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that although the contents of this Subclause have been discussed, consensus
has not yet been reached on all aspects.
It has been touched on in [W04-013] and [MMX-079r1] and is part of the roadmap in [W02-014].
Consensus agreement is required.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-040R3</comment>
<PP id="PPgql063" number="GQL-063" severity="major" realm="technical">

<reference><specref ref="gql_conc_btt"/>.
</reference>

<noteAt><specref ref="w05020-3"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that despite being touched on in [W04-013], further discussion needed
to establish consensus agreement.

</para>

</problem>

</PP>


<comment>Resolved by WG3:W23-013</comment>
<PP id="PPgql064" number="GQL-064" severity="major" realm="technical">

<reference><specref ref="gql_conc_constr"/>.
</reference>

<noteAt><specref ref="w05020-4"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that despite being discussed in [W03-034] with the exception of
<specref ref="gql_conc_path"/>, which is included in
the roadmap in [W02-014] and touched in in [W04-013], further discussion is needed to establish
consensus agreement.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-040R3</comment>
<PP id="PPgql065" number="GQL-065" severity="major" realm="technical">

<reference><specref ref="gql_conc_vt_ref"/>.
</reference>

<noteAt><specref ref="w05020-5"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that the text in this Subclause, although included in the
roadmap in [W02-014] and touched on in [W03-034] and [W04-013], has not been considered by
WG3 and that consensus agreement is required.
</para>

<para>The editors had also noted that further details needed to be supplied.
</para>

</problem>

</PP>


<comment>Resolved by WG3:UTC-077</comment>
<PP id="PPgql066" number="GQL-066" severity="major" realm="technical">

<reference><specref ref="gql_procedures"/>.
</reference>

<noteAt><specref ref="w05020-6"/>, <specref ref="gql_PP066_1"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that the text in this clause has not been considered by
WG3 and that consensus agreement is required.
</para>

<comment>W13-024: Stefan Plantikow 2021-07-21</comment>
<comment>WG3:RKE-015</comment>
<para>WG3:RKE-015 has reviewed and reached consensus agreement for
<specref ref="gql_procedure_body"/>.
</para>

</problem>

<comment>W13-024: Stefan Plantikow 2021-07-21</comment>
<comment>WG3:RKE-015</comment>
<solution>

<comment>WG3:RKE-015 Implemented suggestion</comment>

</solution>

</PP>


<comment>Resolved by WG3:W23-013</comment>
<PP id="PPgql067" number="GQL-067" severity="major" realm="technical">

<reference><specref ref="gql_varsparams"/>.
</reference>

<noteAt><specref ref="w05020-7"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that the text in this clause has not been considered by
WG3 and that consensus agreement is required.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W22-051</comment>
<PP id="PPgql068" number="GQL-068" severity="major" realm="technical">

<reference><specref ref="gql_objects"/>.
</reference>

<noteAt><specref ref="gql_PP068_2"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that, although the text in some subclauses of this clause
is not likely to be controversial and indeed some of the text is based on accepted proposals,
further discussion is needed to establish consensus agreement.
Specifically, W05-020 said:
</para>

<ulist>

<item><specref ref="gql_gexpr"/>, is based on [MMX-028r2] and [MMX-055] but further discussion
is needed.
</item>

<item><specref ref="gql_gtexpr"/>, is based on [MMX-028r2] and [MMX-055] but further discussion
is needed.
</item>

</ulist>

</problem>

</PP>


<comment>Resolved by WG3:W23-013</comment>
<PP id="PPgql069" number="GQL-069" severity="major" realm="technical">

<reference><specref ref="gql_stm"/>.
</reference>

<noteAt><specref ref="w05020-9"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that the text in this clause, which was outlined in BNE-023,
needs further discussion to achieve consensus agreement.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-037</comment>
<PP id="PPgql070" number="GQL-070" severity="major" realm="technical">

<reference><specref ref="gql_ddl"/>.
</reference>

<noteAt><specref ref="w05020-10a"/>, <specref ref="w05020-10b"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that <specref ref="gql_drop_graph"/>,
and <specref ref="gql_drop_graph_type"/>,
still have open questions.
Further discussion is needed to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:UTC-096R1</comment>
<PP id="PPgql071" number="GQL-071" severity="major" realm="technical">

<reference><specref ref="gql_dml"/>.
</reference>

<noteAt><specref ref="w05020-11"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that, although the text in the subclauses of this clause
have been discussed in various papers further discussion is needed to establish consensus agreement.
Specifically, W05-020 said:
</para>

<ulist>

<item>Discussion is needed for <specref ref="gql_lin_data_mod_stm"/>.
</item>

<item><specref ref="gql_insert"/>, was discussed in [W06-009] and [BNE-023] but further
discussion is needed.
</item>

<item><specref ref="gql_set_stmt"/>, was discussed in [W06-009] and [BNE-023] but further
discussion is needed.
</item>

<item><specref ref="gql_remove"/>, was discussed in [W06-009] and [BNE-023] but further
discussion is needed.
</item>

<item><specref ref="gql_delete"/>, was discussed in [W06-009] and [BNE-023] but further
discussion is needed.
</item>

<item><specref ref="gql_call_data_proc"/>, was discussed in [BNE-023] but further discussion
is needed.
</item>

</ulist>

</problem>

</PP>


<comment>Resolved by WG3:W23-013</comment>
<PP id="PPgql072" number="GQL-072" severity="major" realm="technical">

<reference><specref ref="gql_stm_result"/>.
</reference>

<noteAt><specref ref="w05020-12"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that discussion of this Subclause is needed to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W23-013</comment>
<PP id="PPgql073" number="GQL-073" severity="major" realm="technical">

<reference><specref ref="gql_project"/>.
</reference>

<noteAt><specref ref="w05020-13"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that discussion of this Subclause is needed to establish consensus.
</para>

<comment>WG3:BER-081</comment>
<para>It needs to be specified in the SRs of <BNF name="project statement"/>, which data types
are acceptable result types for the <BNF name="project statement"/>.
More specifically, this can happen by restricting the declared type of the immediately contained
<BNF name="value expression"/>.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W19-017</comment>
<PP id="PPgql074" number="GQL-074" severity="major" realm="technical">

<reference><specref ref="gql_at"/>.
</reference>

<noteAt><specref ref="w05020-14"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that discussion of this Subclause is needed to establish consensus.
</para>

<comment>W13-024: Stefan Plantikow 2021-07-21</comment>
<para>The scope of the effect of the <BNF name="at schema clause"/> needs to be clarified.
In particular, it needs to be decided if the effect of an <BNF name="at schema clause"/>
<symdef>ASC</symdef> applies only to the statement in which <sym>ASC</sym> is contained or not.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W22-053R2</comment>
<PP id="PPgql075" number="GQL-075" severity="major" realm="technical">

<reference><specref ref="gql_named"/>.
</reference>

<noteAt><specref ref="w05020-15"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that discussion of this Subclause is needed to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W22-054</comment>
<PP id="PPgql076" number="GQL-076" severity="major" realm="technical">

<reference><specref ref="gql_procsig"/>.
</reference>

<noteAt><specref ref="w05020-16"/>, <specref ref="gql_PP076_1"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that discussion of this Subclause is needed to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:RKE-015</comment>
<PP id="PPgql077" number="GQL-077" severity="major" realm="technical">

<reference><specref ref="gql_yield"/>.
</reference>

<noteAt><specref ref="w05020-17"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that discussion of this Subclause is needed to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W23-013</comment>
<PP id="PPgql078" number="GQL-078" severity="major" realm="technical">

<reference><specref ref="gql_group_by"/>.
</reference>

<noteAt><specref ref="w05020-18"/>.
</noteAt>

<source>W05-020, BER-019, OHD-028.
</source>

<problem>

<para>W05-020 suggests that discussion of this Subclause is needed to establish consensus.
</para>

<para>Specific issue 1: The <BNF name="group by clause"/> uses the <BNF name="grouping element"/>
as <BNF name="binding variable"/> for defining a new binding variable.
In most other parts of the draft <BNF name="binding variable"/> is only used
when reading a presumably already defined variable.
While places like <BNF name="value variable definition"/> use 
&lt;BNF name="binding variable name"/>
(and not <BNF name="binding variable"/>) when defining a new variable.
</para>

</problem>

<solution>

<para>Specific issues 1: Replacing <BNF name="binding variable"/> with
&lt;BNF name="binding variable name"/> in
the format of <BNF name="grouping element"/> should be the kernel of a sufficient solution.
</para>

<para>Specific issues 2: Remove the SR.
</para>

</solution>

</PP>


<comment>Resolved by WG3:BER-094R1</comment>
<PP id="PPgql079" number="GQL-079" severity="major" realm="technical">

<reference><specref ref="gql_graph_ele_val"/>.
</reference>

<noteAt><specref ref="w05020-19"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that discussion of this Subclause is needed to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-094R1</comment>
<PP id="PPgql080" number="GQL-080" severity="major" realm="technical">

<reference><specref ref="gql_graph_ele_func"/>.
</reference>

<noteAt><specref ref="w05020-20"/>, <specref ref="gql_valexp"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that discussion of this Subclause is needed to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-094R1</comment>
<PP id="PPgql081" number="GQL-081" severity="major" realm="technical">

<reference><specref ref="gql_settvalconst"/>, <specref ref="gql_valexp"/>.
</reference>

<noteAt><specref ref="w05020-21"/>, <specref ref="gql_PP081_valexpr"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that discussion of this Subclause is needed to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-038R1</comment>
<PP id="PPgql082" number="GQL-082" severity="major" realm="technical">

<reference><specref ref="gql_ordsettvalconst"/>, <specref ref="gql_valexp"/>.
</reference>

<noteAt><specref ref="w05020-22"/>, <specref ref="gql_PP082_valexpr"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that discussion of this Subclause is needed to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W22-036</comment>
<PP id="PPgql083" number="GQL-083" severity="major" realm="technical">

<reference><specref ref="gql_maptvalconst"/>.
</reference>

<noteAt><specref ref="gql_PP083_valexpr"/>, <specref ref="w05020-23"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that discussion of this Subclause is needed to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-040R3</comment>
<PP id="PPgql084" number="GQL-084" severity="major" realm="technical">

<reference><specref ref="gql_recordtvalconst"/>, <specref ref="gql_valexp"/>.
</reference>

<noteAt><specref ref="w05020-24"/>, <specref ref="gql_PP084_valexpr"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that discussion of this Subclause is needed to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W23-013</comment>
<PP id="PPgql085" number="GQL-085" severity="major" realm="technical">

<reference><specref ref="gql_prop_ref"/>.
</reference>

<noteAt><specref ref="w05020-25"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that discussion of this Subclause is needed to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:UTC-069</comment>
<PP id="PPgql086" number="GQL-086" severity="major" realm="technical">

<reference><specref ref="gql_lexical"/>.
</reference>

<noteAt><specref ref="w05020-26"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para><specref ref="gql_lexical"/>, is based on
<extref ref="fnd_lexical" standard="9075" part="02"/>,
of SQL/Foundation and adapted by [MMX-011r1], [MMX-028r2] and [W03-034].
Two proposals, [W04-015] and [W04-019], attempted to resolve perceived issues with this clause and
both were rejected by WG3.
W05-020 suggests that further discussion of this clause is needed to establish consensus.
</para>

<para>W12-029 agreed on the following parts of <specref ref="gql_value_type"/>:
</para>

<ulist>

<item>The Format of <BNF name="predefined type"/>.
</item>

<item>The Syntax Rules 1-42) introduced by W12-029.
</item>

<item>The General Rules 1-6) introduced by W12-029.
</item>

</ulist>

</problem>

</PP>


<comment>Resolved by WG3:W23-013</comment>
<PP id="PPgql087" number="GQL-087" severity="major" realm="technical">

<reference><specref ref="gql_setop_result"/>.
</reference>

<noteAt><specref ref="w05020-27"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that discussion of this Subclause is needed to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-040R3</comment>
<PP id="PPgql088" number="GQL-088" severity="major" realm="technical">

<reference><specref ref="gql_conc_obj_statdyn"/>.
</reference>

<noteAt><specref ref="w05020-28"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that further discussion of this Subclause is needed to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by RKE-040</comment>
<PP id="PPgql089" number="GQL-089" severity="major" realm="technical">

<reference><specref ref="gql_conc_g"/>.
</reference>

<noteAt><specref ref="w05020-29"/>, <specref ref="w05020-29a"/>, <specref ref="w05020-29b"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that consensus has not been reached on all aspects of this
Subclause and that further discussion is needed to establish that consensus.
The text is based on [SXM-030r3].
</para>

</problem>

</PP>


<comment>Resolved by W13-010R1</comment>
<PP id="PPgql090" number="GQL-090" severity="minor" realm="technical">

<reference><specref ref="gql_conc_env_cat"/>.
</reference>

<noteAt><specref ref="w05020-30"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that, although this Subclause is based on [SQL-Framework-2016] and [MMX-055],
which was accepted and then adapted, further discussion on details is likely as consensus has not
been established on all details.
</para>

</problem>

</PP>


<comment>Resolved by W08-010</comment>
<PP id="PPgql091" number="GQL-091" severity="major" realm="editorial">

<reference><specref ref="gql_conc_env_agent"/>.
</reference>

<noteAt><specref ref="w05020-31"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this subclause is not likely to be controversial.
It was touched on in [BNE-023] and [W08-017].
However, W05-020 still suggests that consensus agreement is needed.
</para>

</problem>

</PP>


<comment>Resolved by W10-019R1</comment>
<PP id="PPgql092" number="GQL-092" severity="major" realm="editorial">

<reference><specref ref="gql_conc_env_principals"/>.
</reference>

<noteAt><specref ref="w05020-32"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this subclause is not likely to be controversial.
It was mentioned in [ARK-028].
However, W05-020 still suggests that consensus agreement is needed.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-040R3</comment>
<PP id="PPgql093" number="GQL-093" severity="major" realm="editorial">

<reference><specref ref="gql_conc_val"/>.
</reference>

<noteAt><specref ref="w05020-33"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause is not likely to be controversial.
It was discussed in [W03-034].
However, W05-020 still suggests that consensus agreement is needed.
</para>

</problem>

</PP>


<comment>Resolved by W08-014</comment>
<PP id="PPgql094" number="GQL-094" severity="major" realm="editorial">

<reference><specref ref="gql_conc_session"/>.
</reference>

<noteAt><specref ref="w05020-34"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this subclause is not likely to be controversial.
It was touched on in [W08-017].
However, W05-020 still suggests that consensus agreement is needed.
</para>

</problem>

</PP>


<comment>Resolved by W08-013</comment>
<PP id="PPgql095" number="GQL-095" severity="major" realm="editorial">

<reference><specref ref="gql_conc_req"/>.
</reference>

<noteAt><specref ref="w05020-33"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this subclause is not likely to be controversial.
It was touched on in [W08-017].
However, W05-020 still suggests that consensus agreement is needed.
</para>

</problem>

</PP>


<comment>Resolved by W12-019</comment>
<PP id="PPgql096" number="GQL-096" severity="major" realm="editorial">

<reference><specref ref="gql_conc_exe"/>.
</reference>

<noteAt><specref ref="w05020-36"/>.
</noteAt>

<source>W05-020, W09-021R1.
</source>

<problem>

<para>W05-020 suggests that this Subclause is not likely to be controversial.
It was touched on in [W08-017] and explicitly discussed in parts in W09-021R1.
However, W05-020 still suggests that consensus agreement is needed.
</para>

<para>W09-021R1 agreed on:
</para>

<ulist>

<item>The first paragraph of <specref ref="gql_conc_exe_gendescr"/>.
</item>

<item>Execution context comprising of characteristics 1) to 4) as listed in
<specref ref="gql_conc_exe_gendescr"/>.
</item>

<item>The paragraph of <specref ref="gql_conc_exe_gendescr"/> starting
<quote>The current execution context is an execution context <ellipsis/></quote>.
</item>

<item>The paragraph of <specref ref="gql_conc_exe_gendescr"/> starting
<quote>As a principle, phrases of the form current x <ellipsis/></quote>
and items 1) to 4) of the item list following it.
</item>

</ulist>

</problem>

</PP>


<comment>Resolved by WG3:BER-086R1</comment>
<PP id="PPgql097" number="GQL-097" severity="major" realm="editorial">

<reference><specref ref="gql_conc_prcmd"/>.
</reference>

<noteAt><specref ref="w05020-37"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that, although the concepts of this section were outlined in
[W08-017], further discussion is needed.
</para>

</problem>

</PP>


<comment>Resolved by WG3:UTC-117</comment>
<PP id="PPgql098" number="GQL-098" severity="major" realm="editorial">

<reference><specref ref="gql_conc_dt"/>.
</reference>

<noteAt><specref ref="w05020-38"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that, whilst the introductory text is based on that in
SQL/Foundation, the Subclause as a whole has not yet reached consensus agreement.
</para>

<para>W12-029 agreed on the following Subclauses:
</para>

<ulist>

<item><specref ref="gql_conc_dt_genintro"/>.
</item>

<item><specref ref="gql_conc_dt_predefined_names"/>.
</item>

<item><specref ref="gql_conc_dt_descriptors"/>.
</item>

</ulist>

</problem>

</PP>


<comment>Resolved by WG3:UTC-117</comment>
<PP id="PPgql099" number="GQL-099" severity="major" realm="editorial">

<reference><specref ref="gql_conc_vt_predef"/>.
</reference>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that, whilst this Subclause is not considered controversial
and has already been discussed in [W03-034], there is still a need to establish consensus.
</para>

<para>W12-029 agreed on the following subclauses:
</para>

<ulist>

<item><specref ref="gql_conc_Boolean"/>.
</item>

<item><specref ref="gql_conc_char_string"/>.
</item>

<item><specref ref="gql_conc_byte_string"/>.
</item>

<item><specref ref="gql_conc_numeric"/>.
</item>

</ulist>

</problem>

</PP>


<comment>Resolved by W08-013</comment>
<PP id="PPgql100" number="GQL-100" severity="major" realm="editorial">

<reference><specref ref="gql_request"/>.
</reference>

<noteAt><specref ref="w05020-40"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this clause is not likely to be controversial and that
<specref ref="gql_program"/> is based on [ARK-034r2].
However W05-020 believes consensus agreement is necessary.
</para>

</problem>

</PP>


<comment>Resolved by W08-014</comment>
<PP id="PPgql101" number="GQL-101" severity="major" realm="editorial">

<reference><specref ref="gql_session_mngt"/>.
</reference>

<noteAt><specref ref="w05020-41"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this clause is not likely to be controversial that
some discussion is needed to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by W15-017</comment>
<PP id="PPgql102" number="GQL-102" severity="major" realm="editorial">

<reference><specref ref="gql_stm_comp_query_stm"/>.
</reference>

<noteAt><specref ref="w05020-42"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that, despite most of this being very familiar from SQL,
a few things need further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-049</comment>
<PP id="PPgql103" number="GQL-103" severity="major" realm="editorial">

<reference><specref ref="gql_stm_cond_query_stm"/>.
</reference>

<noteAt><specref ref="w05020-43"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that discussion of this Subclause is needed to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by W15-017</comment>
<PP id="PPgql104" number="GQL-104" severity="major" realm="editorial">

<reference><specref ref="gql_stm_comp_query_expr"/>.
</reference>

<noteAt><specref ref="w05020-44"/>, <specref ref="gql_PP104_1"/>, <specref ref="gql_PP104_2"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that discussion of this Subclause is needed to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by W15-017</comment>
<PP id="PPgql105" number="GQL-105" severity="major" realm="editorial">

<reference><specref ref="gql_stm_lin_query_expr"/>.
</reference>

<noteAt><specref ref="w05020-45"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was based on [JCJ-010r1], has been agreed in
spirit but the details might need further discussion is needed to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by W15-017</comment>
<PP id="PPgql106" number="GQL-106" severity="major" realm="editorial">

<reference><specref ref="gql_stm_lin_query_stm"/>.
</reference>

<noteAt><specref ref="w05020-46"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was based on [JCJ-010r1], has been agreed in
spirit but the details might need further discussion is needed to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W23-013</comment>
<PP id="PPgql107" number="GQL-107" severity="major" realm="editorial">

<reference><specref ref="gql_call_query"/>.
</reference>

<noteAt><specref ref="w05020-47"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was discussed in [BNE-023],
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W23-015</comment>
<PP id="PPgql108" number="GQL-108" severity="major" realm="editorial">

<reference><specref ref="gql_mandatory"/>.
</reference>

<noteAt><specref ref="w05020-48"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was discussed in [BNE-023],
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W23-015</comment>
<PP id="PPgql109" number="GQL-109" severity="major" realm="editorial">

<reference><specref ref="gql_optional"/>.
</reference>

<noteAt><specref ref="w05020-49"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was discussed in [BNE-023],
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by W14-013</comment>
<PP id="PPgql110" number="GQL-110" severity="major" realm="editorial">

<reference><specref ref="gql_filter"/>.
</reference>

<noteAt><specref ref="w05020-50"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was discussed in [BNE-023] as WITH,
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W22-030</comment>
<PP id="PPgql111" number="GQL-111" severity="major" realm="editorial">

<reference><specref ref="gql_let"/>.
</reference>

<noteAt><specref ref="w05020-51"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was discussed in [BNE-023] as WITH,
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W23-013</comment>
<PP id="PPgql112" number="GQL-112" severity="major" realm="editorial">

<reference><specref ref="gql_aggregate"/>.
</reference>

<noteAt><specref ref="w05020-52"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was discussed in [BNE-023] as WITH,
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W23-013</comment>
<PP id="PPgql113" number="GQL-113" severity="major" realm="editorial">

<reference><specref ref="gql_for"/>.
</reference>

<noteAt><specref ref="w05020-53"/>, <specref ref="gql_PP113_rationale"/>,
<specref ref="gql_PP113_item"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was discussed in [BNE-023] as UNWIND,
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by W15-020</comment>
<PP id="PPgql114" number="GQL-114" severity="major" realm="editorial">

<reference><specref ref="gql_order_by_and_page"/>.
</reference>

<noteAt><specref ref="w05020-54"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was discussed in [BNE-023],
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W20-013</comment>
<PP id="PPgql115" number="GQL-115" severity="major" realm="editorial">

<reference><specref ref="gql_call_function"/>.
</reference>

<noteAt><specref ref="w05020-55"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was discussed in [BNE-023],
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:UTC-081</comment>
<PP id="PPgql116" number="GQL-116" severity="major" realm="editorial">

<reference><specref ref="gql_stm_return"/>.
</reference>

<noteAt><specref ref="w05020-56"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was discussed in [JCJ-010r1] and
[BNE-023], needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W23-028R2</comment>
<PP id="PPgql117" number="GQL-117" severity="major" realm="editorial">

<reference><specref ref="gql_select"/>.
</reference>

<noteAt><specref ref="w05020-57"/>, <specref ref="w15017_1"/>.
</noteAt>

<source>W05-020, W15-017.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was discussed in [JCJ-010r1],
needs further discussion to establish consensus.
Furthermore, the Syntax and General Rules are probably incomplete and, in any case, need to be
reviewed.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W24-024R1</comment>
<PP id="PPgql118" number="GQL-118" severity="major" realm="editorial">

<reference><specref ref="gql_procedure_call"/>.
</reference>

<noteAt><specref ref="w05020-58"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was discussed in [BNE-023],
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:OHD-017</comment>
<PP id="PPgql119" number="GQL-119" severity="major" realm="editorial">

<reference><specref ref="gql_inline_procedure_call"/>.
</reference>

<noteAt><specref ref="w05020-59"/>, <specref ref="gql_PP119_1"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was discussed in [BNE-023],
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W22-054</comment>
<PP id="PPgql120" number="GQL-120" severity="major" realm="editorial">

<reference><specref ref="gql_named_procedure_call"/>.
</reference>

<noteAt>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was discussed in [BNE-023],
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by W15-020</comment>
<PP id="PPgql121" number="GQL-121" severity="major" realm="editorial">

<reference><specref ref="gql_ordering_and_paging"/>.
</reference>

<noteAt><specref ref="w05020-61"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was discussed in [BNE-023],
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by W15-020</comment>
<PP id="PPgql122" number="GQL-122" severity="major" realm="editorial">

<reference><specref ref="gql_order_by"/>.
</reference>

<noteAt><specref ref="w05020-62"/>, <specref ref="gql_PP122"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was discussed in [BNE-023],
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W23-013</comment>
<PP id="PPgql123" number="GQL-123" severity="major" realm="editorial">

<reference><specref ref="gql_aggregate_func"/>.
</reference>

<noteAt><specref ref="w05020-63"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was discussed in [BNE-023],
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by W15-020</comment>
<PP id="PPgql124" number="GQL-124" severity="major" realm="editorial">

<reference><specref ref="gql_sort_spec_list"/>.
</reference>

<noteAt><specref ref="w05020-64"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was discussed in [BNE-023],
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by W15-020</comment>
<PP id="PPgql125" number="GQL-125" severity="major" realm="editorial">

<reference><specref ref="gql_limit"/>.
</reference>

<noteAt><specref ref="w05020-65"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was discussed in [BNE-023],
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by W15-020</comment>
<PP id="PPgql126" number="GQL-126" severity="major" realm="editorial">

<reference><specref ref="gql_offset"/>.
</reference>

<noteAt><specref ref="w05020-66"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was discussed in [BNE-023],
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W22-051</comment>
<PP id="PPgql127" number="GQL-127" severity="major" realm="editorial">

<reference><specref ref="gql_obj_refs"/>.
</reference>

<noteAt><specref ref="w05020-67"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this clause, which is based on [MMX-055] and discussed
in [W03-034], needs further discussion to establish consensus.
</para>

<comment>W13-024: Stefan Plantikow 2021-07-21</comment>
<para>W13-024 agreed on <specref ref="gql_schema_refs"/>.
</para>

<para>All primary object references should be resolved by Syntax Rules.
</para>

<para><BNF name="schema reference"/>s are resolved by Syntax Rules.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-094R1</comment>
<PP id="PPgql128" number="GQL-128" severity="major" realm="editorial">

<reference><specref ref="gql_collvalconst"/>.
</reference>

<noteAt><specref ref="w05020-68"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause which is based on
<BNF name="collection value constructor" standard="9075" part="02"/> of SQL/Foundation,
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-094R1</comment>
<PP id="PPgql129" number="GQL-129" severity="major" realm="editorial">

<reference><specref ref="gql_listvalexp"/>.
</reference>

<noteAt><specref ref="w05020-69"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause which is based on
<extref ref="fnd_arrelemref" standard="9075" part="02"/> in SQL/Foundation,
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-094R1</comment>
<PP id="PPgql130" number="GQL-130" severity="major" realm="editorial">

<reference><specref ref="gql_listvalfunc"/>.
</reference>

<noteAt><specref ref="w05020-70"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which is based on
<extref ref="fnd_arrayvalfunc" standard="9075" part="02"/> in SQL/Foundation,
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-094R1</comment>
<PP id="PPgql131" number="GQL-131" severity="major" realm="editorial">

<reference><specref ref="gql_listvalconst"/>.
</reference>

<noteAt><specref ref="w05020-71"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which is based on
<extref ref="fnd_arrayvalconst" standard="9075" part="02"/> in SQL/Foundation,
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-094R1</comment>
<PP id="PPgql132" number="GQL-132" severity="major" realm="editorial">

<reference><specref ref="gql_multisetvalexp"/>.
</reference>

<noteAt><specref ref="w05020-72"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which is based on
<extref ref="fnd_multisetvalexp" standard="9075" part="02"/> in SQL/Foundation,
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-094R1</comment>
<PP id="PPgql133" number="GQL-133" severity="major" realm="editorial">

<reference><specref ref="gql_multisetsetvalfunc"/>.
</reference>

<noteAt><specref ref="w05020-73"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which is based on
<extref ref="fnd_multisetvalfunc" standard="9075" part="02"/> in SQL/Foundation,
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-094R1</comment>
<PP id="PPgql134" number="GQL-134" severity="major" realm="editorial">

<reference><specref ref="gql_multisettvalconst"/>.
</reference>

<noteAt><specref ref="w05020-74"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which is based on
<extref ref="fnd_multisetvalconst" standard="9075" part="02"/> in SQL/Foundation,
needs further discussion to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by WG3:UTC-070</comment>
<PP id="PPgql136" number="GQL-136" severity="minor" realm="editorial">

<reference><specref ref="gql_definitions"/>.
</reference>

<noteAt><specref ref="w05020-76"/>.
</noteAt>

<source>SXM-052, W05-020, W09-016, W09-021R1, W09-036, W10-019R1, W11-031, W12-019, W12-029,
W13-010R1, W19-017.
</source>

<problem>

<para>W05-020 suggests that, although much of this clause taken from SQL/PGQ and
SQL Foundation, and is not expected to be controversial, it should nevertheless be reviewed.
</para>

<para>The following terms from <specref ref="gql_general_terms_defns"/>, require further
review of their associated definitions and regarding their general inclusion in the document:
</para>

<olist>

<item>variable &lt;<quote>x variable</quote>
</item>

</olist>

<para>The following terms from <specref ref="gql_graph_terms_defns"/>, require further
review of their associated definitions and regarding their general inclusion in the document:
</para>

<olist>

<item>empty graph
</item>

<item>directed edge
</item>

</olist>

<para>The following terms from <specref ref="gql_env_terms_defns"/>, require
further review of their associated definitions and regarding their general inclusion in the
document:
</para>

<olist>

<item>GQL-environment
</item>

<item>GQL-server
</item>

<item>principal
</item>

<item>GQL-client
</item>

<item>GQL-agent
</item>

<item>session-derived &lt;GQL-object>
</item>

<item>GQL-transaction
</item>

<item>original
</item>

<item>derived
</item>

</olist>

<para>The following terms from <specref ref="gql_cat_terms_defns"/>, require further
review of their associated definitions and regarding their general inclusion in the document:
</para>

<olist>

<item>type object
</item>

<item>catalog-derived &lt;object>
</item>

<item>visible &lt;GQL-object>
</item>

<item>home schema
</item>

<item>home graph
</item>

</olist>

<para>The following terms from <specref ref="gql_proc_terms_defns"/>, require further
review of their associated definitions and regarding their general inclusion in the document:
</para>

<olist>

<item>locally-derived &lt;object>
</item>

<item>stored procedure
</item>

<item>procedure
</item>

<item>simple view
</item>

<item>parameterized view
</item>

<item>view
</item>

<item>command
</item>

<item>session command
</item>

<item>transaction command
</item>

<item>GQL-procedure
</item>

<item>external procedure
</item>

<item>statement
</item>

</olist>

<para>The following terms from <specref ref="gql_proc_syntax_terms_defns"/>, require
further review of their associated definitions and regarding their general inclusion in the
document:
</para>

<olist>

<item>pattern
</item>

<item>pattern macro
</item>

<item>path pattern macro
</item>

<item>pattern variable &lt;<quote>x pattern variable</quote>
</item>

<item>pattern match
</item>

<item>element pattern
</item>

<item>label expression
</item>

<item>linear composition
</item>

<item>whitespace
</item>

</olist>

<para>The following terms from <specref ref="gql_val_terms_defns"/>, require further
review of their associated definitions and regarding their general inclusion in the document:
</para>

<olist>

<item>character string
</item>

</olist>

<para>The following terms from <specref ref="gql_ty_terms_defns"/>, require further review
of their associated definitions and regarding their general inclusion in the document:
</para>

<olist>

<item>any type
</item>

<item>graph type
</item>

<item>nothing type
</item>

</olist>

</problem>

<solution>

<comment>Editorial: Stefan Plantikow, 2022-01-06 1309 Terms already vetted</comment>

<para>The following terms are directly inherited from SQL with marginal editorial modifications.
All of these terms may still be subject to further review as may be indicated by additional
Possible Problems or Language Opportunities.
</para>

<olist>

<comment>Terms already vetted: Stefan Plantikow, 2022-01-06 1310 Terms already vetted</comment>

<item>scope (of a name or declaration)
</item>

</olist>

<para>In the following we cite change proposals that have agreed on the inclusion of some terms
and their associated definition in this document.
All of these terms may still be subject to further review as may be indicated by additional
Possible Problems or Language Opportunities.
</para>

<para>BER-019 agreed on the terms:
</para>

<olist>

<item>Variable
</item>

<item> Binding variable
</item>

<item> Fixed variable
</item>

<item> Iterated variable
</item>

<item> Value variable
</item>

<item> graph variable
</item>

<item> Binding table variable
</item>

<item> Binding table type
</item>

<item> Declared type
</item>

</olist>

<para>W19-017R2 agreed on the terms:
</para>

<olist>

<item>scope (of a working object)
</item>

<item>scope clause
</item>

<item>declaration &lt;<quote>x declaration</quote>
</item>

<item>definition &lt;<quote>x definition</quote>
</item>

</olist>

<para>W13-010R1 agreed on the terms:
</para>

<olist>

<item>descriptor
</item>

<item>persistent
</item>

<item>dictionary
</item>

<item>temporary
</item>

<item>GQL-catalog
</item>

<item>GQL-catalog-root
</item>

<item>GQL-directory
</item>

<item>GQL-schema
</item>

<item>catalog object
</item>

<item>GQL-data
</item>

<item>GQL-object
</item>

<item>data object
</item>

<item>primary object
</item>

<item>secondary object
</item>

</olist>

<para>W12-029 agreed on the terms:
</para>

<olist>

<item>atomic
</item>

<item>composite
</item>

<item>identify
</item>

<item>identifier
</item>

<item>object &lt;<quote>X</quote> object&gt;
</item>

<item>multiset
</item>

<item>set
</item>

<item>sequence
</item>

<item>ordered set
</item>

<item>instance &lt;<quote>X</quote> instance&gt;
</item>

<item>site
</item>

<item>reference &lt;<quote>X</quote> reference&gt;
</item>

<item>literal
</item>

<item>referent &lt;<quote>X</quote> referent&gt;
</item>

<item>data type
</item>

<item>supertype &lt;<quote>X</quote> supertype&gt;
</item>

<item>subtype &lt;<quote>X</quote> subtype&gt;
</item>

<item>meta type
</item>

<item>base type
</item>

<item>most specific type &lt;of <quote>X</quote>&gt;
</item>

<item>constructed &lt;data type&gt;
</item>

<item>user-defined &lt;data type&gt;
</item>

<item>predefined &lt;data type&gt;
</item>

<item>atomic &lt;data type&gt;
</item>

<item>nullable &lt;data type&gt;
</item>

<item>object type
</item>

<item>value type
</item>

<item>reference value type
</item>

<item>property value type
</item>

<item>value &lt;<quote>X</quote> value&gt;
</item>

<item>direct &lt;value&gt;
</item>

<item>indirect &lt;value&gt;
</item>

<item>reference value
</item>

<item>material &lt;value&gt;
</item>

<item>null value
</item>

</olist>

<para>W12-019 agreed on the terms:
</para>

<olist>

<item>dictionary
</item>

<item>session context
</item>

<item>current session context
</item>

<item>session parameter
</item>

<item>session parameter flag
</item>

<item>GQL-request
</item>

<item>request source
</item>

<item>request parameter
</item>

<item>GQL-request context
</item>

<item>current request context
</item>

<item>execution stack
</item>

<item>context parameter
</item>

<item>side effect
</item>

<item>execution
</item>

<item>operation
</item>

<item>execution context
</item>

<item>current execution context
</item>

<item>execution outcome
</item>

<item>current execution outcome
</item>

<item>successful outcome
</item>

<item>failed outcome
</item>

<item>regular result
</item>

<item>omitted result
</item>

<item>current execution result
</item>

<item>evaluation
</item>

<item>working schema
</item>

<item>working graph
</item>

<item>working table
</item>

<item>working record
</item>

<item>material
</item>

<item>null value
</item>

</olist>

<para>W14-014 deleted the term:
</para>

<olist>

<item>current
</item>

</olist>

<para>W10-019R1 agreed on the terms:
</para>

<olist>

<item>edge variable
</item>

<item>element (graph element)
</item>

<item>endpoint
</item>

<item>graph pattern
</item>

<item>label
</item>

<item>path
</item>

<item>path pattern
</item>

<item>property
</item>

<item>graph (property graph)
</item>

<item>subpath
</item>

<item>undirected edge
</item>

<item>node (vertex)
</item>

<item>node variable
</item>

</olist>

<para>W09-036 agreed on the terms:
</para>

<olist>

<item>multigraph
</item>

<item>mixed graph
</item>

<item>directed graph
</item>

<item>undirected graph
</item>

<item>directionality &lt;edge>
</item>

<item>undirected edge
</item>

<item>any-directed edge
</item>

<item>endpoint &lt;edge>
</item>

<item>endpoint &lt;path>
</item>

<item>source node (start node)
</item>

<item>destination node (end node)
</item>

</olist>

<para>W09-021R1 agreed on the terms:
</para>

<olist>

<item>binding table
</item>

<item>record
</item>

<item>field
</item>

<item>column name
</item>

<item>column type
</item>

<item>column
</item>

<item>record type
</item>

<item>field type
</item>

</olist>

<para>W09-016 agreed on the terms:
</para>

<olist>

<item>node variable
</item>

<item>node pattern
</item>

<item>edge pattern
</item>

</olist>

<para>SXM-052 agreed on the terms:
</para>

<olist>

<item>graph pattern variable
</item>

<item>element variable
</item>

<item>node (vertex) variable
</item>

<item>edge (relationship) variable
</item>

<item>path variable
</item>

<item>subpath variable
</item>

</olist>

<para>BER-040R3 agreed on the terms:
</para>

<olist>

<item>GQL-session
</item>

<item>static object type
</item>

<item>static object
</item>

<item>static site
</item>

<item>static
</item>

<item>dynamic object type
</item>

<item>dynamic object
</item>

<item>dynamic site
</item>

<item>dynamic
</item>

<item>boxed value
</item>

<item>constant object
</item>

<item>property value
</item>

<item>property type &lt;node type or edge type definition>
</item>

</olist>

<para>BER-060 agreed on the terms:
</para>

<olist>

<item>supported result
</item>

</olist>

<comment>WG3:BER-081</comment>
<para>BER-081 agreed on the terms:
</para>

<olist>

<item>adjacent
</item>

<item>result object
</item>

<item>result object type
</item>

<item>locally-defined &lt;object>
</item>

<item>successful result statement
</item>

<item>successful statement
</item>

<item>failed statement
</item>

</olist>

<comment>WG3:BER-082R1</comment>
<para>BER-082R1 agreed on the terms:
</para>

<olist>

<item>alias
</item>

</olist>

</solution>

</PP>


<PP id="PPgql135" number="GQL-135" severity="minor" realm="editorial">

<reference><specref ref="gql_scope_clause"/>.
</reference>

<noteAt><specref ref="w05020-75"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this clause should be reviewed for adherence to the
NWIP scope, adherence to current ISO directives, completeness, and readability.
</para>

</problem>

</PP>


<comment>Resolved by W08-015</comment>
<PP id="PPgql137" number="GQL-137" severity="minor" realm="editorial">

<reference><specref ref="gql_conc_env_gendescr"/>.
</reference>

<noteAt><specref ref="w05020-77"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this subclause, which is based on
SQL/Framework and has been discussed in [ARK-028] and [ARK-032], should be reviewed.
</para>

</problem>

</PP>


<comment>Resolved by W08-016</comment>
<PP id="PPgql138" number="GQL-138" severity="minor" realm="editorial">

<reference><specref ref="gql_conc_env_impl"/>.
</reference>

<noteAt><specref ref="w05020-78"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this subclause, which is based on [SQL-Framework-2016] and touched on
in [W08-017], should be reviewed.
</para>

</problem>

</PP>


<comment>Resolved by W13-010R1</comment>
<PP id="PPgql139" number="GQL-139" severity="minor" realm="editorial">

<reference><specref ref="gql_conc_obj_gendescr"/>.
</reference>

<noteAt><specref ref="w05020-79"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this, probably uncontroversial, Subclause, which is adapted from
[MMX-028r2], [MMX-055], and [SQL-Foundation-2016], should be reviewed.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W20 P00-USA-041, P00-DEU-004</comment>
<PP id="PPgql140" number="GQL-140" severity="minor" realm="editorial">

<reference><specref ref="gql_conc_procdef"/>.
</reference>

<noteAt><specref ref="w05020-80"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause was accepted and adapted from [MMX-055] and
should be reviewed.
However, this Subclause is merely comprised of an editor<apos/>s note!
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-040R3</comment>
<PP id="PPgql141" number="GQL-141" severity="minor" realm="editorial">

<reference><specref ref="gql_conc_bt"/>.
</reference>

<noteAt><specref ref="w05020-81"/>.
</noteAt>

<source>W05-020, W09-021R1.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was accepted and adapted from [MMX-055],
should be reviewed.
</para>

<para>W09-021R1 agreed on <specref ref="gql_conc_bt"/>, except for:
</para>

<ulist>

<item>The paragraph starting
<quote>The collection value for a binding table is defined <ellipsis/></quote>
and item list following it.
</item>

</ulist>

</problem>

</PP>


<comment>Resolved by WG3:W22-033</comment>
<PP id="PPgql142" number="GQL-142" severity="minor" realm="editorial">

<reference><specref ref="gql_conc_lib"/>.
</reference>

<noteAt><specref ref="w05020-82"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was accepted and adapted from [MMX-055],
should be reviewed.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-082R1</comment>
<PP id="PPgql143" number="GQL-143" severity="minor" realm="editorial">

<reference><specref ref="gql_conc_als"/>.
</reference>

<noteAt><specref ref="w05020-83"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was accepted and adapted from [MMX-055],
should be reviewed.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-040R3</comment>
<PP id="PPgql144" number="GQL-144" severity="minor" realm="editorial">

<reference><specref ref="gql_conc_consts"/>.
</reference>

<noteAt><specref ref="w05020-84"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was accepted and adapted from [MMX-055],
should be reviewed.
</para>

</problem>

</PP>


<comment>Resolved by W15-018</comment>
<PP id="PPgql145" number="GQL-145" severity="minor" realm="editorial">

<reference><specref ref="gql_conc_macros"/>.
</reference>

<noteAt><specref ref="w05020-85"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was accepted and adapted from [MMX-055],
should be reviewed.
</para>

</problem>

</PP>


<comment>Editorially resolved in line with CD1/2022 P00-USA-630, P00-NLD-045</comment>
<PP id="PPgql146" number="GQL-146" severity="minor" realm="editorial">

<reference><specref ref="gql_notation"/>.
</reference>

<noteAt><specref ref="w05020-86"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that the term <quote>predicative production rule</quote>
should be reviewed.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W23-013</comment>
<PP id="PPgql147" number="GQL-147" severity="minor" realm="editorial">

<reference><specref ref="gql_ddl"/>.
</reference>

<noteAt><specref ref="w05020-87"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this clause, which was accepted and adapted from
[MMX-055] and [MMX-028r2, should be reviewed.
</para>

</problem>

</PP>


<comment>Resolved by W16-041</comment>
<PP id="PPgql148" number="GQL-148" severity="minor" realm="editorial">

<reference><specref ref="gql_match_graph"/>.
</reference>

<noteAt><specref ref="w05020-88"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was accepted and adapted from [MMX-055],
should be reviewed.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W20-027R1</comment>
<PP id="PPgql149" number="GQL-149" severity="minor" realm="editorial">

<reference><specref ref="gql_from"/>.
</reference>

<noteAt><specref ref="w05020-89"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was accepted and adapted from [MMX-055]
and also discussed in [BNE-023], should be reviewed.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W20-027R1</comment>
<PP id="PPgql150" number="GQL-150" severity="minor" realm="editorial">

<reference><specref ref="gql_use"/>.
</reference>

<noteAt><specref ref="w05020-90"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was accepted and adapted from
[MMX-055] and also discussed in [BNE-023], should be reviewed.
</para>

</problem>

</PP>


<comment>Resolved by W16-041</comment>
<PP id="PPgql151" number="GQL-151" severity="minor" realm="editorial">

<reference><specref ref="gql_graph_object_pattern"/>.
</reference>

<noteAt><specref ref="w05020-91"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was accepted and adapted from [MMX-055],
should be reviewed.
</para>

</problem>

</PP>


<comment>Resolved by W14-013</comment>
<PP id="PPgql152" number="GQL-152" severity="minor" realm="editorial">

<reference><specref ref="gql_where"/>.
</reference>

<noteAt><specref ref="w05020-92"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was adapted from
[SQL-PGQ-8iwd12] and [SQL-Foundation-2016], should be reviewed.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W21-058</comment>
<PP id="PPgql153" number="GQL-153" severity="minor" realm="editorial">

<reference><specref ref="gql_comp"/>.
</reference>

<noteAt><specref ref="w05020-93"/>.
</noteAt>

<source>W05-020.
</source>

<problem>

<para>W05-020 suggests that this Subclause, which was adapted from SQL, should be reviewed.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-050</comment>
<PP id="PPgql154" number="GQL-154" severity="major" realm="technical">

<reference><specref ref="gql_merge"/>.
</reference>

<noteAt><specref ref="w06013-1"/>.
</noteAt>

<source>W06-013.
</source>

<problem>

<para><BNF name="merge statement"/> does not handle <BNF name="element property specification"/>.
</para>

</problem>

<solution>

<para>It is expected that <BNF name="merge statement"/> will be redefined via syntactic
transformation involving <BNF name="match statement"/> and <BNF name="insert statement"/>.
Once this is done the treatment of <BNF name="element property specification"/> specified in the
rules for those BNF productions will take care of this problem.
</para>

</solution>

</PP>


<comment>Resolved by WG3:BER-084R1</comment>
<PP id="PPgql155" number="GQL-155" severity="minor" realm="technical">

<reference><specref ref="gql_path_pattern_prefix"/>.
</reference>

<noteAt><specref ref="w07009-1"/>.
</noteAt>

<source>W07-009.
</source>

<problem>

<para>No solutions will be returned if the same edge variable appears more than once in
a restrictive <BNF name="parenthesized path pattern expression"/> that contains
a <BNF name="path pattern prefix"/> specifying a <BNF name="path mode"/> of <kw>TRAIL</kw>,
<kw>SIMPLE</kw>, or <kw>ACYCLIC</kw>.
</para>

</problem>

<solution>

<para>Perhaps a Syntax Rule could be added to prohibit the repetition of edge variables
under <kw>TRAIL</kw>, <kw>SIMPLE</kw>, and <kw>ACYCLIC</kw>.
</para>

</solution>

</PP>

<comment>Resolved by WG3:084R1</comment>
<PP id="PPgql156" number="GQL-156" severity="minor" realm="technical">

<reference><specref ref="gql_path_pattern_prefix"/>.
</reference>

<noteAt><specref ref="w07009-2"/>.
</noteAt>

<source>W07-009.
</source>

<problem>

<para>No solutions will be returned if the same node variable appears in any position
other than in the first and last <BNF name="node pattern"/> in
a <BNF name="parenthesized path pattern expression"/> that contains
a <BNF name="path pattern prefix"/> specifying a <BNF name="path mode"/> of <kw>SIMPLE</kw>.
</para>

</problem>

<solution>

<para>Perhaps a Syntax Rule could be added to prohibit the repetition of node variables in
any position save for the first and last <BNF name="node pattern"/> in
a <BNF name="parenthesized path pattern expression"/> under <kw>SIMPLE</kw>.
</para>

</solution>

</PP>


<comment>Resolved by WG3:084R1</comment>
<PP id="PPgql157" number="GQL-157" severity="minor" realm="technical">

<reference><specref ref="gql_path_pattern_prefix"/>.
</reference>

<noteAt><specref ref="w07009-3"/>.
</noteAt>

<source>W07-009.
</source>

<problem>

<para>No solutions will be returned if the same node variable appears more than once in
a <BNF name="parenthesized path pattern expression"/> that contains
a <BNF name="path pattern prefix"/> specifying a <BNF name="path mode"/> of <kw>ACYCLIC</kw>.
</para>

</problem>

<solution>

<para>Perhaps a Syntax Rule could be added to prohibit the repetition of node variables
under <kw>ACYCLIC</kw>.
</para>

</solution>

</PP>


<comment>Resolved by WG3:OHD-035</comment>
<PP id="PPgql158" number="GQL-158" severity="major" realm="technical">

<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference>Numerous Syntax Rules and General Rules.
</reference>

<noteAt><specref ref="gql158_1"/>, <specref ref="gql158_23"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Exception conditions to be raised by Syntax Rules, General Rules, and during processing in
general need to be determined for each exceptional situation that may occur.
</para>

</problem>

<solution>

<para>Consistently raise exception conditions.
</para>

</solution>

</PP>


<comment>Resolved editorially</comment>
<PP id="PPgql159" number="GQL-159" severity="major" realm="editorial">

<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference>Numerous Syntax Rules and General Rules.
</reference>

<noteAt>Numerous places.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The applySC mechanism should be used consistently to call other subclauses.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-094R1</comment>
<PP id="PPgql160" number="GQL-160" severity="minor" realm="technical">

<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference><specref ref="gql_multisetvalexp"/>.
</reference>

<noteAt><specref ref="gql_PP160_1"/>, <specref ref="gql_PP160_2"/>, <specref ref="gql_PP160_3"/>,
<specref ref="gql_PP160_4"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>All SQL queries included in examples from SQL/Foundation need to be converted to GQL.
</para>

</problem>

</PP>


<comment>Editorially resolved by WG3:W24-009</comment>
<PP id="PPgql164" number="GQL-164" severity="major" realm="technical">

<reference><specref ref="gql_graph_pattern"/>, <specref ref="gql_path_pattern_expr"/>,
<specref ref="gql_label_expr"/>.
</reference>

<noteAt><specref ref="gql_PP164_1"/>, <specref ref="gql_PP164_2"/>, <specref ref="gql_PP164_6"/>,
<specref ref="gql_PP164_13"/>, <specref ref="gql_PP164_14"/>, <specref ref="gql_PP164_18"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Differences between Syntax Rules and General Rules shared between SQL/PGQ and GQL should
be minimized.
</para>

<para>See the different applications of W13-018 in SQL/PGQ and GQL for more places that should
be considered.
</para>

</problem>

</PP>


<comment>Resolved by WG3:OHD-012</comment>
<PP id="PPgql165" number="GQL-165" severity="major" realm="technical">

<reference><specref ref="gql_insert"/>.
</reference>

<noteAt><specref ref="gql_PP165_insert"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>All omitted or incomplete General Rules regarding the modification of GQL-objects by
data-modifying statements need to be fully specified.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-037</comment>
<PP id="PPgql166" number="GQL-166" severity="major" realm="technical">

<reference><specref ref="gql_drop_graph"/>, <specref ref="gql_drop_graph_type"/>.
</reference>

<noteAt><specref ref="gql_PP166_graph"/>, <specref ref="gql_PP166_graph_type"/>.
</noteAt>

<source>Editors, W13-024, W15-018, W16-038, W20-012, W20-013.
</source>

<problem>

<para>Rules that cause the destruction of descriptors of primary objects need to be fully specified.
</para>

</problem>

</PP>


<comment>Resolved by WG3:BER-019</comment>
<PP id="PPgql167" number="GQL-167" severity="major" realm="technical">

<reference><specref ref="gql_varsparams_val"/>, <specref ref="gql_varsparams_graph"/>,
<specref ref="gql_varsparams_bt"/>.
</reference>


<source>Editors.
</source>

<problem>

<para>Rules concerning the inference of data types need to be specified.
</para>

</problem>

</PP>


<comment>Resolved by WG3:OHD-033</comment>
<PP id="PPgql170" number="GQL-170" realm="technical" severity="major">

<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference><specref ref="gql_graph_format"/>.
</reference>

<noteAt><specref ref="gql_PP170"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>It needs to be decided, if GQL should sketch a simple graph serialization format,
<eg/> by re-using (parts of) the syntax and semantics of <specref ref="gql_insert"/>, and
<specref ref="gql_create_graph"/>.
</para>

</problem>

</PP>


<comment>Resolved by WG3:OHD-033</comment>
<LO id="PPgql171" number="GQL-171">

<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference><specref ref="gql_sql_diffs"/>.
</reference>

<noteAt><specref ref="gql_PP171"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Support for large character string objects needs to be specified.
</para>

</problem>

</LO>


<comment>Resolved by WG3:UTC-056R1 and WG3:UTC-081</comment>
<PP id="PPgql172" number="GQL-172" realm="technical" severity="major">

<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference><specref ref="gql_conc_prcmd_scoping_and_names"/>, <specref ref="gql_aggregate_func"/>,
<specref ref="gql_stm_return"/>.
</reference>

<noteAt><specref ref="gql_PP172_1"/>, <specref ref="gql_PP172_2"/>, <specref ref="gql_PP172_3"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Rules regarding the scope and namespaces in which identifiable constructs (such as variables)
are valid need to be defined.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W24-037</comment>
<PP id="PPgql173" number="GQL-173" realm="technical" severity="major">

<reference><specref ref="gql_conc_dt_genintro"/>, <specref ref="gql_equality_ops"/>.
</reference>

<noteAt><specref ref="gql_PP173"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Equality rules need to be specified.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W24-037</comment>
<PP id="PPgql174" number="GQL-174" realm="technical" severity="major">

<reference><specref ref="gql_conc_dt_genintro"/>, <specref ref="gql_ordering_ops"/>,
<specref ref="gql_conc_record"/>, <specref ref="gql_comp"/>.
</reference>

<noteAt><specref ref="gql_PP174_1"/>, <specref ref="gql_PP174_2"/>, <specref ref="gql_PP174_3"/>,
<specref ref="gql_PP174_5"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Rules regarding the comparison and sorting of values need to be specified.
</para>

</problem>

</PP>

<comment>Resolved by WG3:GYD-031</comment>
<LO id="PPgql175" number="GQL-175" kind="feat_ext" size="M">

<brief area="Data types and expressions">Additional functions on collections and graph elements
</brief>

<reference><specref ref="gql_valexp"/>, <specref ref="gql_listvalfunc"/>.
</reference>

<noteAt>None.
</noteAt>

<source>Editors.
</source>

<problem>

<para>It needs to be decided which additional value functions on collections and graph elements
should be included.
</para>

</problem>

</LO>


<comment>Resolved by WG3:W24-037</comment>
<PP id="PPgql178" number="GQL-178" realm="technical" severity="major">

<reference><specref ref="gql_stm_return"/>.
</reference>

<noteAt><specref ref="gql_PP178"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Equivalence (equality relation that treats nulls as identical, <eg/> when using
<kw>DISTINCT</kw>) to be specified.
</para>

</problem>

</PP>


<comment>Resolved by WG3:UTC-049</comment>
<PP id="PPgql179" number="GQL-179" realm="technical" severity="major">

<reference><specref ref="gql_conc_env_cat"/>.
</reference>

<noteAt><specref ref="gql_PP179"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Descriptors of all objects in the GQL-catalog need to be defined.
</para>

</problem>

<solution>

<para>WG3:BER-061 defined the descriptors for GQL-directory and GQL-schema.
</para>

</solution>

</PP>


<comment>Resolved by WG3:W21-048</comment>
<PP id="PPgql180" number="GQL-180" severity="minor" realm="technical">

<reference><specref ref="gql_eval_path_pattern_expr"/>.
</reference>

<noteAt><specref ref="gql_PP_180"/>.
</noteAt>

<source>W08-018.
</source>

<problem>

<para>W08-018 made the <sym>PARTIAL MATCH</sym> parameter of
<specref ref="gql_eval_path_pattern_expr"/>, and
<specref ref="gql_eval_sel_paren_path_pattern_expr"/>, unnecessary.
It did not delete this parameter in the expectation that it could be part of the solution of
<PPref ref="PPgql059"/> and <PPref ref="PPgql051"/>.
</para>

<para>Linked to <ExtPPref ref="PPpgq059" standard="9075" part="16"/>.
</para>

</problem>

</PP>


<comment>Resolved by WG3:UTC-117</comment>
<PP id="PPgql182" number="GQL-182" severity="minor" realm="technical">

<reference><specref ref="gql_literals"/>.
</reference>

<source>Discussion of W08-014, see W09-001.
</source>

<problem>

<para>During the discussion of W08-014, see W09-001, it was apparent that there was no consensus
on the best way to specify a time zone.
Should the standard allow both an explicit offset and an IANA time zone designator and should the
combination also be allowed.
This topic needs to be revisited to establish consensus.
</para>

</problem>

</PP>


<comment>Resolved by W10-019R1</comment>
<PP id="PPgql183" number="GQL-183" severity="minor" realm="technical">

<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference><specref ref="gql_conc_env_cat_dir"/>, <specref ref="gql_conc_env_schema"/>.
</reference>

<noteAt><specref ref="gql_PP183_1"/>, <specref ref="gql_PP183_2"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Relationship between principals and authorization identifiers needs to be clarified.
</para>

</problem>

</PP>


<comment>Resolved by WG3:RKE-040</comment>
<PP id="PPgql184" number="GQL-184" severity="minor" realm="technical">

<reference><specref ref="gql_subgraph"/>.
</reference>

<noteAt><specref ref="gql_PP184"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Automatic generation of named subgraphs needs to be fully specified.
</para>

</problem>

</PP>


<comment>WG3:W23-028R2</comment>
<PP id="PPgql187" number="GQL-187" realm="technical" severity="major">

<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference><specref ref="gql_select"/>.
</reference>

<noteAt><specref ref="gql_PP187"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The <BNF name="select statement"/> needs to be fully specified.
</para>

</problem>

<solution>

<para>Syntax transformation to a <BNF name="return statement"/>.
</para>

</solution>

</PP>


<comment>Resolved by WG3:W24-037</comment>
<PP id="PPgql188" number="GQL-188" realm="editorial" severity="minor">

<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference><specref ref="gql_ordering_ops"/>.
</reference>

<noteAt><specref ref="gql_PP188"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The list of ordering operations needs to be fully specified.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W24-037</comment>
<PP id="PPgql189" number="GQL-189" realm="technical" severity="minor">

<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference><specref ref="gql_equality_ops"/>.
</reference>

<noteAt><specref ref="gql_PP189"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The prohibitions and restrictions by value type on operations that involve testing
for equality need to be fully specified.
</para>

</problem>

</PP>


<comment>WG3:W23-014</comment>
<PP id="PPgql190" number="GQL-190" realm="technical" severity="major">

<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference><specref ref="gql_token"/>.
</reference>

<noteAt><specref ref="gql_PP190_2"/>.
</noteAt>

<source>Editors, WG3:W17-027.
</source>

<problem>

<para>The escaping syntax used for <BNF name="delimited identifier"/>s needs to be decided.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W20-028</comment>
<LO id="PPgql191" number="GQL-191">

<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference><specref ref="gql_functions"/>.
</reference>

<noteAt><specref ref="gql_PP191_1"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The built-in functions of GQL should be moved to a separate clause.
This likely requires refactoring expressions inherited from SQL.
</para>

</problem>

</LO>


<comment>Resolved by WG3:W23-030</comment>
<PP id="PPgql192" number="GQL-192" realm="technical" severity="major">

<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference><specref ref="gql_conc_env_schema"/>.
</reference>

<noteAt><specref ref="gql_PP192_1"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The mechanisms required for referencing named and unnamed descriptors need to be fully
specified.
</para>

</problem>

</PP>


<comment>Resolved by W17-025R1</comment>
<PP id="PPgql193" number="GQL-193" realm="technical" severity="minor">

<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference><specref ref="gql_token"/>.
</reference>

<noteAt><specref ref="gql_PP193"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>It needs to be decided, if GQL should support bracketed comments.
</para>

</problem>

</PP>


<comment>Resolved by W13-012</comment>
<PP id="PPgql195" number="GQL-195" realm="technical" severity="major">

<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<comment>Editorial: Stefan Plantikow 2021-04-26 One editor's note removed</comment>
<reference><specref ref="gql_cast_spec"/>.
</reference>

<comment>Editorial: Stefan Plantikow 2021-04-26 One reference removed</comment>
<noteAt><specref ref="gql_PP195_2"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Some of the expressions intended for inclusion in GQL have roughly equivalent counterparts
in more than one of the input languages.
It needs to be decided how these differences are to be resolved.
</para>

</problem>

</PP>


<comment>Resolved by WG3:UTC-065</comment>
<PP id="PPgql198" number="GQL-198" realm="technical" severity="major">

<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference><specref ref="gql_conc_numeric_approximate"/>.
</reference>

<noteAt><specref ref="gql_PP198_1"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Conformance features of GQL need to be fully specified.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W24-036R1</comment>
<LO id="PPgql199" number="GQL-199">

<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference><specref ref="gql_aggregate"/>.
</reference>

<noteAt><specref ref="gql_PP199"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Consider extending aggregate with <kw>GROUP</kw> <kw>BY</kw>.
</para>

</problem>

</LO>


<comment>Resolved by WG3:W22-051</comment>
<PP id="PPgql200" number="GQL-200" realm="technical" severity="minor">

<comment>Editorial: Stefan Plantikow 2021-03-02 Created for editors' notes</comment>
<reference><specref ref="gql_cat_obj_refs"/>.
</reference>

<noteAt><specref ref="gql_PP200"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>There are differences between the set of allowed characters in an <BNF name="url segment"/>.
A more detailed analysis is required to better align URL segments and <BNF name="identifier"/>s.
</para>

</problem>

<solution>

<para>A possible option might be to define how <BNF name="identifier"/>s are to be mapped implicitly
to <BNF name="url segment"/>s.
</para>

<para>Alternatively, <BNF name="url segment"/> could be redefined without reference to
<BNF name="identifier"/> in order to align it with URL standards.
</para>


</solution>

</PP>


<comment>Resolved by W12-029</comment>
<PP id="PPgql201" number="GQL-201" realm="technical" severity="minor">

<reference><specref ref="gql_value_type"/>.
</reference>

<noteAt><specref ref="gql_PP201"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>It is not clear if <specref ref="gql_value_type"/> needs General Rules or not.
This need to be reviewed.
SQL uses General Rules in the equivalent Subclause to generate descriptors but it is not clear
if GQL will follow this precedent.
</para>

</problem>

</PP>


<comment>Resolved by WG3:UTC-064</comment>
<PP id="PPgql202" number="GQL-202" realm="technical" severity="major">

<reference><specref ref="gql_valquery"/>.
</reference>

<noteAt><specref ref="gql_PP202"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The semantics <specref ref="gql_valquery"/>, have not been defined.
The appropriate Syntax and General Rules must be defined.
</para>

</problem>

</PP>


<comment>Resolved by W16-037</comment>
<PP id="PPgql203" number="GQL-203" realm="technical" severity="major">

<reference><specref ref="gql_simple_graph_pattern"/>.
</reference>

<noteAt><specref ref="gql_PP203"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The General Rules <specref ref="gql_simple_graph_pattern"/> have not been defined.
The appropriate General Rules, if any, must be defined.
</para>

</problem>

</PP>


<comment>Resolved by W16-040</comment>
<PP id="PPgql204" number="GQL-204" realm="technical" severity="major">

<reference><specref ref="gql_varsparams_graph_ty"/>.
</reference>

<noteAt><specref ref="gql_PP204"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The General Rules <specref ref="gql_varsparams_graph_ty"/> have not been defined.
The appropriate General Rules, if any, must be defined.
</para>

</problem>

</PP>


<comment>Resolved by WG3:UTC-081</comment>
<PP id="PPgql205" number="GQL-205" realm="technical" severity="major">

<reference><specref ref="gql_aggregate_func"/>.
</reference>

<noteAt><specref ref="gql_PP205"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>It is strongly suspected that the Syntax and General Rules of
<specref ref="gql_aggregate_func"/>, are incomplete.
These rules must be reviewed and completed as necessary.
</para>

</problem>

</PP>


<comment>Resolved by W15-018</comment>
<PP id="PPgql206" number="GQL-206" realm="technical" severity="major">

<reference><specref ref="gql_create_pathpat"/>.
</reference>

<noteAt><specref ref="gql_PP206"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The Syntax and General Rules of <specref ref="gql_create_pathpat"/> have not been provided.
These rules must be completed as necessary.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W20-013</comment>
<PP id="PPgql207" number="GQL-207" realm="technical" severity="major">

<reference><specref ref="gql_create_function"/>.
</reference>

<noteAt><specref ref="gql_PP207"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The Syntax and General Rules of <specref ref="gql_create_function"/> have not been provided.
These rules must be completed as necessary.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W20-012</comment>
<PP id="PPgql208" number="GQL-208" realm="technical" severity="major">

<reference><specref ref="gql_create_query"/>.
</reference>

<noteAt><specref ref="gql_PP208"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The Syntax and General Rules of <specref ref="gql_create_query"/> have not been provided.
These rules must be completed as necessary.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W20-012</comment>
<PP id="PPgql209" number="GQL-209" realm="technical" severity="major">

<reference><specref ref="gql_create_procedure"/>.
</reference>

<noteAt><specref ref="gql_PP209"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The Syntax and General Rules of <specref ref="gql_create_procedure"/> have not been provided.
These rules must be completed as necessary.
</para>

</problem>

</PP>


<comment>Resolved by W16-038</comment>
<PP id="PPgql210" number="GQL-210" realm="technical" severity="major">

<reference><specref ref="gql_create_constant"/>.
</reference>

<noteAt><specref ref="gql_PP210"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The Syntax and General Rules of <specref ref="gql_create_constant"/> have not been provided.
These rules must be completed as necessary.
</para>

</problem>

</PP>


<comment>Resolved by W13-024</comment>
<PP id="PPgql211" number="GQL-211" realm="technical" severity="major">

<reference><specref ref="gql_create_schema"/>.
</reference>

<noteAt><specref ref="gql_PP211"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The Syntax and General Rules of <specref ref="gql_create_schema"/> have not been provided.
These rules must be completed as necessary.
</para>

</problem>

</PP>


<comment>Resolved by W12-010</comment>
<PP id="PPgql214" number="GQL-214" realm="technical" severity="minor">

<reference><specref ref="gql_program"/>, <specref ref="gql_conc_tx_demarcation"/>.
</reference>

<noteAt><specref ref="gql_program"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>GQL still specifies auto-commit and auto-rollback behaviour contrary to the discussion in WG3
regarding [ARK-034].
This should be corrected.
</para>

</problem>

<solution>

<para>Remove the implicit transaction flag.
</para>

</solution>

</PP>


<comment>Resolved by WG3:W23-029R1</comment>
<PP id="PPgql215" number="GQL-215" severity="major" realm="technical">

<reference><specref ref="gql_value_type"/>.
</reference>

<noteAt><specref ref="gql_PP215"/>.
</noteAt>

<source>W12-029.
</source>

<problem>

<para>Support for graph types and graph element types with and without attached schema
information needs to be developed further.
</para>

</problem>

</PP>


<comment>Resolved by WG3:UTC-90R1</comment>
<PP id="PPgql216" number="GQL-216" severity="major" realm="technical">

<reference><specref ref="gql_value_type"/>.
</reference>

<noteAt><specref ref="gql_PP216_1"/>, <specref ref="gql_PP216_2"/>.
</noteAt>

<source>W12-029.
</source>

<problem>

<comment>W12-029: Stefan Plantikow 2021-06-24</comment>
<para>Use of 1-based numbering of the characters of character strings and the bytes of byte strings
is in alignment with SQL but deviates from the convention of using 0-based numbering commonly
adopted by virtually any other modern mainstream computer language.
</para>

<para>It needs to be decided if and how this issue is to be addressed.
</para>

</problem>

</PP>


<comment>Resolved by WG3:GYD-031</comment>
<LO id="PPgql219" number="GQL-219" kind="feat_ext" size="M">

<brief area="Data model and catalog">Support for SQL-tables with multiple columns with the same name
</brief>

<reference><specref ref="gql_val_terms_defns"/>.
</reference>

<noteAt><specref ref="gql_PP219_term"/>.
</noteAt>

<source>WG3:W12-019.
</source>

<problem>

<para>In a system implementing both SQL and GQL, how would GQL consume a SQL table?
Besides providing syntax, a solution to this LO has to answer the question how GQL should support
mapping SQL tables with multiple columns with the same name into GQL?
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<comment>Resolved by W14-014 (which gave the wrong PP number!)</comment>
<PP id="PPgql220" number="GQL-220" severity="minor" realm="technical">

<reference><specref ref="gql_conc_byte_string"/> and
<specref ref="gql_value_type"/>.
</reference>

<noteAt><specref ref="gql_PP220_conc"/> and <specref ref="gql_PP220_rules"/>.
</noteAt>

<problem>

<para>Empty byte strings are specified but <BNF name="min length"/> is required to be greater than
0 (zero).
</para>

</problem>

<solution>

<para>Possible solutions:
</para>

<ulist>

<item>Remove support for empty byte strings
</item>

<item>Support byte string types with a minimum length of 0 (zero).
</item>

<item>Make the above subject to implementation-defined provisions.
</item>

</ulist>

</solution>

</PP>


<comment>Resolved by WG3:OHD-028</comment>
<PP id="PPgql228" number="GQL-228" severity="major" realm="editorial">

<reference><specref ref="gql_stm_comp_query_expr"/>.
</reference>

<noteAt><specref ref="gql_PP228_1"/>.
</noteAt>

<source>W15-017.
</source>

<problem>

<para>How the columns of the two tables are related and what the result of data type combinations
is, need to be specified.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:GYD-031</comment>
<LO id="PPgql230" number="GQL-230" kind="new_feat" size="M">

<brief area="Statements and clauses">ORDER BY with support for WITH ORDINALITY, WITH OFFSET,
WITH GROUP ORDINALITY, WITH GROUP OFFSET
</brief>

<reference><specref ref="gql_order_by"/>.
</reference>

<source>WG3:W15-020.
</source>

<problem>

<para>WITH ORDINALITY, WITH OFFSET, WITH GROUP ORDINALITY and WITH GROUP OFFSET to be added.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<comment>Resolved by WG3:W23-029R1</comment>
<PP id="PPgql232" number="GQL-232" severity="minor" realm="technical">

<reference><specref ref="gql_conc_g_intro"/>.
</reference>

<noteAt><specref ref="w13018_1"/>.
</noteAt>

<source>W13-018.
</source>

<problem>

<para>It has been questioned whether the term <quote>label set</quote> might give
the wrong impression, that any set of labels constitutes a label set, whereas it is only those
sets of labels designated in the construction of a graph that qualify as label sets.
Some suggestions for alternative terms are <quote>label combination</quote>,
<quote>label grouping</quote> and <quote>labeling</quote>.
</para>

<para>Was linked to SQL/PGQ PP PQG-068, which was resolved for PGQ only by W19-013.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:RKE-018</comment>
<LO id="PPgql236" number="GQL-236">

<reference>No specific location.
</reference>

<source>W16-040.
</source>

<problem>

<para>When GQL becomes more capable of working with graphs as a whole, <ie/> projecting graphs,
having graphs as procedure parameters, <etc/> it becomes more likely that queries like to locally
define graph types and reuse such a local graph type definition throughout a query without
repeating it.
At that point, adding &lt;BNF name="graph type variable definition"/&gt; as another possible
&lt;BNF name="static variable definition"/&gt; becomes useful.
</para>

</problem>

<solution>

<para>W16-040 removed an early draft of such &lt;BNF name="graph type variable definition"/&gt;
from GQL and provides a starting point for a potential solution.
</para>
</solution>

</LO>


<comment>Resolved by WG3:BER-031</comment>
<LO id="PPgql238" number="GQL-238">

<reference><specref ref="gql_conc_graph_patt_match_path_patt_match"/>.
</reference>

<noteAt><specref ref="gql_w16034_3"/>.
</noteAt>

<source>W16-034R2.
</source>

<problem>

<para>Discussion in the SQL/PGQ expert group on October 12, 2021 indicated that it would
be good to enhance the discussion of <specref ref="gql_conc_graph_patt_match_path_patt_match"/>,
with more details, for example, about the concepts of path binding and multi-path binding.
</para>

<para>Linked to &gt;ExtPPref ref="PPpgq072" standard="9075" part="16"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<comment>Resolved by WG3:W24-013</comment>
<PP id="PPgql239" number="GQL-239" severity="major" realm="editorial">

<reference><specref ref="gql_conc_graph_patt_match"/>.
</reference>

<noteAt><specref ref="gql_w16034_4"/>.
</noteAt>

<source>W16-034R2.
</source>

<problem>

<para>The WG3 W16 Meeting accepted the text of W16-034R2 for application also in GQL.
However, it was recognised that some enhancement would probably be necessary to cope with
the enhanced facilities of GQL.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:RKE-037</comment>
<PP id="PPgql240" number="GQL-240" severity="minor" realm="technical">

<reference><specref ref="gql_let"/>.
</reference>

<noteAt><specref ref="w16040_1"/>.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The <BNF name="binding variable definition block"/> is created from the
components of the <BNF name="compact variable definition list"/> but alternatives of the
<BNF name="compact variable definition list"/> are not all be acceptable components of
a <BNF name="binding variable definition block"/>.
Also, the alternatives of the <BNF name="compact variable definition list"/> are probably not,
or no longer, valid.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:RKE-044R1</comment>
<PP id="PPgql249" number="GQL-249" realm="technical" severity="minor">

<reference><specref ref="gql_conc_env_cat_dir"/>.
</reference>

<source>WG3:W20-010 P00-USA-042.
</source>

<problem>

<para>There does not seem to be a definition for <quote>directly contains</quote> and
<quote>direct containment</quote> when it comes to things outside of syntactic containment.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:W24-038</comment>
<PP id="PPgql251" number="GQL-251" severity="major" realm="technical">

<reference><specref ref="gql_path_pattern_expr"/>.
</reference>

<noteAt><specref ref="gql_PP251"/>.
</noteAt>

<source>Email from Petra Selmer 2022-05-09 17:41.
(See W21-009 Seq#519,P16-USA-293.)
</source>

<problem>

<para>The syntax for <BNF name="abbreviated edge pattern"/> is incompatible with syntax in
the widely used graph query language Cypher.
The following pattern:
</para>
<code>
    (a)&dash;->(b)
</code>
<para>represents a single directed edge pattern from the node a to the node b in Cypher, but
would represent a <BNF name="simple comment introducer"/> and comment text
in SQL.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:BER-032R3</comment>
<LO id="PPgql252" number="GQL-252">

<reference><specref ref="gql_machinery_graph_pattern_matching"/>.
</reference>

<noteAt><specref ref="w21050_1"/>.
</noteAt>

<source>WG3:W21-050.
</source>

<problem>

<para>Existing Graph Pattern Querying solutions, such as the widely used Cypher
language, support different pattern matching modes for graph patterns than homomorphism which is
effectively what is being proposed here.
Support for other such graph matching modes, such as isomorphism (with variants of both edge
isomorphism and node isomorphism), should be included.
For a multi-path binding to be an edge isomorphism, node isomorphism, or full isomorphism could
be defined in <specref ref="gql_machinery_graph_pattern_matching"/>, with appropriate defaults or
syntax specified elsewhere to specify when pattern matching should result in such isomorphic
multi-path bindings.
See also WG3:W01-015 section 1.3 list item 1 and WG3:W16-012.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<comment>Resolved by W22-034R1</comment>
<PP id="PPgql253" number="GQL-253" severity="major" realm="technical">

<reference><specref ref="gql_create_graph"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W21-059.
</source>

<problem>

<para>Ballot comment WG3:W21-010 P00-USA-23 noted the following problems in
<specref ref="gql_create_graph"/>:
</para>

<ulist>

<item>The Format for a graph label set definition is not yet defined.
</item>

<item>The Format for a graph property set definition is not yet defined.
</item>

</ulist>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Editorially resolved as consequence of WG3:W22-051</comment>
<PP id="PPgql254" number="GQL-254" severity="minor" realm="technical">

<reference><specref ref="gql_varsparams_graph"/> and
<specref ref="gql_varsparams_val"/>.
</reference>

<noteAt><specref ref="gql_PP254_1"/> and <specref ref="gql_PP254_2"/>.
</noteAt>

<source>WG3:W21-044.
</source>

<problem>

<para><specref ref="gql_varsparams_graph"/>,
<itemref ref="gql_varsparams_graph_init_rewrite" type="SR"/>
rewrites the <BNF name="graph initializer"/> not containing a <BNF name="graph expression"/>
to the form containing a <BNF name="graph expression"/>.
Although <specref ref="gql_varsparams_val"/> has a similar format with
the <BNF name="value initializer"/>, it does not specify a similar rewrite.
This should be revisited and harmonized.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:W24-037</comment>
<PP id="PPgql255" number="GQL-255" severity="minor" realm="technical">

<reference><specref ref="gql_comp"/>.
</reference>

<noteAt><specref ref="w21058_1"/>.
</noteAt>

<source>W21-058.
</source>

<problem>

<para>Comparison of numeric value types having different base types should be further reviewed.
</para>

</problem>

</PP>


<comment>Resolved by WG3:W23-030</comment>
<PP id="PPgql256" number="GQL-256" severity="minor" realm="editorial">

<reference><specref ref="gql_descriptors"/>.
</reference>

<noteAt><specref ref="gql_ber055_1"/>, <specref ref="gql_ber055_2"/>.
</noteAt>

<source>Email from Jan Michels 2022-06-16.
</source>

<problem>

<para>The definitions of generally include and generally depend are currently
not used in the document.
If they are still not used by the time the document exists the DIS stage, they should be removed.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:OHD-017</comment>
<PP id="PPgql257" number="GQL-257" severity="minor" realm="technical">

<reference><specref ref="gql_stm_proc_call"/>.
</reference>

<noteAt><specref ref="gql_PP257"/>.
</noteAt>

<source>BER-019.
</source>

<problem>

<para>BER-019 has established declared type propagation for working record, working table,
and result.
<specref ref="gql_stm_proc_call"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:BER-049</comment>
<PP id="PPgql258" number="GQL-258" severity="minor" realm="technical">

<reference><specref ref="gql_dml_cond_data_mod_stm"/>.
</reference>

<source>BER-019
</source>

<problem>

<para>BER-019 has established declared type propagation for working record, working table,
and result.
<specref ref="gql_dml_cond_data_mod_stm"/> does not do that yet and
requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:OHD=024</comment>
<PP id="PPgql259" number="GQL-259" severity="minor" realm="technical">

<reference><specref ref="gql_do"/>.
</reference>

<noteAt><specref ref="gql_PP259"/>.
</noteAt>

<source>BER-019.
</source>

<problem>

<para>BER-019 has established declared type propagation for working record,
working table, and result.
<specref ref="gql_do"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:OHD-028</comment>
<PP id="PPgql260" number="GQL-260" severity="minor" realm="technical">

<reference><specref ref="gql_insert"/>.
</reference>

<noteAt><specref ref="gql_PP260"/>.
</noteAt>

<source>BER-019.
</source>

<problem>

<para>BER-019 has established declared type propagation for working record,
working table, and result.
<specref ref="gql_insert"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:BER-050</comment>
<PP id="PPgql261" number="GQL-261" severity="minor" realm="technical">

<reference><specref ref="gql_merge"/>.
</reference>

<source>BER-019
</source>

<problem>

<para>BER-019 has established declared type propagation for
working record, working table, and result.
<specref ref="gql_merge"/>
does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:UTC-094</comment>
<PP id="PPgql262" number="GQL-262" severity="minor" realm="technical">

<reference><specref ref="gql_set_stmt"/>.
</reference>

<noteAt><specref ref="gql_PP262"/>.
</noteAt>

<source>BER-019.
</source>

<problem>

<para>BER-019 has established declared type propagation for working record,
working table, and result.
<specref ref="gql_set_stmt"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:UTC-094</comment>
<PP id="PPgql263" number="GQL-263" severity="minor" realm="technical">

<reference><specref ref="gql_remove"/>.
</reference>

<noteAt><specref ref="gql_PP263"/>.
</noteAt>

<source>BER-019.
</source>

<problem>

<para>BER-019 has established declared type propagation for working record,
working table, and result.
<specref ref="gql_remove"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:UTC-094</comment>
<PP id="PPgql264" number="GQL-264" severity="minor" realm="technical">

<reference><specref ref="gql_delete"/>.
</reference>

<noteAt><specref ref="gql_PP264"/>.
</noteAt>

<source>BER-019.
</source>

<problem>

<para>BER-019 has established declared type propagation for working record,
working table, and result.
<specref ref="gql_delete"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:BER-049</comment>
<PP id="PPgql265" number="GQL-265" severity="minor" realm="technical">

<reference><specref ref="gql_stm_cond_query_stm"/>.
</reference>

<source>BER-019
</source>

<problem>

<para>BER-019 has established declared type propagation for
working record, working table, and result.
<specref ref="gql_stm_cond_query_stm"/> does not do that yet and
requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:OHD-028</comment>
<PP id="PPgql266" number="GQL-266" severity="minor" realm="technical">

<reference><specref ref="gql_stm_comp_query_expr"/>.
</reference>

<noteAt><specref ref="gql_PP266"/>.
</noteAt>

<source>BER-019.
</source>

<problem>

<para>BER-019 has established declared type propagation for working record,
working table, and result.
<specref ref="gql_stm_comp_query_expr"/> does not do that yet and requires corresponding Syntax
Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:UTC-087R2</comment>
<PP id="PPgql267" number="GQL-267" severity="minor" realm="technical">

<reference><specref ref="gql_match"/>.
</reference>

<noteAt><specref ref="gql_PP267"/>.
</noteAt>

<source>BER-019.
</source>

<problem>

<para>BER-019 has established declared type propagation for working record,
working table, and result.
<specref ref="gql_match"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:W24-036R1</comment>
<PP id="PPgql268" number="GQL-268" severity="minor" realm="technical">

<reference><specref ref="gql_aggregate"/>.
</reference>

<noteAt><specref ref="gql_PP268"/>.
</noteAt>

<source>BER-019.
</source>

<problem>

<para>BER-019 has established declared type propagation for working record,
working table, and result.
<specref ref="gql_aggregate"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:UTC-088</comment>
<PP id="PPgql269" number="GQL-269" severity="minor" realm="technical">

<reference><specref ref="gql_for"/>.
</reference>

<noteAt><specref ref="gql_PP269"/>.
</noteAt>

<source>BER-019.
</source>

<problem>

<para>BER-019 has established declared type propagation for working record,
working table, and result.
<specref ref="gql_for"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:UTC-022</comment>
<PP id="PPgql270" number="GQL-270" severity="minor" realm="technical">

<reference><specref ref="gql_stm_return"/>.
</reference>

<noteAt><specref ref="gql_PP270"/>.
</noteAt>

<source>BER-019.
</source>

<problem>

<para>BER-019 has established declared type propagation for working record,
working table, and result.
<specref ref="gql_stm_return"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:OHD-017</comment>
<PP id="PPgql271" number="GQL-271" severity="minor" realm="technical">

<reference><specref ref="gql_inline_procedure_call"/>.
</reference>

<noteAt><specref ref="gql_PP271"/>.
</noteAt>

<source>BER-019.
</source>

<problem>

<para>BER-019 has established declared type propagation for working record,
working table, and result.
<specref ref="gql_inline_procedure_call"/> does not do that yet and requires corresponding
Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:W22-054</comment>
<PP id="PPgql272" number="GQL-272" severity="minor" realm="technical">

<reference><specref ref="gql_named_procedure_call"/>.
</reference>

<noteAt>.
</noteAt>

<source>BER-019.
</source>

<problem>

<para>BER-019 has established declared type propagation for working record,
working table, and result.
<specref ref="gql_named_procedure_call"/> does not do that yet and requires corresponding
Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:GQL-028</comment>
<PP id="PPgql273" number="GQL-273" severity="minor" realm="technical">

<reference><specref ref="gql_group_by"/>.
</reference>

<noteAt><specref ref="gql_PP273"/>.
</noteAt>

<source>BER-019.
</source>

<problem>

<para>BER-019 has established declared type propagation for working record,
working table, and result.
<specref ref="gql_group_by"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:UTC-081</comment>
<PP id="PPgql274" number="GQL-274" severity="minor" realm="technical">

<reference><specref ref="gql_aggregate_func"/>.
</reference>

<noteAt><specref ref="gql_PP274"/>.
</noteAt>

<source>BER-019
</source>

<problem>

<para>BER-019 has established declared type propagation for working record, working table, and
result.
The Subclause does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:GQL-028</comment>
<PP id="PPgql275" number="GQL-275" severity="minor" realm="technical">

<reference><specref ref="gql_sort_spec_list"/>.
</reference>

<noteAt><specref ref="gql_PP275"/>
</noteAt>

<source>BER-019.
</source>

<problem>

<para>BER-019 has established declared type propagation for
working record, working table, and result.
<specref ref="gql_sort_spec_list"/>
does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:OHD-022</comment>
<PP id="PPgql276" number="GQL-276" severity="major" realm="technical">

<reference><specref ref="gql_g_refs"/>.
</reference>

<noteAt><specref ref="gql_PP276"/>.
</noteAt>

<source>BER-019.
</source>

<problem>

<para>BER-019 has established declared type propagation for working record, working table, and
result.
<specref ref="gql_g_refs"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG2:OHD-022</comment>
<PP id="PPgql277" number="GQL-277" severity="minor" realm="technical">

<reference><specref ref="gql_bt_refs"/>.
</reference>

<noteAt><specref ref="gql_PP277"/>.
</noteAt>

<source>BER-019.
</source>

<problem>

<para>BER-019 has established declared type propagation for working record, working table, and
result.
<specref ref="gql_bt_refs"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:UTC-064</comment>
<PP id="PPgql278" number="GQL-278" severity="minor" realm="technical">

<reference><specref ref="gql_valquery"/>.
</reference>

<problem>

<para>BER-019 has established declared type propagation for working record, working table, and
result.
<specref ref="gql_valquery"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:UTC-015</comment>
<PP id="PPgql280" number="GQL-280" severity="minor" realm="technical">

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:BER-100.
</source>

<problem>

<para>The notion of a <quote>most specific type</quote> seems out-of-date by [W12-029] and
[BER-040r3] and needs to be removed consistently from the document.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:W24-034R2</comment>
<PP id="PPgql284" number="GQL-284" severity="minor" realm="technical">

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:BER-040R3.
</source>

<problem>

<para>The rules for store assignment must be defined.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:GYD-030</comment>
<LO id="PPgql286" number="GQL-286" kind="new_feat" size="M">

<brief area="Statements and clauses">Conditional data modifications
</brief>

<reference>No specific location.
</reference>

<source>WG3:BER-049.
</source>

<problem>

<para>The ability to construct a conditional data modification statement with
multiple when-then branches might be useful to GQL users.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<comment>Resolved by WG3:GYD-030</comment>
<LO id="PPgql287" number="GQL-287" kind="new_feat" size="M">

<brief area="Statements and clauses">Conditional queries
</brief>

<reference>No specific location.
</reference>

<source>WG3:BER-049.
</source>

<problem>

<para>The ability to construct a conditional query with multiple when-then branches
might be useful to GQL users.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<comment>Resolved by WG3:UTC-90R1</comment>
<PP id="PPgql289" number="GQL-289" severity="minor" realm="technical">

<reference><specref ref="gql_numexp"/>.
</reference>

<noteAt><specref ref="gql_PP289"/>.
</noteAt>

<source>WG3:BER-094R1.
</source>

<problem>

<para>[BER-019] and [BER-094R1] established declared type propagation for the result.
<specref ref="gql_numexp"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:UTC-90R1</comment>
<PP id="PPgql290" number="GQL-290" severity="minor" realm="technical">

<reference><specref ref="gql_numvalfunc"/>.
</reference>

<noteAt><specref ref="gql_PP290"/>.
</noteAt>

<source>WG3:BER-094R1.
</source>

<problem>

<para>[BER-019] and [BER-094R1] established declared type propagation for the result.
<specref ref="gql_numvalfunc"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:UTC-90R1</comment>
<PP id="PPgql291" number="GQL-291" severity="minor" realm="technical">

<reference><specref ref="gql_stringvalfunc"/>.
</reference>

<noteAt><specref ref="gql_PP291"/>.
</noteAt>

<source>WG3:BER-094R1.
</source>

<problem>

<para>[BER-019] and [BER-094R1] established declared type propagation for the result.
<specref ref="gql_stringvalfunc"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:UTC-117</comment>
<PP id="PPgql292" number="GQL-292" severity="minor" realm="technical">

<reference><specref ref="gql_datevalexp"/>.
</reference>

<source>WG3:BER-094R1.
</source>

<problem>

<para>[BER-019] and [BER-094R1] established declared type propagation for the result.
<specref ref="gql_datevalexp"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:UTC-117</comment>
<PP id="PPgql293" number="GQL-293" severity="minor" realm="technical">

<reference><specref ref="gql_datevalfunc"/>.
</reference>

<source>WG3:BER-094R1.
</source>

<problem>

<para>[BER-019] and [BER-094R1] established declared type propagation for the result.
<specref ref="gql_datevalfunc"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:UTC-117</comment>
<PP id="PPgql294" number="GQL-294" severity="minor" realm="technical">

<reference><specref ref="gql_durvalexp"/>.
</reference>

<source>WG3:BER-094R1.
</source>

<problem>

<para>[BER-019] and [BER-094R1] established declared type propagation for the result.
<specref ref="gql_durvalexp"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:UTC-117</comment>
<PP id="PPgql295" number="GQL-295" severity="minor" realm="technical">

<reference><specref ref="gql_durvalfunc"/>.
</reference>

<noteAt><specref ref="gql_PP295"/>.
</noteAt>

<source>WG3:BER-094R1.
</source>

<problem>

<para>[BER-019] and [BER-094R1] established declared type propagation for the result.
<specref ref="gql_durvalfunc"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:W22-036</comment>
<PP id="PPgql296" number="GQL-296" severity="minor" realm="technical">

<reference><specref ref="gql_maptvalconst"/>.
</reference>

<noteAt><specref ref="gql_PP296"/>.
</noteAt>

<source>WG3:BER-094R1.
</source>

<problem>

<para>[BER-019] and [BER-094R1] established declared type propagation for the result.
<specref ref="gql_maptvalconst"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:UTC-015</comment>
<PP id="PPgql297" number="GQL-297" severity="minor" realm="technical">

<reference><specref ref="gql_prop_ref"/>.
</reference>

<noteAt><specref ref="gql_PP297"/>.
</noteAt>

<source>WG3:BER-094R1.
</source>

<problem>

<para>[BER-019] and [BER-094R1] established declared type propagation for the result.
<specref ref="gql_prop_ref"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:UTC-064</comment>
<PP id="PPgql298" number="GQL-298" severity="minor" realm="technical">

<reference><specref ref="gql_valquery"/>.
</reference>

<noteAt><specref ref="gql_PP298"/>.
</noteAt>

<source>WG3:BER-094R1.
</source>

<problem>

<para>[BER-019] and [BER-094R1] established declared type propagation for the result.
<specref ref="gql_valquery"/> does not do that yet and requires corresponding Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:UTC-015</comment>
<PP id="PPgql299" number="GQL-299" severity="minor" realm="technical">

<reference><specref ref="gql_setop_result"/>.
</reference>

<noteAt><specref ref="gql_PP299"/>.
</noteAt>

<source>WG3:BER-094R1.
</source>

<problem>

<para>[BER-019] and [BER-094R1] established that rules on types should be specified in
Syntax Rules.
<specref ref="gql_setop_result"/> has to be adjusted accordingly, as well as the wording of
every rule that calls the subclause.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:W22-051</comment>
<PP id="PPgql300" number="GQL-300" severity="minor" realm="technical">

<reference><specref ref="gql_drop_graph"/>, <specref ref="gql_drop_graph_type"/>.
</reference>

<noteAt><specref ref="gql_PP300_1"/>, <specref ref="gql_PP300_2"/>.
</noteAt>

<source>Editor.
</source>

<problem>

<para>It is not clear how <BNF name="graph name"/> (<BNF name="graph type name"/>) can be
immediately contained in <BNF name="catalog graph parent and name"/>
(<BNF name="catalog graph type parent and name"/>) immediately contains
<BNF name="url path parameter"/> and not <BNF name="graph parent specification"/>
<BNF name="graph name"/> (<BNF name="graph type name"/>).
It is also not clear if or how it is confirms that that name identifies the correct type of object.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:W24-027 and editorial action</comment>
<PP id="PPgql302" number="GQL-302" severity="minor" realm="editorial">

<reference><specref ref="gql_btt"/>, 
<specref ref="gql_edge_type_defn"/>, <specref ref="gql_lbl_set_defn"/>,
<specref ref="gql_prop_type_set_defn"/>, <specref ref="gql_value_type"/>.
</reference>

<noteAt><specref ref="gql_ber040r3_1"/>, <specref ref="gql_ber040r3_2"/>, 
<specref ref="gql_ber040r3_3"/>, <specref ref="gql_ber040r3_4"/>,
<specref ref="gql_ber040r3_5"/>, <specref ref="gql_ber040r3_6"/>,
<specref ref="gql_ber040r3_7"/>.
</noteAt>

<source>Editor as consequence of WG3:BER-040R3.
</source>

<problem>

<para>It is necessary to ensure that normal forms preserve all required information.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:GYD-031</comment>
<LO id="PPgql303" number="GQL-303" kind="port_feat" size="M">

<brief area="Pattern matching">within-MATCH aggregate
</brief>

<reference><specref ref="gql_aggregate_func"/>.
</reference>

<source>Email from Keith Hare, 2022-07-14 1359.
</source>

<problem>

<para>The within-match aggregate specified in SQL/PGQ is potentially useful and should be 
considered for GQL.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<comment>Resolved editorially during editing for UTC</comment>
<PP id="PPgql305" number="GQL-305" severity="minor" realm="editorial">

<reference><specref ref="gql_conc_wo"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W22-035.
</source>

<problem>

<para>The terms <quote>current working schema</quote> and <quote>current working graph</quote>
should be used in SRs only. 
For use in GRs, an SR can bind the current working x to a specification variable 
(<eg/> <quote>SR x) Let <symdef>CWS</symdef> be the current working schema</quote>) and 
GRs can use that specification variable.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:CMN-028</comment>
<LO id="PPgql307" number="GQL-307">

<reference><specref ref="gql_delete"/>.
</reference>

<noteAt><specref ref="gql_w22042"/>.
</noteAt>

<source>WG3:W22-042.
</source>

<problem>

<para>More accurate keywords than <kw>DETACH</kw> and <kw>NODETACH</kw> should be specified, 
as they do not adequately capture the intent of deleting a node and all its attached edges 
(or not, in the case of <kw>NODETACH</kw>).
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<comment>Resolved by WG3:UTC-062</comment>
<PP id="PPgql311" number="GQL-311" severity="major" realm="technical">

<reference><specref ref="gql_insert"/>, 
<specref ref="gql_set_stmt"/>, <specref ref="gql_remove"/>, <specref ref="gql_delete"/>.
</reference>

<noteAt><specref ref="gql_pp311_1"/>, <specref ref="gql_pp311_2"/>, <specref ref="gql_pp311_3"/>, 
<specref ref="gql_pp311_4"/>. 
</noteAt>

<source>Email from Tobias Lindaaker, 2022-08-16 1857
</source>

<problem>

<para>GQL does not contain any standardized means of expressing constraints on graph types. 
It is however expected that implementations will be extended with such functionality. 
In order to allow such implementations to conform to the specification, data-modifying statements 
need to have rules specifying that the statement may fail if the state resulting from accepting 
the statement would violate an implementation defined constraint.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:UTC-039R1</comment>
<PP id="PPgql312" number="GQL-312" severity="major" realm="technical">

<reference><specref ref="gql_use"/>.
</reference>

<noteAt><specref ref="gql_w22051_1"/>.
</noteAt>

<problem>

<para>SR2) states <quote>Let <symdef>G</symdef> be the graph identified by
the <BNF name="graph expression"/> immediately contained in <sym>UGC</sym>.</quote>.
</para>

<para>By the changes of WG3:W22-051, only a <BNF name="graph reference"/> identifies a graph at
SR time.
A <BNF name="graph expression"/> sets the declared type of a graph at SR time but identifies
the graph as its result at GR time.
The specification is incomplete in this respect.
</para>

</problem>

<solution>

<para>There are two solutions in sight:
</para>

<olist>

<item>Simple: Limit the <BNF name="use graph clause"/> to a <BNF name="graph reference"/>. 
The downside to this solution is that a graph produced by, <eg/> a named procedure cannot be used
as the working graph. 
This limits the compositionality of GQL over graphs.
</item>

<item>Involved: Change the definition of working objects to be sites and propagate the information
if a site is static or dynamic with the declared type of a site.
</item>

</olist>

</solution>

</PP>


<comment>Resolved by WG3:W23-029R1</comment>
<PP id="PPgql313" number="GQL-313" severity="minor" realm="technical">

<reference><specref ref="gql_graph_type"/>.
</reference>

<noteAt><specref ref="gql_w22051_2"/>.
</noteAt>

<problem>

<para>Double check if a type normal form for graph type needs to be specified.
</para>

</problem>

</PP>


<comment>WG3:W23-014</comment>
<PP id="PPgql314" number="GQL-314" severity="minor" realm="editorial">

<reference><specref ref="gql_schema_refs"/>.
</reference>

<noteAt><specref ref="gql_w22051_3"/>.
</noteAt>

<problem>

<para>Consider using a callable subclause for specifying the evaluation of
a <BNF name="simple directory path"/> from start directory.
</para>

</problem>

</PP>


<comment>Resolved by WG3:UTC-039R1</comment>
<PP id="PPgql315" number="GQL-315" severity="minor" realm="technical">

<reference><specref ref="gql_gexpr"/>, <specref ref="gql_bte"/>.
</reference>

<noteAt>None.
</noteAt>

<problem>

<para>Consider moving the use of <kw>VARIABLE</kw> to <BNF name="binding variable reference"/>
instead.
</para>

<para>It may be beneficial for this, to exclude a plain <BNF name="graph name"/> from the
set of supported <BNF name="graph reference"/>s here.
</para>

</problem>

</PP>


<comment>Resolved by WG3:UTC-126</comment>
<PP id="PPgql316" number="GQL-316" severity="major" realm="editorial">

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>Editor.
</source>

<problem>

<para>Consistently use active or passive voice in Rules.
This is particularly relevant to actions taken as part of catalog-modifying and/or data-modifying
operations and when creating and destroying descriptors.
</para>

</problem>

<solution>

<para>Prefer passive voice; this may be overridden locally to use the active voice when
specifying a sequence of steps to be performed by prefixing such a list with fitting
introductory text in passive voice, such as <quote>The following steps are performed:</quote>.
</para>

</solution>

</PP>


<comment>Resolved by WG3:W23-030</comment>
<PP id="PPgql317" number="GQL-317" severity="minor" realm="editorial">

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>Editor.
</source>

<problem>

<para>Make sure to correctly distinguish between named and unnamed descriptors.
</para>

<para>Currently, named (as opposed to "plain") descriptors should be created (and eventually
destroyed) for primary objects.
This isn't fully the case and requires review.
</para>

</problem>

<solution>

<para>Either consistently use named descriptors or remove the notion of named descriptors.
</para>

</solution>

</PP>


<comment>Resolved by WG3:W23-014</comment>
<PP id="PPgql318" number="GQL-318" severity="minor" realm="editorial">

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>Editor.
</source>

<problem>

<para>The syntax for <BNF name="delimited identifier"/>s should support repeating the contained
<BNF name="unbroken accent quoted character sequence"/> just as it supports
<BNF name="double quoted character sequence"/> and thereby provide support for quoting
<BNF name="grave accent"/> using this syntax.
</para>

</problem>

</PP>


<comment>Resolved by WG3:UTC-042</comment>
<PP id="PPgql320" number="GQL-320" severity="minor" realm="editorial">

<reference><specref ref="gql_objects"/>.
</reference>

<noteAt><specref ref="gql_w22051_6"/>.
</noteAt>

<source>Editor.
</source>

<problem>

<para>WG3:W22-051 suggested renaming <specref ref="gql_objects"/> to 
<quote>Object expressions</quote> without moving <BNF name="binding table type"/>.
Further work is needed before this change can be made.
</para>

</problem>

<solution>

<para>As an alternative, moving <BNF name="graph type specification"/> and related
material here (possibly renaming it to <quote>graph type</quote>) may allow to
keep the current name of <specref ref="gql_objects"/>.
</para>

</solution>
</PP>


<comment>Resolved  by WG3:W23-030</comment>
<PP id="PPgql321" number="GQL-321" severity="major" realm="editorial">

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>Editor.
</source>

<problem>

<para>It needs to be clarified if (when) the construction or the destruction of objects implies
the construction or destruction, respectively, of their corresponding descriptors.
</para>

<para>Editorial language implementing the chosen model needs to be implemented consistently.
</para>

</problem>

<solution>

<para>It is proposed to always explicitly both create and destroy objects and their associated
descriptors using language such as <quote>A foo is created together with its associated foo
descriptor that comprises:</quote> and <quote>foo and its foo descriptor are destroyed</quote>.
</para>

<para>Alternatively, the destruction of associated descriptors could be defined to be implied.
</para>

</solution>

</PP>


<comment>Resolved by WG3:W23-023</comment>
<PP id="PPgql322" number="GQL-322" severity="minor" realm="technical">

<reference><specref ref="gql_match"/>.
</reference>

<noteAt><specref ref="ohd017_1"/>.
</noteAt>

<source>WG3:OHD-017.
</source>

<problem>

<para><itemref ref="gql_match_opt_SR" type="SR"/> and <itemref ref="gql_match_mand_SR" type="SR"/>
of <BNF name="match statement"/> states a syntax transformation with a <quote>Return *</quote> 
contained in a <BNF name="nested procedure specification"/> of 
an <BNF name="inline procedure call"/>.
WG3:OHD-017 suggested that syntax transformation should transform to explicit syntax.
</para>

</problem>

<solution>

<para>Rewrite <quote>Return *</quote> to explicitly state the list of variables.
</para>

</solution>

</PP>


<comment>Resolved by WG3:W23-023</comment>
<PP id="PPgql323" number="GQL-323" severity="minor" realm="technical">

<reference><specref ref="gql_for"/>.
</reference>

<noteAt><specref ref="ohd017_2"/>.
</noteAt>

<source>WG3:OHD-017.
</source>

<problem>

<para><itemref ref="gql_for_opt_SR" type="SR"/> and <itemref ref="gql_for_mand_SR" type="SR"/> 
of <BNF name="for statement"/> states a syntax transformation with a <quote>Return *</quote> 
contained in a <BNF name="nested procedure specification"/> of 
an <BNF name="inline procedure call"/>.
WG3:OHD-017 suggested that syntax transformation should transform to explicit syntax.
</para>

</problem>

<solution>

<para>Rewrite <quote>Return *</quote> to explicitly state the list of variables.
</para>

</solution>

</PP>


<comment>Resoved by WG3:W24:012</comment>
<PP id="PPgql324" number="GQL-324" severity="minor" realm="technical">

<reference><specref ref="gql_exists"/>.
</reference>

<noteAt><specref ref="ohd017_3"/>.
</noteAt>

<source>WG3:OHD-017.
</source>

<problem>

<para><itemref ref="gql_exists_gp_SR" type="SR"/> of <BNF name="exists predicate"/> states 
a syntax transformation with a <quote>Return *</quote> contained in 
a <BNF name="nested procedure specification"/> of an <BNF name="inline procedure call"/>.
WG3:OHD-017 suggested that syntax transformation should transform to explicit syntax.
</para>

</problem>

<solution>

<para>Rewrite <quote>Return *</quote> to explicitly state the list of variables.
</para>

</solution>

</PP>


<comment>Resolved as consequence of WG3:W23-037</comment> 
<PP id="PPgql326" number="GQL-326" severity="minor" realm="technical">

<reference><specref ref="gql_conc_dt_terminology"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:OHD-023.
</source>

<problem>

<para>It should be clarified if the notion of two data types being compatible requires
taking into account the <quote>indication of whether the type contains the null value</quote>
that each type descriptor includes.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:W23-029R1</comment>
<PP id="PPgql327" number="GQL-327" severity="minor" realm="technical">

<reference><specref ref="gql_conc_gt_intro"/>, <specref ref="gql_graph_type_desc"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:OHD-023.
</source>

<problem>

<para>The node type name dictionary and the edge type name dictionary are specified twice  
in the graph type and the graph type descriptor. 
There is no obvious reason for such duplication.
</para>

</problem>

<solution>

<para>Remove the node type name dictionary and the edge type name dictionary from
the definition of a graph type.
</para>

</solution>

</PP>


<comment>Resolved by WG3:GYD-031</comment>
<LO id="PPgql331" number="GQL-331" kind="new_feat" size="XL">

<brief area="Java language bindings">System and execution model
</brief>

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:OHD-042
</source>

<problem>

<para>It is a language opportunity to provide an annex, probably informative, that specifies
a language binding, probably Java, to the abstract API defined in this document.
</para>

<para>Doing so will validate that the specification of the abstract API is complete and 
sufficiently well-defined to enable other language bindings to be defined.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<comment>Resolved by WG3:GYD-031</comment>
<LO id="PPgql332" number="GQL-332" kind="new_feat" size="M">

<brief area="Procedures">Call external procedures
</brief>

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:OHD-042
</source>

<problem>

<para>It is a language opportunity to provide the ability for GQL to call functions and 
procedure written in languages other than GQL.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<comment>Resolved by WG3:W23-029R1</comment>
<PP id="PPgql333" number="GQL-333" severity="major" realm="editorial">

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W23-001 Agenda Item 12.15.
</source>

<problem>

<para>A fuller explanation of what it means to be <quote>of a graph type</quote> is needed to 
support the checking of this.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:W24-027</comment>
<PP id="PPgql334" number="GQL-334" severity="minor" realm="technical">

<reference><specref ref="gql_node_type_defn"/>, 
<specref ref="gql_edge_type_defn"/>.
</reference>

<noteAt>None.
</noteAt>

<source>Editors.
</source>

<problem>

<para>The General Rules introduced by WG3:OHD-015 and WG3:OHD-047 should be Syntax Rules.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:W23-014</comment>
<PP id="PPgql" number="GQL-335" severity="major" realm="editorial">

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>Editors.
</source>

<problem>

<para>Terminology involving identifiers, names, and their referents is not used consistently.
</para>

</problem>

<solution>

<para>An identifier is a BNF non-terminal, <ie/> either a <BNF name="delimited identifier"/> or
a <BNF name="non-delimited identifier"/>.
Every identifier has a representative form that is a character string.
Two identifiers are considered equivalent if their representative forms are equal.
</para>

<para>Names are the representative forms of the identifiers specified by certain BNF non-terminals
(<eg/> <BNF name="parameter name"/>).
</para>

<para>Given this description, the following statements outline acceptable
specification language:
</para>

<olist>

<item>Two identifiers are equivalent because they have equal representative forms. 
</item>

<item>A <BNF name="parameter name"/> identifies a parameter by specifying its (parameter) name.
</item>

<item>Two <BNF name="parameter name"/>s are equivalent because the parameter names they
specify are equal.
</item>

<item>Two columns from different binding tables may have equal names (the same name).
</item>

</olist>

<para>Consider adopting consistent use of the outlined or alternative specification language
regarding this topic.
</para>

</solution>

</PP>


<comment>Resolved by WG3:UTC-065</comment>
<PP id="PPgql337" number="GQL-337" severity="major" realm="technical">

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W23-037.
</source>

<problem>

<para>Conformance features for optionally supporting the various defined data types need
to be added.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:UTC-086R1</comment>
<PP id="PPgql338" number="GQL-338" severity="minor" realm="technical">

<reference><specref ref="gql_stm_proc_call"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W23-015.
</source>

<problem>

<para>Consider defining field name-disjoint for record types, so that if a record type A and 
record type B are field name-disjoint, then they shall not have any field name in common. 
Currently, this is only defined for a set of fields or column names of a record or, respectively, 
a binding table. 
Wording of Syntax Rules such as <itemref ref="gql_stm_proc_call_SR_disjoint" type="SR"/> of 
<specref ref="gql_stm_proc_call"/>, would use it.
</para>

</problem>

<solution>

<para>Add the following to Concepts: A record or, respectively, a binding table A and a record or,
respectively, a binding table B are field name-disjoint if A's record type or, respectively,
binding table type and B's record type or, respectively, binding table type are field
name-disjoint. 
If A and B are field name-disjoint, then A and B are field type-compatible.
</para>

</solution>

</PP>


<comment>Resolved by WG3:W24-029</comment>
<PP id="PPgql339" number="GQL-339" severity="minor" realm="technical">

<reference><specref ref="gql_let"/>.
</reference>

<noteAt>None.
</noteAt>

<source>WG3:W23-015.
</source>

<problem>

<para>Syntax rewrite should always transform to explicit syntax. 
<itemref ref="gql_let_SR_syntax_trans" type="SR"/> which syntactically transforms a let statement 
into a CALL <BNF name="inline procedure call"/> should use an explicit 
<BNF name="variable scope clause"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:UTC-075</comment>
<PP id="PPgql351" number="GQL-351" severity="minor" realm="technical">

<reference><specref ref="gql_graph_pattern"/>. 
</reference>

<noteAt><specref ref="PPgql351_1"/>. 
</noteAt>

<source>Email from Jim Melton, 2022-12-08. 
</source>

<problem>

<para>The second sentence (<quote>The degree of exposure of <sym>PV</sym> and the
path variable that it identifies is unconditional singleton.</quote>) makes no sense to [Jim]. 
Basically, it says that <quote>A and B identifies is unconditional singleton.</quote> 
At a minimum, the verb (<quote>is</quote>) should be plural (<quote>are</quote>),
but [Jim doesn't] understand what that would mean. 
[Jim thinks] a rewrite of the sentence is called for.
</para>

<para>In addition, most uses of <quote>degree of exposure</quote> are followed by a NOTE that
points the reader to the place where the term is defined. 
</para>

<para>Linked to <ExtPPref ref="PPpgq097" standard="9075" part="16"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Editorially resolved as consequence of editing for UTC</comment>
<PP id="PPgql352" number="GQL-352" severity="minor" realm="technical">

<reference><specref ref="gql_names"/>.
</reference>

<noteAt><specref ref="PPgql352_1"/>.
</noteAt>

<source>WG3:UTC-080.
</source>

<problem>

<para>To preserve the ability for subpath variables to be bound in the future, we should
not allow a <BNF name="subpath variable"/> to shadow a <BNF name="binding variable"/>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:GYD-031</comment>
<LO id="PPgql357" number="GQL-357" kind="new_feat" size="M">

<brief area="Data types and expressions">Duration groups
</brief>

<reference>No specific location.
</reference>

<source>WG3:UTC-117.
</source>

<problem>

<para>In a future GQL version, it would be useful to have &lt;duration group&gt;s to allow a user
to specify a refined duration type and specify the duration units that result from
a datetime subtraction.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<comment>Resolved by WG3:CMN-028</comment>
<LO id="PPgql360" number="GQL-360">

<source>WG3:UTC-106.
</source>

<problem>

<comment>WG3:UTC-106</comment>
<para>There are many rules of the form:
</para>

<para><emph>Something or another</emph>, 1 (one) <leq/> <symdef>n</symdef>, 
<emph>some more things</emph>.
</para>

<para>It would help readability of this document tremendously, if those rules were restructured
to start with the iteration.
</para>

<para>For example:
</para>

<para>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>n</sym>,
<emph>let something be <etc/></emph>
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<comment>Resolved by WG3:CMN-028</comment>
<LO id="PPgql361" number="GQL-361">

<source>WG3:UTC-106.
</source>

<problem>

<comment>WG3:UTC-106</comment>
<para>It is a Language Opportunity to minimize the use of variable subscripts throughout
the document to simplify reading.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<comment>Withdrawn as minuted for WG3:UTC-126</comment>
<LO id="PPgql363" number="GQL-363">

<source>WG3:UTC-126.
</source>

<problem>

<para>It is a Language Opportunity to consistently use active or passive voice in Rules.
This is particularly relevant to actions taken as part of catalog-modifying and/or
data-modifying operations and when creating and destroying descriptors.
</para>

<para>Prefer the passive voice; although when specifying a sequence of steps to be
performed the steps should be in the active voice but prefix with suitable
introductory text in passive voice, such as <quote>The following steps are performed:</quote>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>
</LO>


<comment>Resolved by WG3:GYD-031</comment>
<LO id="PPgql372" number="GQL-372" kind="improv" size="S">

<brief area="DDL">Prevent mixing of IF NOT EXISTS and OR REPLACE
</brief>

<reference><specref ref="gql_create_graph"/>. 
</reference>

<noteAt>None.
</noteAt>

<source>WG:CMN-064.
</source>

<problem>

<para>From GQL DIS Comment P00-DEU-017, Consider writing the <BNF name="create graph statement"/>
production in a simpler way as
</para>

<code>
<kw>CREATE</kw> [ <kw>OR</kw> <kw>REPLACE</kw> ] [ <kw>PROPERTY</kw> ] <kw>GRAPH</kw> [ <kw>IF</kw> <kw>NOT</kw> <kw>EXISTS</kw> ]
</code>

<para>and write a syntax rule that <kw>OR</kw> <kw>REPLACE</kw> and <kw>IF</kw> <kw>NOT</kw> 
<kw>EXISTS</kw> cannot be specified together (and analogously for other CREATE statements).
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<comment>Resolved by WG3:SYX-017</comment>
<LO id="PPgql384" number="GQL-384">

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>Email from Keith Hare 2024-02-09 1618.
</source>


<since>2024-02-09.
</since>

<problem>

<para>The GQL standard has a number of <impDef annex="no" code="None"/> elements that depend on 
optional features. 
It would be helpful if an appendix or artifact could link <impDef annex="no" code="None"/> elements
with optional features. 
This would help readers who are building a product-specific table of 
<impDef annex="no" code="None"/> elements.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</LO>


<comment>Resolved by WG3:BGI-035</comment>
<PP id="PPgql385" number="GQL-385" severity="minor" realm="technical">

<reference><specref ref="gql_listvalfunc"/>.
</reference>

<noteAt><specref ref="gql_PPgql385"/>.
</noteAt>

<source>Editor.
</source>

<problem>

<para>CR 1) of <specref ref="gql_listvalfunc"/> implicitly, but incorrectly, makes 
<feature code="GF04"/> depend on <feature code="GV50"/>.
The two features are independent of each other.
CR 1) of <specref ref="gql_listvalfunc"/> in in any case redundant as it is already covered by
CR 1) of <specref ref="gql_listvalexp"/>.
</para>

</problem>

<solution>

<para>Delete CR 1) of <specref ref="gql_listvalfunc"/>.
</para>

</solution>

</PP>


<comment>Resolved by WG3:GYD-013</comment>
<PP id="PPgql386" number="GQL-386" severity="minor" realm="technical">

<brief area="Format">Unused repetition of <BNF name="object name"/>
</brief>

<reference><specref ref="gql_cat_obj_refs"/>.
</reference>

<noteAt><specref ref="gql_PPgql386"/>.
</noteAt>

<source>LDBC.
</source>

<problem>

<para>The BNF for <BNF name="catalog object parent reference"/> supports an optional potentially 
repeating <BNF name="object name"/>, so the following is valid syntax:
</para>

<code>
CREATE GRAPH /someRoot/someDirectory/mySchema/Object1.Object2.MyGraph ANY
</code>

<para>Nothing in the GQL V1 draft takes advantage of the repeating <BNF name="object name"/>s so 
perhaps they are not needed.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:BGI-036</comment>
<PP id="PPgql387" number="GQL-387" severity="minor" realm="technical">

<reference><specref ref="gql_implied_featurerelations"/>.
</reference>

<noteAt>None.
</noteAt>

<source>Editor.
</source>

<problem>

<para><feature code="GP18"/> requires the existance of both <feature code="GC04"/> and 
<feature code="GD01"/> to be relevant.
However, this is not defined in <specref ref="gql_implied_features"/>.
</para>

</problem>

<solution>

<para>Add the missing rows to <specref ref="gql_implied_features"/>.
</para>

</solution>

</PP>


<comment>Resolved by WG3:SYX-029R1</comment>
<PP id="PPgql389" number="GQL-389" severity="minor" realm="editorial">

<reference><specref ref="gql_conc_env_cat_gendescr"/>.
</reference>

<noteAt><specref ref="gql_PPgql389"/>.
</noteAt>

<source>LDBC GQL-IP-002.
</source>

<problem>

<para>Informative <specref ref="gql_cat_diag"/> of the standard mistakenly shows Node and Edge as 
secondary catalog objects. 
There are data objects inside a Graph for nodes and edges, but there are no catalog objects 
contained by the Graph object other than Graph type, or graph type <quote>omitted</quote>. 
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>

<comment>Resolved by WG3:GYD-010</comment>
<PP id="PPgql404" number="GQL-404" severity="minor" realm="technical">

<brief area="Conditions">Identical exception conditions
with GQLSTATUS codes 22G03 and 22G12
</brief>

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>Neo4j LANGSTAR.
</source>

<problem>

<para>The GQL exception codes 22G03 and 22G12 are identical and 
are used in similar cases in the rules.
</para>

<ulist>
<item><raise class="22" subclass="G03"/>
</item>
<item><raise class="22" subclass="G12"/>
</item>
</ulist>

<para>These exceptions either need to be merged or disentangled. 
This will likely need a corrigenda entry.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:GYD-018</comment>
<PP id="PPgql390" number="GQL-390" severity="minor" realm="technical">

<brief area="Data types and expressions">Lack of preferred names per graph element types
and incomplete descriptor list
</brief>

<reference><specref ref="gql_node_type_defn"/>.
</reference>

<noteAt><specref ref="gql_PPgql390_1"/> and <specref ref="gql_PPgql390_2"/>.
</noteAt>

<source>LDBC GQL-IP-007.
</source>

<problem>

<para>Preferred name is specified (<ie/> NODE or VERTEX <etc/>) but that is not per element type, 
but system wide. 
Label set keys, implied content and aliases are not included in the descriptor list.
Mutatis mutandis, the same goes for edge type spec descriptors.
</para>

</problem>

<solution>

<para>Remove preferred name from, and add label set keys, implied content and aliases to the 
descriptor list.
</para>

</solution>

</PP>


<comment>Resolved by WG3:GYD-017</comment>
<PP id="PPgql405" number="GQL-405" severity="minor" realm="technical">

<brief area="Language">Invalid use of <quote>nothing type</quote>
</brief>

<reference><specref ref="gql_gts_combo_vts"/>.
</reference>

<noteAt><specref ref="gql_PPgql405"/>.
</noteAt>

<source>Neo4j LANGSTAR.
</source>

<problem>

<para><specref ref="gql_gts_combo_vts"/>, <itemref ref="gql_gts_combo_vts_empty" type="SR"/> says:
</para>

<para>Otherwise, <sym>DTR</sym> is the nothing type.
</para>

<para>In GQL the nothing type is called the empty type, 
<cf/> <specref ref="gql_immat_null_empty_dts"/>.
</para>

<para>Hence the rule should say:
</para>

<para>Otherwise, <sym>DTR</sym> is the <strikethrough>nothing</strikethrough> 
<bold>empty</bold> type.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:GYD-019</comment>
<PP id="PPgql407" number="GQL-407" severity="minor" realm="technical">

<brief area="Language">Inconsistent use of terminology related to
empty sequences
</brief>

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>Neo4j LANGSTAR.
</source>

<problem>

<para>The GQL draft contains numerous instances of
</para>

<ulist>
<item>empty sequence
</item>
<item>(possibly empty) sequence
</item>
<item>non-empty sequence
</item>
</ulist>

<para>These instances should be reviewed to see if they can be replaced by the appropriate 
variation of <quote>zero-length</quote>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:GYD-011</comment>
<PP id="PPgql408" number="GQL-408" severity="minor" realm="technical">

<brief area="Data types and expressions">Unnecessary conditional
protection against absence of declared type
</brief>

<reference><specref ref="gql_stm_proc_call"/>.
</reference>

<noteAt><specref ref="gql_PPgql408"/>.
</noteAt>

<source>Neo4j LANGSTAR.
</source>

<problem>

<para><specref ref="gql_stm_proc_call"/>, <itemref ref="gql_gql_stm_proc_call_SR_IPC" type="SR"/>
says:
</para>

<lbllist>
<lblitem label="b)">If <sym>PC</sym> is the <BNF name="inline procedure call"/> 
<symdef>IPC</symdef> and <sym>IPC</sym> has a declared type, then <sym>OTARTPC</sym> is the record 
type of the declared type of <sym>IPC</sym>.
</lblitem>
</lbllist>

<para>Since the introduction of the empty type <sym>IPC</sym> always has a declared type. 
There is no <quote>no declared type</quote> anymore.
Hence, it should say instead:
</para>

<lbllist>
<lblitem label="b)">If <sym>PC</sym> is the <BNF name="inline procedure call"/> 
<symdef>IPC</symdef> and <sym>IPC</sym> has a declared type 
<bold>that is a binding table type</bold>, then 
<sym>OTARTPC</sym> is the record type of the declared type of <sym>IPC</sym>.
</lblitem>
</lbllist>

<para>or
</para>

<lbllist>
<lblitem label="b)">If <sym>PC</sym> is the <BNF name="inline procedure call"/> 
<symdef>IPC</symdef> and <sym>IPC</sym> has a declared type 
<bold>that is not the empty type</bold>, then 
<sym>OTARTPC</sym> is the record type of the declared type of <sym>IPC</sym>.
</lblitem>
</lbllist>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:GYD-011</comment>
<PP id="PPgql409" number="GQL-409" severity="minor" realm="technical">

<brief area="Procedures">Failure to prevent inner queries from exposing working record variables
</brief>

<reference><specref ref="gql_stm_proc_call"/>.
</reference>

<noteAt><specref ref="gql_PPgql409"/>.
</noteAt>

<source>Neo4j LANGSTAR.
</source>

<problem>

<para>In <specref ref="gql_stm_proc_call"/>, currently, 
<itemref ref="gql_stm_proc_call_SR_disjoint" type="SR"/> says: 
<quote><sym>ITART</sym> and <sym>OTARTPC</sym> shall be field name-disjoint.</quote>.
</para>

<para>However, this allows the inner query to produce bindings for (outer) working record variables.
</para>

<para>Shouldnt it be: 
<quote><sym>IREDTPC</sym> and <sym>OTART</sym> shall be field name-disjoint.</quote>.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:015</comment>
<PP id="PPgql410" number="GQL-410" severity="minor" realm="technical">

<brief area="Terminology">Lack of definition of being
<quote>of a property type</quote>
</brief>

<reference><specref ref="gql_conc_ot_node"/>.
</reference>

<noteAt><specref ref="gql_PPgql410"/>.
</noteAt>

<source>Neo4j LANGSTAR.
</source>

<problem>

<para>GQL says:
</para>

<para><quote>A node <symdef>N</symdef> in a graph is of a node type <symdef>NT</symdef> (<ie/> 
is included in <sym>NT</sym>) if the label set of <sym>N</sym> and the node type label set of 
<sym>NT</sym> are the same, the number of properties of <sym>N</sym> and the number of property 
types of <sym>NT</sym> are the same, and <bold>every property of <sym>N</sym> is of 
a property type of <sym>NT</sym></bold>.</quote>
</para>

<para>It seems though, there is no place where it gets defined what 
<quote>property is of property type</quote> is supposed to mean.
</para>

<para>Probably the idea was to add that to <specref ref="gql_conc_property_types"/>, and somehow 
that was forgotten.
</para>

<para>A fix could be like that or alter natively, add to node type and edge types a sentence 
similar to the following in <specref ref="gql_conc_record"/>:
</para>

<para>For every record type <symdef>RT</symdef>, a record <symdef>R</symdef> is a material value of 
<sym>RT</sym>, if and only if either <sym>RT</sym> is open or all the following conditions are 
true:
</para>

<ulist>
<item>[<ellipsis/>]
</item>
<item><bold>For every field type in <sym>RT</sym> with name <symdef>FN</symdef> and value type 
<symdef>FVT</symdef>, <sym>R</sym> has a field whose name is <sym>FN</sym> and whose value is of 
<sym>FVT</sym></bold>.
</item>

</ulist>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:GYD-016</comment>
<PP id="PPgql411" number="GQL-411" severity="minor" realm="technical">

<brief area="Conformance">Overly tight restrictions on support for
value type combination of property value types of graph element types
</brief>

<reference><specref ref="gql_conc_struct_consistency_elt_types"/> and 
<specref ref="gql_gts_combo_vts"/>.
</reference>

<noteAt>None.
</noteAt>

<source>Neo4j LANGSTAR.
</source>

<problem>

<para>In <specref ref="gql_conc_struct_consistency_elt_types"/>:
</para>

<para>Both consistency criteria rely on
the <newterm>graph-type specific combination of property value types</newterm> 
to ensure that certain property types of element types of a graph type that have
the same name also either have the same value type or, if <bold><feature code="GG24"/></bold>
is supported, have value types that can be combined by an application of the Syntax Rules of
<specref ref="gql_gen_combo_vts"/> to obtain a supported property value type.
</para>

<note>See  <specref ref="gql_gts_combo_vts"/>.
</note>

<para>The rules in <specref ref="gql_gts_combo_vts"/>, however, only refer to 
<bold><feature code="GG26"/></bold>, Relaxed property value type consistency.
</para>

<para>Further down in <specref ref="gql_conc_struct_consistency_elt_types"/> it says:
</para>

<para>If <feature code="GG24"/> is not supported, then all graph types are property value type
consistent; otherwise, <feature code="GG24"/> is supported and it is possible that some graph types
are not property value type consistent.
</para>

<para>So the picture is, I believe:
</para>

<ulist>
<item>Relaxed structural consistency  no combinability check at all
</item>
<item>Relaxed property value type consistency  General combinability required
</item>
<item>None of the too  same value type required
</item>
</ulist>

<para>In short, the following fix is needed:
</para>

<para>Both consistency criteria rely on the graph-type specific combination of property value 
types to ensure that certain property types of element types of a graph type that have the same 
name also either have the same value type or, if 
<strikethrough><feature code="GG24"/></strikethrough>
<bold><feature code="GG26"/></bold> is supported, have value types that can be combined by 
an application of the Syntax Rules of <specref ref="gql_gen_combo_vts"/> to obtain 
a supported property value type.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:GYD-014</comment>
<PP id="PPgql412" number="GQL-412" severity="minor" realm="technical">

<brief area="Language">Missing <quote>element</quote> in
<quote>graph element reference value type</quote>
</brief>

<reference><specref ref="gql_label_expr"/>.
</reference>

<noteAt>None.
</noteAt>

<source>Neo4j LANGSTAR.
</source>

<problem>

<para><specref ref="gql_label_expr"/>, <itemref ref="gql_label_expr_SR_in_lbl_pred" type="SR"/>
</para>

<lbllist>
<lblitem label="i)">Let <symdef>EVR</symdef> be the <BNF name="element variable reference"/> in 
<sym>LP</sym>.
</lblitem>
<lblitem label="ii)">If the declared type of <sym>EVR</sym> is a closed graph reference value type 
with constraining GQL-object type <symdef>COT</symdef>, then every <BNF name="label name"/> 
contained in <sym>LE</sym> shall identify a label in the label set of <sym>COT</sym>.
</lblitem>
</lbllist>

<para>I believe is should says in ii):
</para>

<para>[<ellipsis/>] closed graph <bold>element</bold> reference value type [<ellipsis/>]
</para>

<para>The declared type of an <BNF name="element variable reference"/> cannot be a graph reference
value type, but is a graph <bold>element</bold> reference value type.
</para>

<para>Paper [WG3:CMN-075r1] had it correct.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:W28-014</comment>
<PP id="PPgql424" number="GQL-424" severity="minor" realm="editorial">

<brief area="Error codes">Possible duplicate</brief>

<reference>No specific location.
</reference>

<noteAt>None.
</noteAt>

<source>Email from: Hannes Voigt, 2024-10-17 1551.
</source>

<problem>

<para>The two exception conditions 2202F and 22G0B are both for list values having too large 
a cardinality. 
2202F is used in store assignment only.
22G0B is used in various places, <eg/> <BNF name="cast specification"/>.
Maybe one exception condition is enough.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:POS-019</comment>
<PP id="PPgql426" number="GQL-426" severity="minor" realm="technical">

<brief area="Conformance">Missing Conformance Feature for specifying the max length of 
list value types</brief>

<reference><specref ref="gql_value_type"/>.
</reference>

<noteAt><specref ref="gql_PP426"/>.
</noteAt>

<source>Email from: Stefan Plantikow, 2024-10-24 1210.
</source>

<problem>

<para>There are Conformance Features for specifying the min, fixed, and max length of 
byte and character string types. 
However, there is currently no matching Conformance Feature for specifying 
the max length of a list value type. 
This seems inconsistent and should be rectified.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:POS-019</comment>
<PP id="PPgql427" number="GQL-427" severity="minor" realm="technical">

<brief area="Conformance">Incomplete Conformance Feature definitions related to
exact numeric types</brief>

<reference><specref ref="gql_value_type"/>.
</reference>

<noteAt><specref ref="gql_PP427"/>.
</noteAt>

<source>Email from: Stefan Plantikow, 2024-10-24 1210.
</source>

<problem>

<para>The Conformance Features GV18, GV19, GV05, GV08, GV10 only mention the compact forms of 
regulated type syntax. 
This is incomplete and should be changed to include all equivalent forms (<eg/> not just 
SMALLINT but also SMALL INTEGER <etc/>).
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:XRH-035</comment>
<PP id="PPgql430" number="GQL-430" severity="minor" realm="technical">

<brief area="Conformance">Optionality of SESSION CLOSE</brief>

<reference><specref ref="gql_session_close"/>.
</reference>

<noteAt><specref ref="gql_PP430"/>.
</noteAt>

<source>WG3:XRH-001 Agenda Item 12.12.
</source>

<problem>

<para>The <BNF name="session close command"/> is not appropriate for systems that do not support 
updates and therefore do not care about session state.
</para>

<para>It should be made subject to a Conformance Rule.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:XRH-035</comment>
<PP id="PPgql431" number="GQL-431" severity="minor" realm="technical">

<brief area="Conformance">Optionality of FINISH</brief>

<reference><specref ref="gql_stm_result"/>.
</reference>

<noteAt><specref ref="gql_PP431"/>.
</noteAt>

<source>WG3:XRH-001 Agenda Item 12.12.
</source>

<problem>

<para>The <kw>FINISH</kw> alternative <BNF name="primitive result statement"/> is only appropriate
for systems that support updates.
</para>

<para>It should be made subject to a Conformance Rule.
</para>

</problem>

<solution>

<para>None provided with comment.
</para>

</solution>

</PP>


<comment>Resolved by WG3:XRH-021R1</comment>
<LO id="PPgql435" number="GQL-435" kind="new_feat" size="M">

<brief area="Data types and expressions">Return an approximate number of rows</brief>

<reference><specref ref="gql_stm_return"/>.
</reference>

<noteAt><specref ref="PPgql435_1"/>.
</noteAt>

<source>WG3:POS-011R1
</source>

<since>2025-03-24
</since>

<problem>

<para>WG3:GYD-024 included syntax to fetch an approximate number of rows.
WG3:POS-011R1 omitted that syntax.
The ability to return an approximate number of rows should be considered.
</para>

</problem>

</LO>


<comment>Resolved by WG3:XRH-020 and WG3:XRH-040</comment>
<LO id="PPgql439" number="GQL-439" size="S">

<brief area="Statements and clauses">Reduce minimal syntax requirements for LET support
</brief>

<reference><specref ref="gql_let"/>.
</reference>

<noteAt><specref ref="PPgql439_1"/>.
</noteAt>

<source>Email from: Hannes Voigt, 2025-03-13 1520.
</source>

<since>2025-03-25
</since>

<problem>

<bar note="WG3:XRH-020"/>
<comment>WG3:XRH-020</comment>
<para>Current mandatory functionality of <BNF name="let statement"/> requires implementations
to support <BNF name="value variable definition"/> syntax in
<BNF name="let variable definition"/>s.
However, in practice, this verbose form is not very common.
Therefore, making this syntax optional should be considered, leading to a smaller minimal grammar
for GQL.
Alongside, optional support for specifying an <BNF name="opt typed value initializer"/>
in the shorthand syntax should be added for consistency of implementations with
<BNF name="opt typed value initializer"/> support.
</para>
<endbar/>

</problem>

</LO>


-->

</EditorNotes>
