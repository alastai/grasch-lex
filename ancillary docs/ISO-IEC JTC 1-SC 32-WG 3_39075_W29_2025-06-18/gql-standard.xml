<?xml version="1.0" encoding="UTF-8"?>
<!--
1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
-->
<!DOCTYPE standard SYSTEM "Standard.dtd" [

  <!-- Include the definition of character entities                                              -->
  <!ENTITY % winansi SYSTEM "./winansi.entities">
  %winansi;

  <!ENTITY ednotes SYSTEM "./gql-standard_editor_notes.xml">

  <!ENTITY forewordBoilerplatePart1 SYSTEM "./forewordBoilerplatePart1.xml">
  <!ENTITY forewordBoilerplatePart2For39075 SYSTEM "./forewordBoilerplatePart2For39075.xml">

  <!ENTITY normativeReferencesBoilerplate SYSTEM "./normativeReferencesBoilerplate.xml">

  <!ENTITY termsAndDefinitionsBoilerplate SYSTEM "./termsAndDefinitionsBoilerplate.xml">

<!-- docName identifies the document by its "common name"                                        -->
  <!ENTITY docName "GQL">

<!-- docTitleEnglish gives the full name of the document in English                              -->
<!--   It does so in four (3) different parts!                                                   -->
  <!ENTITY docTitleEnglish1 "Information technology &mdash; Database languages &mdash; GQL">
  <!ENTITY docTitleEnglish2 "">
  <!ENTITY docTitleEnglish3 "">

<!-- docTitleFrench gives the full name of the document in French                                -->
  <!ENTITY docTitleFrench1 "Technologies de l&rsquo;information &mdash;
                            Langages de base de donn&eacute;es &mdash; GQL">
  <!ENTITY docTitleFrench2 "">
  <!ENTITY docTitleFrench3 "">

  <!ENTITY % entities SYSTEM "gql-standard.entities">
  %entities;
]>
<?xml-stylesheet type="text/xsl" href="StandardMaster.xsl"?>

<?xml-stylesheet type="text/css" href="standard.less"?>

<standard documentType="International_Standard"
             documentLanguage="English"
             documentShortname="&docName;"
             standard="39075"
             isoNumber="39075"
             partNumber2digit="00"
             principleEditor="Stefan Plantikow"
             associateEditor="Stephen Cannan">

<comment>GQL - Graph Query Language</comment>
<coverPage>

<SCtitle>ISO/IEC JTC 1/SC 32</SCtitle>
<WGtitle>ISO/IEC JTC 1/SC 32/WG 3</WGtitle>
<secretariat>The United States of America (ANSI)</secretariat>

<partTitleEnglish>
  <partTitleEnglish1>&docTitleEnglish1;</partTitleEnglish1>
  <partTitleEnglish2>&docTitleEnglish2;</partTitleEnglish2>
  <partTitleEnglish3>&docTitleEnglish3;</partTitleEnglish3>
</partTitleEnglish>
<partTitleFrench>
  <partTitleFrench1>&docTitleFrench1;</partTitleFrench1>
  <partTitleFrench2>&docTitleFrench2;</partTitleFrench2>
</partTitleFrench>

</coverPage>

<copyrightNoticePage/>

<comment>The initial editorial drafting of GQL followed the discussion expressed by various papers
presented at meetings of ISO/IEC JTC 1/SC 32/WG 3 that lead to the inception of the GQL project
and/or that explored key topics during the initial phase of 39075.
Relevant discussion papers in this regard on topics such as the data model, document structure, 
graph patterns and syntax questions in this source file are (up to the SXM meeting):
* WG3:YTZ-029, WG3:YTZ-030, WG3:YTZ-031, WG3:YTZ-032, WG3:YTZ-033, WG3:YTZ-034, WG3:YTZ-035, 
  WG3:YTZ-036
* WG3:ERF-034, WG3:ERF-035, WG3:ERF-037, WG3:ERF-038, WG3:ERF-042, WG3:ERF-044, WG3:ERF-045
* WG3:BNE-022, WG3:BNE-023, WG3:BNE-027, WG3:BNE-029, WG3:BNE-030, WG3:BNE-035, WG3:BNE-036, 
  WG3:BNE-037, WG3:BNE-041, WG3:BNE-042, WG3:BNE-046, WG3:BNE-050, WG3:BNE-051, WG3:BNE-052,
  WG3:BNE-053, WG3:BNE-054
* WG3:JCJ-009 (1st draft), WG3:JCJ-010, WG3:JCJ-011, WG3:JCJ-012, WG3:JCJ-015, WG3:JCJ-018,
  WG3:JCJ-019, WG3:JCJ-029, WG3:JCJ-031, WG3:JCJ-033
* WG3:ARK-010 (2nd draft), WG3:ARK-012, WG3:ARK-027, WG3:ARK-028, WG3:ARK-030, WG3:ARK-031,
  WG3:ARK-32, WG3:ARK-033, WG3:ARK-34, WG3:ARK-037, WG3:ARK-040
* WG3:SXM-010 (3rd draft), WG3:SXM-027, WG3:SXM-028, WG3:SXM-029, WG3:SXM-055, WG3:SXM-056,
  WG3:SXM-057, WG3:SXM-058, WG3:SXM-059, WG3:SXM-064, WG3:SXM-066, WG3:SXM-067, WG3:SXM-074
</comment>
<standardPartBody>

<partHeading/>

<partTitle>
  <partTitleOne>&docTitleEnglish1;</partTitleOne>
  <partTitleTwo>&docTitleEnglish2;</partTitleTwo>
  <partTitleThree>&docTitleEnglish3;</partTitleThree>
</partTitle>


<foreword id="gql_foreword">
<forewordHeading>Foreword</forewordHeading>

<forewordBody>

<bodyMatter>

<comment>Include a file with the proper boilerplate text, as it changes occasionally</comment>
&forewordBoilerplatePart1;

<comment>Editorial: Stephen Cannan, 2025-04-07 Prepare for second edition</comment>
<bar note="Editorial: Stephen Cannan, 2025-04-07 Prepare for second edition"/>
<ednote id="gql_prepublication">The following needs to be checked before publication.
</ednote>

<para>This second edition of ISO/IEC 39075 cancels and replaces the first edition
(ISO/IEC 39075:2024), which has been technically revised. 
It also incorporates the Technical Corrigenda ISO/IEC 39075:2024/Cor.1:2025(E).
</para>

<para>The main changes compared to the previous edition are as follows:
</para>

<ulist>

<item>Support for the <kw>VECTOR</kw> data type.
</item>

<item>Support for conditional execution of statements.
</item>

</ulist>
<endbar/>

&forewordBoilerplatePart2For39075;

</bodyMatter>

</forewordBody>

</foreword>


<intro id="gql_intro">
<introHeading>Introduction</introHeading>

<introBody>

<bodyMatter>

<comment>WG3:UTC-14R1 Deleted 3 paragraphs</comment>

<comment>WG3:UTC-114R1</comment>
<para>This document defines GQL, a database language for modeling structured data as a graph, and
for storing, querying, and modifying that data in a graph database or other graph store.
There are two major graph data models in current use: the Resource Description Framework (RDF) model
and the Property Graph model.
The RDF model has been standardized by W3C in a number of specifications.
GQL addresses the Property Graph model.
</para>

<para>Property graphs organize data as entities called nodes (or, alternatively, vertices) and edges
(or, alternatively, relationships).
Each graph element (a node or an edge) can have associated labels and properties.
The flexibility and intuitiveness of the data model and its emphasis on interconnections between
graph elements make property graphs suitable for storing complex knowledge and for analytical tasks
such as entity resolution, fraud detection, cyber security, and forecasting.
</para>

<para>GQL is declarative and transactional, taking inspiration from <SQL/> and from
leading independently-developed property graph languages.
Property graphs select data primarily through path pattern matching.
Defining path pattern searches in a graph is often simpler or more flexible than defining the
equivalent joins in <SQL/>.
The flexible data model, the availability of path pattern matching, and the efficiency of
traversing edges compared to joining tables have led to increasing interest in property
graph databases.
</para>

<para>Various graph data models have been around for many decades, but it is only since
the early 21st century that the demand has driven the rise of commercial graph database and
graph analytical systems for property graphs.
</para>

<comment>Editorial; Jim Melton, 2023-09-04; fix which/that problems</comment>
<para>GQL provides a standard yet flexible common language for this growing market.
GQL supports the same graph pattern matching syntax as <SQL/> Property Graph Queries,
ISO/IEC 9075-16, Information technology — Database languages <SQL/>— Part 16: Property Graph 
Queries (<SQL/>/PGQ).
While <SQL/>/PGQ provides the property graph data model and graph pattern matching on top of
a relational <SQL/> database, GQL is intended for pure property graphs that provide 
graph data management independent from <SQL/>.
</para>

<!--
We missed a sentence in the new introduction somehow that I actually care about, leaving it here
in case I find the time to write a paper to bring it back in time before IS - SP

<comment>Editorial: Stefan Plantikow, 2020-04-02</comment>
<comment>Editorial: Stefan Plantikow, 2022-11-02 WG3:W23-009R1 P00-DNK-001</comment>
<para>As a declarative language, GQL is intended to allow multiple, different implementation
strategies using different storage representations and targeting various classes of workloads
(<eg/> OLTP, OLAP).
</para>
-->

</bodyMatter>

</introBody>

</intro>


<clause id="gql_scope_clause">
<clauseHeading>Scope</clauseHeading>

<bodyMatter>

<comment>Editors' meeting, 2022-09-25</comment>
<para>This document defines data structures and basic operations on
property graphs. 
It provides capabilities for creating, accessing, querying, maintaining,
and controlling property graphs and the data they comprise.
</para>

<comment>Editors' meeting, 2022-09-25</comment>
<para>This document specifies the syntax and semantics of
a data management language for specifying and modifying the
structure of property graphs and collections thereof. 
This document provides a vehicle for portability of
data definitions and manipulation among GQL-implementations.
</para>

<comment>Editors' meeting, 2022-09-25</comment>
<para>Implementations of this document can exist in environments
that also support application programming languages,
end-user query facilities, and various tools for database design,
data administration, and performance optimization.
</para>

</bodyMatter>

</clause>


<clause id="gql_refer">
<clauseHeading>Normative references</clauseHeading>

<bodyMatter>

<para>&normativeReferencesBoilerplate;
</para>

<comment>Editorial: Stephen Cannan, 2022-03-07 WG3:RKE-010 P00-USA-302</comment>
<normativeReferences>

<comment>Editorial: Stephen Cannan, 2019-07-25</comment>
<comment>Editorial: Stephen Cannan, 2020-02-12 Use new referencing mechanism</comment>
<referencedDocument id="ISO8601-1_2019"/>

<comment>Editorial: Stephen Cannan, 2020-02-12 Use new referencing mechanism</comment>
<referencedDocument id="ISO8601-2_2019"/>

<comment>Editorial: Stephen Cannan, 2020-02-12 Use new referencing mechanism</comment>
<referencedDocument id="ISO9075-2_2023"/>

<comment>Editorial: Stephen Cannan, 2019-07-25</comment>
<comment>Editorial: Stephen Cannan, 2020-02-12 Use new referencing mechanism</comment>
<comment>WG3:W23-009R1 P00-CAN-004</comment>
<referencedDocument id="ISO14651_2020"/>

<comment>Editorial: Stephen Cannan, 2020-02-12 Use new referencing mechanism</comment>
<referencedDocument id="IEEE754"/>

<comment>Editorial: Stefan Plantikow, 2020-07-27 WG3:MMX-055</comment>
<comment>Editorial: Stefan Plantikow, 2020-07-26 WG3:MMX-055</comment>
<referencedDocument id="RFC3986"/>

<comment>WG3:UTC-117 Deleted 1 (one) Normative Reference</comment>

<comment>Editorial: Stephen Cannan, 2020-03-05 Add use of UTC-SLS</comment>
<referencedDocument id="UTC-SLS"/>

<comment>Editorial: Stephen Cannan, 2020-02-12 Use new referencing mechanism</comment>
<referencedDocument id="Unicode"/>

<comment>Editorial: Stephen Cannan, 2020-02-12 Use new referencing mechanism</comment>
<referencedDocument id="Unicode10"/>

<comment>Editorial: Stephen Cannan, 2020-02-12 Use new referencing mechanism</comment>
<referencedDocument id="Unicode15"/>

<comment>Editorial: Stephen Cannan, 2020-02-12 Use new referencing mechanism</comment>
<referencedDocument id="Unicode31"/>

<comment>Editorial: Stefan Plantikow, 2020-07-27 WG3:MMX-055</comment>
<comment>Editorial: Stefan Plantikow, 2020-07-26 WG3:MMX-055</comment>
<referencedDocument id="WHATWG-URL"/>

</normativeReferences>

</bodyMatter>

</clause>


<clause id="gql_definitions">
<clauseHeading>Terms and definitions</clauseHeading>
<comment>WG3:UTC-070 Deleted 1 (one) editor's note</comment>

<termsBoilerplate>

<comment>Alignment with Directives Part 2 2018</comment>
<comment>WG3:W23-009R1 P00-CAN-004</comment>
<comment>WG3:CMN-019 P00-ISO-013</comment>
<para>For the purposes of this document, the following terms and definitions apply.
</para>

&termsAndDefinitionsBoilerplate;


<ednote>The following definitions also have been slightly modified from SQL/PGQ to reflect

<blist>

<item>consistent use of <quote>x pattern</quote> and of <quote>x pattern variable</quote>
</item>

<item>preferred use of <quote>element pattern variable</quote> instead of 
<quote>primary graph pattern variable</quote>
</item>

<item>use of refined <quote>x pattern</quote> definitions
</item>

</blist>

<para>These changes need to be taken into account when adopting content from SQL/PGQ.
They should ultimately flow back into SQL/PGQ.
</para>
</ednote>

</termsBoilerplate>


<subClause id="gql_general_terms_defns">
<clauseHeading>General terms and definitions</clauseHeading>

<bodyMatter>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-17</comment>
<definition id="gql_atomic_defn" type="adj">
<term>atomic</term>
<defn>incapable of being subdivided</defn>
<defnNote>The antonym is <defnref ref="gql_composite_defn"/>.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-09-03 Adjusted</comment>
<definition id="gql_composite_defn" type="adj">
<term>composite</term>
<defn>comprising distinguishable elements</defn>
<defnNote>The antonym is <defnref ref="gql_atomic_defn"/>.
</defnNote>
</definition>

<comment>WG3:BER-010 P00-USA-303</comment>
<comment>Editorial: Add verb - Consequence of WG3:UTC-013 P01-ISO-001</comment>
<definition id="gql_identify_defn" type="verb" qual="x">
<term>identify</term>
<defn>reference without ambiguity</defn>
</definition>

<comment>WG3:W21-053</comment>
<definition type="adj">
<term><impDef annex="no" code="None"/></term>
<defn>possibly differing between GQL-implementations, but specified by the implementer for each
particular GQL-implementation</defn>
</definition>

<comment>WG3:W21-053</comment>
<definition type="adj">
<term><unDef annex="no" code="None"/></term>
<defn>possibly differing between GQL-implementations, but not required to be specified by the 
implementer for any particular GQL-implementation</defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-03-04</comment>
<definition id="gql_identifier_defn">
<term>identifier</term>
<defn><defnref ref="gql_value_defn"/> by which something is identified</defn>
</definition>

<comment>WG3:W26-037R3</comment>
<definition id="gql_gen_identier_defn">
<term>system-generated identifier</term>
<defn>unique <defnref ref="gql_identifier_defn"/> that is different from any user-provided 
identifier</defn>
<defnNote>In this document, system-generated identifiers are not exposed to the user.
See <itemref ref="gql_token_sys_gen_id" type="SR"/> of <specref ref="gql_token"/> for detailed
provisions regarding the construction of system-generated identifiers.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow as per suggestions from Stephen Cannan, 2020-03-04</comment>
<comment>Editorial: Stephen Cannan, 2022-03-07 WG3:RKE-010 P00-GBR-010 and P00-USA-003</comment>
<comment>WG3:UTC-111</comment>
<definition id="gql_object___x_defn" qual="x">
<term>object</term>
<defn>thing that is separately identifiable</defn>
<defnNote>Objects are not <defnref ref="gql_value_defn" plural="yes"/>.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-09-03 Adjusted</comment>
<comment>Editorial: Stefan Plantikow, 2020-03-09</comment>
<comment>Editorial: Stefan Plantikow, 2021-06-17 Adjusted X</comment>
<comment>WG3:W13-010R1</comment>
<comment>Editorial: Stefan Plantikow, 2021-07-29 Consistent use of GQL-object</comment>
<comment>Editorial: Stefan Plantikow, 2021-08-05 Add reference</comment>
<comment>Editorial: Stephen Cannan 2021-12-08 Standardize on GQL-implementation</comment>
<comment>WG3:W24-025</comment>
<definition id="gql_descriptor__x_defn" qual="x">
<term>descriptor</term>
<defn>coded description of the metadata of a <defnref ref="gql_GQL_object_defn"/></defn>
<defnNote>See <specref ref="gql_descriptors"/>.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2021-06-30</comment>
<comment>WG3:W13-010R1</comment>
<definition id="gql_persistent_defn" type="adj">
<term>persistent</term>
<defn>continuing to exist indefinitely, until destroyed 
deliberately</defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-09-03 Adjusted</comment>
<comment>Editorial: Stefan Plantikow as per suggestions from Stephen Cannan, 2020-03-04</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-09 Adjusted to avoid the term collection</comment>
<comment>Editorial: Stefan Plantikow, 2021-04-29 Minor rewording</comment>
<comment>Editorial: Stefan Plantikow, 2021-06-17 Adjusted to X</comment>
<comment>WG3:W21-044</comment>
<comment>WG3:W23-030</comment>
<comment>WG3:CMN-061R1</comment>
<definition id="gql_dictionary_defn">
<term>dictionary</term>
<defnDomain><quote>X</quote> dictionary</defnDomain>
<defn>mapping defined by a set of pairs comprising an identifier and an <quote>X</quote></defn>
<defnNote>Different pairs never have equivalent identifiers.
If a dictionary <symdef>DICT</symdef> contains the pair (<symdef>ID</symdef>, <symdef>X</symdef>), 
then every identifier that is equivalent to <sym>ID</sym> identifies <sym>X</sym> in 
<sym>DICT</sym>.
</defnNote>
</definition>

<comment>WG3:RKE-044R1</comment>
<comment>WG3:BER-010 P00-USA-303</comment>
<comment>WG3:W23-030</comment>
<comment>Editorial: Add verb - Consequence of WG3:UTC-013 P01-ISO-001</comment>
<definition id="gql_hold_defn" type="verb">
<term>hold</term>
<defnDomain><quote>X</quote> in a dictionary</defnDomain>
<defn>contain one identifier-value pair whose value is <quote>X</quote></defn>
</definition>

<definition id="gql_set_defn">
<term>set</term>
<defn>unordered collection of distinguishable elements</defn>
</definition>

<comment>WG3:W23-030</comment>
<definition id="gql_sequence_defn">
<term>sequence</term>
<term type="admitted">list</term>
<defn>ordered collection of elements that are not necessarily
distinguishable</defn>
</definition>

<comment>WG3:RKE-048</comment>
<definition id="gql_cardinality_defn">
<term>cardinality</term>
<defnDomain>collection</defnDomain>
<defn>number of elements in that collection</defn>
<defnNote>Those elements need not necessarily have distinguishable values.
The objects to which this concept applies include graphs, binding tables and
the values of constructed types.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2021-06-30</comment>
<comment>WG3:W13-010R1</comment>
<definition id="gql_temporary_defn" type="adj">
<term>temporary</term>
<defn>lasting for only a limited period of time</defn>
</definition>

<comment>Editorial: Stefan Plantikow as per suggestions from Stephen Cannan, 2020-03-04</comment>
<comment>Editorial: Stefan Plantikow, 2021-06-17 Adjusted X</comment>
<comment>WG3:UTC-087R2</comment>
<definition id="gql_variable__x_defn" qual="x">
<term>variable</term>
<defnDomain><quote>X</quote> variable</defnDomain>
<comment>Editorial: Stefan Plantikow, 2023-03-11 Remove duplicate words</comment>
<defn><defnref ref="gql_identifier_defn"/> assigned to a collection of related
<defnref ref="gql_site_defn" plural="yes"/></defn>
<comment>WG3:UTC-087R2</comment>
<defnNote>A variable represents sites.
</defnNote>
</definition>

</bodyMatter>

</subClause>


<subClause id="gql_env_terms_defns">
<clauseHeading>GQL-environment terms and definitions</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-04-07 Reworded</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<definition id="gql_GQL_environment_defn">
<term>GQL-environment</term>
<defn>milieu in which the <defnref ref="gql_GQL_catalog_defn"/> and
<defnref ref="gql_GQL_data_defn"/> exist and <defnref ref="gql_GQL_request_defn" plural="yes"/>
are executed</defn>
<defnNote>See <specref ref="gql_conc_env"/>.
</defnNote>
</definition>


<comment>Editorial: Stefan Plantikow, 2020-04-06</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 Use SQL term</comment>
<definition id="gql_GQL_server_defn">
<term>GQL-server</term>
<defn>processor capable of executing a <defnref ref="gql_GQL_request_defn"/> that 
was submitted by a <defnref ref="gql_GQL_client_defn"/> and delivering the outcome of that 
<defnref ref="gql_execution_defn"/> back to the GQL-client in accordance with the rules and
definitions of the GQL language</defn>
<defnNote>See <specref ref="gql_conc_env_server"/>.
</defnNote>
</definition>

<comment>Editorial: Stephen Cannan, 2020-05-11 Clarify principal</comment>
<comment>WG3:W10-010R1</comment>
<definition id="gql_principal_defn">
<term>principal</term>
<defn><defnref ref="gql_object___x_defn"/> that represents a user within a GQL-implementation</defn>
<defnNote>See <specref ref="gql_conc_env_principals"/>.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-04-06</comment>
<comment>Editorial: Stephen Cannan, 2020-05-11 Clarify principal</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 Use SQL term</comment>
<definition id="gql_GQL_client_defn">
<term>GQL-client</term>
<defn>processor capable of establishing a connection to a <defnref ref="gql_GQL_server_defn"/> on
behalf of a <defnref ref="gql_GQL_agent_defn"/> that is authenticated to represent 
a <defnref ref="gql_principal_defn"/></defn>
<defnNote>See <specref ref="gql_conc_env_client"/>.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-04-06</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<definition id="gql_GQL_agent_defn">
<term>GQL-agent</term>
<defn>independent process that causes the <defnref ref="gql_execution_defn"/> of
<defnref ref="gql_procedure_defn" plural="yes"/> and
<defnref ref="gql_command_defn" plural="yes"/></defn>
<defnNote>See <specref ref="gql_conc_env_agent"/>.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-04-06</comment>
<comment>Editorial: Stephen Cannan, 2020-05-11 Clarify principal</comment>
<comment>Editorial: Stephen Cannan, 2022-03-07 WG3:RKE-010 P00-USA-341</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-073</comment>
<comment>WG3:CMN-061R1</comment>
<definition id="gql_GQL_session_defn">
<term>GQL-session</term>
<defn>consecutive series of <defnref ref="gql_GQL_request_defn" plural="yes"/> issued on behalf of 
a single user by the <defnref ref="gql_GQL_agent_defn"/> via the 
<defnref ref="gql_GQL_client_defn"/> of the same <defnref ref="gql_GQL_environment_defn"/></defn>
<defnNote>See <specref ref="gql_conc_session"/>.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-04-07 Adjusted to match context overhaul</comment>
<comment>Editorial: Stephen Cannan, 2020-05-18 GQL- prefix reduction</comment>
<definition id="gql_session_context_defn">
<term>session context</term>
<defn>context associated with a <defnref ref="gql_GQL_session_defn"/> in which multiple
<defnref ref="gql_GQL_request_defn" plural="yes"/> are executed consecutively</defn>
<comment>WG3:CMN-072</comment>
<defnNote>See <specref ref="gql_conc_session_ctx"/>.
</defnNote>
</definition>

<comment>Editorial: Stephen Cannan, 2020-05-18 GQL- prefix reduction</comment>
<definition id="gql_current_session_context_defn">
<term>current session context</term>
<defn><defnref ref="gql_session_context_defn"/> associated with the
<defnref ref="gql_GQL_session_defn"/> of the currently executing 
<defnref ref="gql_GQL_request_defn"/></defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-03-10</comment>
<comment>Editorial: Stephen Cannan, 2020-05-18 GQL- prefix reduction</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-19 Parameter terminology reform</comment>
<comment>WG3:W21-044</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:CMN-061R1</comment>
<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<definition id="gql_session_parameter_defn">
<term>session parameter</term>
<defn><defnref ref="gql_gen_param_defn"/> that is defined in 
a <defnref ref="gql_session_context_defn"/></defn>
<defnNote>See <specref ref="gql_conc_prcmd_gql_vars_and_params"/>.
</defnNote>
</definition>
<comment>WG3:W21-044 Term session parameter flags removed</comment>
<comment>Editorial: WG3:W20-010 P00-USA-007 Term session-derived removed</comment>

<comment>WG3:W23-014</comment>
<comment>WG3:CMN-061R1</comment>
<definition id="gql_GQL_request_defn">
<term>GQL-request</term>
<defn>GQL-program and GQL-request parameters</defn>
<defnNote>See <specref ref="gql_conc_req"/>.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-04-07 Introduced for match context refactoring</comment>
<comment>Editorial: Stephen Cannan, 2020-05-18 GQL- prefix reduction</comment>
<comment>WG3:W21-044</comment>
<definition id="gql_GQL_request_context_defn">
<term>GQL-request context</term>
<defn>context that augments a <defnref ref="gql_session_context_defn"/> 
in which an individual <defnref ref="gql_GQL_request_defn"/> is executed</defn>
<defnNote>See <specref ref="gql_conc_req_ctx"/>.
</defnNote>
</definition>

<comment>WG3:CMN-061R1</comment>
<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<definition id="gql_dyn_param_defn">
<term>dynamic parameter</term>
<defn><defnref ref="gql_gen_param_defn"/> that is defined in 
a <defnref ref="gql_GQL_request_context_defn"/></defn>
<defnNote>See <specref ref="gql_conc_prcmd_gql_vars_and_params"/>.
</defnNote>
</definition>

<comment>WG3:CMN-061R1</comment>
<definition id="gql_gen_param_defn">
<term>general parameter</term>
<defn>pair comprising a name and a pair comprising a <defnref ref="gql_value_defn"/> and 
a <defnref ref="gql_value_type_defn"/></defn>
<defnNote>The parameter value type of a general parameter is a static value type of the
parameter value of that general parameter.
</defnNote>
</definition>

<definition id="gql_execution_stack_defn">
<term>execution stack</term>
<defn>push-down stack of 
<defnref ref="gql_execution_context_defn" plural="yes"/>
associated with a <defnref ref="gql_GQL_request_defn"/></defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-03-09</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-19 Renamed to context parameter</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-18 One note to definition removed</comment>
<comment>Editorial: Stefan Plantikow, 2021-04-29 Spelled out pair contents</comment>
<comment>WG3:W21-044 Term context parameter removed</comment>

<comment>Editorial: Stefan Plantikow, 2020-04-07 Added "directly"</comment>
<comment>WG3:UTC-111</comment>
<definition id="gql_GQL_object_defn">
<term>GQL-object</term>
<defn><defnref ref="gql_object___x_defn"/> capable of being manipulated directly by 
the <defnref ref="gql_execution_defn"/> of a <defnref ref="gql_GQL_request_defn"/></defn>
<defnNote>Every GQL-object specified in this document has a definition, and possibly, content.
See <specref ref="gql_conc_obj"/>.
</defnNote>
</definition>

<comment>WG3:W13-010R1</comment>
<definition id="gql_data_object_defn">
<term>data object</term>
<defn><defnref ref="gql_GQL_object_defn"/> comprising data</defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-09-03 Adjusted</comment>
<comment>Editorial: Stefan Plantikow, 2020-03-26</comment>
<comment>WG3:W13-010R1</comment>
<definition id="gql_primary_object_defn">
<term>primary object</term>
<defn>independently definable <defnref ref="gql_GQL_object_defn"/></defn>
<defnNote>A primary object may be defined separately from, but may also be contained as 
a component of another object.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-04-01</comment>
<comment>WG3:W13-010R1</comment>
<comment>WG3:BER-040R3</comment>
<definition id="gql_secondary_object_defn">
<term>secondary object</term>
<defn><defnref ref="gql_GQL_object_defn"/> necessarily defined as a component of other
<defnref ref="gql_GQL_object_defn" plural="yes"/></defn>
</definition>

<comment>WG3:UTC-110 Deleted 1 (one) definition</comment>

<comment>WG3:UTC-110 Deleted 1 (one) definition</comment>
<comment>WG3:UTC-064 Deleted 2 definitions</comment>

</bodyMatter>

</subClause>


<subClause id="gql_cat_terms_defns">
<clauseHeading>GQL-catalog terms and definitions</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-07-12 WG3:MMX-055</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-23 WG3:W20-010 P00-USA-315</comment>
<definition id="gql_GQL_catalog_defn">
<term>GQL-catalog</term>
<defn><defnref ref="gql_persistent_defn"/>, hierarchically-organized collection of
<defnref ref="gql_GQL_directory_defn" plural="yes"/> and 
<defnref ref="gql_GQL_schema_defn" plural="yes"/></defn>
<defnNote>See <specref ref="gql_conc_env_cat"/>.
</defnNote>
</definition>

<comment>WG3:W13-010R1</comment>
<comment>WG3:W20-010 P00-USA-008</comment>
<comment>WG3:RKE-044R1: One Note to Entry removed</comment>
<comment>WG3:BER-061</comment>
<definition id="gql_GQL_catalog_root_defn">
<term>GQL-catalog root</term>
<defn><defnref ref="gql_GQL_directory_defn"/> or a <defnref ref="gql_GQL_schema_defn"/> that is
the root of the <defnref ref="gql_GQL_catalog_defn"/></defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-03-10</comment>
<comment>Editorial: Stefan Plantikow, 2020-02-04</comment>
<definition id="gql_GQL_directory_defn">
<term>GQL-directory</term>
<defn><defnref ref="gql_persistent_defn"/> <defnref ref="gql_dictionary_defn"/> of 
<defnref ref="gql_GQL_directory_defn" plural="yes"/> and 
<defnref ref="gql_GQL_schema_defn" plural="yes"/></defn>
<defnNote>See <specref ref="gql_conc_env_cat_dir"/>.
</defnNote>
</definition>

<comment>WG3:W23-009R1 P00-USA-187</comment>
<definition id="gql_GQL_data_defn" type="npn">
<term>GQL-data</term>
<defn>data that is under the control of a GQL-implementation in 
a <defnref ref="gql_GQL_environment_defn"/></defn>
<defnNote>See <specref ref="gql_conc_env_gqldata"/>.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-07-12 WG3:MMX-055</comment>
<comment>WG3:W13-010R1</comment>
<comment>WG3:W13-010R1</comment>
<definition id="gql_GQL_schema_defn">
<term>GQL-schema</term>
<defn><defnref ref="gql_persistent_defn"/> <defnref ref="gql_dictionary_defn"/> of 
<defnref ref="gql_primary_catalog_object_defn" plural="yes"/></defn>
<defnNote>See <specref ref="gql_conc_env_schema"/>.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-02-04</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-04</comment>
<comment>Editorial: Stefan Plantikow, 2020-07-12 Revised for WG3:MMX-055</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-16 WG3:W20-010 P00-USA-009 Term catalog-derived
removed
</comment>

<comment>Editorial: Stefan Plantikow, 2020-09-09 Adjusted</comment>
<comment>Editorial: Stefan Plantikow, 2020-03-12</comment>
<comment>WG3:W13-010R1</comment>
<comment>WG3:UTC-111</comment>
<definition id="gql_catalog_object_defn">
<term>catalog object</term>
<defn><defnref ref="gql_GQL_object_defn"/> defined, possibly transitively, in the 
<defnref ref="gql_GQL_catalog_defn"/></defn>
</definition>

<comment>WG3:W13-010R1</comment>
<definition id="gql_primary_catalog_object_defn">
<term>primary catalog object</term>
<defn><defnref ref="gql_GQL_object_defn"/> that is both 
a <defnref ref="gql_primary_object_defn"/> and a <defnref ref="gql_catalog_object_defn"/></defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-09-05 Added</comment>
<definition id="gql_visible__gobj_defn" qual="gobj">
<term>visible</term>
<defnDomain>GQL-object</defnDomain>
<defn>capable of being referenced according to effective access control rules</defn>
</definition>

<comment>Editorial: Stephen Cannan, 2020-05-11 Clarify principal</comment>
<comment>Editorial: Stefan Plantikow, 2020-07-12 WG3:MMX-055</comment>
<definition id="gql_home_schema_defn">
<term>home schema</term>
<defn>default <defnref ref="gql_GQL_schema_defn"/> associated with 
a <defnref ref="gql_principal_defn"/></defn>
</definition>

<comment>Editorial: Stephen Cannan, 2020-05-11 Clarify principal</comment>
<definition id="gql_home_graph_defn">
<term>home graph</term>
<defn>default <defnref ref="gql_graph_defn"/> associated with 
a <defnref ref="gql_principal_defn"/></defn>
</definition>

</bodyMatter>

</subClause>


<subClause id="gql_graph_terms_defns">
<clauseHeading>Graph terms and definitions</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-02-03</comment>
<comment>WG3:W10-019R1</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-21 1310 Remove use of: descriptive text</comment>
<comment>WG3:W23-029R1</comment>
<definition id="gql_graph_defn">
<term>graph</term>
<term type="admitted">property graph</term>
<defn>data <defnref ref="gql_object___x_defn"/> comprising zero or more 
<defnref ref="gql_node_defn" plural="yes"/> and zero or more 
<defnref ref="gql_edge_defn" plural="yes"/></defn>
<defnNote>In the context of working with property graphs, the term graph is commonly used in the 
real world as a shorthand for property graph.
Without judgment or prejudice, this document prefers the term graph.
Additionally, the term property graph is only used to establish the right context in introductory
text.
</defnNote>
<comment>WG3:CMN-072</comment>
<defnNote>See <specref ref="gql_conc_g"/>.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-03-04</comment>
<comment>WG3:W09-036</comment>
<comment>Editorial: Stephen Cannan, 2021-04-06</comment>
<definition id="gql_multigraph_defn">
<term>multigraph</term>
<defn><defnref ref="gql_graph_defn"/> that allows more than one 
<defnref ref="gql_edge_defn"/> connecting two <defnref ref="gql_node_defn" plural="yes"/></defn>
</definition>

<definition id="gql_directed_graph_defn">
<term>directed graph</term>
<defn><defnref ref="gql_graph_defn"/> in which every
<defnref ref="gql_edge_defn"/> is directed</defn>
<comment>Editorial: Stefan Plantikow, 2023-02-20 Added antonym</comment>
<defnNote>The antonym is <defnref ref="gql_undirected_graph_defn"/>.
</defnNote>
</definition>

<definition id="gql_undirected_graph_defn">
<term>undirected graph</term>
<defn><defnref ref="gql_graph_defn"/> in which every <defnref ref="gql_edge_defn"/> is 
an <defnref ref="gql_undirected_edge_defn"/></defn>
<comment>Editorial: Stefan Plantikow, 2023-02-20 Added antonym</comment>
<defnNote>The antonym is <defnref ref="gql_directed_graph_defn"/>.
</defnNote>
</definition>

<definition id="gql_mixed_graph_defn">
<term>mixed graph</term>
<defn><defnref ref="gql_graph_defn"/> that allows both
<defnref ref="gql_directed_edge_defn" plural="yes"/> and 
<defnref ref="gql_undirected_edge_defn" plural="yes"/></defn>
</definition>

<definition id="gql_empty_graph_defn">
<term>empty graph</term>
<defn><defnref ref="gql_graph_defn"/> with zero <defnref ref="gql_node_defn" plural="yes"/> and zero
<defnref ref="gql_edge_defn" plural="yes"/></defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-09-03 Adjusted</comment>
<comment>WG3:W10-019R1</comment>
<comment>WG3:W21-023</comment>
<comment>WG3:UTC-080</comment>
<definition id="gql_path_defn">
<term>path</term>
<defn><defnref ref="gql_sequence_defn"/> of an odd number of 
<defnref ref="gql_graph_element_defn" plural="yes"/></defn>
<defnNote>A path always starts and ends with a <defnref ref="gql_node_defn"/> and alternates
between nodes and <defnref ref="gql_edge_defn" plural="yes"/> such that each edge resides in the
path between its <defnref ref="gql_endpoint__edge_defn" plural="yes"/>.
See <specref ref="gql_conc_graph_patt_match_paths"/>, for a fuller discussion of paths.
</defnNote>
<defnNote>A path may comprise a single node.
</defnNote>
<defnNote>A node or an edge may be contained multiple times in a path, including via self-loops.
</defnNote>
</definition>

<comment>WG3:W10-019R1</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>WG3:W21-023</comment>
<definition id="gql_subpath_defn">
<term>subpath</term>
<defn><defnref ref="gql_path_defn"/> fully contained in another path</defn>
<defnNote>A subpath may be identical to its containing path.
</defnNote>
</definition>

<comment>Editorial: Stephen Cannan, 2020-11-05</comment>
<comment>WG3:W10-019R1</comment>
<comment>WG3:W12-033: Stefan Plantikow</comment>
<definition id="gql_graph_element_defn">
<term>graph element</term>
<defn><defnref ref="gql_node_defn"/> or <defnref ref="gql_edge_defn"/></defn>
</definition>

<comment>Editorial: Stephen Cannan, 2021-03-31 conform Directives Part 2</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-21 WG3:W20-010 P00-USA-304</comment>
<definition id="gql_node_defn">
<term>node</term>
<term type="admitted">vertex</term>
<defn>fundamental unit of which a <defnref ref="gql_graph_defn"/> is formed</defn>
<defnNote>Plural: nodes or vertices.
</defnNote>
<comment>WG3:UTC-013 P16-DEU-012</comment>
<comment>Editorial: Stephen Cannan, 2023-07-11, Standardize the spelling of keyword</comment>
<defnNote>Both terms, node and vertex, are used in the real world to denote the same concept.
Without judgment or prejudice, this document uses only the term node.
In BNF productions, wherever the keyword <kw>NODE</kw> is allowed,
the keyword <kw>VERTEX</kw> can be used instead.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-02-04</comment>
<comment>Editorial: Stephen Cannan, 2021-03-30 Consistency with SQL/PGQ</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-21 WG3:W20-010 P00-USA-305</comment>
<definition id="gql_edge_defn">
<term>edge</term>
<term type="admitted">relationship</term>
<defn>connection between two <defnref ref="gql_node_defn" plural="yes"/></defn>
<comment>Editorial: Stephen Cannan, 2023-07-11, Standardize the spelling of keyword</comment>
<defnNote>Both terms, edge and relationship, are used in the real world to denote the same concept.
Without judgment or prejudice, this document uses only the term edge.
In BNF productions, wherever the keyword <kw>EDGE</kw> is allowed,
the keyword <kw>RELATIONSHIP</kw> can be used instead.
</defnNote>
</definition>

<comment>Editorial: Stephen Cannan, 2021-03-30 Consistency with SQL/PGQ</comment>
<comment>Editorial</comment>
<definition id="gql_directed_edge_defn">
<term>directed edge</term>
<defn><defnref ref="gql_edge_defn"/> that distinguishes one of its 
<defnref ref="gql_endpoint__edge_defn" plural="yes"/> as its <defnref ref="gql_source_node_defn"/>
and one of its endpoints as its <defnref ref="gql_destination_node_defn"/></defn>
<defnNote>A directed edge expresses a relationship that is asymmetric.
</defnNote>
<defnNote>The antonym is <defnref ref="gql_undirected_edge_defn"/>.
</defnNote>
</definition>

<comment>WG3:W09-036</comment>
<comment>Editorial</comment>
<definition id="gql_undirected_edge_defn">
<term>undirected edge</term>
<defn><defnref ref="gql_edge_defn"/> that does not distinguish between its 
<defnref ref="gql_endpoint__edge_defn" plural="yes"/></defn>
<defnNote>An undirected edge expresses a relationship that is necessarily symmetric.
</defnNote>
<defnNote>The antonym is <defnref ref="gql_directed_edge_defn"/>.
</defnNote>
</definition>
<comment>Editorial: Stefan Plantikow, 2022-02-21 WG3:W20-010 P00-USA-00 Remove: any-directed edge
</comment>

<comment>Editorial: Stefan Plantikow, 2020-09-03 Adjusted</comment>
<comment>Editorial: Stefan Plantikow, 2020-02-04</comment>
<comment>WG3:W09-036</comment>
<comment>WG3:W10-019R1</comment>
<definition id="gql_endpoint__edge_defn" qual="edge">
<term>endpoint</term>
<term type="admitted">incident node</term>
<defnDomain>edge</defnDomain>
<defn>one of the two <defnref ref="gql_node_defn" plural="yes"/> 
connected by an <defnref ref="gql_edge_defn"/></defn>
<defnNote>Both endpoints of an edge may be the same node.
</defnNote>
</definition>

<comment>WG3:W09-036</comment>
<definition id="gql_source_node_defn">
<term>source node</term>
<term type="admitted">start node</term>
<defn><defnref ref="gql_node_defn"/> that is distinguished as the source of 
a <defnref ref="gql_directed_edge_defn"/></defn>
</definition>

<comment>WG3:W09-036</comment>
<definition id="gql_destination_node_defn">
<term>destination node</term>
<term type="admitted">end node</term>
<defn><defnref ref="gql_node_defn"/> that is distinguished as the destination of 
a <defnref ref="gql_directed_edge_defn"/></defn>
</definition>

<comment>WG3:W10-019R1</comment>
<comment>Editorial: Stefan Plantikow, 2021-04-29 Added indefinite article to edge</comment>
<definition id="gql_label_defn">
<term>label</term>
<defn><defnref ref="gql_identifier_defn"/> associated with a <defnref ref="gql_graph_defn"/>, 
a <defnref ref="gql_node_defn"/>, or an <defnref ref="gql_edge_defn"/></defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2021-04-29 Spelled out pair contents</comment>
<comment>WG3:W10-019R1</comment>
<comment>WG3:BER-040R3</comment>
<definition id="gql_property_defn">
<term>property</term>
<defnDomain>GQL-object</defnDomain>
<defn>pair comprising a name and a <defnref ref="gql_value_defn"/></defn>
<comment>WG3:W26-022R2 Removed 1 (one) Note to entry</comment>
<comment>WG3:CMN-072</comment>
<defnNote>See <specref ref="gql_conc_props_and_spvts"/>.
</defnNote>
</definition>

</bodyMatter>

</subClause>


<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>WG3:CMN-061R1</comment>
<subClause id="gql_proc_terms_defns">
<clauseHeading>Procedure and command terms and definitions</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-03-05</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-12 Reworked definition</comment>
<definition id="gql_side_effect_defn">
<term>side effect</term>
<defn>change caused during the <defnref ref="gql_execution_defn"/> of 
a <defnref ref="gql_GQL_request_defn"/> that is detectable by the execution of another 
<defnref ref="gql_operation_defn"/> as part of the execution of the same or another
GQL-request</defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-03-08</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-12 Reworded</comment>
<definition id="gql_catalog_modifying__eff_defn" type="adj" qual="eff">
<term>catalog-modifying</term>
<defnDomain>side effect</defnDomain>
<defn>modifying the <defnref ref="gql_GQL_catalog_defn"/></defn>
</definition>

<definition id="gql_session_modifying__eff_defn" type="adj" qual="eff">
<term>session-modifying</term>
<defnDomain>side effect</defnDomain>
<defn>modifying the <defnref ref="gql_GQL_session_defn"/> and its context</defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-04-08 Reworded</comment>
<comment>WG3:CMN-019 P00-NLD-003</comment>
<definition id="gql_transaction_modifying__eff_defn" type="adj" qual="eff">
<term>transaction-modifying</term>
<defnDomain>side effect</defnDomain>
<defn>manipulating GQL-transactions</defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2021-06-17 Adjusted for removal of existing</comment>
<definition id="gql_data_modifying__eff_defn" type="adj" qual="eff">
<term>data-modifying</term>
<defnDomain>side effect</defnDomain>
<defn>modifying the content of <defnref ref="gql_data_object_defn" plural="yes"/></defn>
</definition>

<comment>WG3:UTC-105</comment>
<definition id="gql_execution_defn">
<term>execution</term>
<defn>computation of a result that may cause 
<defnref ref="gql_side_effect_defn" plural="yes"/></defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-03-10</comment>
<definition id="gql_operation_defn">
<term>operation</term>
<defn>identifiable action carried out by an <defnref ref="gql_execution_defn"/></defn>
<comment>WG3:CMN-072</comment>
<defnNote>See <specref ref="gql_conc_prcmd_ops"/>.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-09-03 Adjusted</comment>
<comment>Editorial: Stefan Plantikow, 2020-03-10</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-07 Reworded for context refactoring</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-09 Avoid term collection</comment>
<comment>Editorial: Stefan Plantikow, 2022-12-19 WG3:W24-009 344. P00-USA-227</comment>
<definition id="gql_execution_context_defn">
<term>execution context</term>
<defn>context comprising objects that are associated with and manipulated by
the <defnref ref="gql_execution_defn"/> of 
<defnref ref="gql_operation_defn" plural="yes"/></defn>
<defnNote>See <specref ref="gql_conc_exe"/>.
</defnNote>
</definition>

<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10 Deleted term - current</comment>

<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>WG3:W24-028</comment>
<definition id="gql_current_execution_context_defn">
<term>current execution context</term>
<defn><defnref ref="gql_execution_context_defn"/> of the 
currently executing <defnref ref="gql_operation_defn"/> of the currently executing 
<defnref ref="gql_procedure_defn"/>, <defnref ref="gql_command_defn"/>,
<defnref ref="gql_statement_defn"/>, or evaluation of an expression</defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-03-10</comment>
<definition id="gql_execution_outcome_defn">
<term>execution outcome</term>
<defn>component of an <defnref ref="gql_execution_context_defn"/>
representing the outcome of an <defnref ref="gql_execution_defn"/></defn>
<defnNote>See <specref ref="gql_conc_exe_outcome"/>.
</defnNote>
</definition>

<definition id="gql_current_execution_outcome_defn">
<term>current execution outcome</term>
<defn><defnref ref="gql_execution_outcome_defn"/> of the 
<defnref ref="gql_current_execution_context_defn"/></defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-03-10</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-10 result object -> result</comment>
<comment>WG3:BER-060</comment>
<comment>WG3:W26-032R1 Consequence</comment>
<definition id="gql_successful_outcome_defn">
<term>successful outcome</term>
<defnDomain>execution context</defnDomain>
<defn><defnref ref="gql_execution_outcome_defn"/> recording a result</defn>
<defnNote>A successful outcome records no exception conditions.
</defnNote>
<defnNote>The antonym is <defnref ref="gql_failed_outcome_defn"/>.
</defnNote>
<defnNote>See <specref ref="gql_conc_exe_outcome"/>.
</defnNote>
</definition>

<comment>WG3:BER-060</comment>
<comment>WG3:W26-032R1 Minuted change</comment>
<definition id="gql_failed_outcome_defn">
<term>failed outcome</term>
<defnDomain>execution context</defnDomain>
<defn><defnref ref="gql_execution_outcome_defn"/> recording an exception condition</defn>
<defnNote>A failed outcome records no result.
</defnNote>
<defnNote>The antonym is <defnref ref="gql_successful_outcome_defn"/>.
</defnNote>
<defnNote>See <specref ref="gql_conc_exe_outcome"/>.
</defnNote>
</definition>

<comment>WG3:W12-019</comment>
<comment>WG3:UTC-064 Consequence</comment>
<definition id="gql_regular_result_defn">
<term>regular result</term>
<defn>result that is a <defnref ref="gql_value_defn"/> or
a <defnref ref="gql_binding_table_defn"/> produced by
the successful <defnref ref="gql_execution_defn"/> of an <defnref ref="gql_operation_defn"/></defn>
<defnNote>See <specref ref="gql_conc_exe_outcome"/>.
</defnNote>
</definition>

<comment>WG3:W12-019</comment>
<definition id="gql_omitted_result_defn">
<term>omitted result</term>
<defn>result indicating the successful <defnref ref="gql_execution_defn"/>
of an <defnref ref="gql_operation_defn"/> that produced no <defnref ref="gql_value_defn"/></defn>
<defnNote>The <defnref ref="gql_declared_type"/> of an omitted result is the empty type.
</defnNote>
<defnNote>See <specref ref="gql_conc_exe_outcome"/>.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-05-19 Parameter terminology reform</comment>
<definition id="gql_result_type_defn">
<term>result type</term>
<defn><defnref ref="gql_data_type_defn"/> of a result</defn>
</definition>

<definition id="gql_current_execution_result_defn">
<term>current execution result</term>
<defn>result of the <defnref ref="gql_current_execution_outcome_defn"/></defn>
<defnNote>See <specref ref="gql_conc_exe_outcome"/>.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-10-10 result graph</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-10 result table</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-10 result value</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<definition id="gql_evaluation_defn">
<term>evaluation</term>
<defn>computation of a result that is not permitted to cause 
<defnref ref="gql_side_effect_defn" plural="yes"/></defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-03-09</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-08 Added -modifying to term</comment>
<comment>WG3:W22-054</comment>
<comment>WG3:W23-009R1 P00-USA-242</comment>
<comment>WG3:UTC-105</comment>
<definition id="gql_catalog_mod_procedure_defn">
<term>catalog-modifying procedure</term>
<defn><defnref ref="gql_procedure_defn"/> whose <defnref ref="gql_execution_defn"/> can cause
<defnref ref="gql_catalog_modifying__eff_defn"/> <defnref ref="gql_side_effect_defn" plural="yes"/>
only or catalog-modifying side effects together with <defnref ref="gql_data_modifying__eff_defn"/> 
side effects</defn>
</definition>

<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>WG3:UTC-105</comment>
<definition id="gql_data_mod_procedure_defn">
<term>data-modifying procedure</term>
<defn><defnref ref="gql_procedure_defn"/> whose <defnref ref="gql_execution_defn"/> can cause
<defnref ref="gql_data_modifying__eff_defn"/> <defnref ref="gql_side_effect_defn" plural="yes"/>
only</defn>
</definition>
<comment>Editorial: Stefan Plantikow, 2023-02-20 Deleted 1 (one) unused term</comment>

<comment>Editorial: Stefan Plantikow, 2020-04-08 Reworded</comment>
<comment>Editorial: Stefan Plantikow, 2020-03-08</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<definition id="gql_procedure_defn">
<term>procedure</term>
<defn>description of a computation on input arguments whose 
<defnref ref="gql_execution_defn"/> computes an <defnref ref="gql_execution_outcome_defn"/> and 
optionally causes <defnref ref="gql_side_effect_defn" plural="yes"/></defn>
<defnNote>See <specref ref="gql_conc_prcmd_procs"/>.
</defnNote>
</definition>

<comment>Email from: Nathalie Charbel, 2023-03-01 1050 Deleted 1 (one) definition</comment>

<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>WG3:W22-054</comment>
<definition id="gql_query_defn">
<term>query procedure</term>
<defn><defnref ref="gql_procedure_defn"/> whose <defnref ref="gql_execution_defn"/> 
does not cause any <defnref ref="gql_side_effect_defn" plural="yes"/></defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-04-08 Reworded</comment>
<comment>Editorial: Stefan Plantikow, 2020-03-10</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>WG3:W21-010 P00-USA-377</comment>
<comment>WG3:BER-086R1</comment>
<comment>WG3:CMN-019 P00-USA-280</comment>
<comment>WG3:CMN-061R1</comment>
<definition id="gql_command_defn">
<term>command</term>
<defn><defnref ref="gql_operation_defn"/> that is not specified by 
a <defnref ref="gql_gql_procedure_defn"/></defn>
<defnNote>See <specref ref="gql_conc_prcmd_cmds"/>.
</defnNote>
</definition>

<comment>Editorial: Stephen Cannan, 2020-05-18 GQL- prefix reduction</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>WG3:UTC-105</comment>
<definition id="gql_session_command_defn">
<term>session command</term>
<defn><defnref ref="gql_command_defn"/> that can only perform 
<defnref ref="gql_session_modifying__eff_defn"/>
<defnref ref="gql_side_effect_defn" plural="yes"/></defn>
</definition>

<comment>Editorial: Stephen Cannan, 2020-05-18 GQL- prefix reduction</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>WG3:UTC-105</comment>
<definition id="gql_transaction_command_defn">
<term>transaction command</term>
<defn><defnref ref="gql_command_defn"/> that can only perform 
<defnref ref="gql_transaction_modifying__eff_defn"/>
<defnref ref="gql_side_effect_defn" plural="yes"/></defn>
</definition>

<comment>WG3:CMN-042 Removed 4 (four) terms</comment>

<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>WG3:BER-086R1</comment>
<definition id="gql_gql_procedure_defn">
<term>GQL-procedure</term>
<defn><defnref ref="gql_procedure_defn"/> written in the GQL language</defn>
</definition>

<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<definition id="gql_external_procedure_defn">
<term>external procedure</term>
<defn><defnref ref="gql_procedure_defn"/> provided via an <impDef annex="no" code="None"/> 
mechanism</defn>
</definition>

<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<definition id="gql_statement_defn">
<term>statement</term>
<defn><defnref ref="gql_operation_defn"/> executed as part of executing 
a <defnref ref="gql_procedure_defn"/> that updates the
<defnref ref="gql_current_execution_context_defn"/> and its
<defnref ref="gql_current_execution_outcome_defn"/> and that can cause 
<defnref ref="gql_side_effect_defn" plural="yes"/></defn>
</definition>

</bodyMatter>

</subClause>


<comment>WG3:CMN-061R1</comment>
<subClause id="gql_proc_syntax_terms_defns">
<clauseHeading>General syntax terms and definitions</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-10-12 Added and adjusted scope from FND</comment>
<comment>WG3:W19-017 Stefan Plantikow, 2022-01-26 1306 </comment>
<comment>Editorial: Stefan Plantikow, 2022-03-30 WG3:RKE-10 P00-USA-502</comment>
<definition id="gql_scope__name_defn">
<term>scope</term>
<defnDomain>name</defnDomain>
<defn>one or more BNF non-terminal symbols within which a name is effective</defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-10-12 Added and adjusted scope from FND</comment>
<comment>WG3:W19-017 Stefan Plantikow, 2022-01-26 1306 </comment>
<comment>Editorial: Stefan Plantikow, 2022-03-30 WG3:RKE-10 P00-USA-502</comment>
<definition id="gql_scope__wo_defn">
<term>scope</term>
<defnDomain>working object</defnDomain>
<defn>one or more BNF non-terminal symbols within which a working object is available</defn>
</definition>

<comment>WG3:W19-017</comment>
<comment>Editorial: Stefan Plantikow, 2022-03-30 WG3:RKE-10 P00-USA-502</comment>
<definition id="gql_scope_clause__name_defn">
<term>scope clause</term>
<defnDomain>name</defnDomain>
<defn>BNF non-terminal symbol used in defining the <defnref ref="gql_scope__name_defn"/> of the
introduced name</defn>
</definition>

<comment>WG3:W19-017</comment>
<comment>Editorial: Stefan Plantikow, 2022-03-30 WG3:RKE-10 P00-USA-502</comment>
<definition id="gql_scope_clause__wo_defn">
<term>scope clause</term>
<defnDomain>working object</defnDomain>
<defn>BNF non-terminal symbol used in defining the <defnref ref="gql_scope__wo_defn"/> of the
declared working object</defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2022-03-30 0932 WG3:RKE-010 P00-USA-332</comment>
<definition id="gql_namespace_defn">
<term>namespace</term>
<defn>classification scheme that permits a given name to identify multiple objects that are
distinguished by context</defn>
</definition>

<comment>WG3:RKE-048</comment>
<comment>WG3:W25-031R2</comment>
<definition id="gql_assignment_defn">
<term>assignment</term>
<defn>operation whose effect is to ensure that the value at
a <defnref ref="gql_site_defn"/> <symdef>T</symdef> (known as the target) is identical to
a given value <symdef>S</symdef> (known as the source) or a representative of <sym>S</sym> 
obtained using relevant type conversions</defn>
<defnNote>There are two kinds of assignment, regular assignment and store assignment.
Assignment is regular assignment by default and frequently indicated by using the phrases 
<quote><sym>T</sym> is assigned to <sym>S</sym></quote>, 
<quote>the value of <sym>T</sym> is assigned to <sym>S</sym></quote>, or 
<quote>the value of <sym>S</sym> assigned from <sym>T</sym></quote>. 
Store assignment is indicated by explicitly calling the General Rules of 
<specref ref="gql_store"/>.
See <specref ref="gql_conc_ass_mut"/>.
</defnNote>
<defnNote>If <sym>S</sym> is not included in the <defnref ref="gql_declared_type"/> 
<symdef>DT</symdef> of <sym>T</sym>,
then the result of converting <sym>S</sym> to <sym>DT</sym> obtained using relevant type 
conversions is assigned to <sym>T</sym> (instead of <sym>S</sym>). 
See <specref ref="gql_conc_ass_mut"/>.
</defnNote>
<defnNote>GQL-objects are inserted or removed (<eg/> into the GQL-schema or other GQL-objects)
but never assigned. 
However, reference values to GQL-objects are subject to provisions regarding assignment.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-02-04</comment>
<comment>WG3:W12-029: Stefan Plantikow, 2021-06-17 Adjusted X</comment>
<definition id="gql_instance__x_defn" qual="x">
<term>instance</term>
<defnDomain><quote>X</quote> instance</defnDomain>
<defn>physical representation of an <quote>X</quote></defn>
<defnNote>Each instance is at exactly one <defnref ref="gql_site_defn"/>.
An <quote>X</quote> instance has a type that is the type of <quote>X</quote>.
</defnNote>
</definition>

<comment>WG3:UTC-110</comment>
<comment>WG3:CMN-042</comment>
<definition id="gql_site_defn">
<term>site</term>
<defn>place occupied by an <defnref ref="gql_instance__x_defn"/> of a specified data type</defn>
<comment>WG3:CMN-072</comment>
<defnNote>See <specref ref="gql_conc_sites"/>.
</defnNote>
</definition>
<comment>Editorial: Stefan Plantikow, 2022-02-16 WG3:W20-010 P00-USA-020 Term literal removed
</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-16 WG3:W20-010 P00-USA-021 Term opaque removed
</comment>

<comment>Editorial: Stefan Plantikow, 2020-09-03 Adjusted</comment>
<comment>WG3:UTC-087R2</comment>
<definition id="gql_pattern_defn">
<term>pattern</term>
<defn>syntax for specifying requirements on the on the bindings of variables</defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2021-06-17 Adjusted X</comment>
<definition id="gql_pattern_variable__x_defn" qual="x">
<term>pattern variable</term>
<defnDomain><quote>X</quote> pattern variable</defnDomain>
<defn><quote>X</quote> <defnref ref="gql_variable__x_defn"/> that is
declared in an <quote>X</quote> <defnref ref="gql_pattern_defn"/></defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-09-03 Adjusted</comment>
<comment>Editorial: Stefan Plantikow, 2020-02-04</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-09 Avoid collection</comment>
<comment>WG3:UTC-087R2</comment>
<definition id="gql_pattern_match_defn">
<term>pattern match</term>
<defn><defnref ref="gql_pattern_variable__x_defn"/> bindings fulfilling the requirements imposed by 
a <defnref ref="gql_pattern_defn"/></defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-09-04 Reworded</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-17 Reworded</comment>
<definition id="gql_linear_composition_defn">
<term>linear composition</term>
<defn>composition of a <defnref ref="gql_sequence_defn"/> of suboperations that forms 
a <defnref ref="gql_composite_defn"/> <defnref ref="gql_operation_defn"/> that 
effectively executes the suboperations in the order given by the sequence</defn>
<defnNote>The linear composition of operations over binding tables corresponds to
a left lateral join between those tables.
</defnNote>
</definition>

<definition id="gql_whitespace_defn">
<term>whitespace</term>
<defn><defnref ref="gql_sequence_defn"/> of one or more characters that have the Unicode property
White_Space</defn>
<defnNote>Whitespace is typically used to separate <BNF name="non-delimiter token"/>s from one
another, and is always permitted between two tokens in text written in the GQL language.
</defnNote>
<comment>WG3:CMN-072</comment>
<defnNote>See <specref ref="gql_token"/>.
</defnNote>
</definition>

</bodyMatter>

</subClause>


<comment>WG3:UTC-087R2</comment>
<subClause id="gql_gp_terms_defns">
<clauseHeading>Graph pattern terms and definitions</clauseHeading>

<bodyMatter>

<comment>WG3:SXM-052</comment>
<comment>WG3:W10-019R1</comment>
<comment>WG3:BER-031</comment>
<definition id="gql_edge_variable_defn">
<term>edge variable</term>
<defn><defnref ref="gql_element_variable_defn"/> that is declared in 
an <defnref ref="gql_edge_pattern_defn"/></defn>
<defnNote>An edge variable may be bound to a list of <defnref ref="gql_edge_defn" plural="yes"/>.
</defnNote>
</definition>

<comment>WG3:SXM-052</comment>
<comment>Editorial: Stephen Cannan, 2021-03-30 Use correct term</comment>
<comment>WG3:W12-033: Stefan Plantikow</comment>
<comment>WG3:BER-031</comment>
<comment>WG3:UTC-087R2</comment>
<definition id="gql_element_variable_defn">
<term>element variable</term>
<term type="admitted">primary variable</term>
<defn><defnref ref="gql_pattern_variable__x_defn"/> that may be bound to a list of 
<defnref ref="gql_graph_element_defn" plural="yes"/></defn>
<defnNote>An element variable is either a <defnref ref="gql_node_variable_defn"/> or
an <defnref ref="gql_edge_variable_defn"/>.
</defnNote>
</definition>

<comment>WG3:SXM-052</comment>
<comment>Email from: Fred Zemke, 2020-07-21</comment>
<definition id="gql_graph_pattern_variable_defn">
<term>graph pattern variable</term>
<defn><defnref ref="gql_path_variable_defn"/>, <defnref ref="gql_subpath_variable_defn"/> or
<defnref ref="gql_element_variable_defn"/></defn>
</definition>

<comment>WG3:SXM-052</comment>
<comment>WG3:W09-016</comment>
<comment>WG3:W10-019R1</comment>
<comment>WG3:BER-031</comment>
<definition id="gql_node_variable_defn">
<term>node variable</term>
<defn><defnref ref="gql_element_variable_defn"/> that is declared in 
a <defnref ref="gql_node_pattern_defn"/></defn>
<defnNote>A node variable may be bound to a list of <defnref ref="gql_node_defn" plural="yes"/>.
</defnNote>
</definition>

<comment>WG3:SXM-052</comment>
<comment>Editorial: Stephen Cannan, 2021-01-30</comment>
<comment>WG3:BER-031</comment>
<comment>WG3:UTC-055R1</comment>
<comment>WG3:UTC-087R2</comment>
<definition id="gql_path_variable_defn">
<term>path variable</term>
<defn><defnref ref="gql_pattern_variable__x_defn"/> that is declared at the head of 
a <BNF name="path pattern"/></defn>
<defnNote>A path variable can be bound to a path binding that is matched by 
a <defnref ref="gql_path_pattern_defn"/>.
See <specref ref="gql_machinery_graph_pattern_matching"/>, for more details.
</defnNote>
<defnNote>The extracted path of the path binding is a <defnref ref="gql_path_defn"/>.
</defnNote>
<defnNote>Extracted path and path binding are defined in 
<specref ref="gql_machinery_graph_pattern_matching"/>.
</defnNote>
</definition>

<comment>WG3:SXM-052</comment>
<comment>Editorial: Stephen Cannan, 2021-03-31 Use defined terms</comment>
<comment>WG3:BER-031</comment>
<comment>WG3:UTC-087R2</comment>
<definition id="gql_subpath_variable_defn">
<term>subpath variable</term>
<defn><defnref ref="gql_pattern_variable__x_defn"/> that is declared at the head of 
a <BNF name="parenthesized path pattern expression"/></defn>
</definition>

<comment>WG3:W10-019R1</comment>
<definition id="gql_graph_pattern_defn">
<term>graph pattern</term>
<defn><defnref ref="gql_set_defn"/> of one or more 
<defnref ref="gql_path_pattern_defn" plural="yes"/></defn>
</definition>

<comment>WG3:W10-019R1</comment>
<comment>WG3:UTC-055R1</comment>
<definition id="gql_path_pattern_defn">
<term>path pattern</term>
<defn><defnref ref="gql_pattern_defn"/> that matches a <defnref ref="gql_path_defn"/></defn>
</definition>

<comment>Editorial: Stephen Cannan, 2020-11-05</comment>
<comment>Editorial: Stephen Cannan, 2021-03-30 Align with SQL/PGQ</comment>
<definition id="gql_element_pattern_defn">
<term>element pattern</term>
<defn><defnref ref="gql_node_pattern_defn"/> or <defnref ref="gql_edge_pattern_defn"/></defn>
</definition>

<comment>WG3:W09-016</comment>
<definition id="gql_node_pattern_defn">
<term>node pattern</term>
<defn><defnref ref="gql_path_pattern_defn"/> that matches a single
<defnref ref="gql_node_defn"/></defn>
</definition>

<comment>WG3:W09-016</comment>
<definition id="gql_edge_pattern_defn">
<term>edge pattern</term>
<defn><defnref ref="gql_path_pattern_defn"/> that matches a single 
<defnref ref="gql_edge_defn"/></defn>
</definition>

<comment>Editorial: Stephen Cannan, 2021-02-01</comment>
<comment>Editorial: Stephen Cannan, 2021-03-31 conform Directives Part 2</comment>
<comment>WG3:UTC-055R1</comment>
<definition id="gql_label_expression_defn">
<term>label expression</term>
<defn>expression composed from <defnref ref="gql_label_defn"/> names 
using disjunction, conjunction, and negation</defn>
<defnNote>Disjunction, conjunction, and negation are denoted respectively by a vertical bar 
<quote>|</quote>, ampersand <quote>&amp;</quote> and exclamation mark <quote>!</quote>, 
with parentheses for grouping.
See <specref ref="gql_label_expr"/> for more details.
</defnNote>
</definition>

</bodyMatter>

</subClause>


<subClause id="gql_val_terms_defns">
<clauseHeading>Value terms and definitions</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2021-06-17 Adjusted X</comment>
<comment>Editorial: Stefan Plantikow, 2021-06-17 WG3:W12-029</comment>
<definition id="gql_value_defn">
<term>value</term>
<defnDomain><quote>X</quote> value</defnDomain>
<defn>definite, immutable, and irreducible unit of data of some type
<quote>X</quote></defn>
<defnNote>Values stand for themselves.
The identity of a value is independent of where it occurs.
</defnNote>
<defnNote>Values are not <defnref ref="gql_object___x_defn" plural="yes"/>.
</defnNote>
<comment>WG3:CMN-072</comment>
<defnNote>See <specref ref="gql_conc_val"/>.
</defnNote>
</definition>

<comment>WG3:W21-058</comment>
<comment>WG3:W24-037</comment>
<comment>WG3:CMN-057R1</comment>
<comment>WG3:W26-024</comment>
<definition id="gql_comparable_defn" type="adj">
<term>comparable</term>
<defnDomain>pair of values</defnDomain>
<defn>capable of being compared</defn>
<defnNote><defnref ref="gql_comparable__dt_defn"/> defines the same term for
value types.
</defnNote>
<defnNote>Whether a pair of values is capable of being compared is either determined
by the provisions of <specref ref="gql_conc"/> regarding value types or by
the presence of support for <feature code="GA04"/>.
See <specref ref="gql_conc_val_comp"/>.
</defnNote>
</definition>

<comment>WG3:RKE-048</comment>
<definition id="gql_identical__vals_defn" type="adj" qual="vals">
<term>identical</term>
<defnDomain>pair of values</defnDomain>
<defn>indistinguishable, in the sense that it is impossible, by any means specified in
this document, to detect any difference between them</defn>
<defnNote>For the full definition, see <specref ref="gql_identical_vals"/>.
</defnNote>
</definition>

<comment>WG3:UTC-050</comment>
<definition id="gql_distinct__vals_defn" type="adj" qual="vals">
<term>distinct</term>
<defnDomain>pair of values</defnDomain>
<defn>capable of being distinguished within a given context</defn>
<defnNote>Informally, two values are distinct if neither is null and the values are not equal.
A null value and a material value are distinct.
Two null values are not distinct.
See <specref ref="gql_conc_dt_props_of_distinct"/>, and the General Rules of
<specref ref="gql_distinct_vals"/>.
</defnNote>
</definition>

<comment>WG3:UTC-050</comment>
<definition id="gql_duplicates">
<term>duplicates</term>
<defn>two or more values that are not <defnref ref="gql_distinct__vals_defn"/></defn>
</definition>

<comment>WG3:CMN-019 P00-NLD-001</comment>
<definition id="gql_reference_value_defn">
<term>reference value</term>
<defn><defnref ref="gql_value_defn"/> that describes a globally resolved reference to 
a <defnref ref="gql_GQL_object_defn"/></defn>
<comment>WG3:CMN-072</comment>
<defnNote>See <specref ref="gql_conc_ref_vals"/>.
</defnNote>
</definition>

<definition id="gql_material__val_defn" type="adj" qual="val">
<term>material</term>
<defnDomain>value</defnDomain>
<defn>not the <defnref ref="gql_null_value_defn"/></defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2021-06-17 WG3:W12-029</comment>
<comment>WG3:W23-037</comment>
<definition id="gql_null_value_defn">
<term>null value</term>
<defn>special <defnref ref="gql_value_defn"/> that is used to
indicate the absence of other data</defn>
<defnNote>See <specref ref="gql_conc_material_vals"/>.
</defnNote>
</definition>
<comment>WG3:BER-019</comment>

<comment>WG3:W26-022R2 Removed 1 (one) definition</comment>

<comment>Editorial: Stefan Plantikow, 2020-10-14 Introduced static variable</comment>
<comment>WG3:RKE-018</comment>
<comment>WG3:BER-019 Two definitions deleted</comment>

<comment>Editorial: Stefan Plantikow, 2020-10-14 Clarified definition</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-17 Add binding variable</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-18 parameter terminology reform</comment>
<comment>WG3:BER-019</comment>
<comment>WG3:UTC-087R2</comment>
<definition id="gql_binding_variable_defn">
<term>binding variable</term>
<defnDomain>execution context</defnDomain>
<comment>WG3:UTC-087R2</comment>
<comment>WG3:CMN-042</comment>
<defn><defnref ref="gql_variable__x_defn"/> assigned to the identified 
<defnref ref="gql_field_defn"/> of the working record or the identified 
fields of the records of the working table of a given execution context</defn>
<comment>Editorial: Stefan Plantikow, 2023-03-09 Improve wording</comment>
<defnNote>A binding variable never identifies both a field of the working record and fields of the
records of the working table of a given execution context since the record types of the working 
record and the working table of an execution context are always field name-disjoint.
</defnNote>
<defnNote><BNF name="binding variable reference"/>s are resolved to fields of the current working 
record only.
</defnNote>
<comment>WG3:CMN-072</comment>
<defnNote>See <specref ref="gql_conc_prcmd_gql_vars_and_params"/>.
</defnNote>
</definition>

<comment>WG3:BER-019</comment>
<comment>WG3:W23-029R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Correct definition</comment>
<definition id="gql_graph_variable_defn">
<term>graph variable</term>
<defn><defnref ref="gql_binding_variable_defn"/> whose <defnref ref="gql_declared_type"/> is 
a <defnref ref="gql_graph_defn"/> <defnref ref="gql_reference_value_type_defn"/></defn>
</definition>

<comment>WG3:BER-019</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Correct definition</comment>
<definition id="gql_binding_table_variable_defn">
<term>binding table variable</term>
<defn><defnref ref="gql_binding_variable_defn"/> whose <defnref ref="gql_declared_type"/> is 
a <defnref ref="gql_binding_table_defn"/> <defnref ref="gql_reference_value_type_defn"/></defn>
</definition>

<comment>WG3:BER-019</comment>
<definition id="gql_value_variable_defn">
<term>value variable</term>
<defn><defnref ref="gql_binding_variable_defn"/> whose <defnref ref="gql_declared_type"/> is 
a <defnref ref="gql_value_type_defn"/></defn>
</definition>
<comment>WG3:CMN-061R1 Removed 2 (two) terms</comment>
<comment>WG3:BER-019 Definition deleted</comment>

<comment>Editorial: Stefan Plantikow, 2020-02-06</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-06</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:W09-021R1</comment>
<comment>WG3:UTC-086R1</comment>
<definition id="gql_binding_table_defn">
<term>binding table</term>
<defn><defnref ref="gql_primary_object_defn"/> comprising a collection of zero 
or more (possibly duplicate) records of the same <defnref ref="gql_record_type_defn"/></defn>
<defnNote>See <specref ref="gql_conc_bt"/>, and <specref ref="gql_conc_btt"/>.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-04-17 Adjusted</comment>
<definition id="gql_record_defn">
<term>record</term>
<defn><defnref ref="gql_value_defn"/> of a <defnref ref="gql_record_type_defn"/>; 
possibly empty <defnref ref="gql_set_defn"/> of <defnref ref="gql_field_defn" plural="yes"/></defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2021-04-29 Spelled out pair contents</comment>
<comment>WG3:BER-040R3</comment>
<definition id="gql_field_defn">
<term>field</term>
<defnDomain>record</defnDomain>
<defn>pair comprising a name and a value</defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-03-10</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-06</comment>
<comment>WG3:W11-013</comment>
<comment>WG3:BER-019 Two definitions deleted</comment>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19</comment>
<comment>WG3:CMN-019 P00-ISO-011</comment>
<definition id="gql_byte_string_defn">
<term>byte string</term>
<defn>element of the byte string type</defn>
</definition>

<comment>WG3:CMN-019 P00-ISO-012</comment>
<definition id="gql_character_string_defn">
<term>character string</term>
<defn>element of the character string type</defn>
</definition>

<comment>Alignment with Directives Part 2 2018</comment>
<comment>WG3:W23-009R1 P00-CAN-004</comment>
<comment>WG3:UTC-013 P02-ISO-009</comment>
<comment>WG3:CMN-019 P00-ISO-013</comment>
<comment>WG3:CMN-057R1</comment>
<definition id="gql_collation_defn">
<term>collation</term>
<defn>process by which, given two strings, it is determined whether the first one is less than, 
equal to, or greater than the second one</defn>
<defnNote>See <specref ref="gql_collation"/>.
</defnNote>
<defnSource><docref ref="ISO14651_2020"/><defnSection>3.7</defnSection></defnSource>
</definition>

</bodyMatter>

</subClause>


<subClause id="gql_ty_terms_defns">
<clauseHeading>Type terms and definitions</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-04-12 Sketch declared type</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>WG3:BER-019</comment>
<comment>WG3:UTC-051</comment>
<comment>WG3:UTC-096R1</comment>
<comment>WG3:CMN-019 P00-ISO-001</comment>
<comment>WG3:CMN-035</comment>
<definition id="gql_declared_type">
<term>declared type</term>
<!-- defnDomain>site or a BNF non-terminal instance specifying an operation</defnDomain -->
<defn>unique <defnref ref="gql_data_type_defn"/> common to every 
<defnref ref="gql_instance__x_defn"/> that may be assigned to a given <defnref ref="gql_site_defn"/>
or that can result from <defnref ref="gql_execution_defn"/> or <defnref ref="gql_evaluation_defn"/>
of the <defnref ref="gql_operation_defn"/> specified by a given BNF non-terminal instance</defn>
<comment>WG3:W26-026R2</comment>
<defnNote>For every BNF non-terminal instance <symdef>NT</symdef> has an execution outcome, 
if and only if <sym>NT</sym> has an omitted result, the declared type of <sym>NT</sym> is 
the empty type.
See <specref ref="gql_immat_null_empty_dts"/>.
</defnNote>
<defnNote>See <specref ref="gql_conc_nullability"/>, regarding additional provisions for
determining the nullability of declared types.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-02-04</comment>
<comment>Editorial: Stefan Plantikow, 2020-03-11</comment>
<comment>WG3:W12-029: Stefan Plantikow, 2021-06-17</comment>
<comment>WG3:UTC-015</comment>
<definition id="gql_data_type_defn">
<term>data type</term>
<defn><defnref ref="gql_set_defn"/> of elements with shared characteristics representing data</defn>
<defnNote><passage id="gql_type_defnote">A data type characterizes the sites that may be 
occupied by instances of its elements.</passage>
See <specref ref="gql_conc_dt"/>.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2021-06-17 One editor's note removed</comment>
<comment>WG3:W12-029: Stefan Plantikow, 2021-06-17 taxonomic data type</comment>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-17</comment>
<comment>WG3:RKE-048</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<definition id="gql_supertype__x_defn" qual="x">
<term>supertype</term>
<defnDomain><quote>X</quote> supertype</defnDomain>
<defn>containing all elements of some data type or base type <quote>X</quote></defn>
<comment>Editorial: Stefan Plantikow 2023-03-06 </comment>
<defnNote>If <symdef>T1</symdef> is a supertype of <symdef>T2</symdef> and
<sym>T1</sym> and <sym>T2</sym> are not compatible, then <sym>T1</sym> is
a proper supertype of <sym>T2</sym>
(<quote>compatible</quote> is defined in <specref ref="gql_conc_add_term_dt"/>).
</defnNote>
<defnNote>The antonym is <defnref ref="gql_subtype__x_defn"/>.
</defnNote>
</definition>

<comment>WG3:RKE-048</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<definition id="gql_subtype__x_defn" qual="x">
<term>subtype</term>
<defnDomain><quote>X</quote> subtype</defnDomain>
<defn>comprising only elements contained in some data type or base type <quote>X</quote></defn>
<comment>Editorial: Stefan Plantikow 2023-03-06 </comment>
<defnNote>If <symdef>T2</symdef> is a subtype of <symdef>T1</symdef> and
<sym>T1</sym> and <sym>T2</sym> are not compatible, then <sym>T2</sym> is
a proper subtype of <sym>T1</sym>
(<quote>compatible</quote> is defined in <specref ref="gql_conc_add_term_dt"/>).
</defnNote>
<defnNote>The antonym is <defnref ref="gql_supertype__x_defn"/>.
</defnNote>
</definition>

<comment>WG3:RKE-048</comment>
<comment>WG3:UTC-015</comment>
<definition id="gql_base_type_defn">
<term>base type</term>
<defn>set of <defnref ref="gql_data_type_defn" plural="yes"/> with shared characteristics</defn>
<defnNote>See <specref ref="gql_conc_dt_genintro"/>.
</defnNote>
</definition>

<comment>WG3:UTC-015</comment>
<comment>WG3:W25-031R2</comment>
<comment>WG3:CMN-057R1</comment>
<definition id="gql_assignable__dt_defn" type="adj">
<term>assignable</term>
<defnDomain>of data type, taken pairwise</defnDomain>
<defn>characteristic of a value type <sym>T1</sym> that permits a value of <sym>T1</sym> to be 
assigned to a site of a specified value type <sym>T2</sym> using relevant type conversions, 
where <sym>T1</sym> and <sym>T2</sym> may be the same value type</defn>
<defnNote>By default, provisions on the <defnref ref="gql_assignment_defn"/> of values of 
individual value types and related type conversions are considered, as specified in
<specref ref="gql_conc_dyn_union_type"/>, <specref ref="gql_conc_constr"/>, and
<specref ref="gql_conc_vt_predef"/>.
</defnNote>
</definition>

<comment>WG3:W26-024</comment>
<comment>Email from: Nathalie Charbel, 2023-11-20 1628 WG3 W26</comment>
<definition id="gql_comparable__dt_defn" type="adj">
<term>comparable</term>
<defnDomain>pair of value types</defnDomain>
<defn>comprising only pairwise comparable values</defn>
<defnNote><defnref ref="gql_comparable_defn"/> defines the same term for values.
See <specref ref="gql_conc_val_comp"/>.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-09-04 Reworded</comment>
<comment>WG3:W12-029: Stefan Plantikow, 2021-06-17</comment>
<definition id="gql_constructed__dt_defn" type="adj" qual="dt">
<term>constructed</term>
<defnDomain>data type</defnDomain>
<defn>comprising <defnref ref="gql_composite_defn"/> elements</defn>
</definition>

<definition id="gql_predefined__dt_defn" type="adj" qual="dt">
<term>predefined</term>
<defnDomain>data type</defnDomain>
<defn><defnref ref="gql_atomic__dt_defn"/> and provided by the GQL-implementation</defn>
</definition>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-17</comment>
<comment>WG3:BER-074</comment>
<definition id="gql_atomic__dt_defn" type="adj" qual="dt">
<term>atomic</term>
<defnDomain>data type</defnDomain>
<defn>comprising only values that are not composed of values of other data types</defn>
</definition>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-17</comment>
<definition id="gql_material__dt_defn" type="adj" qual="dt">
<term>material</term>
<defnDomain>data type</defnDomain>
<defn>excluding the <defnref ref="gql_null_value_defn"/></defn>
<defnNote>The antonym is <defnref ref="gql_nullable__dt_defn"/>.
</defnNote>
<comment>WG3:W26-026R2</comment>
<defnNote>See <specref ref="gql_conc_mat_null_immat_dts"/>.
</defnNote>
</definition>

<definition id="gql_nullable__dt_defn" type="adj" qual="dt">
<term>nullable</term>
<defnDomain>data type</defnDomain>
<defn>including the <defnref ref="gql_null_value_defn"/></defn>
<defnNote>The antonym is <defnref ref="gql_material__dt_defn"/>.
</defnNote>
<comment>WG3:W26-026R2</comment>
<defnNote>See <specref ref="gql_conc_mat_null_immat_dts"/>.
</defnNote>
</definition>

<comment>WG3:W26-026R2</comment>
<definition id="gql_immaterial__dt_defn" type="adj">
<term>immaterial</term>
<defnDomain>data type</defnDomain>
<defn>excluding <defnref ref="gql_material__dt_defn"/> values</defn>
<defnNote>See <specref ref="gql_conc_mat_null_immat_dts"/>.
</defnNote>
</definition>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-17</comment>
<comment>Consequence of WG3:W23-037</comment>
<comment>WG3:UTC-111</comment>
<definition id="gql_object_type_defn">
<term>GQL-object type</term>
<defn><defnref ref="gql_data_type_defn"/> comprising 
<defnref ref="gql_GQL_object_defn" plural="yes"/></defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-09-04 Reworded</comment>
<definition id="gql_graph_type_defn">
<term>graph type</term>
<defn><defnref ref="gql_object_type_defn"/> describing 
a <defnref ref="gql_graph_defn"/> in terms of restrictions on its labels, properties, nodes, edges, 
and topology</defn>
<defnNote>See <specref ref="gql_conc_gt"/>.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2020-04-06</comment>
<definition id="gql_binding_table_type_defn">
<term>binding table type</term>
<defn><defnref ref="gql_object_type_defn"/> of every 
<defnref ref="gql_binding_table_defn"/> of a specified <defnref ref="gql_record_type_defn"/></defn>
<defnNote>See <specref ref="gql_conc_btt"/>.
</defnNote>
</definition>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-17</comment>
<comment>WG3:BER-019</comment>
<comment>WG3:CMN-057R1</comment>
<definition id="gql_value_type_defn">
<term>value type</term>
<defn><defnref ref="gql_data_type_defn"/> comprising
<defnref ref="gql_value_defn" plural="yes"/></defn>
<defnNote>See <specref ref="gql_conc_dyn_union_type"/>, <specref ref="gql_conc_constr"/>, and
<specref ref="gql_conc_vt_predef"/>.
</defnNote>
</definition>

<definition id="gql_reference_value_type_defn">
<term>reference value type</term>
<defn><defnref ref="gql_value_type_defn"/> comprising
<defnref ref="gql_reference_value_defn" plural="yes"/></defn>
</definition>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-17</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-17 Adjusted</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-019 P00-NLD-002</comment>
<comment>WG3:W26-026R2</comment>
<definition id="gql_property_value_type_defn">
<term>supported property value type</term>
<defn>non-empty <defnref ref="gql_value_type_defn"/> that is supported as the type of
a <defnref ref="gql_property_defn"/> value</defn>
<defnNote>See <specref ref="gql_conc_props_and_spvts"/>.
</defnNote>
</definition>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-30 Deleted "content type"</comment>

<comment>Editorial: Stefan Plantikow, 2020-04-06</comment>
<definition id="gql_column_name_defn">
<term>column name</term>
<defn><defnref ref="gql_field_defn"/> name of a <defnref ref="gql_column_defn"/></defn>
</definition>

<definition id="gql_column_type_defn">
<term>column type</term>
<defn><defnref ref="gql_field_defn"/> <defnref ref="gql_value_type_defn"/> of 
a <defnref ref="gql_column_defn"/></defn>
</definition>

<comment>WG3:BER-019</comment>
<definition id="gql_column_defn">
<term>column</term>
<defn><defnref ref="gql_field_type_defn"/> of the <defnref ref="gql_record_type_defn"/> of 
a <defnref ref="gql_binding_table_type_defn"/></defn>
</definition>

<comment>WG3:W09-021R1</comment>
<comment>WG3:BER-019</comment>
<definition id="gql_record_type_defn">
<term>record type</term>
<defn><defnref ref="gql_value_type_defn"/> that describes the 
<defnref ref="gql_set_defn"/> of <defnref ref="gql_field_defn" plural="yes"/> of 
a <defnref ref="gql_record_defn"/> in terms of their <defnref ref="gql_field_type_defn"/></defn>
<defnNote>See <specref ref="gql_conc_record"/>.
</defnNote>
</definition>

<comment>Editorial: Stefan Plantikow, 2021-04-29 Spelled out pair contents</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-17 Added field type</comment>
<definition id="gql_field_type_defn">
<term>field type</term>
<defnDomain>record type</defnDomain>
<defn>pair comprising a name and a <defnref ref="gql_value_type_defn"/></defn>
</definition>

<comment>Editorial: Stefan Plantikow, 2023-02-20 Deleted 1 (one) unused term</comment>

</bodyMatter>

</subClause>


<subClause id="gql_temporal_terms_defns">
<clauseHeading>Temporal terms and definitions</clauseHeading>

<bodyMatter>

<comment>WG3:UTC-013 P02-ISO-009</comment>
<comment>Alignment with Directives Part 2 2018</comment>
<definition>
<term>time</term>
<defn>mark attributed to an instant or a time interval on a specified time scale</defn>
<defnSource><docref ref="ISO8601-1_2019"/><defnSection>3.1.1.2</defnSection></defnSource>
</definition>

<definition>
<term>instant</term>
<defn>point on the time axis</defn>
<defnSource><docref ref="ISO8601-1_2019"/><defnSection>3.1.1.3</defnSection></defnSource>
</definition>

<comment>Editorial; Jim Melton, 2023-09-04; fix which/that problems</comment>
<definition>
<term>time scale</term>
<defn>system of ordered marks that can be attributed to instants on the time axis, one instant 
being chosen as the origin</defn>
<defnSource><docref ref="ISO8601-1_2019"/><defnSection>3.1.1.5</defnSection></defnSource>
</definition>

<definition>
<term>duration</term>
<defn>non-negative quantity of time equal to the difference between the final and initial 
instants of a time interval</defn>
<defnSource><docref ref="ISO8601-1_2019"/><defnSection>3.1.1.8</defnSection></defnSource>
</definition>

<definition>
<term>time of day</term>
<defn>time occurring within a calendar day</defn>
<defnSource><docref ref="ISO8601-1_2019"/><defnSection>3.1.1.16</defnSection></defnSource>
</definition>

<definition>
<term>Gregorian calendar</term>
<defn>calendar in general use that defines a calendar year that closely approximates 
the tropical year</defn>
<defnSource><docref ref="ISO8601-1_2019"/><defnSection>3.1.1.19</defnSection></defnSource>
</definition>

<definition>
<term>time shift</term>
<defn>constant duration difference between times of two time scales</defn>
<defnSource><docref ref="ISO8601-1_2019"/><defnSection>3.1.1.25</defnSection></defnSource>
</definition>

<definition>
<term>calendar date</term>
<defn>particular calendar day represented by its calendar year, its calendar month and 
its calendar day of month</defn>
<defnSource><docref ref="ISO8601-1_2019"/><defnSection>3.1.2.7</defnSection></defnSource>
</definition>

<definition>
<term>representation with reduced precision</term>
<defn>abbreviation of a date and time representation by omission of lower order time scale 
components</defn>
<defnSource><docref ref="ISO8601-1_2019"/><defnSection>3.1.3.7</defnSection></defnSource>
</definition>

<definition>
<term>negative duration</term>
<defn>duration in the reverse direction to the proceeding time scale</defn>
<defnSource><docref ref="ISO8601-2_2019"/><defnSection>3.1.1.7</defnSection></defnSource>
</definition>

</bodyMatter>

</subClause>

<comment>WG3:CMN-019 P00-ISO-013</comment>

</clause>


<clause id="gql_conc">
<clauseHeading>Concepts</clauseHeading>


<subClause id="gql_conc_terms">
<clauseHeading>Use of terms</clauseHeading>

<bodyMatter>

<comment>WG3:CMN-019 017. P00-USA-003</comment>
<para>The concepts on which this document is based are described in terms of objects and values.
</para>

<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-24 WG3:W20-010 P00-USA-374</comment>
<comment>WG3:W23-009R1 P00-CAN-001</comment>
<comment>WG3:W24-025</comment>
<comment>Email from: Karl Schendel, 2023-02-04 1421 GQL typo</comment>
<para>Some objects are a component of an object on which they depend.
If an object <symdef>O</symdef> ceases to exist, then every object dependent on <sym>O</sym> also
ceases to exist.
The metadata representation of an object is known as a descriptor.
See <specref ref="gql_descriptors"/>.
</para>

</bodyMatter>

</subClause>


<comment>Jim Melton, 2025-03-17, Provide a definition of 'comprise'</comment>
<subClause id="gql_conc_comprise">
<clauseHeading>Use of <quote>comprise</quote></clauseHeading>

<bodyMatter>

<comment>Jim Melton, 2025-03-17, Provide a definition of 'comprise'</comment>
<para>In ISO/IEC 39075,
the term <quote>comprise</quote> is used to specify that one item is made of
one or more other items. 
The word <quote>comprise</quote> is correctly used in a phrase such as
<quote>A <BNF name="procedure specification"/> comprises either
a <BNF name="catalog-modifying procedure specification"/>,
a <BNF name="data-modifying procedure specification"/> or
a <BNF name="query specification"/></quote>.
That is, a <BNF name="procedure specification"/> <quote>contains</quote> or
<quote>is made up of</quote> either a single
<BNF name="catalog-modifying procedure specification"/>, or a single
<BNF name="data-modifying procedure specification"/>, or a single
<BNF name="query specification"/>, but not two or more of those items. 
</para>

<comment>Jim Melton, 2025-03-17, Provide a definition of 'comprise'</comment>
<para><specref ref="gql_procspec"/> defines the BNF non-terminal symbol
<BNF name="procedure specification"/>, including its three mutually-exclusive
alternatives. 
The word <quote>comprise</quote> correctly describes containment of exclusive content
items, as well as containment of the specified items and possibly additional items. 
</para>

<comment>Jim Melton, 2025-03-17, Provide a definition of 'comprise'</comment>
<para>One may find incorrect uses of the term in literature and even in standards. 
For example, one might see a sentence that reads 
A <BNF name="procedure specification"/> is comprised of<ellipsis/>", but that is incorrect. 
</para>

<comment>Jim Melton, 2025-03-17, Provide a definition of 'comprise'</comment>
<para>Occasionally, the use of <quote>comprise(s)</quote> causes confusion. 
In such situations, ISO/IEC 39075 uses
<quote>constitute(s)</quote>, <quote>is composed of</quote>, or <quote>contains</quote>. 
</para>

</bodyMatter>

</subClause>


<subClause id="gql_conc_env">
<clauseHeading>GQL-environments and their components</clauseHeading>

<subClause2 id="gql_conc_env_gendescr">
<clauseHeading>General description of GQL-environments</clauseHeading>

<bodyMatter>

<comment>Editorial: Stephen Cannan, 2020-05-25 Experimental diagram</comment>
<comment>Editorial: Stefan Plantikow, 2023-10-14 Redo diagram in drawio</comment>
<figure id="gql_fig_env" file="gql_environment.svg" padding-after="10pt">
<figureTitle>Components of a GQL-environment</figureTitle>
</figure>

<comment>Editorial: Stefan Plantikow, 2020-04-06</comment>
<comment>Editorial: Stephen Cannan, 2020-11-21 Reference figure conform ISO Directives.</comment>
<para id="gql_env_defn">A GQL-environment is a <repeatdefn ref="gql_GQL_environment_defn"/>.
A pictorial overview is shown in <specref ref="gql_fig_env"/>.
A GQL-environment comprises:
</para>

<comment>Editorial: Stephen Cannan 2023-01-19 Convert to ulists</comment>
<ulist>

<item>One GQL-agent.
</item>

<comment>Editorial: Stephen Cannan, 2020-05-21 Use SQL term</comment>
<item>One GQL-implementation containing one GQL-client and one GQL-server.
</item>

<comment>Editorial: Stephen Cannan, 2020-05-11 Clarify principal</comment>
<item>Zero or more authorization identifiers that identify principals.
</item>

<comment>Editorial: Stefan Plantikow, 2020-02-23</comment>
<comment>WG3:UTC-052</comment>
<item>One GQL-catalog that comprises one GQL-catalog root.
A GQL-catalog that comprises only the GQL-catalog root is considered to be empty. 
The GQL-catalog is not required to be empty after the instantiation of the GQL-environment.
</item>

<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>Consequence of WG3:W13-010R1</comment>
<item>The sites, principally catalog objects, that contain GQL-data,
as described by the content of the GQL-schemas.
This data can be thought of as <quote>the database</quote>, but the term is not used in
this document, because it has different meanings in the general context.
</item>

</ulist>

<comment>Editorial: Stephen Cannan, 2020-05-21 Use SQL term</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-16 WG3:W20-010 P00-USA-308</comment>
<comment>Editorial: Stefan Plantikow, 2023-07-11 WG3:CMN-019 P00-USA-229</comment>
<para>This document recognizes that an installation of a software component that implements GQL
can provide multiple GQL-clients, multiple GQL-servers, and multiple GQL-catalogs
such that some GQL-agents can use multiple GQL-clients and some GQL-servers can
share the same GQL-catalog.
In such a scenario, every interaction of one GQL-agent, one GQL-client, one GQL-server,
and one GQL-catalog is understood to occur in an isolated GQL-environment.
Each such GQL-environment is considered separately in terms of conformance.
Any interaction between multiple such GQL-environments is <unDef code="UA001"/> within
the constraints of GQL-transaction semantics and is understood as the activity of additional
GQL-agents.
</para>

</bodyMatter>

</subClause2>


<subClause2 id="gql_conc_env_agent">
<clauseHeading>GQL-agents</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-02-23</comment>
<comment>Editorial: Stefan Plantikow, 2020-03-09</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-06</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 Use SQL term</comment>
<comment>WG3:W08-010</comment>
<comment>WG3:RKE-047R1</comment>
<comment>WG3:CMN-041</comment>
<comment>WG3:CMN-061R1</comment>
<para><specref ref="gql_env_terms_defns"/> defines a GQL-agent as an independent process that 
causes the execution of procedures and commands. 
For this purpose, a GQL-agent utilizes an <impDef code="IW001"/> mechanism to instruct 
the GQL-client to submit GQL-requests to the GQL-server within a GQL-session, and thus cause the
GQL-implementation to execute the GQL-programs of the submitted GQL-requests.
</para>

<comment>WG3:CMN-061R1</comment>
<note>See <specref ref="gql_conc_req_exe"/>.
</note>

</bodyMatter>

</subClause2>


<subClause2 id="gql_conc_env_impl">
<clauseHeading>GQL-implementations</clauseHeading>

<subClause3 id="gql_conc_env_impl_intro">
<clauseHeading>Introduction to GQL-implementations</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-03-09</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 Use SQL term</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-16 WG3:W20-010 P00-USA-309</comment>
<comment>Editorial: Stefan Plantikow, 2022-12-04 WG3:W23-009R1 272. P00-USA-181</comment>
<para>A <newterm>GQL-implementation</newterm> is a processor that executes GQL-requests
submitted by a GQL-agent.
A GQL-implementation, as perceived by a GQL-agent, includes one GQL-client, to which that
GQL-agent is bound, and one GQL-server.
A GQL-implementation is able to conform to this document even if it allows more than one GQL-server
to exist in a GQL-environment.
</para>


<comment>Editorial: Stefan Plantikow, 2022-02-16 WG3:W20-010 P00-USA-309</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-16 WG3:W20-010 P00-USA-308</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-16 WG3:W20-010 P00-USA-310</comment>
<para>Because a GQL-implementation is specified only in terms of how it manages GQL-sessions
and executes GQL-requests, the concept denotes an installed instance of some software component
(database management system).
This document does not distinguish between features of the GQL-implementation that are determined 
by the software implementer and those determined by the installer.
</para>

<comment>WG3:W21-053</comment>
<para>In this document some aspects are marked as <quote><impDef annex="no" code="None"/></quote>. 
These aspects are permitted to differ in different implementations but each conforming 
implementation is required to fully specify that aspect.
See <specref ref="gql_impl_conformance_claims"/>, for further information.
</para>

<para>Each <impDef annex="no" code="None"/> aspect is assigned a code that is placed in 
parentheses after each occurrence of that <impDef annex="no" code="None"/> aspect in this 
document.
See for example, <itemref ref="gql_value_type_maxlen_SR" type="SR"/> of 
<specref ref="gql_value_type"/>:
</para>

<slist>

<item><quote><repeatitem ref="gql_value_type_maxlen_SR"/></quote>
</item>

</slist>

<para>The codes assigned to <impDef annex="no" code="None"/> aspects comprise the letter 
<quote>I</quote> followed by a letter and three digits.
</para>

<para>The codes assigned to <impDef annex="no" code="None"/> aspects are stable and can be 
depended on to remain constant.
The codes themselves have no other meaning than to identify the specific
<impDef annex="no" code="None"/> aspect. 
</para>

<comment>WG3:UTC-013 P01-ISO-022</comment>
<bar note="Editorial: Stephen Cannan, 2025-04-07 Document hot-links"/>
<comment>Editorial: Stephen Cannan, 2025-04-07 Document hot-links</comment>
<para>For convenience, all the <impDef annex="no" code="None"/> aspects in this document are 
collected together in the non-normative <specref ref="gql_impdef"/>, which lists those
places in this document where an <impDef annex="no" code="None"/> aspect is referenced.
The <impDef annex="no" code="None"/> codes are typeset in a dark blue color; in electronic (PDF)
versions of this document, those codes are <quote>links</quote> to the location in 
<specref ref="gql_impdef"/> that describes the <impDef annex="no" code="None"/> aspect identified
by the code. 
</para>
<endbar/>

<comment>WG3:CMN-019 P00-USA-231</comment>
<comment>WG3:CMN-019 P00-USA-232</comment>
<para>In this document some aspects are marked as <quote><unDef annex="no" code="None"/></quote>.
These aspects are permitted to differ in different implementations, but they are not necessarily
specified for any particular GQL-implementation.
Indeed, a GQL-implementation is not required to exhibit consistent behavior with regard to a given
<unDef annex="no" code="None"/> aspect.
Its behavior may depend on aspects such as the chosen access path, which may vary over time. 
An application should not depend on the specific behavior of any <unDef annex="no" code="None"/>
aspect.
</para>

<comment>Editorial: Stephen Cannan, 2025-03-19 Use consistent terminology</comment>
<para>Each <unDef annex="no" code="None"/> aspect is assigned a code that is placed in parentheses
after each occurrence of that <unDef annex="no" code="None"/> aspect in this document.
See for example, <itemref ref="gql_ele_id_val_GR" type="GR"/> of 
<specref ref="gql_ele_id"/>:
</para>

<slist>

<item><quote><repeatitem ref="gql_ele_id_val_GR"/></quote>
</item>

</slist>

<para>The codes assigned to <unDef annex="no" code="None"/> aspects comprise the letter 
<quote>U</quote> followed by a letter and three digits.
</para>

<para>The codes assigned to <unDef annex="no" code="None"/> aspects are stable and can be depended 
on to remain constant.
The codes themselves have no other meaning than to identify the specific
<unDef annex="no" code="None"/> aspect. 
</para>

<bar note="Editorial: Stephen Cannan, 2025-04-07 Document hot-links"/>
<comment>Editorial: Stephen Cannan, 2025-04-07 Document hot-links</comment>
<para>For convenience, all the <unDef annex="no" code="None"/> aspects in this document are 
collected together in the non-normative <specref ref="gql_undef"/>, which lists those
places in this document where an <unDef annex="no" code="None"/> aspect is referenced.
The <unDef annex="no" code="None"/> codes are typeset in a dark blue color; in electronic (PDF)
versions of this document, those codes are <quote>links</quote> to the location in 
<specref ref="gql_undef"/> that describes the <unDef annex="no" code="None"/> aspect identified
by the code. 
</para>
<endbar/>

<comment>Editorial: Stephen Cannan, 2020-05-21 Use SQL term</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-16 WG3:W20-010 P00-USA-037</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-16 WG3:W20-010 P00-USA-308</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-16 WG3:W20-010 P00-USA-310</comment>
<para>This document recognizes that there is a possibility that GQL-client and GQL-server software 
components have been obtained from different implementers; it does not specify the method of
interaction or communication between GQL-client and GQL-server.
</para>

</bodyMatter>

</subClause3>


<subClause3 id="gql_conc_env_client">
<clauseHeading>GQL-clients</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-04-06</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 Use SQL term</comment>
<comment>WG3:W10-010R1</comment>
<comment>Editorial: Stephen Cannan, 2022-02-24 W20-010 P00-USA-312</comment>
<comment>Editorial: Stephen Cannan, 2022-02-24 W20-010 P00-USA-313</comment>
<comment>Editorial: Stefan Plantikow, 2022-04-07 RKE-010 P00-USA-038 RKE-047R1</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<para>A GQL-client is a <repeatdefn ref="gql_GQL_client_defn"/>.
A GQL-client is perceived by the GQL-agent to be part of the GQL-implementation;
a GQL-client establishes and manages the sequence of GQL-sessions between itself
and its GQL-server and
maintains a GQL-status object and other state data relating to interactions between itself,
the GQL-agent, and the GQL-server for its current GQL-session.
A GQL-agent submits GQL-requests to a GQL-server via a GQL-client.
</para>

<comment>Editorial: Stephen Cannan, 2020-04-16</comment>
<comment>Editorial: Stephen Cannan, 2020-05-11 Clarify principal</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 Use SQL term</comment>
<para>A GQL-implementation may detect the loss of the connection between the GQL-client and 
GQL-server during the execution of a statement.
When such a connection failure is detected, an exception condition is raised: 
<raise class="40" subclass="003"/>.
This exception condition indicates that the results of the actions performed in the GQL-server on 
behalf of the GQL-client are unknown to the GQL-agent.
Similarly, a GQL-implementation may detect the loss of the connection during the execution
of a <BNF name="commit command"/>.
When such a connection failure is detected, an exception condition is raised:
<raise class="08" subclass="007"/>.
This exception condition indicates that the GQL-implementation cannot verify whether the 
GQL-transaction was committed successfully, rolled back, or left active.
</para>

</bodyMatter>

</subClause3>


<subClause3 id="gql_conc_env_server">
<clauseHeading>GQL-servers</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-04-06</comment>
<comment>Editorial: Stefan Plantikow, 2020-02-23</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 Use SQL term</comment>
<comment>Editorial: Stephen Cannan, 2022-02-24 W20-010 P00-USA-314</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<para>A GQL-server is a <repeatdefn ref="gql_GQL_server_defn"/>.
A GQL-server is perceived by the GQL-agent to be part of the GQL-implementation;
a GQL-server manages the GQL-catalog and GQL-data.
</para>

<comment>Editorial: Stephen Cannan, 2020-05-21 Use SQL term</comment>
<comment>Editorial: Stefan Plantikow, 2022-04-07 WG3:RKE-010 P00-USA-038 RKE-047R1</comment>
<para>The GQL-server of a GQL-environment:
</para>

<ulist>

<comment>Editorial: Stefan Plantikow, 2022-04-07 WG3:RKE-010 P00-USA-038 RKE-047R1</comment>
<item>Manages the sequence of GQL-sessions taking place between itself and the GQL-client on behalf
of the GQL-agent.
</item>

<comment>Editorial: Stefan Plantikow, 2022-03-25</comment>
<comment>Editorial: Stefan Plantikow, 2022-04-07 WG3:RKE-010 P00-USA-038 RKE-047R1</comment>
<item>Executes GQL-requests received from the GQL-client to completion and delivers
request outcomes back to the GQL-client as required.

<comment>WG3:CMN-061R1</comment>
<note>See <specref ref="gql_conc_req_exe"/>.
</note>

</item>

<comment>Editorial: Stefan Plantikow, 2020-04-06</comment>
<comment>Editorial: Stephen Cannan, 2020-05-18 GQL- prefix reduction</comment>
<item>Maintains the state of the GQL-session, including the authorization identifier,
the GQL-transaction, and certain session defaults.
</item>

</ulist>


</bodyMatter>

</subClause3>

</subClause2>


<comment>WG3:W10-010R1</comment>
<subClause2 id="gql_basic_sec_model">
<clauseHeading>Basic security model</clauseHeading>

<comment>Editorial: Stephen Cannan, 2020-05-11 Clarify principal</comment>
<subClause3 id="gql_conc_env_principals">
<clauseHeading>Principals</clauseHeading>

<bodyMatter>

<comment>Editorial: Stephen Cannan, 2020-05-11 Clarify principal</comment>
<para>A principal is an <impDef code="ID001"/> <repeatdefn ref="gql_principal_defn"/>.
</para>

<comment>Editorial: Stefan Plantikow, 2020-03-10</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-06</comment>
<comment>Editorial: Stephen Cannan, 2020-05-11 Clarify principal</comment>
<comment>WG3:W22-035</comment>
<para>A principal is identified by one or more <newterm>authorization identifier</newterm>s.
The means of creating and destroying authorization identifiers, and their mapping to
principals, is <impDef code="IW002"/>.
</para>

<comment>WG3:W12-012: Stefan Plantikow, 2021-06-15 Removing roles</comment>
<comment>WG3:CMN-060</comment>
<note>Allowing multiple authorization identifiers to map to a single principal allows a user 
to operate with different sets of privileges.
See <specref ref="gql_auth_ids"/>.
</note>

<comment>Editorial: Stephen Cannan, 2020-05-11 Clarify principal</comment>
<comment>WG3:W22-035</comment>
<para>Every principal is associated with:
</para>

<ulist>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>An optional home schema, which is a GQL-schema.
</item>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>WG3:UTC-045R1</comment>
<item>An optional home graph, which is a graph.
</item>

</ulist>

<para>The manner in which this association is specified is <impDef code="ID002"/>.
</para>

<comment>WG3:CMN-019 25. P00-USA-005</comment>

</bodyMatter>

</subClause3>


<comment>WG3:CMN-060</comment>
<subClause3 id="gql_auth_ids">
<clauseHeading>Authorization identifiers and privileges</clauseHeading>

<bodyMatter>

<comment>WG3:W12-012: Stefan Plantikow, 2021-06-15</comment>
<comment>WG3:CMN-060</comment>
<para>An authorization identifier identifies a principal and a set of privileges for that principal.
An authorization identifier is represented by an <impDef code="IV015"/>
<BNF name="authorization identifier"/>.
</para>

<comment>WG3:CMN-060</comment>
<para>A <newterm>privilege</newterm> is a permission to cause certain kinds of operations to be 
performed by the execution of GQL-requests.
</para>

<comment>Editorial: Stefan Plantikow, 2021-06-15 Adjust wording for WG3:W12-012</comment>
<comment>WG3:W23-009R1 P00-USA-183</comment>
<para>The set of privileges identified by an authorization identifier is <impDef code="ID003"/>.
</para>

<comment>WG3:CMN-060</comment>
<para>If the execution of a GQL-request (See <specref ref="gql_conc_req"/>) would
perform an operation that is not permitted according to the set of privileges identified by the
session authorization identifier, then an exception condition is raised: <raise class="42"/>.
</para>

</bodyMatter>

</subClause3>


<comment>Editorial: Stefan Plantikow, 2021-06-15 WG3:W12-012 Removing roles</comment>

</subClause2>


<subClause2 id="gql_conc_env_cat">
<clauseHeading>GQL-catalog</clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-02-05</comment>
<subClause3 id="gql_conc_env_cat_gendescr">
<clauseHeading>General description of the GQL-catalog</clauseHeading>

<bodyMatter>

<para>The GQL-catalog is a <repeatdefn ref="gql_GQL_catalog_defn"/>.
</para>

<comment>Editorial: Stephen Cannan, 2020-11-21 Reference figure as required by ISO Directives.
</comment>
<para>The GQL-catalog is pictorially represented in <specref ref="gql_cat_diag"/>.
</para>

<comment>Editorial: Stefan Plantikow, 2020-07-13 WG3:MMX-055</comment>
<comment>WG3:W13-010R1</comment>
<comment>WG3:BER-061</comment>
<comment>WG3:OHD-023</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<para>The GQL-catalog comprises the GQL-catalog root, which is either a GQL-directory or
a GQL-schema. 
The name of the GQL-catalog root is the zero-length character string.
</para>

<comment>WG3:MMX-055</comment>
<comment>Editorial: Stefan Plantikow, 2023-10-14 Redo diagram in drawio</comment>
<figure id="gql_cat_diag" file="gql_catalog.svg" padding-after="10pt">
<figureTitle>Components of a GQL-catalog</figureTitle>
</figure>

<comment>WG3:SYX-029R11 Deleted 1 (one) editor's note</comment>

<comment>Editorial: Stefan Plantikow, 2020-07-13 WG3:MMX-055</comment>
<comment>WG3:BER-061</comment>
<para>The maximum depth of nesting of GQL-directories is <impDef code="IL020"/>.
If this depth is zero, then GQL-directories are not supported.
</para>

<comment>Editorial: Stefan Plantikow, 2020-07-13 WG3:MMX-055</comment>
<comment>Editorial: Stephen Cannan 2021-12-08 Standardize on GQL-implementation</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-23 WG3:W20-010 P00-USA-318</comment>
<note>This supports GQL-implementations that provide a GQL-catalog that has only a single 
GQL-schema as its GQL-catalog root, has a single GQL-directory that only contains 
GQL-schemas as its GQL-catalog root, has a nesting structure that directly matches that 
of <SQL/> such that its GQL-catalog root is a GQL-directory of <SQL/>-catalogs (represented as 
GQL-directories) containing GQL-schemas, or has a nesting structure that is suitably restricted in
some other way. 
</note>

<comment>WG3:UTC-049 Deleted 1 (one) editor's note</comment>

<comment>WG3:MMX-055</comment>
<comment>WG3:W13-010R1</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-23 WG3:W20-010 P00-USA-293 Removed note</comment>

</bodyMatter>

</subClause3>


<subClause3 id="gql_conc_env_cat_dir">
<clauseHeading>GQL-directories</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-07-12 WG3:MMX-055</comment>
<para>A GQL-directory is a <repeatdefn ref="gql_GQL_directory_defn"/>.
</para>

<comment>Editorial: Stefan Plantikow, 2022-02-24 WG3:W20-010 P00-USA-049</comment>
<comment>WG3:RKE-044R1: Stefan Plantikow, 2022-04-06 1119 One Editor's Note removed</comment>

<comment>Editorial: Stefan Plantikow, 2020-01-28</comment>
<comment>WG3:RKE-044R1</comment>
<para>The GQL-directory that holds some other GQL-directory or GQL-schema <symdef>DOS</symdef>
is called the <newterm>parent directory</newterm> of <sym>DOS</sym>.
The GQL-catalog root has no parent directory.
</para>

<comment>WG3:W23-030</comment>
<comment>WG3:CMN-019 P00-USA-204</comment>
<para>Every GQL-directory <symdef>DIR</symdef> is described by its GQL-directory descriptor that 
comprises:
</para>

<ulist>

<comment>Editorial: Stefan Plantikow, 2020-09-15 Wording</comment>
<comment>WG3:MMX-055</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-23 WG3:W20-010 P00-USA-042</comment>
<comment>WG3:RKE-044R1</comment>
<comment>WG3:W23-030</comment>
<item>The set of named subobjects that comprises (identifier, object descriptor) pairs that
associate identifiers to the descriptors of every GQL-directory and GQL-schema held by 
<sym>DIR</sym>.
</item>

</ulist>

<comment>WG3:W23-030</comment>
<comment>WG3:UTC-095</comment>
<comment>Editorial: Stefan Plantikow, 2023-07-11 WG3:CMN-019 P00-USA-006</comment>
<para>The name of a GQL-directory <symdef>DIR</symdef> (also known as
<newterm>GQL-directory name</newterm>) is a character string that is defined as follows. 
If <sym>DIR</sym> is the GQL-catalog root, then the name of <sym>DIR</sym> is
the zero-length character string; otherwise, <sym>DIR</sym> is not the GQL-catalog root and
the name of <sym>DIR</sym> is the canonical name form of the identifier that identifies
<sym>DIR</sym> within its parent directory.
</para>

<comment>WG3:OHD-023</comment>
<note>A GQL-directory cannot contain a GQL-directory and a GQL-schema that have equal names.
</note>

<comment>Editorial: Stefan Plantikow, 2020-04-01</comment>
<comment>WG3:W13-010R1</comment>
<para>A GQL-implementation may automatically create a GQL-directory in an <impDef code="IW015"/> 
way.
</para>

<comment>WG3:BER-061</comment>
<comment>Editorial: Stephen Cannan 2023-01-29 Align with Directives Part 2</comment>
<note>For instance, it is possible for a GQL-implementation to create (recursively) GQL-directories 
when a GQL-schema is created in a thus far non-existing GQL-directory.
</note>

</bodyMatter>

</subClause3>


<comment>Editorial: Stefan Plantikow, 2020-03-09</comment>
<comment>Editorial: Stefan Plantikow, 2020-03-07</comment>
<subClause3 id="gql_conc_env_schema">
<clauseHeading>GQL-schemas</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-07-12 WG3:MMX-055</comment>
<comment>WG3:W13-010R1</comment>
<comment>WG3:W23-030</comment>
<para>A GQL-schema is a <repeatdefn ref="gql_GQL_schema_defn"/>.
Every GQL-schema <symdef>SCHEMA</symdef> is described by its GQL-schema descriptor that comprises:
</para>

<ulist>

<comment>WG3:W23-030</comment>
<item>The owner of <sym>SCHEMA</sym>, an authorization identifier of a principal.
</item>

<comment>Editorial: Stefan Plantikow, 2020-09-15 Wording</comment>
<comment>WG3:W13-010R1</comment>
<comment>WG3:RKE-044R1</comment>
<comment>WG3:W23-030</comment>
<item>The set of named subobjects of <sym>SCHEMA</sym> that comprises 
(identifier, object descriptor) pairs that associate identifiers to the catalog object descriptors
of every catalog object held by <sym>SCHEMA</sym>.
</item>

</ulist>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>WG3:UTC-095</comment>
<para>The name of a GQL-schema (also known as <newterm>GQL-schema name</newterm>) is 
a character string that is defined as follows.
The name of a GQL-schema that is the GQL-catalog root is the zero-length character string; 
the name of every GQL-schema <sym>SCHEMA</sym> that is not the GQL-catalog root is the 
canonical name form of the identifier that identifies <sym>SCHEMA</sym> within its parent directory.
</para>

<comment>Editorial: Stephen Cannan, 2022-02-24 W20-010 P00-USA-321</comment>
<para>A GQL-implementation may provide some GQL-schemas that cannot be dropped by the execution 
of a GQL-request.
</para>

<comment>WG3:W13-010R1</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-23 WG3:W20-010 P00-USA-046</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-23 WG3:W20-010 P00-USA-322</comment>
<comment>Editorial: Stephen Cannan, 2022-02-24 WG3:W20-010 P00-USA-323</comment>
<comment>WG3:RKE-044R1</comment>
<comment>WG3:BER-040R3</comment>
<para>A catalog object is a <repeatdefn ref="gql_catalog_object_defn"/>.
Every catalog object is created directly or indirectly in the context of a GQL-schema, and owned by
that GQL-schema.
</para>

<comment>Editorial for the application of WG3:MMX-028R2 looking ahead to WG3:MMX-055</comment>
<comment>WG3:W13-010R1</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:W23-030</comment>
<comment>WG3:CMN-019 P00-USA-204</comment>
<para>Every catalog object is described by a catalog object descriptor that is included in the set 
of named subobjects in the descriptor of the containing GQL-schema or primary catalog object that 
holds it.
</para>

<comment>WG3:W23-030</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>WG3:UTC-095</comment>
<para>The name of a catalog object (also known as <newterm>catalog object name</newterm>) is 
a character string defined as follows.
The name of every catalog object <symdef>OBJECT</symdef> is the canonical name form of the 
identifier that identifies <sym>OBJECT</sym> within the containing GQL-schema or primary catalog 
object that holds it.
</para>

<comment>WG3:W23-030</comment>
<note>A GQL-schema or primary catalog object cannot hold two different catalog objects with 
equal names.
</note>

<para>A catalog object descriptor is one of:
</para>

<ulist>

<item>A graph descriptor.
</item>

<item>A graph type descriptor.
</item>

<comment>Editorial: Stefan Plantikow, 2022-12-19 WG3:W24-009 279. P00-USA-186</comment>
<item>A binding table descriptor.
</item>

<comment>Editorial: Stefan Plantikow, 2020-09-15 Terminology adjusted</comment>
<comment>WG3:UTC-077</comment>
<item>A named procedure descriptor.
</item>

</ulist>

<comment>Editorial: Stefan Plantikow, 2020-07-12 WG3:MMX-055</comment>
<comment>WG3:W13-010R1</comment>
<comment>Editorial: Stephen Cannan, 2022-02-24 WG3:W20-010 P00-USA-324</comment>
<note>A GQL-schema cannot contain a GQL-directory or a GQL-schema, because they are not 
catalog objects.
</note>

<comment>Editorial: Stefan Plantikow, 2020-04-01</comment>
<comment>WG3:POS-023R1</comment>
<para>A GQL-implementation may automatically populate a GQL-schema upon its creation in
an <impDef code="IW016"/> way.
Without <feature code="GC00"/>, a conforming GQL-implementation shall not provide a GQL-schema 
with a pre-populated graph.
</para>

</bodyMatter>

</subClause3>

<comment>Editorial: Stefan Plantikow, 2020-07-12 Catalog objects</comment>
</subClause2>


<comment>Editorial: Stefan Plantikow, 2020-03-25</comment>
<comment>Editorial: Stefan Plantikow, 2019-10-20</comment>
<subClause2 id="gql_conc_env_gqldata">
<clauseHeading>GQL-data</clauseHeading>

<bodyMatter>
<comment>WG3:W23-009R1 P00-USA-187</comment>
<para>GQL-data is <repeatdefn ref="gql_GQL_data_defn"/>.
GQL-data is described by GQL-schemas in the GQL-catalog.
</para>

</bodyMatter>

</subClause2>

</subClause>


<comment>Editorial: Stefan Plantikow, 2019-10-20</comment>
<comment>Editorial: Stefan Plantikow, 2020-01-28</comment>
<comment>Editorial: Stefan Plantikow, 2020-02-05</comment>
<comment>Editorial: Stefan Plantikow, 2020-25-05</comment>
<subClause id="gql_conc_obj">
<clauseHeading>GQL-objects</clauseHeading>


<subClause2 id="gql_conc_obj_genintro">
<clauseHeading>General introduction to GQL-objects</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-03-10</comment>
<comment>Editorial: Stefan Plantikow, 2020-03-09</comment>
<comment>Editorial: Stefan Plantikow, 2021-08-26 Correct application of 2021-028r2</comment>
<comment>WG3:UTC-064</comment>
<para>A GQL-object is an <repeatdefn ref="gql_GQL_object_defn"/>.
</para>

<comment>Editorial: Stefan Plantikow, 2020-05-05 Added internal object identifier</comment>
<comment>This was moved here from graph and in that sense is part of WG3:SXM-052</comment>
<comment>Editorial: Stefan Plantikow, 2020-07-13 Change to internal object identifier</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-10 Clarified internal object identifier</comment>
<comment>WG3:W13-010R1</comment>
<comment>Editorial: Stefan Plantikow, 2021-08-26 Correct application of 2021-028r2</comment>
<comment>Editorial: Stephen Cannan, 2022-02-24 W20-010 P00-USA-326</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:W23-029R1</comment>
<comment>WG3:CMN-019 P00-ISO-001</comment>
<para>Every GQL-object is uniquely identified by one or more effectively immutable 
<newterm>internal object identifiers</newterm> within the GQL-environment 
containing the GQL-object.
A GQL-object can be associated with one such internal object identifier that is called its 
<newterm>global object identifier</newterm> and that reifies its identity during the execution of 
a GQL-request. 
A GQL-object associated with a global object identifier is called 
<newterm>globally identifiable</newterm>.
The value of an object identifier is <unDef code="UV001"/> and is possibly not accessible to 
the user.
When a GQL-object is copied, the copy is assigned a new global object identifier.
Global object identifiers are used for definitional purposes only in order to establish the 
identity of GQL-objects.
</para>

<comment>WG3:W13-010R1</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:CMN-019 P00-ISO-001</comment>
<para>Additionally, a GQL-object can have associated descriptors that define its metadata.
This document defines different kinds of GQL-objects.
The descriptor of a persistent data object describes a catalog object that has a separate existence 
as GQL-data.
Other descriptors describe GQL-objects that have no existence distinct from their descriptors 
(at least as far as this document is concerned).
Hence there is no loss of precision if, for example, the term <quote>path pattern</quote> is used 
when <quote>path pattern descriptor</quote> would be more strictly correct.
</para>

<comment>WG3:CMN-074</comment>
</bodyMatter>

</subClause2>


<comment>WG3:W22-053R2</comment>
<comment>WG3:CMN-042</comment>
<comment>WG3:CMN-074</comment>
<subClause2 id="gql_conc_ref_gql_obj">
<clauseHeading>References to GQL-schemas and GQL-objects</clauseHeading>

<bodyMatter>

<comment>WG3:CMN-019 P00-USA-007</comment>
<comment>WG3:CMN-042</comment>
<para>A reference to a GQL-schema or a GQL-object identifies a GQL-schema or a GQL-object,
respectively, as the referent of the reference.
Resolving a reference determines the referent that it identifies.
</para>

<comment>WG3:CMN-035</comment>
<para>A <newterm>syntactically resolved reference</newterm> is a BNF non-terminal instance
that identifies its referent <symdef>R</symdef> by identifying the static site that <sym>R</sym>
occupies. 
Syntactically resolved references are resolved during the application of Syntax Rules.
</para>

<comment>WG3:CMN-042</comment>
<para>A syntactically resolved reference is an instance of one of the following:
</para>

<comment>WG3:CMN-042</comment>
<ulist>

<comment>WG3:CMN-042</comment>
<item>A <BNF name="schema reference"/> or an <BNF name="absolute catalog schema reference"/>,
whose referent is GQL-schema.
</item>

<comment>WG3:CMN-042</comment>
<item>A <BNF name="graph reference"/> or a <BNF name="catalog graph parent and name"/>,
whose referent is a graph.
</item>

<comment>WG3:CMN-042</comment>
<item>A <BNF name="graph type reference"/> or a <BNF name="catalog graph type parent and name"/>,
whose referent is a graph type.
</item>

<comment>WG3:CMN-042</comment>
<item>A <BNF name="binding table reference"/> or
a <BNF name="catalog binding table parent and name"/>, whose referent is a binding table.
</item>

<comment>WG3:CMN-042</comment>
<item>A <BNF name="procedure reference"/> or a <BNF name="catalog procedure parent and name"/>,
whose referent is a procedure.
</item>

</ulist>

<comment>WG3:CMN-035</comment>
<para>A <newterm>globally resolved reference</newterm> identifies its referent <symdef>R</symdef>
by the global object identifier associated with <sym>R</sym> in the GQL-environment. 
Globally resolved references are resolved during the application of Syntax Rules or General Rules.
The globally identifiable GQL-object <symdef>O</symdef> referenced by a site <symdef>S</symdef> is 
represented by a globally resolved reference that identifies <sym>O</sym> in GQL-data. 
The resolution of such a globally resolved reference that represents <sym>O</sym> at <sym>S</sym> 
is implicit; referring to <sym>O</sym> at <sym>S</sym> implicitly resolves the representing 
globally resolved reference.
</para>

<comment>WG3:CMN-074</comment>
<para><specref ref="gql_val_terms_defns"/> defines a reference value as a value that
describes a globally resolved reference to a GQL-object.
</para>

<note>See <specref ref="gql_conc_ref_vals"/>.
</note>

<comment>Editorial: Stefan Plantikow, 2023-10-16 Reference list of supported types</comment>
<note>See <specref ref="gql_conc_vt_ref"/>.
</note>

</bodyMatter>

</subClause2>


<comment>WG3:CMN-074</comment>
<subClause2 id="gql_pri_obj_and_sec_obj">
<clauseHeading>Primary objects and secondary objects</clauseHeading>

<bodyMatter>

<comment>WG3:W13-010R1</comment>
<comment>Editorial: Stephen Cannan, 2022-02-24 W20-010 P00-USA-327</comment>
<comment>WG3:BER-040R3</comment>
<para>Every GQL-object is either a <newterm>primary</newterm> object or 
a <newterm>secondary</newterm> object.
</para>

<comment>Editorial: Stefan Plantikow, 2020-05-18 Adjusted</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>Editorial: Stefan Plantikow, 2020-07-12 WG3:MMX-055</comment>
<comment>Editorial: Stefan Plantikow, 2020-09-15 Reworded</comment>
<comment>WG3:W13-010R1</comment>
<comment>Editorial: Stefan Plantikow, 2022-03-25 Reworded to use result of evaluation</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:BER-081</comment>
<comment>WG3:UTC-131</comment>
<comment>WG3:UTC-064</comment>
<comment>Email from: Hannes Voigt, 2023-03-01 1716</comment>
<comment>WG3:CMN-061R1</comment>
<comment>WG3:CMN-074</comment>
<para>A primary object is an independently definable GQL-object.
Every primary object is globally identifiable and has a descriptor.
Reference values can refer to primary objects.
Procedures or commands may define new primary objects in the GQL-catalog,
assign reference values referring to primary objects to session parameters in a GQL-session, or 
bind them to local variables, subject to syntax restrictions.
Reference values referring to primary objects may also be passed as GQL-request parameters or
in procedure arguments.
Furthermore, reference values referring to primary objects may be returned as
the result of an execution outcome or generally occur as the result of evaluation.
</para>

<para>This document defines the following kinds of primary objects:
</para>

<comment>Editorial: Stefan Plantikow, 2020-03-07</comment>
<comment>Editorial: Stefan Plantikow, 2022-12-19 WG3:W24-009 286. P00-USA-191</comment>
<ulist>

<comment>Editorial: Stefan Plantikow, 2020-03-06</comment>
<item>Graphs, as defined in <specref ref="gql_conc_g"/>.
</item>

<item>Graph types, as defined in <specref ref="gql_conc_gt"/>.
</item>

<item>Binding tables, as defined in <specref ref="gql_conc_bt"/>.
</item>

<comment>WG3:UTC-077</comment>
<item>Named procedures, as defined in <specref ref="gql_conc_prcmd_procs"/>.
</item>

</ulist>

<comment>Editorial: Stefan Plantikow, 2020-04-01</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-10 result object -> result</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-10 Reworded</comment>
<comment>WG3:W13-010R1</comment>
<comment>Editorial: Stephen Cannan, 2022-02-24 W20-010 P00-USA-049</comment>
<comment>WG3:UTC-131</comment>
<comment>WG3:UTC-064</comment>
<comment>Editorial: Use repeatdefn element</comment>
<comment>WG3:CMN-061R1</comment>
<comment>WG3:CMN-074</comment>
<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<para>A secondary object is a <repeatdefn ref="gql_secondary_object_defn" />.
Reference values can refer to secondary objects. 
A procedure or command may create, modify, delete, or otherwise interact with secondary objects
as long as the primary object that contains them has not been deleted.
Reference values referring to secondary objects may be set as session parameters,
passed as GQL-request parameters or as procedure parameter arguments, bound as local variables,
may occur as the result of expression evaluation, or may be returned as
the result of an execution outcome.
</para>

<para>This document defines the following kinds of secondary objects:
</para>

<ulist>

<comment>Editorial: Stefan Plantikow, 2023-09-13 Add missing references</comment>
<item>Nodes, as defined in <specref ref="gql_conc_g_intro"/>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-09-13 Add missing references</comment>
<item>Edges, as defined in <specref ref="gql_conc_g_intro"/>.
</item>

<comment>WG3:W13-010R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-09-13 Add missing references</comment>
<item>Node types, as defined in <specref ref="gql_conc_ot_node"/>.
</item>

<comment>WG3:W13-010R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-09-13 Add missing references</comment>
<item>Edge types, as defined in <specref ref="gql_conc_ot_edge"/>.
</item>

</ulist>

</bodyMatter>

</subClause2>


<comment>Editorial: Stefan Plantikow, 2020-03-31</comment>
<comment>Editorial: Stefan Plantikow, 2020-07-12 Moved here from GQL-objects</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:W23-037</comment>
<subClause2 id="gql_conc_props_and_spvts">
<clauseHeading>Properties and supported property value types</clauseHeading>

<bodyMatter>

<comment>WG3:BER-040R3</comment>
<comment>WG3:W23-037</comment>
<comment>WG3:CMN-019 P00-ISO-001</comment>
<para>Certain GQL-objects (<eg/> graph elements) can have properties, <ie/> a pair comprising
a name and a value. 
A property name is the name and a property value is the value of a property of such a GQL-object.
</para>

<comment>WG3:W22-041</comment>
<comment>WG3:W23-037</comment>
<comment>WG3:CMN-019 P00-USA-007</comment>
<comment>WG3:CMN-019 P00-NLD-002</comment>
<comment>WG3:W26-026R2</comment>
<para>Every property value is the value of a supported property value type. 
<specref ref="gql_ty_terms_defns"/>, defines a supported property value type as 
a <repeatdefn ref="gql_property_value_type_defn"/>.
</para>

<comment>WG3:W26-026R2</comment>
<note>The empty type is not a supported property value type. 
See <specref ref="gql_immat_null_empty_dts"/>.
</note>

<comment>WG3:W23-037</comment>
<note>The set of all value types that are supported property value types is included in the
conformance claim of a GQL-implementation or a GQL-program. 
See <specref ref="gql_min_conform"/>.
</note>

<comment>WG3:UTC-015</comment>
<para>The <newterm>dynamic property value type</newterm> is an <impDef code="IV011"/> dynamic union
type such that each supported property value type is a subtype of the dynamic property value type.
</para>
<note>See <specref ref="gql_conc_dyn_union_type"/> for more details on dynamic union types.
</note>

</bodyMatter>

</subClause2>
<comment>WG3:UTC-110 Deleted 2 Subclauses</comment>


<comment>Editorial: Stefan Plantikow, 2020-03-10</comment>
<subClause2 id="gql_conc_g">
<clauseHeading>Graphs</clauseHeading>

<subClause3 id="gql_conc_g_intro">
<clauseHeading>Introduction to graphs</clauseHeading>

<bodyMatter>

<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>Email from: Jan Michels, 2022-02-26 0223</comment>
<para>Graphs are the primary form of data that is queried and manipulated by procedures.
</para>

<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>Editorial: Stephen Cannan, 2022-02-26 W20-010 P00-USA-330</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<para>In the GQL language, every graph is a property graph.
Therefore, both terms can be used interchangeably, although the shorter term <quote>graph</quote>
is preferred in this document.
</para>

<comment>WG3:SXM-030r3</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-25 WG3:W20-010 P00-USA-331</comment>
<comment>WG3:CMN-019 P00-ISO-001</comment>
<para>A graph can be a mixed graph, a multigraph, neither, or both and is a primary object that 
comprises:
</para>

<ulist>
<comment>WG3:W22-034R1 deleted two list items</comment>

<item>A set of zero or more globally identifiable nodes.
Each node comprises:

<ulist>

<item>A node label set that comprises a set of zero or more labels.
A label has a name, which is an identifier that is unique within the node.

<comment>WG3:OHD-015</comment>
<para>The minimum cardinality of node label sets is <impDef code="IL001"/>.
</para>

<para>The maximum cardinality of node label sets is <impDef code="IL001"/>.
</para>

</item>

<item>A node property set that comprises zero or more properties.
Each property comprises:

<ulist>

<comment>WG3:CMN-019 P00-USA-009</comment>
<item>Its name, which is an identifier that uniquely identifies the property within
the node property set.

<comment>WG3:CMN-026</comment>
<note>The names of node labels and of node properties are in separate namespaces.
That is, a label and a property can have the same name in a node.
</note>
</item>

<comment>WG3:BER-040R3</comment>
<item>Its value, which can be of any supported property value type.
</item>

</ulist>

<para>The maximum cardinality of node property sets is <impDef code="IL002"/>.
</para>

</item>

</ulist>

</item>

<item>A set of zero or more globally identifiable edges.
Each edge comprises:

<ulist>

<item>An edge label set that comprises a set of zero or more labels.
A label has a name, which is an identifier that is unique within the edge.

<comment>WG3:OHD-015</comment>
<para>The minimum cardinality of edge label sets is <impDef code="IL001"/>.
</para>

<para>The maximum cardinality of edge label sets is <impDef code="IL001"/>.
</para>

</item>

<item>An edge property set that comprises zero or more properties.
Each property comprises:

<ulist>

<comment>WG3:CMN-019 P00-USA-009</comment>
<item>Its name, which is an identifier that uniquely identifies the property within
the edge property set.

<comment>WG3:CMN-026</comment>
<note>The names of edge labels and of edge properties are in separate namespaces.
That is, a label and a property can have the same name in an edge.
</note>
</item>

<comment>WG3:BER-040R3</comment>
<item>Its value, which can be of any supported property value type.
</item>

</ulist>

<para>The maximum cardinality of edge property sets is <impDef code="IL002"/>.
</para>

</item>

<comment>WG3:W09-036 Editorial license</comment>
<item>Two (possibly identical) endpoints, which are nodes contained in the same graph.
</item>

<comment>WG3:W27-013</comment>
<item>The indication of whether the edge is a directed edge or an undirected edge 
(which is also called the <newterm>directionality</newterm> of the edge).

<comment>WG3:W09-036 Editorial license</comment>
<comment>WG3:W23-029R1</comment>
<para>Additionally, a directed edge identifies one of its endpoints as its source, and
the other as its destination.
The direction of a directed edge is from its source to its destination.
If both endpoints of a directed edge are identical, such an edge is a directed loop on a single
graph node.
</para>
<comment>WG3:CMN-026 Removed 1 (one) paragraph</comment>

</item>

</ulist>

</item>

</ulist>

<comment>Editorial: Stefan Plantikow, 2020-07-13 WG3:MMX-055</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>Consequence of WG3:W13-010R1</comment>
<comment>WG3:OHD-014</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>Editorial: Stephen Cannan 2023-01-29 Align with Directives Part 2</comment>
<note>A graph can be a catalog object that has a name, but graphs can exist that have no name, 
or at least have no name that is required to be visible to a user of a GQL-implementation.
<BNF name="graph initializer"/>s (<specref ref="gql_varsparams_graph"/>) are examples of
graphs that do not have visible names. 
Graph variables have names but are not visible in the GQL-catalog.
</note>

<comment>WG3:W23-029R1</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<para>A graph that has a constraining graph type is said to be closed. 
A closed graph cannot contain nodes and edges that are of node types and edge types, 
respectively, that are not specified in the graph<apos/>s constraining graph type. 
A graph that does not have a constraining graph type is said to be open. 
An open graph does not restrict the types of nodes and edges it can contain.
</para>

</bodyMatter>

</subClause3>


<comment>WG3:MMX-028R2</comment>
<comment>WG3:MMX-055</comment>
<subClause3 id="gql_graph_descriptors">
<clauseHeading>Graph descriptors</clauseHeading>

<bodyMatter>

<comment>WG3:CMN-019 P00-USA-204</comment>
<para>A graph is described by a graph descriptor that comprises: 
</para>

<ulist>

<comment>WG3:W22-051</comment>
<comment>WG3:W23-029R1</comment>
<item>The optional constraining graph type that is a globally resolved reference to a graph type 
schema object.
</item>

</ulist>
<comment>WG3:W22-051 deleted one editor's note</comment>

<comment>Consequence of WG3:W13-010R1</comment>
<comment>WG3:W23-030</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<para>For every graph <symdef>G</symdef> that is a catalog object, the graph descriptor of 
<sym>G</sym> is a catalog object descriptor. 
The name of <sym>G</sym> (also known as graph name) is the catalog object name of <sym>G</sym>. 
<sym>G</sym> is a <newterm>named graph</newterm>.
</para>

<comment>WG3:W22-051</comment>
<comment>WG3:W23-029R1</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<para>In this document, the phrase <quote>the graph type of <symdef>G</symdef></quote>, 
where <sym>G</sym> is a graph, is used to refer to the graph type that is identified by the 
constraining graph type in the graph descriptor of <sym>G</sym>.
</para>

</bodyMatter>

</subClause3>


</subClause2>
<comment>Editorial: Stefan Plantikow, 2022-02-24 WG3:W20-010 P00-USA-041, P00-DEU-004</comment>


<comment>Editorial: Stefan Plantikow, 2020-03-12</comment>
<subClause2 id="gql_conc_bt">
<clauseHeading>Binding tables</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-05-04 Add detail to binding table</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-08 Introduce column terminology</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-11 Added purpose</comment>
<comment>WG3:BER-019</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-086R1</comment>
<para>A binding table is a <repeatdefn ref="gql_binding_table_defn"/>.
Binding tables mainly serve as:
</para>

<ulist>

<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>Editorial: Stephen Cannan, 2022-02-24 W20-010 P00-USA-335</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>The primary iteration construct that drives the execution of procedures.
</item>

<comment>Editorial: Stephen Cannan, 2022-02-24 W20-010 P00-USA-335</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>A container that holds intermediary results produced by statements
such as the matches found by graph pattern matching.
</item>

<comment>Editorial: Stephen Cannan, 2022-02-24 W20-010 P00-USA-335</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>WG3:UTC-086R1</comment>
<item>An execution result that is returned to the GQL-agent as part of an execution outcome.
</item>

</ulist>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-068</comment>
<para>The elements of the collection of records of a binding table <symdef>BT</symdef> are 
referred to as the records of <sym>BT</sym> and the number of such records is referred to as the 
cardinality of <sym>BT</sym>.
The <newterm>unit binding table</newterm> is the unordered binding table comprising the unit record.
An <newterm>empty binding table</newterm> is a binding table whose cardinality is 0 (zero).
</para>

<para>Every binding table has an associated binding table descriptor that comprises:
</para>

<ulist>

<comment>WG3:BER-019</comment>
<item>The binding table type of the binding table.

<comment>Editorial: Stephen Cannan 2023-01-29 Align with Directives Part 2</comment>
<note>Binding table records can contain reference values to primary or secondary objects.
</note>

<comment>WG3:CMN-068</comment>
<note>See <specref ref="gql_conc_btt"/>.
</note>

</item>

<comment>WG3:UTC-086R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-03-07 Simplify wording</comment>
<item>The indication of whether the binding table is <newterm>ordered</newterm> or
<newterm>unordered</newterm>.
<note>If a binding table is ordered, then the order of its records has been determined according 
to some <BNF name="sort specification"/>.
</note>

</item>

<comment>Editorial: Stefan Plantikow, 2020-05-11 Made optional</comment>
<comment>WG3:BER-019</comment>
<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-068</comment>
<item>The preferred column name sequence, which is either <quote>not set</quote> or a permutation 
of the column names of the binding table type.

<note>The preferred column name sequence is metadata tracked in this document to allow
implementations to provide a column sequence for a binding table that is returned as 
a result to the GQL-agent.
</note>

</item>

</ulist>

<comment>WG3:W22-053R2</comment>
<comment>WG3:UTC-086R1</comment>
<para>Given a binding table <symdef>BT</symdef>, the record type of <sym>BT</sym> is the record 
type of the binding table type <symdef>BTT</symdef> of <sym>BT</sym>, the column names of 
<sym>BT</sym> are the column names of <sym>BTT</sym>, and the columns of <sym>BT</sym> are the 
columns of <sym>BTT</sym>.
</para>

<comment>WG3:W11-013</comment>
<comment>Editorial: Stephen Cannan, 2022-05-04 Correct application of W11-013</comment>
<comment>WG3:BER-019</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>WG3:W24-037</comment>
<comment>Email from: Nathalie Charbel, 2022-12-20 1738</comment>
<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-068</comment>
<para>The <newterm>effective column name sequence</newterm> of a binding table <symdef>BT</symdef>
is defined as follows. 
If the preferred column name sequence <symdef>PCS</symdef> of <sym>BT</sym> is defined, 
then the effective column name sequence of <sym>BT</sym> is <sym>PCS</sym>.
Otherwise, the effective column name sequence of <sym>BT</sym> is the sequence of column names of 
<sym>BT</sym>&narrownbsp;<apos/>s binding table type in ascending order.
</para>

<comment>Editorial: Stefan Plantikow, 2020-05-08 Corrected and reworded</comment>
<comment>WG3:UTC-086R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-03-07 Simplify wording</comment>
<comment>WG3:CMN-068</comment>
<para>In the absence of relevant additional provisions, binding tables are implicitly initialized 
as unordered and their preferred column name sequence is implicitly initialized as 
<quote>not set</quote>.
</para>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-068</comment>
<para>A <newterm>copy of a binding table without the columns identified by a set of names</newterm>
and similar grammatical variants describes a new binding table <sym>NT</sym> 
whose record type is the record type of a given binding table <symdef>T</symdef> without the fields 
identified by a set of names <symdef>NAMES</symdef> and whose records are the records of 
<sym>T</sym>, each without the fields identified by <sym>NAMES</sym>. 
If <sym>T</sym> is ordered, <sym>NT</sym> is ordered; otherwise, <sym>NT</sym> is unordered.
If the preferred column name sequence of <sym>T</sym> is defined, then the preferred column name 
sequence of <sym>NT</sym> is the preferred column name sequence of <sym>T</sym> without names in 
<sym>NAMES</sym>.
</para>

<comment>WG3:W09-021R1</comment>
<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-019 P00-USA-011</comment>
<para>If a General Rule <symdef>RULE</symdef> refers to
the <symdef>i</symdef>-th record <symdef>RECORD</symdef> of a table <symdef>TABLE</symdef>, then
</para>

<para>Case:
</para>

<olist>

<item>If <sym>TABLE</sym> is an ordered binding table, then <sym>RECORD</sym> is the 
<sym>i</sym>-th record of <sym>TABLE</sym> in the order determined by <sym>TABLE</sym>.
</item>

<item>Otherwise, <sym>TABLE</sym> is an unordered binding table and <sym>RECORD</sym> is the 
<sym>i</sym>-th record in some sequence of all records of <sym>TABLE</sym> in 
an <unDef code="US001"/> order determined for each application of <sym>RULE</sym> and any of its 
subrules.
</item>

</olist>

<comment>WG3:W09-021R1</comment>
<para>If the application of a General Rule <symdef>RULE</symdef> processes all records of 
a binding table using order-independent terms, then the records are to be processed effectively in 
an <unDef code="US001"/> order determined for that application of <sym>RULE</sym> and the
application of all following rules in the same Subclause. 
Otherwise, the records are processed effectively in the order determined by the binding table.
</para>

<comment>WG3:BER-040R3</comment>
<comment>WG3:W09-021R1</comment>
<comment>WG3:CMN-019 P00-ISO-001</comment>
<para>The records of a binding table are not modified after the initial 
construction and population of that binding table.
The binding table assigned to a site <symdef>S</symdef> (such as the current working table) can 
be replaced by assigning a new binding table to <sym>S</sym> but is never modified after its 
initial construction.
</para>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-057R1</comment>
<comment>WG3:W26-024</comment>
<para>Let <symdef>A</symdef> and <symdef>B</symdef> be two binding tables. 
If the record types of <sym>A</sym> and <sym>B</sym> are field name-equal or field name-disjoint, 
then <sym>A</sym> and <sym>B</sym> are <newterm>column name-equal</newterm> or 
<newterm>column name-disjoint</newterm>, respectively.
If the record types of <sym>A</sym> and <sym>B</sym> are comparable value types or
field type-combinable, then <sym>A</sym> and <sym>B</sym> are <newterm>column-comparable</newterm>
or <newterm>column-combinable</newterm>, respectively.
</para>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-057R1</comment>
<note>See <specref ref="gql_conc_record"/>, for the definitions of field name-equal,
field name-disjoint, field type-comparable, and field type-combinable.
</note>

<comment>WG3:UTC-086R1</comment>
<para>The <newterm>combined columns</newterm> of two column-combinable binding tables 
<symdef>A</symdef> and <symdef>B</symdef> are given by the combined field types of the record type 
of <sym>A</sym> and the record type of <sym>B</sym>.
</para>

<comment>WG3:UTC-086R1</comment>
<note>See <specref ref="gql_conc_record"/>, for the definition of combined field types.
</note>

<comment>WG3:W22-053R2</comment>
<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-057R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<para>Let <symdef>A</symdef> and <symdef>B</symdef> be two records whose most specific static 
value types are field type-combinable material closed record types.
If it holds for each pair of fields <symdef>F</symdef><sub><sym>A</sym></sub> from <sym>A</sym> and 
<symdef>F</symdef><sub><sym>B</sym></sub> from <sym>B</sym> with the same name that 
<sym>F</sym><sub><sym>A</sym></sub> and <sym>F</sym><sub><sym>B</sym></sub> have equal values,
then <sym>A</sym> and <sym>B</sym> are called <newterm>naturally joinable</newterm>.
</para>

<comment>WG3:W22-053R2</comment>
<comment>Editorial: Stefan Plantikow, 2022-12-19 WG3:W24 317. P00-USA-204</comment>
<comment>WG3:UTC-086R1</comment>
<para>Given two binding tables <symdef>A</symdef> and <symdef>B</symdef>,
the phrase <sym>B</sym> <newterm>is appended to</newterm> <sym>A</sym> or similar grammatical
variants is used to insert one copy of every record of <sym>A</sym> into the collection of records 
of <sym>B</sym>. 
Appending only occurs during the initial population of <sym>A</sym>.
</para>

<comment>WG3:W22-053R2</comment>
<note>Appending preserves the identity of <sym>A</sym> as a GQL-object.
</note>

<comment>Editorial: Stefan Plantikow, 2020-04-19 Added Cartesian product</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-08 Reworded</comment>
<comment>WG3:W11-013</comment>
<comment>WG3:W09-021R1</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:W22-053R2</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>WG3:UTC-086R1</comment>
<para>The <newterm>Cartesian product</newterm> between a record <symdef>R</symdef> and
a binding table <symdef>T</symdef> whose closed record types are field name-disjoint is 
a new binding table <symdef>NT</symdef> whose columns are given by the union of the field types 
of <sym>R</sym> and columns of <sym>T</sym> and that comprises a collection of new records 
obtained by constructing a new record <symdef>NR</symdef> for every record <symdef>TR</symdef> 
of <sym>T</sym> such that the fields of <sym>NR</sym> are the fields of both <sym>TR</sym> and 
<sym>R</sym>.
</para>

<comment>WG3:W09-021R1</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:W22-053R2</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>WG3:UTC-086R1</comment>
<para>By extension, the Cartesian product between two binding tables <symdef>T1</symdef> and 
<symdef>T2</symdef> that are column name-disjoint is a new binding table <symdef>T3</symdef> 
whose columns are given by given by the union of the columns of <sym>T1</sym> and <sym>T2</sym> 
and that comprises a collection of every record from the Cartesian products between each record of 
<sym>T1</sym> with <sym>T2</sym>.
</para>

<comment>WG3:W22-053R2</comment>
<comment>WG3:UTC-086R1</comment>
<comment>WG3:W26-024</comment>
<para>The <newterm>natural join</newterm> between a record <symdef>R</symdef> and a binding table 
<symdef>T</symdef> (and vice versa) whose closed record types are comparable value types is a new
binding table <symdef>NT</symdef> that comprises the collection of all records obtained by 
constructing a new record for each record <symdef>TR</symdef> from <sym>T</sym> that is naturally 
joinable with <sym>R</sym> by amending <sym>R</sym> with <sym>TR</sym>. 
If <sym>T</sym> is ordered, <sym>NT</sym> is ordered; otherwise, <sym>NT</sym> is unordered.
In this document, the columns of such a binding table <symdef>NT</symdef> are specified explicitly 
such that the value type of every column of <sym>NT</sym> is a supertype of the value type of at 
least one corresponding field type of <sym>R</sym> or column of <sym>T</sym> with an equal name.
</para>

<comment>WG3:W22-053R2</comment>
<note>Amending of records is defined in <specref ref="gql_conc_record"/>.
</note>

<comment>WG3:W22-053R2</comment>
<comment>WG3:UTC-086R1</comment>
<para>By extension, the natural join between two binding tables <symdef>T1</symdef> and 
<symdef>T2</symdef> that are column-comparable is a new binding table <symdef>T3</symdef> that 
comprises the collection of every record from the natural joins between each record of 
<sym>T1</sym> with <sym>T2</sym>. 
In this document, the columns of such a binding table <symdef>T3</symdef> are specified explicitly
such that the value type of every column of <sym>T3</sym> is a supertype of the value type of at 
least one corresponding column of <sym>T1</sym> or <sym>T2</sym> with an equal name.
</para>

</bodyMatter>

</subClause2>


<comment>WG3:W24-009 318. P00-USA-207 removed one Subclause</comment>


<comment>WG3:W24-009 319. P00-USA-208 removed one Subclause</comment>

</subClause>


<subClause id="gql_conc_val">
<clauseHeading>Values</clauseHeading>

<subClause2 id="gql_conc_val_gendescr">
<clauseHeading>General information about values</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-03-31</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-045R1</comment>
<comment>WG3:UTC-045R1</comment>
<para>Values defined in this document are definite objects that either occur at sites to which they
have been assigned (such as results, parameter values, procedure arguments, property values, or
parts of GQL-objects) or are used to describe characteristics of GQL-objects in their descriptors.
</para>

<comment>WG3:UTC-045R1</comment>
<para>Assigning a value to a site implicitly copies the value.
</para>

</bodyMatter>

</subClause2>


<comment>WG3:W26-024</comment>
<subClause2 id="gql_conc_val_comp">
<clauseHeading>Comparable values</clauseHeading>

<bodyMatter>

<comment>WG3:W26-024</comment>
<para><specref ref="gql_val_terms_defns"/>, defines that two values are comparable values if they
are capable of being compared.
For every two values <symdef>LV</symdef> and <symdef>RV</symdef> it holds that
<sym>LV</sym> and <sym>RV</sym> are comparable values if and only if one of the following is true:
</para>

<olist>

<comment>WG3:W26-024</comment>
<item>The provisions in <specref ref="gql_conc"/> regarding value types explicitly determine
<sym>LV</sym> and <sym>RV</sym> as comparable values.
If this is the case, then <sym>LV</sym> and <sym>RV</sym> are said to be
<newterm>essentially comparable values</newterm>.

<comment>WG3:W27-013</comment>
<note>In this document, every two identical values are essentially comparable values.
</note>

</item>

<comment>WG3:W26-024</comment>
<item>The values <sym>LV</sym> and <sym>RV</sym> are not essentially comparable values but the
GQL-implementation supports <feature code="GA04"/>.
If this is the case, then <sym>LV</sym> and <sym>RV</sym> are said to be
<newterm>universally comparable values</newterm>.

<comment>WG3:W26-024</comment>
<note>In the absence of support for <feature code="GA04"/>, no two values are
universally comparable values. 
</note>

</item>

</olist>

<comment>WG3:W26-024</comment>
<para>In summary, <sym>LV</sym> and <sym>RV</sym> are comparable values if and only if
<sym>LV</sym> and <sym>RV</sym> are either essentially comparable values or
universally comparable values.
Further, the two relations defining comparability of values are disjoint, <ie/> no two values are
both essentially comparable values and universally comparable values.
</para>

</bodyMatter>

</subClause2>


<comment>WG3:W26-026R2</comment>
<subClause2 id="gql_conc_dt_props_of_distinct">
<clauseHeading>Properties of distinct values</clauseHeading>

<bodyMatter>

<comment>WG3:RKE-048</comment>
<comment>WG3:UTC-050</comment>
<para>Two values are distinct if they are capable of being distinguished within a given context.
</para>

<comment>WG3:RKE-048</comment>
<para>Two null values are not distinct.
</para>

<comment>WG3:RKE-048</comment>
<para>A null value and a material value are distinct.
</para>

<comment>WG3:RKE-048</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:UTC-050</comment>
<comment>WG3:W26-024</comment>
<para>If two values <symdef>V1</symdef> and <symdef>V2</symdef> are not comparable values, then 
the determination of whether they are distinct raises an exception condition:
<raise class="22" subclass="G04"/>.
</para>

<comment>WG3:CMN-057R1</comment>
<comment>WG3:W26-024</comment>
<note>See <specref ref="gql_conc_val_comp"/>.
</note>

<comment>WG3:CMN-057R1</comment>
<para>The application of the General Rules of <specref ref="gql_distinct_vals"/>, determines 
whether two values are distinct or not.
</para>

</bodyMatter>

</subClause2>


<comment>Editorial: Stefan Plantikow, 2020-03-31</comment>
<subClause2 id="gql_conc_ref_vals">
<clauseHeading>Reference values</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-05-05 Adjust for internal object identifier</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:W22-053R2</comment>
<comment>WG3:CMN-019 P00-USA-007</comment>
<comment>WG3:CMN-019 P00-NLD-001</comment>
<comment>WG3:CMN-074</comment>
<para><specref ref="gql_val_terms_defns"/> defines a reference value as 
a <repeatdefn ref="gql_reference_value_defn"/>.
</para>

<comment>WG3:CMN-074</comment>
<note>A reference value effectively encapsulates the global object identifier of the GQL-object.
</note>

<comment>WG3:BER-040R3</comment>
<comment>WG3:CMN-019 P00-USA-013</comment>
<comment>WG3:CMN-031</comment>
<comment>WG3:W26-024</comment>
<comment>Email from: Nathalie Charbel, 2023-11-20 1628 WG3 W26</comment>
<para>If two reference values have referents of the same static base type,
then they are essentially comparable values.
Two reference values are equal if and only if they refer to the same referent. 
</para>

<comment>WG3:UTC-045R1</comment>
<para>Assigning a reference value to a site implicitly copies the reference value but not its 
referent.
</para>

<comment>WG3:UTC-104</comment>
<comment>Email from: Keith Hare, 2023-09-08 2314</comment>
<comment>WG3:CMN-042</comment>
<comment>WG3:W26-031</comment>
<para>If a referent of a reference value is deleted or the referent’s descriptor is destroyed
while the reference value is still occupying a site, then the reference value is
<newterm>invalidated</newterm>.
In this document, deleting the referent of a given reference value is considered an idempotent
operation.
Accessing any characteristics of a descriptor of the referent or content of the referent of
an invalidated reference value raises an exception condition: 
<raise class="22" subclass="G11"/>.
</para>

<comment>WG3:CMN-063</comment>
<para>Copying an invalidated reference value does not constitute an access to
a characteristic of the descriptor of the referent or the value of the referent and does not raise
the exception.
</para>

</bodyMatter>

</subClause2>


<comment>WG3:W26-026R2</comment>
<subClause2 id="gql_conc_material_vals">
<clauseHeading>Material values and the null value</clauseHeading>

<bodyMatter>

<para>Every value that is not the null value is a material value. 
The null value is a special value, sometimes denoted by the keyword <kw>NULL</kw>. 
This value differs from material values in the following respects:
</para>

<ulist>

<item>The null value is the only value that is included in multiple data types of different static
base types.

<note>See <specref ref="gql_conc_dt_genintro"/>.
</note>

</item>

<item>If the GQL-implementation does not support <feature code="GV71"/>, then the data type of 
the null value implied by the keyword <kw>NULL</kw> cannot always be inferred; hence in such 
a GQL-implementation <kw>NULL</kw> can be used to denote the null value only in certain contexts, 
rather than everywhere that a literal is permitted.
<note>See <specref ref="gql_immat_null_empty_dts"/>.
</note>

</item>

<item>Although the null value is neither equal to any other value nor not equal to any other value,
it is unknown whether or not it is equal to any given value. 
In some contexts, multiple null values are treated together; for example, 
the <BNF name="group by clause"/> treats all null values together.
</item>

</ulist>

<para>Furthermore, the null value of a Boolean type and the truth value <bool>Unknown</bool> are 
the same value.
</para>

<note>See <specref ref="gql_conc_Boolean"/>".
</note>

</bodyMatter>

</subClause2>

</subClause>


<comment>Editorial: Stefan Plantikow, 2019-10-22</comment>
<subClause id="gql_conc_session">
<clauseHeading>GQL-sessions</clauseHeading>

<subClause2 id="gql_conc_session_gendescr">
<clauseHeading>General description of GQL-sessions</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow per suggestion by Stephen Cannan, 2020-03-04</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-06</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-06 Improve wording</comment>
<comment>WG3:W12-019</comment>
<comment>WG3:UTC-073</comment>
<comment>WG3:CMN-061R1</comment>
<para><specref ref="gql_env_terms_defns"/> defines a GQL-session as 
a <repeatdefn ref="gql_GQL_session_defn"/>.
At any one time during a GQL-session, exactly one of these consecutive GQL-requests is being
executed and is said to be the <newterm>executing GQL-request</newterm> of the GQL-session.
</para>

<comment>Editorial: Stephen Cannan, 2020-05-21 Use SQL term</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-06 Add explicit and implicit creation</comment>
<comment>WG3:UTC-073</comment>
<para>A GQL-session is created either explicitly by the GQL-client, on behalf of a GQL-agent or
implicitly whenever a GQL-client, on behalf of a GQL-agent, initiates a request to a GQL-server and
no GQL-session is current.
The GQL-session is terminated, either as the result of
an explicit <BNF name="session close command"/>, or in the absence of
an explicit <BNF name="session close command"/>, following the last request from that GQL-client,
on behalf of that GQL-agent.
The mechanism and rules by which a GQL-implementation determines
when the last request has been received are <impDef code="IW003"/>.
</para>

<comment>Editorial: Stephen Cannan, 2022-03-07 WG3:RKE-010 P00-USA-342</comment>
<para>The context of a GQL-session is manipulated by session management commands.
</para>

</bodyMatter>

</subClause2>


<comment>Editorial: Stefan Plantikow, 2019-10-22</comment>
<comment>Editorial: Stephen Cannan, 2020-05-18 GQL- prefix reduction</comment>
<subClause2 id="gql_conc_session_ctx">
<clauseHeading>Session contexts</clauseHeading>

<subClause3 id="gql_conc_session_ctx_intro">
<clauseHeading>Introduction to session contexts</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-04-06</comment>
<comment>Editorial: Stephen Cannan, 2020-05-18 GQL- prefix reduction</comment>
<comment>Editorial: Stephen Cannan, 2021-01-27 Typo</comment>
<comment>WG3:W21-044</comment>
<para>A session context is a <repeatdefn ref="gql_session_context_defn"/>.
A session context comprises the following characteristics:
</para>

<comment>WG3:W12-019</comment>
<comment>Editorial: Stephen Cannan, 2022-03-07 WG3:RKE-010 P00-USA-343</comment>
<ulist>

<comment>WG3:CMN-061R1</comment>
<item>The authorization identifier, which is a character string.
</item>

<comment>Editorial: Stephen Cannan, 2020-05-11 Clarify principal</comment>
<item>The principal identified by the authorization identifier.
</item>

<comment>Editorial: Stefan Plantikow, 2020-10-06 Change to use time zone identifier</comment>
<comment>WG3:UTC-117 Consequence</comment>
<comment>WG3:CMN-061R1</comment>
<item>The time zone displacement, which is a character string conforming to the representation
specified in <docref ref="ISO8601-1_2019"/>, 4.3.13, <quote>Time shift</quote>.
</item>

<comment>Editorial: Stefan Plantikow, 2020-07-12 WG3:MMX-055</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>WG3:UTC-045R1</comment>
<comment>WG3:CMN-061R1</comment>
<item>The session schema, which is either <quote>not set</quote> or 
an <BNF name="absolute catalog schema reference"/> that identifies a GQL-schema.
</item>

<comment>Editorial: Stefan Plantikow, 2020-10-06 home schema</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>WG3:UTC-045R1</comment>
<comment>WG3:CMN-061R1</comment>
<item>The session graph, which is either <quote>not set</quote> or a material graph reference 
value.
</item>

<comment>Editorial: Stefan Plantikow, 2020-10-06 home graph</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-19 Adjusted terminology</comment>
<comment>WG3:W21-044</comment>
<comment>WG3:CMN-061R1</comment>
<item>The session parameters, which are represented as a (possibly empty) dictionary of general 
parameters.

<comment>Editorial: Stefan Plantikow, 2023-11-06 Align</comment>
<para>The parameter names of <impDef code="ID049"/> default session parameters start with 
underscore (<string>_</string>).
</para>

</item>

<comment>Editorial: Stephen Cannan, 2020-10-16 Improve transaction management</comment>
<comment>WG3:W12-019</comment>
<comment>WG3:W22-035</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>Editorial: Stefan Plantikow, 2023-02-28 Use definite article</comment>
<comment>WG3:CMN-061R1</comment>
<item>The transaction, which is either <quote>not set</quote> or a GQL-transaction.
</item>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>Editorial: Stefan Plantikow, 2023-02-28 Use definite article</comment>
<comment>WG3:CMN-061R1</comment>
<item>The request context, which is either <quote>not set</quote> or a GQL-request context.
</item>

<comment>Editorial: Stefan Plantikow, 2020-10-06 Added explanatory note</comment>
<comment>Editorial: Stephen Cannan, 2021-04-02 See WG3:W09-024</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>The termination flag, which is a Boolean value.

<comment>WG3:W08-013</comment>
<comment>Editorial: Stefan Plantikow, 2022-03-09 Correct formatting and improve wording</comment>
<comment>Editorial: Stephen Cannan 2023-01-29 Align with Directives Part 2</comment>
<note>The termination flag is initially set to <bool>False</bool> but the execution of 
a <BNF name="session close command"/> will set it to <bool>True</bool> to signal that the 
current session is to be terminated.
</note>

</item>

</ulist>

<para>The current session context is the <repeatdefn ref="gql_current_session_context_defn"/>.
</para>

<comment>Editorial: Stefan Plantikow, 2020-10-06 Reworded</comment>
<comment>WG3:BER-010 P00-USA-357</comment>
<comment>WG3:W22-035</comment>
<para>In this document the following phrases are used:
</para>

<comment>Editorial: Stephen Cannan, 2022-03-07 WG3:RKE-010 P00-USA-343</comment>
<ulist>

<comment>WG3:CMN-060</comment>
<comment>Editorial: Stefan Plantikow, 2023-10-18 1 (one) Note</comment>
<item>The <newterm>session authorization identifier</newterm> is the authorization identifier of
the current session context.
</item>

<item>The <newterm>current principal</newterm> is the principal of the current session context.
</item>

<comment>Editorial: Stefan Plantikow, 2020-07-12 WG3:MMX-055</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-06 Add home graph and home schema</comment>
<comment>WG3:CMN-019 025. P00-USA-005</comment>
<item>The <newterm>current home schema</newterm> is the home schema of the current principal.
</item>

<comment>Editorial: Stefan Plantikow, 2020-07-12 WG3:MMX-055</comment>
<comment>WG3:CMN-019 025. P00-USA-005</comment>
<item>The <newterm>current home graph</newterm> is the home graph of the current principal.
</item>

<comment>Editorial: Stefan Plantikow, 2020-10-06 Change to use time zone identifier</comment>
<comment>WG3:UTC-117 Consequence</comment>
<item>The <newterm>current time zone displacement</newterm> is the time zone displacement of
the current session context.
</item>

<comment>Editorial: Stefan Plantikow, 2020-10-06 current home graph</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-06 current home schema</comment>
<comment>Editorial: Stefan Plantikow, 2020-07-12 WG3:MMX-055</comment>
<item>The <newterm>current session schema</newterm> is the session schema of the current session 
context.

</item>

<item>The <newterm>current session graph</newterm> is the session graph of
the current session context.
</item>

<item>The <newterm>current session parameters</newterm> are the session parameters of
the current session context.
</item>

<comment>WG3:W22-035</comment>
<item>The <newterm>current transaction</newterm> is the transaction of the current session context.
</item>

<comment>WG3:UTC-059</comment>
<item>The <newterm>current transaction access mode</newterm> is the 
<BNF name="transaction access mode"/> specified by the transaction characteristics of the 
current transaction.
</item>

<item>The <newterm>current request context</newterm> is the request context of
the current session context.
</item>

<item>The <newterm>current termination flag</newterm> is the termination flag of
the current session context.
</item>

</ulist>

</bodyMatter>

</subClause3>


<comment>Editorial: Stefan Plantikow, 2020-04-07 Add session context creation</comment>
<comment>Editorial: Stephen Cannan, 2020-05-18 GQL- prefix reduction</comment>
<comment>WG3:CMN-061R1</comment>
<subClause3 id="gql_conc_session_ctx_create">
<clauseHeading>Session context creation</clauseHeading>

<bodyMatter>

<comment>Editorial: Stephen Cannan, 2020-05-18 GQL- prefix reduction</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-06 impDef defaulting of characteristics</comment>
<comment>WG3:W22-035</comment>
<comment>WG3:W23-014</comment>
<comment>WG3:CMN-061R1</comment>
<para>A new session context <symdef>SCX</symdef> is created and initialized as follows:
</para>

<note>The provisions specified in <specref ref="gql_conc_req_exe"/> determine the associated 
session context of the GQL-session.
</note>

<ulist>

<item>Let <symdef>AUTH</symdef> be the authorization identifier associated with the GQL-agent. 
The authorization identifier and the principal of <sym>SCX</sym> are set to <sym>AUTH</sym> and 
the principal identified by <sym>AUTH</sym>, respectively.
</item>

<item>The time zone displacement of <sym>SCX</sym> is set to the <impDef code="ID048"/> 
default time zone displacement.
</item>

<item>If the current home schema is defined, then the session schema of <sym>SCX</sym> is set to
the current home schema; otherwise, the session schema of <sym>SCX</sym> is set to 
<quote>not set</quote>.
</item>

<item>If the current home graph is defined, then the session graph of <sym>SCX</sym> is set to 
the current home graph; otherwise, the session graph of <sym>SCX</sym> is set to 
<quote>not set</quote>.
</item>

<item>The session parameters of <sym>SCX</sym> are set to the <impDef code="ID049"/> 
default session parameters.
</item>

<item>The transaction is set to <quote>not set</quote>.
</item>

<item>The request context is set to <quote>not set</quote>.
</item>

<item>The termination flag of <sym>SCX</sym> is set to <bool>False</bool>.
</item>

</ulist>

</bodyMatter>

</subClause3>


<subClause3 id="gql_conc_session_ctx_modification">
<clauseHeading>Session context modification</clauseHeading>

<bodyMatter>

<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>WG3:OHD-023</comment>
<comment>WG3:CMN-061R1</comment>
<para>In this document, the characteristics of a session context are only modified after their 
initialization by:
</para>

<ulist>

<comment>Editorial: Stefan Plantikow, 2020-10-06 Change to time zone identifier</comment>
<comment>WG3:UTC-117 Consequence</comment>
<item>Setting the time zone displacement.
</item>

<comment>Editorial: Stefan Plantikow, 2020-07-12 WG3:MMX-055</comment>
<item>Setting the session schema.
</item>

<item>Setting the session graph.
</item>

<item>Setting the session parameters.
</item>

<comment>WG3:W12-010: Stefan Plantikow, 2021-06-15 Removing the implicit transaction flag</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-06 Added more detailed restrictions</comment>
<comment>WG3:RKE-042 Editorial</comment>
<comment>WG3:CMN-061R1</comment>
<item>Setting the transaction.
</item>

<item>Setting the request context upon starting or terminating the execution of a GQL-request.
</item>

<comment>WG3:CMN-061R1</comment>
<item>Setting the termination flag to <bool>True</bool> to signal that the GQL-session is about 
to be terminated.
</item>

</ulist>

</bodyMatter>

</subClause3>

</subClause2>

</subClause>


<comment>WG3:SXM-027-Access control and transactions in the first version of GQL</comment>
<subClause id="gql_conc_tx">
<clauseHeading>GQL-transactions</clauseHeading>

<subClause2 id="gql_conc_tx_gendescr">
<clauseHeading>General description of GQL-transactions</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-03-31</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-06</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>WG3:UTC-112</comment>
<para>A <newterm>GQL-transaction</newterm> (transaction) is a sequence of executions of procedures 
that is atomic with respect to recovery.
That is to say: either the complete execution of each procedure results in a successful 
outcome, or the failed execution of any procedures results in having no effect on any objects in
the GQL-catalog or on GQL-data.
</para>

<comment>Editorial: Stephen Cannan, 2020-05-21 Use SQL term</comment>
<comment>WG3:RKE-042 Editorial</comment>
<comment>WG3:UTC-073</comment>
<para>At any time, there is at most one currently active transaction in a GQL-session.
A single transaction may span several consecutive GQL-requests of a GQL-session, but
a single GQL-request is always contained within a single transaction.
Initiation and termination of a transaction does not affect the GQL-session context except for
registering the presence or absence of a current transaction.
</para>

<comment>WG3:RKE-042 Editorial</comment>
<comment>WG3:W23-009R1 P00-USA-216</comment>
<para>For the purposes of this document there is only one currently active transaction,
which is the behavior of a system that only supports serializable transactions.
</para>

<para>Statements within a procedure effectively execute serially.
The state of GQL-data and the GQL-catalog, as affected by a successfully-completed statement,
are visible to a successor statement.
</para>

<para>Any relaxation of the assumption of the serializable transactional behavior (for example,
less restrictive isolation levels) is an <impDef code="IE004"/> extension.
</para>

<comment>Editorial: Stephen Cannan, 2020-05-07 Clarify mixed transactions.</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>Editorial: Stefan Plantikow, 2022-12-19 Correct logical connective</comment>
<para>A GQL-implementation may define different kinds of GQL-transactions
to be initiated for the execution of a catalog-modifying procedure,
a data-modifying procedure, or a query procedure.
</para>

<comment>WG3:CMN-055</comment>
<para>Catalog-modifying procedures performing statements such as <kw>CREATE</kw> <kw>SCHEMA</kw>,
<kw>CREATE</kw> <kw>GRAPH</kw>, <kw>DROP</kw> <kw>GRAPH</kw>, and <kw>DROP</kw> <kw>SCHEMA</kw> may
require the allocation or release of operating system resources that are not under
transaction control in a GQL-implementation. 
It is <impDef code="IW025"/> which and how many catalog-modifying procedures are under
transaction control, and which catalog-modifying procedures can be contained in
a single transaction.
</para>

<comment>WG3:BER-022</comment>
<comment>Editorial: Stefan Plantikow, 2022-12-19 Switch order of procedure kinds allowed</comment>
<para>If a GQL-implementation supports <feature code="GP18"/>, then a GQL-transaction can contain 
the execution of both catalog-modifying and data-modifying procedures. 
Without <feature code="GP18"/>, executing catalog-modifying and data-modifying procedures in 
the same GQL-transaction results in an exception.
If permitted, there may be additional <impDef code="IE006"/> restrictions, requirements, 
and conditions.
If any such restrictions, requirements, or conditions are violated, then 
an exception condition or a completion condition warning is raised with 
an <impDef code="IE007"/> class and/or subclass code.
</para>

</bodyMatter>

</subClause2>


<subClause2 id="gql_conc_tx_demarcation">
<clauseHeading>Transaction demarcation</clauseHeading>

<bodyMatter>
 
<comment>Editorial: Stephen Cannan, 2020-05-21 Use SQL term</comment>
<comment>Editorial: Stefan Plantikow, 2021-06-15 WG3:W12-010</comment>
<comment>WG3:OHD-023</comment>
<comment>WG3:UTC-116</comment>
<para>The GQL language includes the following explicit transaction demarcation commands,
to be issued by agents in GQL-requests to a GQL-server.
</para>

<comment>Editorial: Stephen Cannan, 2020-05-18 GQL- prefix reduction</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>WG3:W12-010: Stefan Plantikow, 2021-06-15 Removing the implicit transaction flag</comment>
<comment>Editorial: Stephen Cannan, 2022-03-05 WG3:RKE-010 P00-USA-081</comment>
<comment>Editorial: Stephen Cannan, 2022-03-05 WG3:RKE-010 P00-USA-344</comment>
<para>A GQL-transaction can be initiated by a GQL-agent submitting a GQL-request that specifies 
a <BNF name="start transaction command"/>.
If no GQL-transaction has been initiated, the commencement of execution of a procedure will 
initiate a GQL-transaction.
</para>

<comment>Editorial: Stephen Cannan, 2020-05-18 GQL- prefix reduction</comment>
<comment>WG3:W12-010: Stefan Plantikow, 2021-06-15 Removing the implicit transaction flag</comment>
<comment>Editorial: Stephen Cannan, 2022-03-05 WG3:RKE-010 P00-USA-081</comment>
<comment>Editorial: Stephen Cannan, 2022-03-05 WG3:RKE-010 P00-USA-345</comment>
<para>The <BNF name="start transaction command"/> allows the specification of the characteristics 
of the GQL-transaction, such as the mode (read-only or read-write).
If a <BNF name="start transaction command"/> is submitted when there is already an active 
GQL-transaction, then an exception condition is raised: <raise class="25" subclass="G01"/>.
</para>

<comment>Editorial: Stefan Plantikow, 2020-03-26</comment>
<para>Every GQL-transaction is terminated by an attempt to either commit or a rollback.
A successful rollback causes the transaction to have no effect on the GQL-catalog or GQL-data;
a successful commit causes the execution outcome to be completely successful.
</para>

<comment>Editorial: Stephen Cannan, 2020-05-18 GQL- prefix reduction</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 Use SQL term</comment>
<comment>WG3:CMN-019 P00-ISO-001</comment>
<para>The GQL-agent that initiated a transaction can request the GQL-implementation to
either commit or rollback that transaction by submitting a GQL-request that specifies 
a transaction commit command or a transaction rollback command to the GQL-server.
</para>

<comment>Editorial: Stephen Cannan, 2020-05-18 GQL- prefix reduction</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 Use SQL term</comment>
<comment>WG3:RKE-042 Editorial</comment>
<para>The transaction demarcation commands may be submitted in the same GQL-request as a procedure.
A&nbsp;GQL-request may state a <BNF name="start transaction command"/> prior to the procedure,
allowing specifying characteristics of the transaction started for that procedure.
A GQL-request may state a transaction commit command or a transaction rollback command
following the procedure.
A GQL-request containing a transaction commit command following a procedure causes a request
to the GQL-server to terminate the currently active GQL-transaction by committing
upon the successful completion of that procedure.
A GQL-request containing a transaction rollback command following a procedure causes
a request to the GQL-server to terminate the currently active GQL-transaction by
rolling back upon the successful completion of that procedure.
</para>

<comment>Editorial: Stephen Cannan, 2022-03-05 WG3:RKE-010 P00-USA-083</comment>
<comment>WG3:W26-032R1</comment>
<para>If a GQL-transaction becomes blocked, cannot complete without causing semantic inconsistency,
or if the resources required to continue its execution become unavailable, then 
it is <unDef code="UA007"/> whether or not a rollback is forced.
</para>

<comment>Editorial: Stefan Plantikow, 2022-12-19 WG3:W24-009 333. P00-USA-221</comment>
<comment>WG3:W26-032R1 Minuted change</comment>
<para>Any execution of a procedure with a failed outcome will cause an attempt by
the GQL-implementation to rollback the current transaction.
</para>

<ednote id="gql_PP030">It would be preferable to (be able to) decide in the application logical 
whether to commit or rollback.
See <PPref ref="PPgql030"/>.
</ednote>

<ednote id="gql_LO374"><PPref ref="PPgql374"/> questions the general policy of rollback on 
exception.
See <PPref ref="PPgql374"/>.
</ednote>

<comment>Editorial: Stephen Cannan, 2022-03-05 WG3:RKE-010 P00-USA-346</comment>
<comment>Editorial: Stefan Plantikow, 2022-12-19 WG3:W24-009 334. P00-USA-222</comment>
<para>Once a commit or rollback has been issued, then no further procedures will be executed in 
the sequence of procedures that make up the transaction.
</para>

<comment>Editorial: Stefan Plantikow, 2020-02-23</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>Editorial: Stephen Cannan, 2022-03-05 WG3:RKE-010 P00-USA-347</comment>
<comment>WG3:OHD-023</comment>
<para>Once requested, transaction termination either succeeds or fails.
If a termination request cannot be processed successfully, then the state of the GQL-catalog and
GQL-data becomes indeterminate.
The ways in which termination success or failure
statuses are made available to the GQL-agent or to an administrator is <impDef code="IW005"/>.
</para>

<comment>WG3:UTC-116</comment>
<para>Starting and terminating of transactions may be accomplished by <impDef code="IW004"/> means
(including proprietary agent-server protocols, transaction managers that act out of band to
agent-server interactions, auto-starting, and auto-rollback on exception of transactions).
The behavior of transactions started and terminated by an <impDef annex="no" code="None"/>
means shall be the same as transactions started with a <BNF name="start transaction command"/> and
terminated with an <BNF name="end transaction command"/>.
</para>

</bodyMatter>

</subClause2>


<subClause2 id="gql_conc_tx_isolation">
<clauseHeading>Transaction isolation</clauseHeading>

<bodyMatter>

<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>Editorial: Stephen Cannan, 2022-03-05 WG3:RKE-010 P00-USA-348</comment>
<comment>WG3:W23-033</comment>
<para>Provisional (uncommitted) changes to the GQL-catalog or GQL-data state that are made in 
the context of a transaction executing a catalog-modifying procedure or a data-modifying procedure
may be visible, at some point or to some degree, to other GQL-agents executing 
a concurrent transaction.
Other than serializable, the levels of transaction isolation, their interactions, their granularity
of application, and the means of selecting them are <impDef code="IE002"/>.
</para>

<note>GQL-implementations are therefore free to use the isolation levels defined in <SQL/>,
or more recently-defined levels such as Snapshot Isolation or Serializable Snapshot Isolation,
or other industrially-applied or theoretical variants.
</note>

</bodyMatter>

</subClause2>


<comment>Editorial: Stephen Cannan, 2020-10-16 Add missing description of encompassing txns
</comment>
<subClause2 id="gql_trans_encompassing_extagent">
<clauseHeading>Encompassing transaction belonging to an external agent</clauseHeading>

<bodyMatter>

<para>In some environments (<eg/> remote database access), a GQL-transaction can be 
part of an encompassing transaction that is controlled by an agent other than the GQL-agent.
</para>

<comment>WG3:OHD-023</comment>
<para>In such environments, an encompassing transaction is terminated via that
other agent, which interacts with the GQL-implementation via 
an interface that may be different from GQL (<kw>COMMIT</kw> or <kw>ROLLBACK</kw>), in order to
coordinate the orderly termination of the encompassing transaction.
If the encompassed GQL-transaction is terminated by an implicitly initiated
<BNF name="rollback command"/>, then the GQL-implementation will interact with that other agent 
to terminate that encompassing transaction.
The specification of the interface between such agents and the GQL-implementation is beyond the
scope of this document.
However, it is important to note that the semantics of a GQL-transaction remain as defined in 
the following sense:
</para>

<ulist>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>When an agent other than the GQL-agent requests the
GQL-implementation to rollback a GQL-transaction, the General Rules of 
<specref ref="gql_tx_rollback"/>, are performed.
</item>

<comment>Editorial: Stefan Plantikow, 2022-02-24 WG3:W20-010 P00-USA-374</comment>
<item>When such an agent requests the GQL-implementation to commit a GQL-transaction, 
the General Rules of <specref ref="gql_tx_commit"/>, are performed.
To guarantee orderly termination of the encompassing transaction, this commit operation may be 
processed in several phases not visible to the application; it is not required that all of the
General Rules of <specref ref="gql_tx_commit"/>, are executed in a single phase.
</item>

</ulist>

</bodyMatter>

</subClause2>

</subClause>


<comment>Editorial: Stefan Plantikow, 2020-04-07 Re-factored context structure</comment>
<comment>Editorial: Stefan Plantikow, 2019-10-22</comment>
<comment>WG3:W23-014</comment>
<subClause id="gql_conc_req">
<clauseHeading>GQL-requests and GQL-programs</clauseHeading>


<comment>WG3:W23-014</comment>
<subClause2 id="gql_conc_req_gendescr">
<clauseHeading>General description of GQL-requests and GQL-programs</clauseHeading>

<bodyMatter>

<comment>WG3:BER-086R1</comment>
<comment>WG3:CMN-061R1</comment>
<para>A GQL-request is the basic unit of communication between the GQL-client and the GQL-server.
</para>

<comment>WG3:CMN-061R1</comment>
<para>A GQL-request is described by a GQL-request descriptor that comprises:
</para>

<ulist>

<comment>WG3:W08-013</comment>
<comment>WG3:W23-014</comment>
<comment>Editorial: Stefan Plantikow 2023-09-13 Wording</comment>
<comment>WG3:CMN-061R1</comment>
<item>The GQL-program, which is a <newterm>GQL source text</newterm>.

<comment>WG3:CMN-032</comment>
<comment>WG3:CMN-061R1</comment>
<para>A GQL source text is a character string whose character repertoire shall be 
an <impDef code="IV001"/> subset of the Universal Character Set repertoire specified by 
<docref ref="Unicode"/> that includes every <BNF name="GQL language character"/> and every 
<BNF name="other language character"/> supported by the GQL-implementation.
</para>

<note>Any additional character not included in the character repertoire of GQL source text can
still be represented in character string literals and identifiers by 
an <BNF name="escaped character"/>.
</note>

</item>

<comment>Editorial: Stephen Cannan 2021-12-08 Standardize on GQL-implementation</comment>
<comment>Editorial: Stephen Cannan, 2022-03-02 WG3:RKE-010 P00-USA-349 and P00-USA-540</comment>
<comment>Editorial: Stefan Plantikow, 2022-05-24 Adjusted for WG3:W21-044</comment>
<comment>WG3:W23-014</comment>
<comment>Editorial: Stefan Plantikow 2023-09-13 Wording</comment>
<comment>WG3:CMN-061R1</comment>
<item>The GQL-request parameters, which are represented as a (possibly empty) dictionary of
general parameters that is implicitly determined using an <impDef code="IW006"/> mechanism.
</item>

</ulist>

<comment>WG3:BER-086R1</comment>
<comment>WG3:W23-014</comment>
<comment>WG3:CMN-061R1</comment>
<para>If the GQL-program is GQL source text in conforming GQL language, then it is generated by
a <BNF name="GQL-program"/> <symdef>PROG</symdef> that specifies the commands and GQL-procedures 
that are to be executed; otherwise, an exception condition is raised as specified by 
<specref ref="gql_conc_req_exe"/>.
The request outcome of a GQL-request is the execution outcome of the requested GQL-program.
</para>

</bodyMatter>

</subClause2>


<subClause2 id="gql_conc_req_ctx">
<clauseHeading>GQL-request contexts</clauseHeading>

<subClause3 id="gql_conc_req_ctx_intro">
<clauseHeading>Introduction to GQL-request contexts</clauseHeading>

<bodyMatter>

<para>A GQL-request context is a <repeatdefn ref="gql_GQL_request_context_defn"/> and 
that comprises the following characteristics:
</para>

<comment>Editorial: Stephen Cannan, 2022-03-02 WG3:RKE-010 P00-USA-354</comment>
<ulist>

<comment>Editorial: Stefan Plantikow, 2020-05-19 Request parameters added</comment>
<comment>WG3:W21-044</comment>
<comment>WG3:W23-014</comment>
<comment>WG3:CMN-061R1</comment>
<item>The dynamic parameters, which are represented as a (possibly empty) dictionary of general 
parameters.
</item>

<comment>Editorial: Stefan Plantikow, 2023-10-27 Change order of items</comment>
<comment>WG3:UTC-132</comment>
<comment>WG3:CMN-019 P00-USA-015</comment>
<comment>WG3:CMN-061R1</comment>
<item>The request timestamp, which is either <quote>not set</quote> or a zoned datetime
at which every <BNF name="datetime value function"/> in the GQL-program is effectively
evaluated.
<note>See <specref ref="gql_conc_temporal"/>.
</note>
</item>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>The execution stack, which is a push-down stack of execution contexts.
</item>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>The request outcome, which is an execution outcome.
</item>

</ulist>

<comment>WG3:BER-010 P00-USA-357</comment>
<comment>WG3:W22-035</comment>
<para>In this document the following phrases are used:
</para>

<comment>Editorial: Stephen Cannan, 2022-03-02 WG3:RKE-010 P00-USA-354</comment>
<ulist>

<comment>Editorial: Stefan Plantikow, 2023-10-27 Change order of items</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-19 Added request parameters</comment>
<comment>WG3:CMN-061R1</comment>
<item>The <newterm>current dynamic parameters</newterm> are the dynamic parameters of
the current request context.
</item>

<comment>WG3:UTC-132</comment>
<item>The <newterm>current request timestamp</newterm> is the request timestamp of
the current request context.
</item>

<item>The <newterm>current execution stack</newterm> is the execution stack of
the current request context.
</item>

<item>The <newterm>current request outcome</newterm> is the request outcome of
the current request context.
</item>

</ulist>

</bodyMatter>

</subClause3>


<subClause3 id="gql_conc_req_create">
<clauseHeading>GQL-request context creation</clauseHeading>

<bodyMatter>

<comment>WG3:W21-044</comment>
<comment>Editorial: Stephen Cannan 2022-08-09</comment>
<comment>WG3:W23-014</comment>
<comment>WG3:CMN-061R1</comment>
<para>A new GQL-request context <symdef>RCX</symdef> is created and initialized with a dictionary 
of dynamic parameters <symdef>DYN_PARAMS</symdef> as follows:
</para>

<note>The provisions specified in <specref ref="gql_conc_req_exe"/> define the 
current request context of the currently executing GQL-request.
</note>

<ulist>

<comment>Editorial: Stefan Plantikow, 2023-10-27 Change order of items</comment>
<item>The dynamic parameters of <sym>RCX</sym> are set to <sym>DYN_PARAMS</sym>.
</item>

<item>The request timestamp of <sym>RCX</sym> is set to <quote>not set</quote>.
</item>

<item>The execution stack of <sym>RCX</sym> is set to a new empty execution stack.
</item>

<item>The request outcome of <sym>RCX</sym> is set to a successful outcome with an omitted result.
</item>

</ulist>

</bodyMatter>

</subClause3>


<subClause3 id="gql_conc_req_modification">
<clauseHeading>GQL-request context modification</clauseHeading>

<bodyMatter>

<comment>WG3:BER-076</comment>
<comment>WG3:CMN-061R1</comment>
<para>In this document, application of General Rules only modifies an already initialized
GQL-request context by:
</para>

<comment>WG3:CMN-061R1</comment>
<ulist>

<item>Pushing a new execution context onto its execution stack.
</item>

<item>Popping an execution context from its execution stack.
</item>

<item>Setting its request outcome.
</item>

<item>Setting its request timestamp.
</item>

</ulist>

</bodyMatter>

</subClause3>

</subClause2>


<comment>WG3:CMN-061R1</comment>
<subClause2 id="gql_conc_req_exe">
<clauseHeading>Execution of GQL-requests</clauseHeading>

<bodyMatter>

<para>If a GQL-request <symdef>REQUEST</symdef> is submitted by the GQL-client on behalf of the 
GQL-agent to the GQL-server in the context of the GQL-environment, then <sym>REQUEST</sym> is 
executed by effectively performing the following steps:
</para>

<olist>

<item>Let <symdef>SESSION</symdef> be the GQL-session in which <sym>REQUEST</sym> was submitted. 
If no session context has been associated with <sym>SESSION</sym>, then a new session context is 
created and initialized, as specified in <specref ref="gql_conc_session_ctx_create"/>, and 
associated with <sym>SESSION</sym>.

<note>This ensures that the current session context is defined.
</note>

</item>

<item>Let <symdef>SCX</symdef> be the current session context and let <symdef>SES_SCHEMA</symdef>,
<symdef>SES_GRAPH</symdef> and <symdef>SES_PARAMS</symdef> be the session schema, 
the session graph, and the session parameters, respectively, of <sym>SCX</sym>.
</item>

<item>Let <symdef>DYN_PARAMS</symdef> be the dictionary of general parameters comprising every 
session parameter of <sym>SCX</sym> whose parameter name is not the parameter name of 
a GQL-request parameter of <sym>REQUEST</sym> and every GQL-request parameter of 
<sym>REQUEST</sym>.
</item>

<item>Let <symdef>PROG</symdef> be determined by effectively performing the following steps:

<olist>

<item>If the GQL-program <symdef>SOURCE</symdef> of <sym>REQUEST</sym> conforms to the Format of
<BNF name="GQL-program"/>, then <sym>SOURCE</sym> forms the BNF non-terminal instance 
<sym>PROG</sym> that is determined by the left normal form derivation of <sym>SOURCE</sym> from 
<BNF name="GQL-program"/>; otherwise, an exception condition is raised: <raise class="42"/>.
</item>

<item>The <applySC ref="gql_annot_gql_program" rules="SR">
<symarg param="GQL_PROGRAM"><sym>PROG</sym></symarg>
<symarg param="INI_SCHEMA"><sym>SES_SCHEMA</sym></symarg>
<symarg param="INI_GRAPH"><sym>SES_GRAPH</sym></symarg>
<symarg param="SES_PARAMS"><sym>SES_PARAMS</sym></symarg>
<symarg param="DYN_PARAMS"><sym>DYN_PARAMS</sym></symarg>
</applySC>.
</item>

<item>The Syntax Rules and Conformance Rules of <specref ref="gql_program"/> are applied
to <sym>PROG</sym>.
</item>

<item>The execution of <sym>PROG</sym> shall be permitted according to the provisions of 
<specref ref="gql_auth_ids"/>.
</item>

<item>If performing any of the preceding steps fails, then an exception condition is raised.
Unless a Syntax Rule, Access Rule, or other provision was violated in
the determination of <sym>PROG</sym> that specifies an explicit exception condition,
an exception condition is raised: 
<raise class="42"/>.
</item>

</olist>

</item>

<item>Let <symdef>RCX</symdef> be a new request context that is initialized with 
<sym>DYN_PARAMS</sym> as its dictionary of dynamic parameters.
</item>

<item>The current request context is set to <sym>RCX</sym>.
</item>

<comment>WG3:CMN-051</comment>
<item>Case:

<olist>

<comment>WG3:CMN-051</comment>
<comment>WG3:W26-033</comment>
<item>If the preceding determination of <sym>PROG</sym> caused exception conditions to be raised,
then the current request outcome is set to a failed outcome that records these exception
conditions in accordance with the provisions of <specref ref="gql_conditions"/>. 
If multiple exception conditions with the same highest priority have been raised, then
it is <unDef code="UW001"/> which of these exception conditions is set as
the status of the current request outcome. 
</item>

<item>Otherwise, the General Rules of <specref ref="gql_program"/> are applied to <sym>PROG</sym> in
a new root execution context. 
The provisions of <specref ref="gql_conc_tx"/>, are effective.
If this application of General Rules fails and thus causes the GQL-implementation to rollback the
currently active GQL-transaction, then the current transaction is set to <quote>not set</quote>.

<comment>WG3:W26-033</comment>
<note>In the case of failure, the current execution stack is effectively abandoned.
</note>

</item>

</olist>

</item>

<item>If the current transaction is active and the current termination flag is set to 
<bool>True</bool>, then the General Rules of <specref ref="gql_tx_rollback"/>, are applied in 
a new root execution context.

<note>This sets the current request outcome to a failed outcome.
</note>

</item>

<item>The current request outcome is returned to the GQL-client for delivery to the GQL-agent.

<comment>WG3:W26-033</comment>
<note>This includes the result (if any), the declared type of the result (if available), and all
recorded diagnostic information.
See <specref ref="gql_conc_exe_outcome"/>.
</note>

</item>

<item>If the current termination flag is set to <bool>True</bool>, then <sym>SCX</sym> is 
dissociated from <sym>SESSION</sym> and <sym>SCX</sym> and <sym>RCX</sym> may be destroyed; 
otherwise, the current termination flag is set to <bool>False</bool> and 
the current request context is set to <quote>not set</quote>.
</item>

</olist>

</bodyMatter>

</subClause2>


<subClause2 id="gql_conc_woschema">
<clauseHeading>Working schema references</clauseHeading>
<bodyMatter>

<comment>WG3:CMN-042</comment>
<para>In addition to the current request context and the current session context, the execution of 
procedures, statements, and commands interacts with GQL-schemas identified by working schema
references.
</para>

<comment>WG3:CMN-042</comment>
<para>A <newterm>working schema reference</newterm> is
an <BNF name="absolute catalog schema reference"/> identified by the Syntax Rules of
a BNF non-terminal instance, such as a <BNF name="GQL-program"/> or
a <BNF name="use graph clause"/>.
A working schema reference has a scope.
A BNF non-terminal instance that identifies a working schema reference has a scope clause.
</para>

<comment>WG3:CMN-042</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<para>In this document, the phrase <newterm>current working schema reference</newterm> of
<symdef>A</symdef> is used to refer to one specific working schema reference of
a BNF non-terminal instance <sym>A</sym> (unless <quote>omitted</quote>), defined as follows.
</para>

<comment>WG3:CMN-042</comment>
<para>Case:
</para>

<olist>

<comment>WG3:CMN-042</comment>
<item>If there is a working schema reference <symdef>WSR</symdef> identified by
the BNF non-terminal instance with the innermost scope clause containing <sym>A</sym> and
the scope of <sym>WSR</sym> includes <sym>A</sym>, then
the current working schema reference of <sym>A</sym> is <sym>WSR</sym>.
</item>

<comment>WG3:CMN-042</comment>
<item>Otherwise, the current working schema reference of <sym>A</sym> is <quote>omitted</quote>.
</item>

</olist>

<comment>WG3:CMN-042</comment>
<para>The phrase <newterm>current working schema</newterm> of <symdef>A</symdef> is used to refer to
one specific GQL-schema (unless <quote>omitted</quote>), defined as follows.
</para>

<comment>WG3:CMN-042</comment>
<para>Case:
</para>

<olist>

<comment>WG3:CMN-042</comment>
<item>If the current working schema reference of <sym>A</sym> is defined, then
the current working schema of <sym>A</sym> is the GQL-schema identified by
the current working schema reference of <sym>A</sym>.

<comment>WG3:CMN-042</comment>
<note>The GQL-schema identified by an <BNF name="absolute catalog schema reference"/> is defined by
the Syntax Rules of <specref ref="gql_schema_refs"/>.
</note>

</item>

<comment>WG3:CMN-042</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<item>Otherwise, the current working schema of <sym>A</sym> is <quote>omitted</quote>.
</item>

</olist>

<comment>WG3:CMN-042 Removed 10 (ten) paragraphs</comment>

</bodyMatter>

</subClause2>


<subClause2 id="gql_conc_wograph">
<clauseHeading>Working graph site</clauseHeading>

<bodyMatter>
<comment>WG3:CMN-042</comment>
<para>In addition to the current request context, the current session context, and working schema 
references, the execution of procedures, statements, and commands interacts with graphs that are
the referent of graph reference values occupying sites identified as working graph sites.
</para>

<comment>WG3:CMN-042</comment>
<para>A working graph site is a site whose declared type is a graph reference value type and that
is identified by the Syntax Rules of a BNF non-terminal instance, such as
a <BNF name="GQL-program"/> or a <BNF name="use graph clause"/>.
A working graph site has a scope.
A BNF non-terminal instance that identifies a working graph site has a scope clause.
Once a working graph site <symdef>WGS</symdef> is occupied, the graph referenced by <sym>WGS</sym>
is the graph that is the referent of the graph reference value occupying <sym>WGS</sym>.
</para>

<comment>WG3:CMN-042</comment>
<note>In this document, the phrase <quote>graph referenced by a working graph site</quote>
is not used in Syntax Rules.
</note>

<comment>WG3:CMN-042</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<para>In this document,
the phrase <newterm>current working graph</newterm> site of <symdef>A</symdef> is used to refer to
one specific working graph site of a BNF non-terminal instance <sym>A</sym>
(unless <quote>omitted</quote>), defined as follows.
</para>

<comment>WG3:CMN-042</comment>
<para>Case:
</para>

<comment>WG3:CMN-042</comment>
<ulist>

<comment>WG3:CMN-042</comment>
<item>If there is a site <symdef>WGS</symdef> that is identified as a working graph site by
the BNF non-terminal instance with the innermost scope clause containing <sym>A</sym> and
the scope of <sym>WGS</sym> includes <sym>A</sym>, then
the current working graph site of <sym>A</sym> is <sym>WGS</sym>.
</item>

<comment>WG3:CMN-042</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<item>Otherwise, the current working graph site of <sym>A</sym> is <quote>omitted</quote>.
</item>

</ulist>

</bodyMatter>

</subClause2>

<subClause2 id="gql_conc_req_stack">
<clauseHeading>Execution stack</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-10-16 Clarified lowest/highest</comment>
<comment>Editorial: Stefan Plantikow, 2022-12-19 WG:W24-009 341. P00-USA-225</comment>
<para>The execution stack is a <repeatdefn ref="gql_execution_stack_defn"/>.
The execution stack is created and initialized with a new execution context explicitly by
the General Rules of <specref ref="gql_program"/>.
This newly created execution context is always the lowest execution context in the execution stack.
</para>

<comment>Editorial: Stefan Plantikow, 2020-04-13 Made push for commands optional</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>WG3:UTC-096R1</comment>
<comment>WG3:CMN-035</comment>
<para>An execution context is pushed on the stack for each procedure or command
that is executed, and is removed when that procedure or command completes
execution.
Child execution contexts may be pushed on the stack for the execution of a statement, 
the evaluation of an expression, or the processing of some other BNF non-terminal instance.
If such an execution context has been created, it is removed when that execution, evaluation, or
processing completes.
</para>

<comment>Editorial: Stefan Plantikow, 2020-10-16 Added note</comment>
<comment>WG3:CMN-061R1</comment>
<note>Changes to the execution stack are always explicitly specified in <specref ref="gql_conc"/> 
or by General Rules.
</note>

<comment>Editorial: Stefan Plantikow, 2020-10-16 Reworded</comment>
<comment>WG3:CMN-019 P00-USA-007</comment>
<comment>WG3:CMN-061R1</comment>
<para>The current execution context is always the highest execution context in the execution stack
of the currently executing GQL-request.
</para>

</bodyMatter>

</subClause2>


<comment>WG3:UTC-105</comment>
<subClause2 id="gql_conc_prcmd_ops">
<clauseHeading>Operations</clauseHeading>

<bodyMatter>

<comment>WG3:CMN-019 P00-USA-007</comment>
<comment>WG3:CMN-047R1</comment>
<para><specref ref="gql_proc_terms_defns"/> defines an operation as an identifiable action
carried out by an execution.
Operations are either indivisible or comprise multiple successive suboperations.
</para>

<comment>WG3:CMN-061R1</comment>
<para>The execution of a GQL-request is the operation that evaluates the specified GQL-program of
that GQL-request.
</para>

<comment>WG3:CMN-061R1</comment>
<note>See <specref ref="gql_conc_req_exe"/>.
</note>

<comment>WG3:CMN-061R1</comment>
<comment>WG3:CMN-035</comment>
<para>The execution of a component of the GQL language specified by a BNF non-terminal instance is
the operation that evaluates that BNF non-terminal instance.
In particular:
</para>

<ulist>


<comment>WG3:CMN-047R1</comment>
<item>A GQL-program is executed by evaluating the specified GQL-procedure or the specified
commands of the GQL-program.
</item>

<comment>WG3:CMN-047R1</comment>
<item>A GQL-procedure is executed by evaluating the variable definitions and statements of
the GQL-procedure that are specified in the <BNF name="procedure body"/>.
</item>

<comment>WG3:CMN-047R1</comment>
<item>An external procedure is executed by evaluating its procedural logic.
</item>

<item>A command is executed by evaluating the specified syntactic elements of the command.
</item>

<item>A statement is executed by evaluating the specified syntactic elements of the statement.
</item>

</ulist>

<comment>WG3:CMN-047R1</comment>
<para>Certain operations can cause one or more side effects specified in this document.
Such side effects can be session-modifying, transaction-modifying, catalog-modifying, or
data-modifying.
</para>

<comment>WG3:CMN-047R1</comment>
<note>See <specref ref="gql_proc_terms_defns"/>.
</note>

<comment>WG3:CMN-047R1</comment>
<para>The side effects of a composite operation include the side effects of its suboperations, 
if any.
</para>

<comment>WG3:CMN-047R1</comment>
<para>The construction of a new GQL-object is not considered as causing a catalog-modifying side
effect or a data-modifying side effect, per se.
However the assignment of such a newly constructed GQL-object to certain sites is
possibly considered as causing a catalog-modifying side effect or a data-modifying side effect,
depending on the nature of the site.   
</para>

<comment>WG3:CMN-047R1</comment>
<note>As an example, the construction and initial population of a transient binding table that
is not assigned to a site in the GQL-catalog or the session context during the application of
General Rules is not considered a catalog-modifying side effect or a data-modifying side effect.
</note>

<comment>WG3:W26-032R1</comment>
<para>Operations that are performed as part of executing a GQL-request are considered as
<newterm>successful operations</newterm> or as <newterm>failed operations</newterm>, respectively, 
depending on the current execution outcome present immediately after their completion.
</para>

<comment>WG3:CMN-047R1 (one) Subclause</comment>

</bodyMatter>

</subClause2>

</subClause>


<comment>Editorial: Stefan Plantikow, 2019-10-22</comment>
<subClause id="gql_conc_exe">
<clauseHeading>Execution contexts</clauseHeading>

<subClause2 id="gql_conc_exe_gendescr">
<clauseHeading>General description of execution contexts</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-04-07 Adjusted as part of context refactoring</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-09 Reworded</comment>
<comment>WG3:W09-021R1</comment>
<para>An execution context is a <repeatdefn ref="gql_execution_context_defn"/>.
It provides access to visible objects, allowing their manipulation by the execution of 
a procedure or a command.
</para>

<para>An execution context comprises the following characteristics:
</para>

<comment>Editorial: Stefan Plantikow, 2020-03-07</comment>
<comment>Editorial: Stephen Cannan, 2022-02-16 WG3:W20-010 P00-USA-355</comment>
<ulist>

<comment>Editorial: Stefan Plantikow, 2020-05-18 local parameters replaced by local variables
</comment>
<comment>Editorial: Stefan Plantikow, 2020-07-12 WG3:MMX-055</comment>
<comment>WG3:W19-017 Working schema removed</comment>

<comment>WG3:W09-021R1</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>WG3:UTC-096R1 Change order of items</comment>
<item>The working record, which is a record.
</item>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>WG3:UTC-096R1 Change order of items</comment>
<item>The working table, which is a binding table.
</item>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>The execution outcome, which is an execution outcome.
</item>

</ulist>

<comment>WG3:UTC-087R2</comment>
<para>For every execution context <symdef>CONTEXT</symdef> created or modified by the General Rules
specified in this document, it always holds that the working table and the working record of 
<sym>CONTEXT</sym> are field name-disjoint.
</para>

<comment>Editorial: Stefan Plantikow, 2020-04-07 Adjusted as part of context refactoring</comment>
<comment>Editorial: Stephen Cannan, 2022-02-26 W20-010 P00-USA-356</comment>
<para>The atomicity of multiple operations that are executed in an execution context depends on 
the types of the operations.
</para>

<comment>Editorial: Stefan Plantikow, 2020-04-07 Introduced as part of context refactoring</comment>
<comment>WG3:W09-021R1</comment>
<comment>Editorial: Stefan Plantikow, 2022-12-19 WG3:W24-009 345. P00-USA-228</comment>
<para>The current execution context is the <repeatdefn ref="gql_current_execution_context_defn"/>.
</para>

<comment>WG3:BER-010 P00-USA-357</comment>
<comment>WG3:W23-009R1 P00-USA-229</comment>
<para>In this document the following phrases are used:
</para>

<comment>Editorial: Stephen Cannan, 2022-02-16 WG3:W20-010 P00-USA-355</comment>
<ulist>
<comment>Editorial: Stefan Plantikow, 2020-05-18 local parameters replaced by local variables
</comment>
<comment>Editorial: Stefan Plantikow, 2020-07-12 WG3:MMX-055</comment>
<comment>WG3:W19-017 Working schema removed</comment>

<comment>WG3:UTC-096R1</comment>
<item>The <newterm>current working record</newterm> is the working record of
the current execution context.
</item>

<item>The <newterm>current working table</newterm> is the working table of
the current execution context.
</item>

<comment>Editorial: Stefan Plantikow, 2020-05-11 One note removed</comment>
<comment>Editorial: Use repeatdefn element</comment>
<item>The current execution outcome is the <repeatdefn ref="gql_current_execution_outcome_defn"/>.
</item>

<comment>Editorial: Stefan Plantikow, 2020-10-10 result object -> result</comment>
<comment>Email from: Jan Michels, 2022-02-26 0223</comment>
<comment>Editorial: Use repeatdefn element</comment>
<item>The current execution result is the <repeatdefn ref="gql_current_execution_result_defn"/>.
</item>

</ulist>

<comment>WG3:BER-019</comment>
<comment>WG3:W23-014</comment>
<comment>WG3:CMN-035</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<para>In this document, the Syntax Rules applying to a BNF non-terminal instance <symdef>X</symdef>
that is contained in a <BNF name="GQL-program"/> can refer to the following additional transient 
sites and their declared types:
</para>

<ulist>

<comment>WG3:UTC-096R1 Change order of items</comment>
<comment>WG3:XRH-036</comment>
<item>The <newterm>incoming working record</newterm> of <sym>X</sym> is the current working record
immediately before the application of the first General Rule of <sym>X</sym>.
The <newterm>incoming working record type</newterm> of <sym>X</sym> is 
the declared type of the incoming working record of <sym>X</sym>.
</item>

<comment>WG3:UTC-096R1 Change order of items</comment>
<comment>WG3:XRH-036</comment>
<item>The <newterm>incoming working table</newterm> of <sym>X</sym> is the current working table 
immediately before the application of the first General Rule of <sym>X</sym>.
The <newterm>incoming working table type</newterm> of <sym>X</sym> is 
the declared type of the incoming working table of <sym>X</sym>.
</item>

<comment>WG3:UTC-096R1 Change order of items</comment>
<comment>WG3:CMN-019 P00-USA-016</comment>
<comment>WG3:XRH-036</comment>
<item>The <newterm>outgoing working record</newterm> of <sym>X</sym> is the current working record
immediately after the application of the last applicable General Rule of <sym>X</sym>.
The <newterm>outgoing working record type</newterm> of <sym>X</sym> is 
the declared type of the outgoing working record of <sym>X</sym>.
</item>

<comment>WG3:UTC-096R1 Change order of items</comment>
<comment>WG3:CMN-019 P00-USA-016</comment>
<comment>WG3:XRH-036</comment>
<item>The <newterm>outgoing working table</newterm> of <sym>X</sym> is the current working table 
immediately after the application of the last applicable General Rule of <sym>X</sym>.
The <newterm>outgoing working table type</newterm> of <sym>X</sym> is 
the declared type of the outgoing working table of <sym>X</sym>.
</item>

</ulist>

<comment>WG3:UTC-096R1</comment>
<comment>WG3:CMN-035</comment>
<comment>WG3:XRH-036</comment>
<para>If a BNF non-terminal instance <symdef>INNER</symdef> is immediately contained in 
a BNF non-terminal instance <symdef>OUTER</symdef> and if neither 
the incoming working record type of <sym>INNER</sym> nor the incoming working table type
of <sym>INNER</sym> is specified explicitly, then all of the following conditions are implicit:
</para>

<ulist>

<comment>WG3:UTC-096R1</comment>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>INNER</sym> is the the incoming working record type
of <sym>OUTER</sym>.
</item>

<comment>WG3:UTC-096R1</comment>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>INNER</sym> is the the incoming working table type
of <sym>OUTER</sym>.
</item>

</ulist>

<comment>WG3:UTC-096R1</comment>
<comment>WG3:CMN-035</comment>
<comment>WG3:XRH-036</comment>
<para>If every possible instance <symdef>OUTER</symdef> of a BNF non-terminal symbol &lt;OUTER&gt;
immediately contains exactly one BNF non-terminal instance <symdef>INNER</symdef> and
if neither the outgoing working record type of <sym>OUTER</sym>,
nor the outgoing working table type of <sym>OUTER</sym>,
nor the declared type of <sym>OUTER</sym> itself is specified explicitly, then
all of the following conditions are implicit:
</para>

<ulist>

<comment>WG3:UTC-096R1</comment>
<comment>WG3:XRH-036</comment>
<item>For the outgoing working record type of <sym>OUTER</sym>:

<para>Case:
</para>

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<comment>WG3:XRH-036</comment>
<item>If the outgoing working record type of <sym>INNER</sym> is not
<quote>omitted</quote>, then the outgoing working record type of <sym>OUTER</sym> is
the outgoing working record type of <sym>INNER</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<comment>WG3:XRH-036</comment>
<item>Otherwise, the outgoing working record type of <sym>OUTER</sym> is <quote>omitted</quote>.
</item>

</olist>

</item>

<comment>WG3:UTC-096R1</comment>
<item>For the outgoing working table type of <sym>OUTER</sym>:

<para>Case:
</para>

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<comment>WG3:XRH-036</comment>
<item>If the outgoing working table type of <sym>INNER</sym> is not
<quote>omitted</quote>, then the outgoing working table type of <sym>OUTER</sym> is
the outgoing working table type of <sym>INNER</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<comment>WG3:XRH-036</comment>
<item>Otherwise, the outgoing working table type of <sym>OUTER</sym>
is <quote>omitted</quote>.
</item>
<endbar/>

</olist>

</item>

<comment>WG3:UTC-096R1</comment>
<item>For the declared type of <sym>OUTER</sym>:

<para>Case:
</para>

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<item>If the declared type of <sym>INNER</sym> is not <quote>omitted</quote>, then
the declared type of <sym>OUTER</sym> is the declared type of <sym>INNER</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<item>Otherwise, the declared type of <sym>OUTER</sym> is <quote>omitted</quote>.
</item>

</olist>

</item>

</ulist>

<comment>WG3:W26-026R2</comment>
<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<para>For every BNF non-terminal instance <symdef>NT</symdef> that has an execution outcome: 
if and only if <sym>NT</sym> has an omitted result, then the declared type of <sym>NT</sym> is 
the empty type.
</para>

<comment>WG3:W26-026R2</comment>
<note>See <specref ref="gql_immat_null_empty_dts"/>.
</note>

</bodyMatter>

</subClause2>


<comment>WG3:CMN-061R1</comment>
<subClause2 id="gql_conc_exe_create">
<clauseHeading>Execution context creation and initialization</clauseHeading>

<bodyMatter>

<comment>Editorial: Stephen Cannan, 2022-03-02 WG3:RKE-010 P00-USA-459</comment>
<para>A new execution context is be created by one of the following approaches:
</para>

<comment>Editorial: Stephen Cannan, 2022-03-02 WG3:RKE-010 P00-USA-358</comment>
<ulist>

<comment>Editorial: Stefan Plantikow, 2020-04-07 Reword</comment>
<comment>WG3:BER-051R1</comment>
<comment>WG3:CMN-061R1</comment>
<item>Creating a new <newterm>root execution context</newterm> <symdef>RTX</symdef> that is 
initialized as follows:

<ulist>

<item>The working table of <sym>RTX</sym> is set to a new unit binding table.
</item>

<item>The working record of <sym>RTX</sym> is set to a new empty record.
</item>

<item>The execution outcome of <sym>RTX</sym> is set to a successful outcome with 
an omitted result.
</item>

</ulist>

</item>

<comment>Editorial: Stefan Plantikow, 2020-04-18 Introduce child execution context</comment>
<comment>WG3:CMN-061R1</comment>
<item>Creating a new <newterm>child execution context</newterm> <symdef>CTX</symdef> that is 
initialized as follows:

<ulist>

<comment>Editorial: Stefan Plantikow, 2020-05-12 Fix wording</comment>
<comment>WG3:W12-019</comment>
<comment>Editorial: Stephen Cannan, 2022-03-02 WG3:RKE-010 P00-USA-359</comment>
<comment>WG3:UTC-096R1</comment>
<comment>WG3:CMN-061R1</comment>
<item>The working record of <sym>CTX</sym> is set to a copy of the current working record.
</item>

<comment>WG3:W12-019</comment>
<comment>WG3:CMN-061R1</comment>
<item>The working table of <sym>CTX</sym> is set to a unit binding table.
</item>

<comment>WG3:UTC-096R1</comment>
<comment>WG3:CMN-061R1</comment>
<item>The execution outcome of <sym>CTX</sym> is set to a copy of the current execution outcome.
</item>

</ulist>

<comment>Editorial: Stefan Plantikow, 2020-05-12 Reworded</comment>
<comment>WG3:BER-051R1</comment>
<comment>Editorial: Stefan Plantikow, 2022-08-23 Properly introduce variable</comment>
<comment>Editorial: Stefan Plantikow, 2022-12-19 WG3:W24-009 348. P00-USA-230</comment>
<para>The creation of a new child execution context may be further modified
by overriding some of its characteristics <symdef>CHARACTERISTIC</symdef> using a phrase such as
<quote>with <ellipsis/> as its <sym>CHARACTERISTIC</sym></quote> or similar grammatical 
variants.
</para>

</item>

</ulist>

<comment>WG3:CMN-061R1</comment>
<para>The execution of a <symdef>PROGRAM</symdef> in a new root execution context using
a phrase such as <quote>perform <sym>PROGRAM</sym> in a new root execution context</quote> or
similar grammatical variants is defined as follows:
</para>

<comment>WG3:BER-051R1</comment>
<olist>

<comment>WG3:CMN-061R1</comment>
<item>A new root execution context <symdef>CTX0</symdef> is created.

<note>This establishes the current execution context.
</note>

</item>

<comment>WG3:CMN-061R1</comment>
<comment>WG3:CMN-061R1</comment>
<item><sym>CTX0</sym> is pushed onto the current execution stack.
</item>

<comment>WG3:CMN-061R1</comment>
<item><sym>PROGRAM</sym> is performed.
</item>

<comment>WG3:CMN-061R1</comment>
<item>The current request outcome is set to the current execution outcome.
</item>

<comment>WG3:CMN-061R1</comment>
<item>The current execution stack is popped.

<note>This empties the current execution stack.
</note>

</item>

</olist>

<comment>Editorial: Stefan Plantikow, 2020-05-14 Added note on extra child contexts</comment>
<comment>Editorial: Stephen Cannan 2021-12-08 Standardize on GQL-implementation</comment>
<comment>Editorial: Stephen Cannan 2023-01-29 Align with Directives Part 2</comment>
<comment>WG3:CMN-019 P00-ISO-015</comment>
<comment>WG3:CMN-019 P00-ISO-016</comment>
<note>A GQL-implementation can choose to implement an instruction to execute an <emph>ACTION</emph>
in a new child execution context by executing it directly in the current execution context instead,
as long as that direct execution is indistinguishable from the execution in a new child
execution context that was specified by the instruction.
</note>

<comment>WG3:BER-051R1</comment>
<para>The execution of an <symdef>ACTION2</symdef> in a new child execution context amended with 
some record <symdef>R</symdef> using a phrase such as <quote>perform <sym>ACTION2</sym> in a new 
child execution context amended with <sym>R</sym></quote> or similar grammatical variants is 
defined as follows:
</para>

<olist>

<comment>WG3:W22-053R2</comment>
<item>Let <symdef>AWR</symdef> be the current working record amended with <sym>R</sym>.

<note>Amending of records is defined in <specref ref="gql_conc_record"/>.
</note>

</item>

<item>Let <symdef>ACTION1</symdef> be defined as the following sequence of actions:

<olist>

<comment>WG3:W22-053R2</comment>
<item>Set the current working record to <sym>AWR</sym>.
</item>


<item>Perform <sym>ACTION2</sym>.
</item>

</olist>

</item>

<item>Perform <sym>ACTION1</sym> in a new child execution context.
</item>

</olist>

<comment>WG3:UTC-096R1</comment>
<comment>Editorial: Stephen Cannan, 2024-04-10 Move unwanted content out of newterm</comment>
<para>For a BNF non-terminal instance <symdef>NT</symdef>, the phrases 
<newterm>is the result of</newterm> <sym>NT</sym>,
<newterm>of the result of</newterm> <sym>NT</sym>,
<newterm>is the value of</newterm> <sym>NT</sym>, and
<newterm>of the value of</newterm> <sym>NT</sym>
or similar grammatical variants are used in General Rules to refer to the result of
the execution outcome present after a single evaluation of <sym>NT</sym> in
a new execution context that copies each of its characteristics from
the corresponding characteristics of its parent execution context.
</para>

<comment>WG3:UTC-096R1</comment>
<note>If these phrases are used for the same non-terminal instance in two separate
current execution contexts, then these effectively represent two independent evaluations
in two separate child execution contexts.
</note>

</bodyMatter>

</subClause2>


<subClause2 id="gql_conc_exe_modification">
<clauseHeading>Execution context modification</clauseHeading>

<bodyMatter>

<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>WG3:BER-062</comment>
<comment>WG3:CMN-061R1</comment>
<para>In this document, the characteristics of an execution context are only modified after their
initialization by:
</para>

<comment>Editorial: Stefan Plantikow, 2020-03-07</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-07 Adjusted for context refactoring</comment>
<ulist>

<comment>Editorial: Stefan Plantikow, 2020-05-18 Working parameters removed by parameter terminology
reform
</comment>
<comment>Editorial: Stefan Plantikow, 2020-07-12 WG3:MMX-055</comment>
<comment>WG3:W19-017: Stefan Plantikow, 2022-01-31 1529 Working schema removed</comment>

<item>Setting the working table.
</item>

<item>Setting the working record.
</item>

<item>Setting the execution outcome.
</item>

</ulist>

</bodyMatter>

</subClause2>


<comment>Editorial: Stefan Plantikow, 2020-02-05</comment>
<subClause2 id="gql_conc_exe_outcome">
<clauseHeading>Execution outcomes</clauseHeading>

<bodyMatter>

<para>An execution outcome is a <repeatdefn ref="gql_execution_outcome_defn"/>
and comprises:
</para>

<comment>Editorial: Stephen Cannan, 2022-03-02 WG3:RKE-010 P00-USA-360</comment>
<ulist>

<comment>WG3:W10-010R1</comment>
<comment>WG3:BER-099R1</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-06 Align wording with other items</comment>
<item>A <newterm>status</newterm>, which is the (primary) GQL-status object of
the execution outcome.
</item>

<comment>WG3:W26-033</comment>
<item>A (possibly empty) list of additional GQL-status objects.
This list is empty by default unless specified otherwise.
</item>

<comment>WG3:BER-060</comment>
<comment>WG3:BER-099R1</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>WG3:UTC-064</comment>
<comment>WG3:W26-033</comment>
<item>An optional <newterm>result</newterm>, which (if present) is either a regular result or
an omitted result (as explained below).
</item>

</ulist>

<para>An execution outcome is one of:
</para>

<ulist>

<comment>Editorial: Stefan Plantikow, 2020-10-10 result object -> result</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>WG3:BER-060</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>A successful outcome, which is an <repeatdefn ref="gql_successful_outcome_defn"/>.
The result of a successful outcome is one of:

<ulist>

<comment>WG3:W12-019</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<item>A regular result is a <repeatdefn ref="gql_regular_result_defn"/>.
</item>

<comment>WG3:W12-019</comment>
<item>An omitted result is a <repeatdefn ref="gql_omitted_result_defn"/>.
</item>

</ulist>

</item>

<comment>WG3:BER-060</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>A failed outcome, which is an <repeatdefn ref="gql_failed_outcome_defn"/>.
The failed outcome has no result.
</item>

</ulist>

<comment>WG3:UTC-064</comment>
<para>In particular, the result of a successful outcome can be any of the following:
</para>

<comment>WG3:UTC-064</comment>
<ulist>

<comment>Email from: Hannes Voigt, 2023-03-01 1716</comment>
<comment>WG3:UTC-064</comment>
<comment>WG3:CMN-035</comment>
<item>The result of a successful outcome representing the outcome of an execution of a procedure,
a command, a statement, or an expression that is a <BNF name="composite query expression"/>, or
a BNF non-terminal instance related to the execution of one of these items is either
an omitted result or a binding table.
</item>

<comment>WG3:UTC-064</comment>
<comment>Email from: Hannes Voigt, 2023-03-01 1716</comment>
<item>The result of a successful outcome representing the outcome of an execution of an expression
that is a <BNF name="value expression"/> is a value.
</item>

<comment>WG3:UTC-064</comment>
<comment>Email from: Hannes Voigt, 2023-03-01 1716</comment>
<item>The result of a successful outcome representing the outcome of an execution of an expression
that is a <BNF name="graph expression"/> is a graph reference value.
</item>

<comment>WG3:UTC-064</comment>
<comment>Email from: Hannes Voigt, 2023-03-01 1716</comment>
<item>The result of a successful outcome representing the outcome of an execution of an expression
that is a <BNF name="binding table expression"/> is a binding table reference value.
</item>

</ulist>

<comment>WG3:UTC-064</comment>
<comment>Editorial: Stephen Cannan, 2023-08-10</comment>
<note>As a counterexample, the <BNF name="use graph clause"/> and
the <BNF name="at schema clause"/> are not executed. 
They do not have any General Rules and do not interact with an execution context.
Consequently, they have neither an execution outcome nor a result.
</note>

<comment>WG3:W26-026R2</comment>
<para>It is <impDef code="IA001"/>, whether the declared type of a regular result of 
a successful outcome of a GQL-request is exposed to the GQL-client. 
The empty type that is the declared type of an omitted result of a successful outcome of 
a GQL-request is not exposed to the GQL-client.
</para>

<comment>WG3:W10-010R1</comment>
<comment>Editorial: Stefan Plantikow, 2022-05-04 Wording</comment>
<comment>WG3:CMN-061R1</comment>
<para>The GQL-status object of a successful outcome has a GQLSTATUS that corresponds to
a completion condition and that indicates that any previous errors have been recovered and
no new exception condition was raised by the last operation executed in the execution context.
</para>

<comment>WG3:W10-010R1</comment>
<comment>Editorial: Stefan Plantikow, 2022-05-04 Wording</comment>
<comment>WG3:CMN-061R1</comment>
<para>The GQL-status object of a failed outcome has a GQLSTATUS that corresponds to
an exception condition and that indicates that a previously raised exception condition was not 
recovered or that a new exception condition was raised by the last operation executed in the 
execution context.
</para>

<comment>WG3:BER-099R1</comment>
<para>If a non-terminal <symdef>NT</symdef> has an outcome, then it is an execution outcome and 
the result and status of <sym>NT</sym> are the result and status, respectively, of the outcome 
of <sym>NT</sym>.
</para>

</bodyMatter>

</subClause2>

</subClause>


<comment>WG3:W10-010R1</comment>
<comment>Editorial: Stefan Plantikow, 2022-11-11 Renamed for clarity</comment>
<subClause id="gql_diaginf_conc">
<clauseHeading>Diagnostic information</clauseHeading>

<comment>Editorial: Stefan Plantikow, 2022-11-11 Renamed for clarity</comment>
<subClause2 id="gql_diaginf_intro">
<clauseHeading>Introduction to diagnostic information</clauseHeading>

<bodyMatter>

<comment>Editorial: Stephen Cannan, 2022-03-01 WG3:RKE-010 P00-USA-361</comment>
<comment>Editorial: Stefan Plantikow, 2022-11-11 Reword to use executions of programs</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-06 Reword to use returned</comment>
<para>Following the execution of a GQL-request, diagnostic information is returned to the GQL-client
that originated that GQL-request.
</para>

<comment>Editorial: Stefan Plantikow, 2021-04-29 Wording</comment>
<comment>WG3:W23-039</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-06 W26-033 Consequenly link to outcome</comment>
<para>This diagnostic information is contained in the status of an execution outcome that describes
the returned (primary) condition and
that may also include additional <impDef code="ID017"/> diagnostic information.
</para>

<comment>Editorial: Stefan Plantikow, 2023-11-06 W26-028 Consequenly link to outcome</comment>
<note>See <specref ref="gql_conc_exe_outcome"/>.
</note>

<para>It is <impDef code="IW007"/> how a GQL-status object is presented to a GQL-client.
</para>

<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>Editorial: Stephen Cannan, 2022-003-01 WG3:RKE-010 P00-USA-362</comment>
<comment>Editorial: Stefan Plantikow, 2022-05-04 Wording</comment>
<comment>Editorial: Stephen Cannan 2023-01-29 Align with Directives Part 2</comment>
<comment>WG3:W26-033</comment>
<note>For example, in a Java environment a GQL-status object with a GQLSTATUS whose
corresponding condition<apos/>s category is <quote>X</quote> could cause a Java runtime exception
to be thrown.
</note>

<comment>WG3:W26-033</comment>
<para>The diagnostic information made available to the GQL-client is the diagnostic information
recorded in the current request outcome.
</para>

<comment>WG3:W26-033</comment>
<note>See <specref ref="gql_conc_session_ctx"/>.
</note>

</bodyMatter>

</subClause2>


<comment>Editorial: Stephen Cannan, 2020-04-20</comment>
<comment>WG3:W10-010R1</comment>
<comment>Editorial: Stefan Plantikow, 2022-11-11 Moved due to top-down struct </comment>
<subClause2 id="gql_conc_diagarea">
<clauseHeading>GQL-status objects</clauseHeading>

<bodyMatter>

<comment>WG3:W26-033</comment>
<para>A <newterm>GQL-status object</newterm> represents a <newterm>condition</newterm>
together with all related diagnostic information.
</para>

<comment>Editorial: Stefan Plantikow, 2022-11-11 Forward reference to conditions</comment>
<note>Conditions are introduced in <specref ref="gql_conditions"/>.
</note>

<comment>WG3:W08-013</comment>
<comment>WG3:BER-072</comment>
<comment>WG3:W23-014</comment>
<para>Whenever a GQL-request is executed, it sets values, representing one or more conditions 
resulting from that execution, in a GQL-status object.
These values give some indication of what has happened.
The diagnostic information is returned as part of the request outcome to the GQL-client.
</para>

<comment>Editorial: Stefan Plantikow, 2021-04-29 Editorial</comment>
<para>Each GQL-status object comprises:
</para>

<ulist>

<comment>Editorial: Stefan Plantikow, 2021-06-22 Be precise about string types</comment>
<comment>Editorial: Stefan Plantikow, 2022-11-11 Reword to clarify</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>A GQLSTATUS, which is a character string identifying a condition as defined in 
<specref ref="gql_diagrepr_gqlstatus"/>.
</item>

<comment>Editorial: Stefan Plantikow, 2021-06-19 consistent use of "character string"</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>Editorial: Stephen Cannan, 2022-07-06 Eliminate mixed lists</comment>
<comment>WG3:W23-039</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>A <newterm>status description</newterm>, which is a character string describing
the GQLSTATUS.
</item>

<comment>WG3:W22-036</comment>
<item>A record with diagnostic information as defined in <specref ref="gql_diagrepr_rec"/>.
</item>

<comment>WG3:W26-033 Removed 1 (one) item</comment>

<comment>WG3:W26-033</comment>
<item>An optional nested GQL-status object for providing additional diagnostic information,
such as a cause.
</item>

<comment>WG3:W26-033 Removed 1 (one) item</comment>

</ulist>

<comment>WG3:W26-033</comment>
<para>The diagnostic record can include additional <impDef code="ID017"/> fields.
The names of such fields shall start with underscore (<string>_</string>).
</para>

<comment>WG3:CMN-019 P00-USA-018</comment>
<para>Without <feature code="GA08"/>, a GQL-status object in a conforming GQL-implementation
shall not contain a diagnostic record.
</para>

<comment>Editorial: Stephen Cannan, 2022-07-06 Eliminate mixed lists</comment>
<comment>WG3:W23-039</comment>
<comment>WG3:CMN-019 P00-USA-019</comment>
<para>A status description is the concatenation of either a standard description or 
an <impDef code="ID016"/> translation of that standard description appropriate for the locale of 
the GQL-client, and any <impDef code="IV016"/> additional text about the condition provided by the 
GQL-implementation.
</para>

<comment>Editorial: Stefan Plantikow, 2022-05-04 WG3:W20-010 P00-USA-367</comment>
<para>A <newterm>standard description</newterm> is defined as follows:
</para>

<olist>

<item>Let <symdef>CAT</symdef>, <symdef>SUBCLASS</symdef>, <symdef>COND</symdef>, 
and <symdef>SUBCOND</symdef> be the Category, Subclass, Condition, and Subcondition fields of the
associated row in <specref ref="gql_gqlstatevals"/>, for the condition corresponding to the
GQLSTATUS.
</item>

<comment>WG3:CMN-078 Removed 1 (one) Rule</comment>

<comment>WG3:CMN-078</comment>
<item>Let <symdef>TEXT</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:CMN-078</comment>
<item>If <sym>CAT</sym> is <string>S</string>, <string>N</string>, or <string>X</string>, then

<para>Case:
</para>

<olist>

<comment>WG3:CMN-078</comment>
<item>If <sym>SUBCLASS</sym> is <string>000</string>, then <sym>TEXT</sym> is <sym>COND</sym>.
</item>

<comment>WG3:CMN-078</comment>
<item>Otherwise, <sym>TEXT</sym> is the concatenation of <sym>COND</sym>, <string> - </string>,
and <sym>SUBCOND</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-078</comment>
<item>Otherwise, <sym>CAT</sym> is <string>W</string> or <string>I</string>, and <sym>TEXT</sym> is
<sym>SUBCOND</sym>.
</item>

</olist>

</item>

<item>Case:

<olist>

<item>If <sym>CAT</sym> is <string>X</string>, then the standard description is the concatenation 
of <string>error: </string> and <sym>TEXT</sym>.
</item>

<comment>WG3:W23-039</comment>
<comment>WG3:CMN-078</comment>
<item>If <sym>CAT</sym> is <string>W</string>, then the standard description is the concatenation 
of <string>warn: </string> and <sym>SUBCOND</sym>.
</item>

<comment>WG3:CMN-078</comment>
<item>If <sym>CAT</sym> is <string>S</string> or <string>N</string>, then the standard description
is the concatenation of <string>note: </string> and <sym>TEXT</sym>.
</item>

<comment>WG3:CMN-019 P00-USA-020</comment>
<comment>WG3:CMN-078</comment>
<item>Otherwise, <sym>CAT</sym> is <string>I</string> and the standard description is
the concatenation of <string>info: </string> and <sym>TEXT</sym>.
</item>

</olist>

</item>

</olist>

<comment>Editorial: Stephen Cannan 2021-12-08 Standardize on GQL-implementation</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-24 WG3:W20-010 P00-USA-370</comment>
<comment>Editorial: Stefan Plantikow, 2022-05-04 Reword and clarify</comment>
<comment>Editorial: Stefan Plantikow, 2022-11-13 Reword</comment>
<para>At the beginning of an execution, the current GQL-status object is emptied.
A GQL-implementation places diagnostic information about a completion condition or an exception
condition corresponding to the GQLSTATUS into this GQL-status object.
If other conditions are raised, the extent to which further GQL-status objects are included is 
<impDef code="IA002"/>.
</para>

</bodyMatter>

</subClause2>


<comment>Editorial: Stephen Cannan, 2020-04-20</comment>
<subClause2 id="gql_conditions">
<clauseHeading>Conditions</clauseHeading>

<bodyMatter>

<comment>Editorial: Stephen Cannan, 2022-03-01 WG3:RKE-010 P00-USA-363</comment>
<comment>Editorial: Stefan Plantikow, 2022-05-04 Wording</comment>
<comment>WG3:BGI-033</comment>
<para>Processing of GQL-requests can cause various conditions to be raised.
Each such condition is identified by a unique code called GQLSTATUS, which is a character
string that always includes a class code that specifies the principle category to which
the condition belongs.
It may also include a subclass code that specifies additional information about the reason for
raising the condition.
The exact format of GQLSTATUS codes is specified in <specref ref="gql_diagrepr_gqlstatus"/>.
</para>

<comment>WG3:BGI-033</comment>
<para>For example, the GQLSTATUS <string>22003</string> identifies the exception condition 
<quote>data exception &mdash; numeric value out of range</quote>.
</para>

<comment>WG3:BGI-033</comment>
<para>The GQLSTATUS codes assigned by this document to conditions are stable and can be depended on
to remain constant.
</para>

<comment>WG3:W10-010R1</comment>
<para>There are two types of conditions:
</para>

<ulist>

<item>completion conditions.
</item>

<item>exception conditions.
</item>

</ulist>

<comment>WG3:W10-010R1</comment>
<comment>Editorial: Stephen Cannan, 2022-03-01 WG3:RKE-010 P00-USA-363</comment>
<comment>WG3:W23-014</comment>
<para>A <newterm>completion condition</newterm> is one that permits the execution of 
a GQL-request to have an effect other than that associated with raising the condition.
The completion conditions comprise the conditions: <raise class="00"/>, <raise class="01"/>, and
<raise class="02"/>, including all subclass code variants.
</para>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Adjust to match WG3:W26-028</comment>
<para>The completion condition <raise class="01"/> is broadly defined as completion in which the 
effects are correct, but there is reason to caution the user about those effects.
The subclass code provides information as to the specific reason for the warning.
It is raised for <impDef code="IE008"/> conditions as well as conditions specified 
in this document.
The completion condition <raise class="02"/> has special significance and is used to indicate 
an empty result (<eg/> an empty tabular result).
The completion conditions <raise class="00"/>, including any <impDef annex="no" code="None"/>
subclasses, as well as the completion condition <raise class="00" subclass="001"/> are defined
to indicate a completion condition that does not correspond to
<raise class="01"/> or <raise class="02"/>.
</para>

<comment>WG3:W10-010R1</comment>
<comment>Editorial: Stephen Cannan, 2022-03-01 WG3:RKE-010 P00-USA-363</comment>
<comment>Editorial: Stefan Plantikow, 2022-05-04 Minor rewording</comment>
<comment>WG3:CMN-019 P00-ISO-017</comment>
<para>If no other completion or exception condition has been specified, then the 
completion condition <raise class="00"/> is returned.
This includes conditions represented by a GQLSTATUS whose subclass code provides 
<impDef code="IE010"/> information of a non-cautionary nature.
</para>

<comment>WG3:W26-028</comment>
<para>A successful outcome with a regular result returns
the completion condition <raise class="00"/>,
including any <impDef annex="no" code="None"/> subclasses.
</para>

<comment>WG3:W26-028</comment>
<para>A successful outcome with an omitted result returns
the completion condition <raise class="00" subclass="001"/>.
</para>

<comment>WG3:W10-010R1</comment>
<comment>WG3:W23-014</comment>
<para>An <newterm>exception condition</newterm> is one that causes the execution of a GQL-request
to have no effect other than that associated with raising the condition 
(that is, not a completion condition).
</para>

<comment>WG3:CMN-078</comment>
<comment>WG3:W26-033</comment>
<para>The informational conditions, <raise class="03"/>, are secondary conditions that provide
additional information that is of interest to the user and are only returned in
the list of additional GQL-status objects of an execution outcome.
The subclass code provides information as to the specific reason for the
informational condition. 
The <impDef code="IE009"/> informational conditions shall never be returned as
the status of an execution outcome.
</para>


<comment>WG3:CMN-051</comment>
<para>Except where otherwise specified, the phrase 
<quote>an exception condition is raised:</quote>, followed by the name of a condition, is used in 
General Rules and elsewhere in this document to indicate that:
</para>

<ulist>

<comment>WG3:W23-014</comment>
<item>The execution of the GQL-request is unsuccessful.
</item>

<item>The application of the General Rules is terminated, unless explicitly stated otherwise.
</item>

<comment>WG3:W26-033</comment>
<item>Diagnostic information is recorded in the current request outcome.

<comment>WG3:W26-033</comment>
<note>The current request outcome is made available to the GQL-client by the provisions of
<specref ref="gql_conc_req_ctx"/>.
</note>

</item>

<comment>WG3:W23-014</comment>
<item>Execution of the GQL-request is to have no effect on GQL-data or the GQL-catalog.
</item>

</ulist>

<comment>WG3:W23-014</comment>
<comment>WG3:CMN-051</comment>
<para>The phrase <quote>a completion condition is raised:</quote>, followed by the name
of a condition, is used in General Rules and elsewhere in this document to indicate that
application of General Rules is not terminated and diagnostic information is made available; unless
an exception condition is also raised, the execution of the GQL-request is successful.
</para>

<comment>WG3:W10-010R1</comment>
<comment>WG3:OHD-023</comment>
<comment>WG3:W23-014</comment>
<comment>WG3:UTC-009 P00-USA-169</comment>
<para>If more than one condition could have occurred as a result of the execution of 
a GQL-request, then it is <unDef code="UA002"/> whether
diagnostic information pertaining to more than one condition is made available.
</para>

<comment>WG3:UTC-057</comment>
<comment>WG3:CMN-019 P00-USA-017</comment>
<comment>Editorial: Stefan Plantikow 2023-07-11 Temporary workaround for broken unDef</comment>
<comment>WG3:W26-033</comment>
<note>There are several circumstances in which a GQL-implementation does not necessarily detect 
all possible exception conditions.
For example, during left to right evaluation of an expression when the result can be determined 
without evaluating the entire expression (See <specref ref="gql_eval_order"/>, or during 
evaluation of a selective <BNF name="path pattern"/> when not all candidate path bindings need to 
be tested (See <specref ref="gql_candidates_infinite"/> in 
<specref ref="gql_eval_sel_paren_path_pattern_expr"/>.
In these situations multiple conditions could be, but not necessarily are, detected.
It is possible to make such multiple conditions available, but the exact circumstances in which
this is done remains <unDef code="UA002"/>.
</note>

<comment>WG3:W26-033</comment>
<para>Those additional conditions, if any, are placed in separate GQL-status objects in the list of
additional GQL-status objects of the current request outcome.
</para>

<comment>WG3:CMN-019 P00-USA-021</comment>
<comment>WG3:W26-033</comment>
<para>For the purpose of choosing the status to be returned in an execution outcome:
</para>

<ulist>

<item>Every exception condition for transaction rollback has precedence over every other exception
condition.

<comment>Email from: Hannes Voigt, 2023-03-13 1520</comment>
<ednote id="PPgql440_1">It should be clarified which exception conditions for transaction rollback
are precisely intended here.
See <PPref ref="PPgql440"/>.
</ednote>

<comment>Editorial: Stefan Plantikow</comment>
<ednote id="PPgql441_1">It should be clarified, whether transaction rollback exceptions are to be
raised when another exception condition causes an implicit transaction abort.
See <PPref ref="PPgql441"/>.
</ednote>

</item>

<comment>Editorial: Stefan Plantikow, 2022-02-24 WG3:W20-010 P00-USA-366</comment>
<item>Every exception condition has precedence over every completion condition.
</item>

<item>The completion condition <raise class="02"/> has precedence over the completion condition 
<raise class="01"/>.
</item>

<comment>WG3:W26-028</comment>
<item>The completion condition <raise class="01"/> has precedence over the completion condition 
<raise class="00"/> for any successful completion subclass.
</item>

</ulist>

<comment>WG3:W26-033 Removed 1 (one) paragraph</comment>

</bodyMatter>

</subClause2>

</subClause>


<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-27 Combined into one clause</comment>
<subClause id="gql_conc_prcmd">
<clauseHeading>Procedures and commands</clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-04-08 Reworked as part of context refactoring</comment>
<comment>Editorial: Stefan Plantikow, 2019-10-22</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<subClause2 id="gql_conc_prcmd_gendescr">
<clauseHeading>General description of procedures and commands</clauseHeading>

<bodyMatter>

<comment>WG3:BER-086R1</comment>
<para>Procedures and commands are executed as part of executing a GQL-program in order to:
</para>

<comment>Editorial: Stefan Plantikow, 2020-02-23</comment>
<comment>Editorial: Stephen Cannan, 2022-03-01 WG3:RKE-010 P00-USA-371</comment>
<ulist>

<item>Read or modify the GQL-catalog and the catalog objects it contains.
</item>

<item>Read or modify GQL-data.
</item>

<comment>Editorial: Stephen Cannan, 2020-05-18 GQL- prefix reduction</comment>
<comment>Editorial: Stefan Plantikow, 2022-12-19 WG3:W24-009 357. P00-USA-236</comment>
<item>Read or modify characteristics of the current session context (<eg/> the session schema,
the session graph, the session parameters, or the optional transaction).
</item>

<comment>Editorial: Stefan Plantikow, 2020-05-27 Added request parameters</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-06 Consequence CMN-061R1</comment>
<item>Read characteristics of the current request context (<eg/> the current dynamic parameters
or the current request timestamp).
</item>

<item>Read, modify, or manipulate other GQL-objects that are reachable via
the current execution context, the current request context, or
the current session context.
</item>

</ulist>

</bodyMatter>

</subClause2>


<comment>Editorial: Stefan Plantikow, 2020-04-08 Aligned wording</comment>
<comment>Editorial: Stefan Plantikow, 2019-10-22</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<subClause2 id="gql_conc_prcmd_procs">
<clauseHeading>Procedures</clauseHeading>

<ednote id="gql_PP003_procs">Bindings for host languages should eventually be defined.
See <PPref ref="PPgql003"/>.
</ednote>

<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<subClause3 id="gql_conc_prcmd_procs_gendescr">
<clauseHeading>General description of procedures</clauseHeading>

<bodyMatter>

<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-13 Added descriptor</comment>
<comment>Editorial: Stephen Cannan, 2022-03-01 WG3:RKE-010 P00-USA-372</comment>
<comment>WG3:OHD-029</comment>
<comment>Email from: Nathalie Charbel, 2023-03-01 1050 inline definition</comment>
<comment>WG3:CMN-047R1</comment>
<para><specref ref="gql_proc_terms_defns"/> defines a procedure
as a <repeatdefn ref="gql_procedure_defn"/>.
In this document, every procedure specifies its <newterm>procedure logic</newterm>
that comprises operations (such as statements) together with the order in which they
have to be effectively performed to completely execute the computation described by the procedure.
</para>

<comment>WG3:CMN-047R1</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<para>These operations may read, modify, or otherwise manipulate the GQL-catalog, the GQL-data,
the GQL-session, or other GQL-objects reachable via the current execution context,
the current request context, or the current session context that are available during
their execution.
</para>

<comment>WG3:OHD-029</comment>
<comment>WG3:W23-030</comment>
<comment>WG3:CMN-047R1</comment>
<para>A <newterm>named procedure</newterm> is a procedure that is defined in the GQL-catalog,
<ie/> it is a primary catalog object.
An <newterm>inline procedure</newterm> is a procedure that is defined by 
a <BNF name="procedure specification"/> in a conforming GQL-program.
</para>

<comment>WG3:W23-030</comment>
<para>In a <BNF name="GQL-program"/>, a named procedure is specified by 
a <BNF name="procedure reference"/> that identifies it while an inline procedure is specified 
directly by giving its definition.
</para>

<comment>WG3:CMN-047R1</comment>
<para>A GQL-procedure is a procedure whose procedure logic is specified in the GQL language,
specifically by a <BNF name="procedure body"/>.
An external procedure is a procedure provided via an <impDef code="IW010"/> mechanism.
</para>

<comment>WG3:CMN-047R1</comment>
<para>This document does not specify the mechanism by which a named procedure is defined in
conforming GQL language.
Consequently, a named procedure is an external procedure while an inline procedure is
a GQL-procedure.
</para>

</bodyMatter>

</subClause3>


<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>WG3:OHD-029</comment>
<comment>WG3:W23-030</comment>
<subClause3 id="gql_conc_prcmd_procs_descr">
<clauseHeading>Named procedure descriptors</clauseHeading>

<bodyMatter>

<comment>WG3:W23-030</comment>
<comment>WG3:UTC-077</comment>
<comment>WG3:CMN-019 P00-USA-204</comment>
<para>A named procedure is described by a named procedure descriptor that comprises:
</para>

<ulist>
<comment>WG3:UTC-077 Deleted 4 items</comment>

<comment>WG3:UTC-077</comment>
<comment>WG3:W25-022R1</comment>
<item>The list of the declared types of the mandatory procedure parameters and their names.
</item>

<comment>WG3:UTC-077</comment>
<comment>WG3:W25-022R1</comment>
<item>The list of the declared types of the optional procedure parameters, their names, and 
their default values.

<comment>WG3:UTC-077</comment>
<note>Optionality is only supported for a succession of parameters leading to the end of
the list of parameters. 
If a named procedure call provides an argument for any one of a succession of optional parameters,
then it must provide arguments for all preceding optional parameters. 
Comma-separated gaps in the argument list are not supported.
</note>
</item>

<comment>WG3:UTC-077</comment>
<item>The procedure result type.
</item>

<comment>WG3:UTC-077</comment>
<comment>WG3:UTC-105</comment>
<item>The indication of the kinds of side effects the execution of the named procedure can cause,
specified as follows:

<ulist>

<comment>WG3:UTC-077</comment>
<comment>Email from: Nathalie Charbel, 2023-03-01 1050</comment>
<item>CATALOG PROCEDURE indicates that this procedure is a catalog-modifying procedure,
as described in <specref ref="gql_conc_prcmd_procs_by_effects"/>.
</item>

<comment>WG3:UTC-077</comment>
<comment>Email from: Nathalie Charbel, 2023-03-01 1050</comment>
<item>DATA PROCEDURE indicates that this procedure is a data-modifying procedure, 
as described in <specref ref="gql_conc_prcmd_procs_by_effects"/>.
</item>

<comment>WG3:UTC-077</comment>
<comment>Email from: Nathalie Charbel, 2023-03-01 1050</comment>
<item>QUERY PROCEDURE indicates that this procedure is a query procedure,
as described in <specref ref="gql_conc_prcmd_procs_by_effects"/>.
</item>

</ulist>

</item>

</ulist>

<comment>WG3:W25-022R1</comment>
<para>The parameter name of each mandatory and optional procedure parameter is unique within
the named procedure descriptor.
</para>

<comment>Consequence of WG3:W13-010R1</comment>
<comment>WG3:OHD-029</comment>
<comment>WG3:W23-030</comment>
<comment>WG3:UTC-077</comment>
<para>For every named procedure <symdef>PROC</symdef>, the named procedure descriptor of 
<sym>PROC</sym> is a catalog object descriptor. 
The name of <sym>PROC</sym> (also known as procedure name) is the catalog object name of 
<sym>PROC</sym>.
</para>

<comment>WG3:UTC-077</comment>
<comment>WG3:W25-022R1</comment>
<comment>WG3:CMN-019 P00-USA-278</comment>
<para>For a given named procedure descriptor <symdef>PROCDESC</symdef>,
let <symdef>LMPP</symdef> be the list of the declared types of
the mandatory procedure parameters and their names that is included in <sym>PROCDESC</sym>. 
Let <symdef>LOPP</symdef> be the list of the declared types of
the optional procedure parameters, their names, and their default values that is included in 
<sym>PROCDESC</sym>.
The number of the procedure parameters required by <sym>PROCDESC</sym> is
the number of elements of <sym>LMPP</sym>, 
the maximum number of the procedure parameters that are allowed by <sym>PROCDESC</sym> is
the sum of the number of the procedure parameters required by <sym>PROCDESC</sym> and
the number of elements of <sym>LOPP</sym>, and
the list of procedure parameters of <sym>PROCDESC</sym> is the list formed by
the elements of <sym>LMPP</sym> followed by the elements of <sym>LOPP</sym>.
</para>

<comment>Editorial: Stefan Plantikow, 2020-10-13 One paragraph moved</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-10 One paragraph removed</comment>

</bodyMatter>

</subClause3>

<comment>WG3:UTC-077 Deleted 1 (one) Subclause</comment>


<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<subClause3 id="gql_conc_prcmd_procs_exe">
<clauseHeading>Procedure execution</clauseHeading>

<bodyMatter>

<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-16 Clarified</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-24 WG3:W20-010 P00-USA-374</comment>
<comment>WG3:W22-054</comment>
<comment>WG3:OHD-023</comment>
<comment>WG3:OHD-029</comment>
<comment>WG3:UTC-077</comment>
<para>Procedures are executed by calling them in a specified execution context.
In the case of named procedures, procedure call arguments are passed via the working record of 
that execution context.
Prior to the execution of a named procedure call, the provided procedure call arguments shall 
fulfill the requirements of the named procedure descriptor of the called named procedure regarding
their number and data type.
Every optional parameter of the named procedure descriptor of the called named procedure that is not
included in the provided procedure call arguments is defaulted as specified by
the named procedure descriptor of the called named procedure.
</para>

<comment>Editorial: Stefan Plantikow, 2020-03-31</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-08 Reworded and aligned</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-10 result object -> result</comment>
<comment>WG3:BER-099R1</comment>
<para>The outcome of the execution <symdef>EXE</symdef> of a procedure is the execution outcome 
present in the specified execution context after execution has terminated.
The result and status of <sym>EXE</sym> are the result and status, respectively, of the outcome
of <sym>EXE</sym>.
</para>

</bodyMatter>

</subClause3>


<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>WG3:W22-054</comment>
<subClause3 id="gql_conc_prcmd_procs_by_effects">
<clauseHeading>Procedures classified by kind of side effects</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-04-08 Removed limitations on return objects</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>WG3:W22-054</comment>
<comment>WG3:UTC-105</comment>
<para>Procedures are classified by the kind of side effects that their execution can cause.
For this purpose, this document distinguishes between:
</para>

<comment>Editorial: Stefan Plantikow, 2020-02-05</comment>
<ulist>

<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>Editorial: Stefan Plantikow, 2022-05-05 WG3:W20-010 P00-USA-376</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>A catalog-modifying procedure, which is
a <repeatdefn ref="gql_catalog_mod_procedure_defn"/>.
</item>

<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>Editorial: Stefan Plantikow, 2022-05-05 Remove redundant information</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>A data-modifying procedure, which is a <repeatdefn ref="gql_data_mod_procedure_defn"/>.
</item>

<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>WG3:W20-013</comment>
<comment>Editorial: Stefan Plantikow, 2022-05-05 Remove redundant information</comment>
<comment>WG3:W22-054</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>A query procedure, which is a <repeatdefn ref="gql_query_defn"/>.
</item>

</ulist>

</bodyMatter>

</subClause3>

<comment>WG3:CMN-047R1 Deleted 1 (one) Subclause</comment>

</subClause2>


<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<subClause2 id="gql_conc_prcmd_cmds">
<clauseHeading>Commands</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-03-09</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>WG3:W21-010 P00-USA-377</comment>
<comment>WG3:BER-086R1</comment>
<comment>WG3:CMN-019 P00-USA-280</comment>
<comment>WG3:CMN-019 P00-ISO-018</comment>
<comment>WG3:CMN-019 P00-ISO-001</comment>
<para>A command is an <repeatdefn ref="gql_command_defn"/>.
The execution of a command computes an execution outcome and can cause side effects.
</para>

<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<para>Every supported command is one of the following:
</para>

<ulist>

<comment>Editorial: Stephen Cannan, 2020-05-18 GQL- prefix reduction</comment>
<comment>WG3:UTC-105</comment>
<item>A session command, <ie/> a <repeatdefn ref="gql_session_command_defn"/>.
</item>

<item>A transaction command, <ie/> a <repeatdefn ref="gql_transaction_command_defn"/>.
</item>

</ulist>

<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<para>Commands are executed by calling them in a specified execution context.
</para>

<comment>Editorial: Stefan Plantikow, 2022-02-24 WG3:W20-010 P00-USA-374</comment>
<comment>WG3:CMN-019 P00-ISO-019</comment>
<note>All required arguments are supplied implicitly via the current execution context.
</note>

<comment>Editorial: Stefan Plantikow, 2020-03-31</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-08 Reworded and aligned</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-10 result object -> result</comment>
<comment>WG3:BER-099R1</comment>
<para>The outcome of the execution <symdef>EXE</symdef> of a command is the execution outcome 
present in the specified execution context after execution has terminated.
The result and status of <sym>EXE</sym> are the result and status, respectively, of the outcome
of <sym>EXE</sym>.
</para>

</bodyMatter>

</subClause2>


<comment>Editorial: Stefan Plantikow, 2020-10-10 Procedure classifications moved out of subsection
</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-10 One Subclause remove</comment>
<comment>WG3:BER-086R1</comment>
<subClause2 id="gql_conc_prcmd_gql">
<clauseHeading>GQL-procedures</clauseHeading>

<subClause3 id="gql_conc_prcmd_gql_intro">
<clauseHeading>Introduction to GQL-procedures</clauseHeading>

<bodyMatter>

<comment>WG3:BER-086R1</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<para>A GQL-procedure is a procedure written in the GQL language, which is part of 
(or available to) a GQL-program.
</para>

<para>The procedure logic of a GQL-procedure is specified by the <BNF name="procedure body"/> 
provided when the procedure is defined.
</para>

<para>A <BNF name="procedure body"/> comprises:
</para>

<comment>Editorial: Stephen Cannan, 2022-03-01 WG3:RKE-010 P00-USA-380</comment>
<ulist>

<comment>Editorially complete WG3:W16-040</comment>
<comment>WG3:BER-019</comment>
<item>A (possibly empty) sequence of <BNF name="binding variable definition"/>s that are 
specified by a <BNF name="binding variable definition block"/> and that define
fixed variables.
</item>

<comment>WG3:CMN-019 P00-USA-022</comment>
<item>A sequence of statements that are specified by the <BNF name="statement block"/> directly
contained in the <BNF name="procedure body"/>.
</item>

</ulist>

<comment>WG3:BER-086R1</comment>
<para>The procedure logic of a GQL-procedure is executed in the current execution context by 
first executing its variable definitions followed by executing its statements.
This is specified completely by <specref ref="gql_procedure_body"/>.
</para>

<comment>WG3:BER-086R1</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>WG3:CMN-047R1</comment>
<para>This document does not specify the mechanism by which a procedure that is not 
a GQL-procedure is specified or provided to the GQL-server.
</para>

</bodyMatter>

</subClause3>


<subClause3 id="gql_conc_prcmd_gql_vars_and_params">
<comment>WG3:W26-026R2</comment>
<clauseHeading>Binding variables and general parameters</clauseHeading>

<bodyMatter>

<comment>WG3:CMN-061R1</comment>
<comment>WG3:CMN-047R1</comment>
<para>GQL-procedures interact with the following kinds of variables and general parameters:
</para>

<comment>WG3:CMN-061R1</comment>
<note><specref ref="gql_env_terms_defns"/>, defines a general parameter as a pair comprising 
a name and a pair comprising a value and a value type.
</note>

<comment>Editorial: Stephen Cannan, 2022-03-01 WG3:RKE-010 P00-USA-381</comment>
<ulist>

<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>WG3:W21-044</comment>
<comment>WG3:OHD-029</comment>
<comment>WG3:CMN-061R1</comment>
<item>One or more session parameters, where a session parameter is 
a <repeatdefn ref="gql_session_parameter_defn"/>.
</item>

<comment>WG3:W21-044</comment>
<comment>WG3:OHD-029</comment>
<comment>WG3:CMN-061R1</comment>
<item>One or more dynamic parameters, where a dynamic parameter is 
a <repeatdefn ref="gql_dyn_param_defn"/>.
</item>

<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>WG3:BER-019</comment>
<comment>WG3:BER-060</comment>
<comment>WG3:OHD-023</comment>
<comment>WG3:OHD-029</comment>
<comment>WG3:UTC-087R2</comment>
<comment>WG3:CMN-019 P00-USA-024</comment>
<item>One or more binding variables, where a binding variable is a variable bound to a value
occupying a site that is assigned to the binding variable in the context of executing some
operation.
Every binding variable is one of the following (relative to a contextually implied execution
context):

<ulist>

<comment>WG3:BER-019</comment>
<comment>WG3:CMN-061R1</comment>
<item>A <newterm>fixed variable</newterm> that is a binding variable assigned to the identified 
field of the working record.

<comment>WG3:CMN-061R1</comment>
<note>A fixed variable is always bound to exactly one value when iterating
over the current working table during procedure execution.
</note>

</item>

<comment>WG3:BER-019</comment>
<comment>WG3:CMN-061R1</comment>
<item>An <newterm>iterated variable</newterm> that is a binding variable assigned to the identified 
fields of the records of the working table.

<comment>Editorial: Stephen Cannan 2023-01-29 Align with Directives Part 2</comment>
<comment>WG3:CMN-061R1</comment>
<comment>WG3:W26-026R2</comment>
<note>An iterated variable <symdef>VAR</symdef> possibly binds to zero, one, or more values when 
iterating  over a working table <symdef>TABLE</symdef>, <eg/> during procedure execution.
A concrete binding is realized through the creation of a child execution context 
<symdef>CONTEXT</symdef> for each iterated record <symdef>RECORD</symdef> from <sym>TABLE</sym> 
such that <sym>VAR</sym> is bound as a fixed variable in the working record of <sym>CONTEXT</sym> 
to the corresponding field value of <sym>RECORD</sym>.
</note>

</item>

</ulist>
<comment>WG3:BER-019 Paragraph deleted</comment>

</item>

</ulist>
<comment>WG3:BER-019 List deleted</comment>
<comment>WG3:BER-019 List deleted</comment>

<comment>WG3:CMN-061R1</comment>
<para>Binding variables and parameters are defined in disjoint namespaces and syntactically
disambiguated by always prefixing the parameter name specified by 
a <BNF name="general parameter reference"/> with a <BNF name="dollar sign"/> and 
the parameter name specified by a <BNF name="substituted parameter reference"/> with 
a <BNF name="double dollar sign"/>.
</para>

<comment>WG3:CMN-061R1</comment>
<note>See <specref ref="gql_token"/>.
</note>

</bodyMatter>

</subClause3>


<comment>Editorial: Stefan Plantikow, 2020-10-15 One Subclause removed</comment>

<subClause3 id="gql_conc_prcmd_stm">
<clauseHeading>Statements</clauseHeading>

<bodyMatter>

<comment>WG3:BER-086R1</comment>
<comment>WG3:CMN-019 P00-ISO-001</comment>
<comment>WG3:CMN-047R1</comment>
<para>A statement defines one or more operations executed as part of executing a GQL-procedure.
Each operation updates the current execution context and its current execution outcome, and 
can cause side effects.
</para>

<comment>WG3:BER-086R1</comment>
<comment>Editorial: Stephen Cannan, 2023-07-11, Standardize the spelling of keyword</comment>
<para>Many languages use a delimiter such as semicolon between the language<apos/>s statements. 
GQL does not use any delimiter between operations within a statement; statement components are 
identified by leading keywords.
</para>

<comment>WG3:W24-009 372. P00-USA-244 removed one paragraph</comment>

</bodyMatter>

</subClause3>


<comment>WG3:BER-062</comment>
<subClause3 id="gql_conc_stmt_by_wg">
<clauseHeading>Statements classified by use of working graph sites</clauseHeading>

<bodyMatter>

<comment>WG3:CMN-042</comment>
<comment>WG3:W26-030R1</comment>
<para>A statement is classified according to its use of the <BNF name="use graph clause"/>.
Given a statement <symdef>S</symdef> and the result <symdef>S1</symdef> of applying all syntactic 
transformations to <sym>S</sym>, <sym>S</sym> is classified as follows:
</para>

<comment>Editorial: Stephen Cannan 2023-01-19 Convert to ulists</comment>
<ulist>

<comment>WG3:CMN-042</comment>
<comment>WG3:W26-030R1</comment>
<item>If neither <sym>S</sym> nor <sym>S1</sym> directly contain a <BNF name="use graph clause"/>, 
then <sym>S</sym> is an <newterm>ambient statement</newterm>. 
An ambient statement <symdef>S</symdef> operates on the graph referenced by 
the current working graph site of <sym>S</sym>.
</item>

<comment>WG3:CMN-042</comment>
<comment>WG3:W26-030R1</comment>
<item>If <sym>S</sym> or <sym>S1</sym> directly contains one or more 
<BNF name="use graph clause"/>s, then <sym>S</sym> is a <newterm>focused statement</newterm>.
A focused statement identifies one or more working graph sites and operates on the graphs
referenced by these working graph sites.
</item>

</ulist>

</bodyMatter>

</subClause3>


<subClause3 id="gql_conc_prcmd_stm_by_func">
<clauseHeading>Statements classified by function</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-10-10 Moved here from deleted Subclause</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>WG3:UTC-105</comment>
<para>A statement is classified according to its function.
</para>

<comment>Editorial: Stefan Plantikow, 2020-02-06</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-10 Adapted GQL-style naming</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-10 Overhauled to include reading and transforming
</comment>
<ulist>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>Editorial: Stefan Plantikow, 2022-12-19 WG3:W24-009 375. P00-USA-245</comment>
<item>A <newterm>catalog-modifying statement</newterm> is a statement that can modify the 
catalog structure to create, and drop catalog objects and that can cause catalog-modifying side
effects as well as optional additional data-modifying side effects to this end.
</item>

<!-- To be uncommented when Access Control is defined.
<item>dcl statements that can be used to grant and revoke privileges.
These statements are used in environment-modifying procedures.
</item>
-->

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>A <newterm>data-modifying statement</newterm> is a statement that can perform insert, update,
and delete operations on data objects and that can cause data-modifying side effects to this end.
</item>

<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>WG3:W22-055</comment>
<item>A <newterm>query statement</newterm> is a statement that can read persistent data and 
perform filtering, aggregating, and projecting operations.
</item>

</ulist>

</bodyMatter>

</subClause3>
<comment>WG3:UTC-056R1 Deleted 1 (one) Subclause</comment>


</subClause2>

</subClause>


<comment>WG3:ERF-035</comment>
<comment>WG3:W16-034R2</comment>
<comment>Editorial: Stephen Cannan 2022-07-17</comment>
<subClause id="gql_conc_graph_patt_match">
<clauseHeading>Graph pattern matching</clauseHeading>

<comment>WG3:W16-034R2</comment>
<subClause2 id="gql_conc_graph_patt_match_sum">
<clauseHeading>Summary of graph pattern matching</clauseHeading>

<bodyMatter>

<comment>WG3:W22-053R2</comment>
<para><newterm>Graph pattern matching</newterm> is the process of applying a list of 
special-purpose regular expressions called a <BNF name="graph pattern"/> on a property graph 
<symdef>PG</symdef>, which in this document is always the current working graph, in order to return 
a set of reduced matches.
Each reduced match is a list of path bindings; each path binding is a function that maps the 
symbols in a word of a regular language to a path of <sym>PG</sym>. 
The regular language and related concepts such as path binding and reduced match are specified in 
<specref ref="gql_machinery_graph_pattern_matching"/>, and <specref ref="gql_graph_pattern"/>.
</para>

<para>A <BNF name="graph pattern"/> is a list of <BNF name="path pattern"/>s. 
Each <BNF name="path pattern"/> in the list is matched to <sym>PG</sym> to detect 
a possibly-empty set of path bindings in <sym>PG</sym> that correspond to the 
<BNF name="path pattern"/>.
</para>

<comment>Email from: Fred Zemke, 2022-02-01 1829 Remove redundant equi- prefix</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-24 WG3:W20-W10 P00-USA-397</comment>
<comment>WG3:BER-031</comment>
<para>The cross-product of these sets is reduced by natural joins over those global
singleton element variables that are exposed by each <BNF name="path pattern"/> and that are 
bound to the same graph element of <sym>PG</sym>.
The remaining tuples are called reduced matches; the set of these reduced matches may be empty, 
but cannot be infinite because of syntactic restrictions to guard against infinite cycling.
</para>

<para>The behavior of the graph pattern matching is defined in this document.
</para>

<comment>WG3:BER-031</comment>
<note>A more detailed summary can be found in 
<specref ref="gql_conc_graph_patt_match_path_patt_match"/>.
</note>

<comment>WG3:BER-083R1</comment>
<para>Additional qualifying parameters (predicates, a selective <BNF name="path search prefix"/>, 
a <BNF name="path mode"/>, and the <BNF name="different edges match mode"/>) that restrict 
the result may be supplied.
</para>

<comment>Editorial: Stefan Plantikow, 2022-02-24 WG3:W20-010 P00-USA-398</comment>
<comment>WG3:BER-083R1</comment>
<comment>Email from Jan Michels, 2022-07-16 0119</comment>
<para>If <sym>PG</sym> contains cycles, then a match to a <BNF name="path pattern"/> having 
an unbounded quantifier might return an infinite set of paths.
However, this possibility is prevented by Syntax Rules that require the use of selective 
<BNF name="path search prefix"/>s, restrictive <BNF name="path mode"/>s, or the 
<BNF name="different edges match mode"/> (or any combination thereof) to prevent 
infinitely-sized result sets.
</para>

</bodyMatter>

</subClause2>


<comment>WG3:W16-034R2</comment>
<subClause2 id="gql_conc_graph_patt_match_paths">
<clauseHeading>Paths</clauseHeading>

<bodyMatter>

<comment>WG3:W21-023</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<para>A path <symdef>P</symdef> is a sequence of <symdef>N</symdef> graph elements of
a property graph <symdef>PG</symdef>, such that:
</para>

<ulist>

<comment>WG3:UTC-080</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item><sym>N</sym> is an odd number.
</item>

<comment>WG3:UTC-080</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>If <sym>N</sym> = 1 (one), then <sym>P</sym> has no edges.
</item>

<comment>WG3:UTC-080</comment>
<item>The graph element at each odd index is a node and the graph element at each even index is 
an edge that connects the pair of nodes immediately before and after the edge in the sequence.
</item>

</ulist>

<comment>WG3:UTC-080</comment>
<para>A path contains a non-empty sequence of nodes and a (possibly empty) sequence of edges. 
If there are two or more nodes, then the path is a sequence of graph elements that starts with 
a node and is followed by a sequence of ordered (edge, node) pairs.
</para>

<para>If <sym>PG</sym> is a multigraph, then an edge in the path between a pair of nodes is 
one of possibly several edges between those nodes in <sym>PG</sym>.
</para>

<comment>WG3:BER-075R1</comment>
<para>Every edge <symdef>E</symdef> in the path has an orientation.
If <sym>E</sym> is undirected, then the orientation of <sym>E</sym> is 
<newterm>undirected</newterm>.
Let <symdef>V1</symdef> be the node that immediately precedes <sym>E</sym> in the path, and 
let <symdef>V2</symdef> be the node that immediately follows <sym>E</sym>. 
If the source of <sym>E</sym> is <sym>V1</sym> and the destination of <sym>E</sym> is 
<sym>V2</sym>, then the orientation of <sym>E</sym> is <newterm>left to right</newterm>. 
It is also said that the orientation of <sym>E</sym> is <newterm>directed pointing right</newterm>.
If the source of <sym>E</sym> is <sym>V2</sym> and the destination of <sym>E</sym> is 
<sym>V1</sym>, then the orientation of <sym>E</sym> is <newterm>right to left</newterm>.
It is also said that the orientation of <sym>E</sym> is <newterm>directed pointing left</newterm>.
</para>

<note>A directed self-edge (<ie/> when <sym>E</sym> is directed and <sym>V1</sym> and <sym>V2</sym>
are the same node), is oriented both left to right and right to left.
</note>

<comment>Email from: Fred Zemke, 2021-10-16 1200</comment>
<para>If no edge from <sym>PG</sym> appears more than once in a path, then the path is called 
a <newterm>trail</newterm>. 
If no node from <sym>PG</sym> appears more than once in a path, except possibly as the first and
last nodes of the path, then the path is called <newterm>simple</newterm>. 
If no node from <sym>PG</sym> appears more than once in a path, then the path is called 
<newterm>acyclic</newterm>.
</para>


<comment>Editorial: Stefan Plantikow, 2022-02-25 1307 WG3:W20-010 P00-USA-400</comment>
<comment>Editorial: Stephen Cannan 2023-01-20 Align with Directives Part 2</comment>
<note>The term <quote>path</quote> is used in more than one way in mathematical graph theory and 
in informal technical presentations and discussions. 
In this document the term path always denotes what a graph-theoretic work could call
a partially-oriented walk in a pure property graph. 
Such a graph is a mixed multigraph; edges can be directed or undirected, and there can be multiple 
edges between two nodes.
</note>

</bodyMatter>

</subClause2>


<comment>WG3:W16-034R2</comment>
<subClause2 id="gql_conc_graph_patt_match_path_patt">
<clauseHeading>Path patterns</clauseHeading>

<bodyMatter>

<para>A <BNF name="path pattern"/> is an expression built from the following syntactic elements,
governed by the Format and Syntax Rules of <specref ref="gql_graph_pattern"/>, and
other Subclauses:
</para>

<ulist>

<comment>WG3:BER-031</comment>
<item>An optional <BNF name="path variable declaration"/>, to declare a path variable to be bound 
to a path binding.
</item>

<item>An optional <BNF name="path pattern prefix"/>.

<note><BNF name="path pattern prefix"/> is described in 
<specref ref="gql_conc_graph_patt_match_path_mode"/>, and 
<specref ref="gql_conc_graph_patt_match_path_srch_pre"/>, 
and specified in <specref ref="gql_path_pattern_prefix"/>.
</note>

</item>

<item>A mandatory <BNF name="path pattern expression"/>.
</item>

</ulist>

<para>A <BNF name="path pattern expression"/> is an expression built recursively from 
<BNF name="element pattern"/>s, governed by the Format and Syntax Rules of 
<specref ref="gql_path_pattern_expr"/>, and other Subclauses.
</para>

<para>An <BNF name="element pattern"/> is a pattern to match a single graph element. 
There are two kinds of <BNF name="element pattern"/>s:
</para>

<ulist>

<comment>Editorial: Stephen Cannan, 2022-03-07 WG3:RKE-010 P00-USA-401</comment>
<comment>Consequence of WG3:POS-024</comment>
<bar note="Consequence of WG3:POS-024"/>
<item><BNF name="node pattern"/>:
<para>A <BNF name="node pattern"/> is a pattern to match a single node. 
A <BNF name="node pattern"/> contains at a minimum a matching pair of parentheses, which
may contain an optional <BNF name="element pattern filler"/>, described subsequently.
</para>
<endbar/>

</item>

<comment>Editorial: Stephen Cannan, 2022-03-07 WG3:RKE-010 P00-USA-401</comment>
<item><BNF name="edge pattern"/>:
<para>An <BNF name="edge pattern"/> is a pattern to match a single edge. 
An <BNF name="edge pattern"/> is either a <BNF name="full edge pattern"/> 
(which optionally permits <BNF name="element pattern filler"/>) or 
an <BNF name="abbreviated edge pattern"/> 
(which does not support <BNF name="element pattern filler"/>). 
These two major classes of <BNF name="edge pattern"/> have seven variants each, for the seven 
possible non-empty combinations of the three edge orientations 
(the individual edge orientations being directed pointing left, undirected, or 
directed pointing right). 
Thus there are fourteen varieties of <BNF name="edge pattern"/>.
</para>
</item>

</ulist>

<para><BNF name="element pattern filler"/> provides three optional components of 
<BNF name="node pattern"/>s and <BNF name="full edge pattern"/>s:
</para>

<ulist>

<comment>WG3:BER-031</comment>
<item><BNF name="element variable declaration"/>, to declare an element variable to be bound to 
a graph element by the <BNF name="element pattern"/>.
</item>

<comment>Editorial: Stephen Cannan, 2022-03-07 WG3:RKE-010 P00-USA-403</comment>
<comment>WG3:RKE-027 P16-USA-747</comment>
<comment>Email from: Fred Zemke, 2022-05-22 2231</comment>
<item><BNF name="label expression"/>, a predicate regarding the labels of the graph element that is
bound by the <BNF name="element pattern"/>. 
A <BNF name="label expression"/> is an expression formed from <BNF name="label name"/>s and the 
<BNF name="wildcard label"/> <quote>%</quote>, using the operation signs 
<BNF name="vertical bar"/> <quote>|</quote> for disjunction, 
<BNF name="ampersand"/> <quote>&amp;</quote> for conjunction, 
<BNF name="exclamation mark"/> <quote>!</quote> for negation, and 
balanced pairs of parentheses for grouping.
</item>

<item><BNF name="element pattern where clause"/>, a <BNF name="search condition"/> 
to be satisfied by the graph element that is bound by the <BNF name="element pattern"/>.
</item>

</ulist>

<para><BNF name="path pattern expression"/>s are regular expressions built recursively from 
<BNF name="element pattern"/>s using the following operations, governed by the Format and 
Syntax Rules of <specref ref="gql_path_pattern_expr"/>, and other Subclauses.
</para>

<ulist>

<item>Concatenation, indicated syntactically by string concatenation 
(<ie/> no operation sign).

<comment>Editorial: Stephen Cannan 2023-01-20 Align with Directives Part 2</comment>
<note><BNF name="element pattern"/>s and more complex <BNF name="path pattern expression"/>s
can be concatenated in ways that appear to juxtapose either two <BNF name="node pattern"/>s or 
two <BNF name="edge pattern"/>s. 
These topologically inconsistent patterns are understood during pattern matching as follows:

<ulist>

<item>Two consecutive <BNF name="node pattern"/>s bind to the same node.
</item>

<item>Two consecutive <BNF name="edge pattern"/>s conceptually have an implicit 
<BNF name="node pattern"/> between them.
</item>

</ulist>

</note>

</item>

<comment>Email from: Fred Zemke, 2022-05-22 2231</comment>
<comment>WG3:BER-031</comment>
<item>Grouping, using matching pairs of parentheses to form 
a <BNF name="parenthesized path pattern expression"/>. 
A <BNF name="parenthesized path pattern expression"/> may optionally contain the following:

<ulist>

<item>A <BNF name="subpath variable declaration"/> to declare a subpath variable.
</item>

<item>A <BNF name="search condition"/> to constrain matches.
</item>

</ulist>

</item>

<item>Alternation, indicated by <BNF name="vertical bar"/> or 
<BNF name="multiset alternation operator"/>.

<note>Alternation with <BNF name="vertical bar"/> provides set semantics using 
deduplication of redundant equivalent reduced matches, whereas alternation with 
<BNF name="multiset alternation operator"/> provides multiset semantics, with no deduplication.
</note>

</item>

<item>Quantification, indicated by a postfix <BNF name="graph pattern quantifier"/>, which may be
affixed to an <BNF name="edge pattern"/> or a <BNF name="parenthesized path pattern expression"/>.
</item>

<item><BNF name="questioned path primary"/>, indicated by a postfix 
<BNF name="question mark"/> affixed to an <BNF name="edge pattern"/> or 
a <BNF name="parenthesized path pattern expression"/>.

<comment>WG3:BER-031</comment>
<comment>WG3:W24-013</comment>
<note>Unlike many regular expression languages, the <BNF name="question mark"/> operator in 
<BNF name="path pattern expression"/>s is not the same as {0,1}, the difference being that 
<BNF name="questioned path primary"/> exposes its singleton element or subpath variables as 
conditional singletons, whereas {0, 1}, in common with all other quantifiers, exposes all element 
or subpath variables as group.
</note>

</item>

</ulist>

</bodyMatter>

</subClause2>


<comment>WG3:BER-031</comment>
<subClause2 id="gql_conc_path_patt_vars">
<clauseHeading>Graph pattern variables</clauseHeading>

<bodyMatter>

<comment>WG3:W22-053R2</comment>
<comment>WG3:CMN-019 P00-USA-007</comment>
<para>A graph pattern variable <symdef>GPV</symdef> is a site identified by 
a <BNF name="regular identifier"/> (the <newterm>name</newterm> of the graph pattern variable) 
and having a value determined by a multi-path binding <symdef>MPB</symdef> to 
a <BNF name="graph pattern"/>.
</para>

<para>There are four kinds of graph pattern variables:
</para>

<ulist>

<comment>WG3:W22-053R2</comment>
<item>Node variables; the value of a node variable represents a list of bound nodes.
</item>

<comment>WG3:W22-053R2</comment>
<item>Edge variables; the value of an edge variable represents a list of bound edges.
</item>

<comment>WG3:W22-053R2</comment>
<item>Path variables; the value of a path variable represents a path binding.
</item>

<item>Subpath variables.

<comment>WG3:CMN-019 P00-ISO-020</comment>
<note>Subpath variables are not bound to a value in this document. 
They serve to assure multiset semantics in <BNF name="path multiset alternation"/>.
</note>

</item>

</ulist>

<comment>WG3:W22-053R2</comment>
<para>In a <BNF name="graph pattern binding table"/> <symdef>GPBT</symdef>, 
a <BNF name="regular identifier"/> shall not identify more than one graph pattern variable; 
thus <sym>GPBT</sym> defines a namespace in which there is a one-to-one correspondence between 
the names of graph pattern variables and the graph pattern variables that they name.
</para>

<comment>WG3:UTC-075</comment>
<note>Because of this one-to-one correspondence, certain terms that are defined for 
graph pattern variables are also defined for their names, so that the name of the variable and 
the variable itself can be used interchangeably in the rules. 
These terms include <quote>declare</quote> and <quote>expose</quote>.
</note>

<para>Node variables and edge variables are collectively called element variables. 
</para>

<comment>WG3:UTC-087R2</comment>
<para>A node variable <symdef>VV</symdef> and its name are declared by 
an <BNF name="element variable declaration"/> simply contained in a <BNF name="node pattern"/>.
</para>

<para>An edge variable <symdef>EV</symdef> and its name are declared by 
an <BNF name="element variable declaration"/> simply contained in 
a <BNF name="full edge pattern"/>.
</para>

<para>An element variable may be declared in more than one <BNF name="element pattern"/>. 
A multiply declared element variable <symdef>MDPV</symdef> expresses a natural equijoin in 
two circumstances:
</para>

<ulist>

<item>If <sym>MDPV</sym> is declared in both operands of a <BNF name="path concatenation"/>.
</item>

<comment>Editorial: Stephen Cannan, 2024-04-13 Correct symbol</comment>
<item>If <sym>MDPV</sym> is declared in two or more <BNF name="path pattern"/>s of 
a <BNF name="graph pattern"/>.
</item>

</ulist>

<comment>WG3:UTC-087R2</comment>
<note>Declaring an element variable in two operands of 
a <BNF name="path pattern union"/> or <BNF name="path multiset alternation"/> does not express 
a natural join between the matches of the operands.
</note>

<comment>WG3:W24-022</comment>
<para>Element variables may be declared as temporary element variables. 
The scope of a temporary element variable is limited to the innermost <BNF name="path term"/> that
contains its declaration.
</para>

<comment>WG3:W24-022</comment>
<comment>Editorial: Stephen Cannan 2023-01-29 Align with Directives Part 2</comment>
<note>The introduction of new element variables by syntactic transformations possibly inadvertently 
changes the cardinality of results.
In this document, this issue is avoided by generating syntax that declares such variables as 
temporary element variables. 
However, such syntax for the declaration of temporary element variables is not made available 
to the user.
</note>

<comment>WG3:W24-022</comment>
<para>A path variable <symdef>PV</symdef> and its name are declared by 
a <BNF name="path variable declaration"/> simply contained in a <BNF name="path pattern"/>. 
A path variable may only be declared once in a <BNF name="graph pattern"/>.
</para>

<comment>WG3:W24-022</comment>
<para>A subpath variable <symdef>SV</symdef> and its name are declared by 
a <BNF name="subpath variable declaration"/> simply contained in 
a <BNF name="parenthesized path pattern expression"/>. 
More than one operand of a <BNF name="path pattern union"/> may declare <sym>SV</sym>; 
otherwise, <sym>SV</sym> cannot be multiply declared in a <BNF name="graph pattern"/>.
</para>

</bodyMatter>

</subClause2>


<comment>WG3:BER-031</comment>
<subClause2 id="gql_graph_patt_var_ref">
<clauseHeading>References to graph pattern variables</clauseHeading>

<bodyMatter>

<comment>WG3:W22-053R2</comment>
<comment>Editorial: Stefan Plantikow, 2023-02-23 Clarify wording</comment>
<comment>WG3:CMN-019 P00-ISO-001</comment>
<para>Graph pattern variables are visible within the <BNF name="graph pattern binding table"/> 
<symdef>GPBT</symdef> in which they are declared. 
They can be referenced in <BNF name="value expression"/>s, <BNF name="search condition"/>s,
and the <BNF name="graph pattern yield clause"/> within <sym>GPBT</sym> where they are exposed as
binding variables of the current working record and can be used accordingly.
The binding table result of <sym>GPBT</sym> exposes yielded graph pattern variables as columns.
Such a result is then consumed, <eg/> by the containing <BNF name="match statement"/> of
<sym>GPBT</sym> by naturally joining it with the current working table to obtain
a new current working table for further processing.
</para>

<comment>WG3:W22-053R2</comment>
<para>Assume a fixed <BNF name="graph pattern binding table"/> as the implicit context for the 
remainder of this Subclause.
</para>

<comment>WG3:UTC-087R2</comment>
<para>Element variables may be referenced in instances of the following BNF non-terminal symbols:
</para>

<ulist>

<item><BNF name="element pattern where clause"/>.
</item>

<item><BNF name="parenthesized path pattern where clause"/>.
</item>

<item><BNF name="graph pattern where clause"/>.
</item>

<item><BNF name="graph pattern yield clause"/>.
</item>

</ulist>

<comment>WG3:UTC-087R2</comment>
<comment>Editorial: Stefan Plantikow, 2023-03-02 Consistent wording</comment>
<para>If an element variable <symdef>EV</symdef> is declared in 
a <BNF name="quantified path primary"/> <symdef>QPP</symdef>, then it may bind to more than one 
graph element. 
References to <sym>EV</sym> are interpreted contextually.
If the reference occurs outside <sym>QPP</sym>, then the reference is to the complete list of 
graph elements that are bound to <sym>EV</sym>. 
In this circumstance, the reference is said to have <newterm>group degree of reference</newterm>. 
If the reference does not cross a quantifier, then the reference has 
<newterm>singleton degree of reference</newterm> and references at most one graph element, 
even if the multi-path binding binds <sym>EV</sym> multiple times.
</para>

<comment>Editorial: Stefan Plantikow, 2023-03-09 Improve formatting</comment>
<note>For example,

<code>
(<symdef>X</symdef>) -[<symdef>E</symdef> <kw>WHERE</kw> <sym>E</sym>.<symdef>P</symdef> > 1]->{1,10} (<symdef>Y</symdef>) <kw>WHERE</kw> <kw>SUM</kw>(<sym>E</sym>.<sym>P</sym>) &lt; 100
</code>
This example references the edge variable <sym>E</sym> twice: once in the <BNF name="edge pattern"/>
and once outside the <BNF name="edge pattern"/>.
Within the <BNF name="edge pattern"/>, <sym>E</sym> has singleton degree of reference and the 
<BNF name="property reference"/> <sym>E</sym>.<sym>P</sym> references a property of a single edge.
On the other hand, the reference within the <kw>SUM</kw> aggregate has group degree of reference 
(because of the quantifier <mono>{1,10}</mono>) and references the list of edges that are bound to
<sym>E</sym>.
</note>

<para>A reference <symdef>R</symdef> to a graph pattern variable <symdef>GPV</symdef> is termed 
<newterm>local</newterm> in these circumstances:
</para>

<ulist>

<item>If <sym>GPV</sym> is declared in an <BNF name="element pattern"/> <symdef>EP</symdef> and 
<sym>R</sym> is contained in the <BNF name="element pattern where clause"/> of <sym>EP</sym>.
</item>

<item>If <sym>GPV</sym> is declared in a <BNF name="parenthesized path pattern expression"/> 
<symdef>PPPE</symdef> and <sym>R</sym> is contained in the 
<BNF name="parenthesized path pattern where clause"/> of <sym>PPPE</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-02-23 Adopt to GQL context</comment>
<item>If <sym>R</sym> is in a <BNF name="graph pattern where clause"/> or
a <BNF name="graph pattern yield clause"/>.
</item>

</ulist>

<comment>WG3:W22-053R2</comment>
<para><sym>R</sym> has a degree of reference, determined by the Syntax Rules of 
<specref ref="gql_var_refs"/>.
The degree of reference of <sym>R</sym> is one of the following: unconditional singleton, 
conditional singleton, or effectively bounded group.
</para>

<comment>Editorial: Stephen Cannan 2023-01-20 Align with Directives Part 2</comment>
<note>Subpath variables cannot be referenced by GQL language defined in this document, 
though it is possible they will be referenceable in a future version. 
At present their only use is to distinguish operands of a <BNF name="path multiset alternation"/>.
</note>

<ednote id="gql_ber031_1">It is a Language Opportunity to support references to subpath variables, 
for example, in <BNF name="graphical path length function" standard="9075" part="16"/>, or 
a TOTAL_COST function once CHEAPEST is defined. 
See <PPref ref="PPgql279"/>.
</ednote>

<comment>Editorial: Stephen Cannan 2023-01-20 Align with Directives Part 2</comment>
<comment>Editorial: Stephen Cannan 2023-09-15</comment>
<note>In general, an element variable that is declared within 
a <BNF name="quantified path primary"/> is bound by a multi-path binding to a list of 
graph elements. 
The reference <sym>R</sym>, on the other hand, can reference a proper subset of this list, based
on the syntactic context in which <sym>R</sym> is placed. 
The degree of reference expresses the cardinality of the list that <sym>R</sym> references, as 
follows. 
An unconditional singleton references a list of cardinality 1 (one), a conditional singleton 
references a list of cardinality 0 (zero) or 1 (one), an effectively bounded group references 
a finite list. 
Syntax rules prohibit the possibility of referencing an infinite list.

<para>A reference to a path variable always has unconditional singleton degree of reference.
</para>

</note>

<comment>Editorial: Stefan Plantikow, 2023-02-23 Clarify scope of statement</comment>
<para>References to graph pattern variables declared in <sym>GPBT</sym> are subject to
the following constraints:
</para>

<ulist>

<item>An operand <symdef>OP</symdef> of <BNF name="path pattern union"/> or 
<BNF name="path multiset alternation"/> <symdef>U</symdef> may only reference element variables 
declared in <sym>OP</sym>, or outside of <sym>U</sym>.
</item>

<item>A non-local reference shall have singleton degree of reference.
</item>

<comment>WG3:UTC-123R2 Consequence</comment>
<item>The group references in a <BNF name="value expression"/> or
a <BNF name="dependent value expression"/> immediately contained in
an <BNF name="aggregate function"/> shall reference the same graph pattern variable.
</item>

<item>A selective <BNF name="path pattern"/> <symdef>SPP</symdef> shall not reference a graph 
pattern variable that is not declared in <sym>SPP</sym>.
</item>

</ulist>

</bodyMatter>

</subClause2>


<comment>WG3:W16-034R2</comment>
<subClause2 id="gql_conc_graph_patt_match_path_patt_match">
<clauseHeading>Path pattern matching</clauseHeading>

<bodyMatter>

<comment>Editorial: Stephen Cannan, 2022-02-26 WG3:RKE-010 P00-USA-406</comment>
<para>Path pattern matching is performed by <specref ref="gql_graph_pattern"/>, which in turn 
may invoke <specref ref="gql_eval_path_pattern_expr"/>, and 
<specref ref="gql_eval_sel_paren_path_pattern_expr"/>, as well as other Subclauses incidentally 
invoked for expression evaluation.
</para>

<comment>WG3:BER-031</comment>
<comment>WG3:UTC-061</comment>
<para>In more detail, a <BNF name="path pattern"/> can be seen as a regular expression built from
<BNF name="node pattern"/>s and <BNF name="edge pattern"/>s. 
To formalize this, an alphabet is formed 
(in <specref ref="gql_machinery_graph_pattern_matching"/>),
comprising the element variable names, plus additional special symbols for the anonymous node 
symbol, the anonymous edge symbol, bracket symbols to indicate the beginning and ending of
bindings to <BNF name="parenthesized path pattern expression"/>s, and subpath symbols to mark
the beginning and ending of subpaths. 
The precise specification of the corresponding regular language is found in 
<specref ref="gql_eval_path_pattern_expr"/>.
</para>

<comment>WG3:UTC-061</comment>
<para>Each <BNF name="path pattern"/> of a <BNF name="graph pattern"/> is 
evaluated independently of each other, resulting in a set of path bindings. 
A path binding is a list of elementary bindings; each elementary binding is an ordered pair 
(<sym>LET</sym>, <sym>GE</sym>), where <symdef>LET</symdef> is a member of the alphabet, and 
<symdef>GE</symdef> is
</para>

<comment>WG3:UTC-061</comment>
<para>Case:
</para>

<ulist>

<item>if <sym>LET</sym> is a node variable or the anonymous node symbol, then a node;
</item>

<item>if <sym>LET</sym> is an edge variable or the anonymous edge symbol, then an edge;
</item>

<item>otherwise, equal to <sym>LET</sym>.
</item>

</ulist>

<comment>Editorial: Stephen Cannan 2023-01-20 Align with Directives Part 2</comment>
<note id="gql_reject_pb">In the formal semantics, <BNF name="label expression"/>s are evaluated 
at this stage, but <BNF name="search condition"/>s are not; hence it is possible that some 
path bindings will be subsequently rejected because they fail a <BNF name="search condition"/>.
Implementations are of course free to <quote>push down</quote> predicate evaluation as long
as the ultimate results are the same as prescribed by the formal semantics.
</note>

<ednote id="gql_PPgql392_1">It is not clear what <quote>formal semantics</quote> means. 
It does not mean the formal semantics as it would be meant conventionally in CS 
(denotational, operational, axiomatic).
See <PPref ref="PPgql392"/>.
</ednote>

<para>Projecting the elementary bindings of a path binding to the first component yields 
a word of the regular language of the <BNF name="path pattern"/>. 
Projecting to the second component yields an annotated path, which is a path interspersed with 
mark-up to indicate the beginning and ending of 
<BNF name="parenthesized path pattern expression"/>s and the beginning and ending of subpaths.
</para>

<comment>WG3BER-083R1</comment>
<comment>WG3:UTC-009 P00-USA-169</comment>
<para>If a <BNF name="path pattern"/> has an unbounded quantifier that is not in the scope of 
a restrictive <BNF name="path mode"/> or the <BNF name="different edges match mode"/>, then
there may be infinitely many path bindings. 
Such a <BNF name="path pattern"/> must have a selective <BNF name="path search prefix"/> 
<symdef>SPSP</symdef>. 
<specref ref="gql_eval_sel_paren_path_pattern_expr"/>, is invoked to reduce this potentially 
infinite set of path bindings to a finite set.
All <BNF name="search condition"/>s contained in the selective 
<BNF name="path pattern"/> are evaluated to reduce the set of path bindings prior to making the 
final selection according to <sym>SPSP</sym>.
</para>

<note id="gql_inf_sets">An implementation cannot generate an infinite set and then apply
<BNF name="search condition"/>s; instead it must enumerate the search space in a fashion
enabling it to arrive at the same result as specified by the formal semantics. 
The formal semantics do not specify the algorithm for this enumeration, only the result.
</note>

<ednote id="gql_PPgql392_2">It is not clear what <quote>formal semantics</quote> means. 
It does not mean the formal semantics as it would be meant conventionally in CS 
(denotational, operational, axiomatic).
See <PPref ref="PPgql392"/>.
</ednote>

<comment>WG3BER-083R1</comment>
<para>At this point, there is a finite set of path bindings for each <BNF name="path pattern"/> in
a <BNF name="graph pattern"/>. 
The cross product of these sets is formed; a member of the cross product is called 
a multi-path binding. 
A multi-path binding does not violate any restrictive <BNF name="path mode"/> or 
<BNF name="different edges match mode"/> that may be in force.
The set of multi-path bindings is reduced by enforcing natural equijoins on the 
unconditional singleton variables exposed by the <BNF name="path pattern"/>s.
</para>

<comment>WG3:UTC-013 P16-DEU-014</comment>
<para>Then the <BNF name="search condition"/>s in the <BNF name="graph pattern"/> are 
evaluated, potentially further reducing the set of multi-path bindings. 
Those that remain satisfy all the selective <BNF name="path search prefix"/>es and all the 
<BNF name="search condition"/>s of the <BNF name="graph pattern"/>.
</para>

<comment>WG3:W24-022</comment>
<comment>WG3:UTC-013 P16-DEU-014</comment>
<para>Then the function <symdef>REDUCE</symdef> (defined in 
<specref ref="gql_machinery_graph_pattern_matching"/>) is applied to the remaining 
multi-path bindings.
<sym>REDUCE</sym> removes the elementary bindings of the bracket symbols, erases temporary element 
bindings by replacing them with corresponding anonymous node and edge symbol bindings, and 
collapses adjacent anonymous node symbol bindings into a single elementary binding. 
The results, now called reduced matches, are deduplicated according to set semantics.
</para>

<note>If there is a <BNF name="path pattern union"/> in the <BNF name="graph pattern"/>, then
duplicates can arise.
</note>

</bodyMatter>

</subClause2>


<comment>WG3:W16-034R2</comment>
<comment>Email from Jan Michels, 2022-07-15 0307</comment>
<subClause2 id="gql_conc_graph_patt_match_path_mode">
<clauseHeading>Path modes</clauseHeading>

<bodyMatter>

<para>A <BNF name="path mode"/> may be specified for any 
<BNF name="parenthesized path pattern expression"/> or any <BNF name="path pattern"/> from the 
following choices:
</para>

<ulist>

<comment>Editorial: Stephen Cannan, 2022-02-26 WG3:RKE-010 P00-USA-407</comment>
<item><kw>WALK</kw>, the default <BNF name="path mode"/>, is the absence of any filtering 
implied by the other <BNF name="path mode"/>s.
</item>

<item><kw>TRAIL</kw>, where path bindings with repeated edges are not returned.
</item>

<item><kw>ACYCLIC</kw>, where path bindings with repeated nodes are not returned.
</item>

<item><kw>SIMPLE</kw>, where path bindings with repeated nodes are not returned unless these
repeated nodes are the first and the last in the path.
</item>

</ulist>

<comment>Editorial: Stephen Cannan, 2022-02-26 WG3:RKE-010 P00-USA-408</comment>
<para>Using trail, acyclic, or simple matching path modes for all unbounded quantifiers
guarantees that the result set of a graph pattern matching will be finite.
</para>

<comment>WG3:UTC-091</comment>
<note id="gql_path_mode_hier">There is no implied hierarchy between path modes. 
Specifically, path mode <kw>SIMPLE</kw> does not imply path mode <kw>TRAIL</kw>. 
While such an implication holds for directed graphs, it does not hold for graphs with undirected 
edges. 
For instance, the pattern ( ) - ( ) - ( ) on a graph with two nodes and one undirected edge between
them returns a match under <kw>SIMPLE</kw> but does not return any matches under <kw>TRAIL</kw>.
</note>

<ednote id="gql_PPgql393">Pattern ()-()-() is inconsistent with the text.
The pattern ()-()-() cannot be matched in a graph ()~[]~().
See <PPref ref="PPgql393"/>.
</ednote>

</bodyMatter>

</subClause2>


<comment>WG3:W16-034R2</comment>
<comment>Email from Jan Michels, 2022-07-15 0307</comment>
<subClause2 id="gql_conc_graph_patt_match_path_srch_pre">
<clauseHeading>Selective path search prefixes</clauseHeading>

<bodyMatter>

<comment>Editorial: Stephen Cannan, 2022-02-26 WG3:RKE-010 P00-USA-409</comment>
<para>The set of path bindings resulting from a graph pattern match can be further restricted
by a selective <BNF name="path search prefix"/> <symdef>SPSP</symdef>. 
<sym>SPSP</sym> is defined by partitioning the potentially infinite set of path bindings by the 
endpoints, which are the first and last nodes bound by the path bindings.
</para>

<comment>Editorial: Stephen Cannan 2023-01-20 Align with Directives Part 2</comment>
<note>This partitioning is crucial to the definition of <sym>SPSP</sym>. 
<sym>SPSP</sym> makes a selection of some number of path bindings from each partition. 
For example, a path binding is <quote>shortest</quote> if its length is minimal within its 
partition. 
A <quote>shortest</quote> path binding in one partition can be longer than 
a <quote>shortest</quote> path binding in another partition.
</note>

<para><sym>SPSP</sym> can constrain the result set in the following ways:
</para>

<ulist>

<comment>WG3:CMN-061R1</comment>
<item><BNF name="any path search"/>: to non-deterministically pick some number of path bindings
from each partition; the number is specified by 
a <BNF name="non-negative integer specification"/>.
</item>

<item><BNF name="all shortest path search"/>: to pick all the shortest path bindings in 
each partition.
</item>

<comment>WG3:CMN-061R1</comment>
<item><BNF name="counted shortest path search"/>: to non-deterministically pick some number of
shortest path bindings from each partition; the number is specified by 
a <BNF name="non-negative integer specification"/>.
</item>

<comment>WG3:CMN-061R1</comment>
<item><BNF name="counted shortest group search"/>: to group each partition into groups of path
bindings having the same length, order the groups by path length, and pick all path bindings in 
some number of groups from the front of each partition; the number is specified by 
a <BNF name="non-negative integer specification"/>.
</item>

</ulist>

<para>The specification of <sym>SPSP</sym> guarantees that the result set of 
a graph pattern matching will be finite.
</para>

</bodyMatter>

</subClause2>


<comment>WG3:BER-032R3</comment>
<comment>Email from Jan Michels, 2022-07-15 0307</comment>
<subClause2 id="pgq_conc_match_mode">
<clauseHeading>Match modes</clauseHeading>

<bodyMatter>

<para>A <BNF name="graph pattern"/> <symdef>GP</symdef> may optionally specify 
a <BNF name="match mode"/> that applies to all <BNF name="path pattern"/>s simply contained in 
<sym>GP</sym>.
</para>

<para>There are two <BNF name="match mode"/>s:
</para>

<ulist>

<item><kw>DIFFERENT</kw> <kw>EDGES</kw>: A matched edge is not permitted to bind to more than one 
edge variable.
There are no restrictions on matched nodes.
</item>

<item><kw>REPEATABLE</kw> <kw>ELEMENTS</kw>: There are no restrictions on matched edges or 
matched nodes.
</item>

</ulist>

<para>If a <BNF name="match mode"/> is not specified, then an <impDef code="ID086"/>
<BNF name="match mode"/> is implicit.
</para>

</bodyMatter>

</subClause2>

</subClause>


<?set_qualifiers ["type",nil]?>
<subClause id="gql_conc_dt">
<clauseHeading>Data types</clauseHeading>
<comment>Editorial: Stefan Plantikow, 2023-02-21 Deleted 1 (one) editor's note</comment>
<comment>Editorial: Stefan Plantikow, 2022-11-16 One editor's note removed</comment>

<comment>Editorial: Stefan Plantikow, 2020-03-12</comment>
<comment>WG3:UTC-015</comment>
<subClause2 id="gql_conc_dt_genintro">
<clauseHeading>General introduction to data types and base types</clauseHeading>

<bodyMatter>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-17 WG3:W12-029</comment>
<comment>WG3:W20-010: Stefan Plantikow, 2022-03-14 P00-USA-410</comment>
<comment>WG3:RKE-048</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:W23-037</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:UTC-111</comment>
<comment>WG3:CMN-057R1</comment>
<para>A data type is a <repeatdefn ref="gql_data_type_defn"/>.
If <symdef>X</symdef> is an element of some data type <symdef>DT</symdef>, then 
<sym>X</sym> is said to be <quote>of data type <sym>DT</sym>&narrownbsp;</quote>.
<repeatpassage ref="gql_type_defnote"/>
Every instance at a site belongs to one or more data types.
The physical representation of an instance of a data type is <unDef code="UV005"/>.
</para>

<comment>WG3:CMN-057R1</comment>
<note>See <specref ref="gql_conc_sites"/>.
</note>

<comment>Editorial: Stephen Cannan, 2020-11-05</comment>
<comment>WG3:W12-029: Stefan Plantikow, 2021-06-17 WG3:W12-029</comment>
<comment>Email from: Jan Michels, 2022-02-26 0223</comment>
<comment>WG3:RKE-048</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-019 P00-ISO-001</comment>
<comment>WG3:CMN-057R1</comment>
<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<para>A data type <symdef>A</symdef> can be equivalent to, disjoint from, overlap with, or be
included in some other data type <symdef>B</symdef> depending on the sharing of elements between
<sym>A</sym> and <sym>B</sym>.
In this document, any two data types with the exact same elements are equivalent.
All data types form a partial order that is implicitly defined by the inclusion relation between 
them.
A data type containing all elements of some data type <symdef>X</symdef> is a supertype of 
<sym>X</sym>. 
A data type comprising elements contained in some data type <symdef>X</symdef> is a subtype of
<sym>X</sym>.
For a site <symdef>X</symdef> whose declared type is <symdef>DT</symdef> and a specification of 
data types <symdef>SODTS</symdef>, the phrase 
<quote><sym>X</sym> is of at least <sym>SODTS</sym></quote> expresses the condition of whether 
<sym>DT</sym> is a supertype of the data types specified by <sym>SODTS</sym>.
</para>

<ednote id="gql_W26_026_2">Alternative subtyping models have been suggested.
See <PPref ref="PPgql376"/>.
</ednote>

<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<comment>Editorial: Stefan Plantikow, 2024-04-06 Correct reference</comment>
<note>The system of data types defined in this document is structural. 
Values are not distinguished by tagging them with their type. 
<bar note="Editorial: Stefan Plantikow, 2024-04-06 Correct reference"/>
However, the static base type and the most specific static value type of every value are
well-defined, as explained in <specref ref="gql_conc_most_spec_val_type"/>.
<endbar/>
A GQL-implementation could extend the type system with nominal types, <eg/> by introducing a form 
of type name-tagged values. 
The details of such a hypothetical extension with nominal types are not considered in this 
document.
</note>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-17</comment>
<comment>Editorial: Stephen Cannan, 2022-02-26 W20-010 P00-USA-140</comment>
<comment>WG3:RKE-048</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:W23-037</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:W25-031R2</comment>
<comment>WG3:CMN-057R1</comment>
<comment>WG3:CMN-057R1</comment>
<para>A base type is a <repeatdefn ref="gql_base_type_defn"/>
(<ie/> it is a <quote>type of types</quote>).
If <symdef>T</symdef> is a data type included in some base type <symdef>BT</symdef>, then 
<sym>T</sym> is said to be <quote>of base type <sym>BT</sym>&narrownbsp;</quote>. 
The supertype and subtype relations on base types are defined analogous to the corresponding 
definitions for data types given above.
Elements of a data type of some base type <symdef>A</symdef> may still be assigned to a site 
whose declared type is another data type of some other base type <symdef>B</symdef>, which is 
possibly different from <sym>A</sym> using relevant type conversions.
</para>

<comment>WG3:W25-031R2</comment>
<note>See <specref ref="gql_conc_ass_mut"/>.
</note>

<comment>WG3:CMN-057R1</comment>
<comment>WG3:W26-026R2</comment>
<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<para>Every data type is associated with exactly one of its base types, which is called the 
<newterm>primary base type</newterm> of the data type. 
Primary base types indirectly determine the universe of elements from which each of their 
data types are drawn (<eg/> the character strings). 
If a base type only includes data types whose primary base type is the base type 
itself, then the base type is a <newterm>static base type</newterm>; otherwise, the base type is 
a <newterm>dynamic base type</newterm>.
Similarly, the data types whose primary base type is a static base type or a dynamic base type, 
are called <newterm>static data type</newterm>s or <newterm>dynamic data type</newterm>s, 
respectively.
</para>

<comment>WG3:CMN-057R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-28 Fix typo</comment>
<comment>Email from: Stefan Plantikow, 2023-11-28 1549</comment>
<para>Every data type defined in this document is included in its primary base type and every 
value type defined in this document is included in the dynamic base type of all value types 
(ANY DATA). 
For every dynamic union type, those two base types are identical.
</para>

<comment>WG3:CMN-057R1</comment>
<note>See <specref ref="gql_conc_dyn_union_type"/>.
</note>

</bodyMatter>

</subClause2>


<comment>WG3:CMN-057R1</comment>
<subClause2 id="gql_major_class_dts">
<clauseHeading>Major classes of data types</clauseHeading>

<bodyMatter>

<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<comment>WG3:W26-026R2</comment>
<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<comment>WG3:POS-011R1</comment>
<para><specref ref="gql_fig_types"/> shows a pictorial overview of major classes of
data types defined in this document together with their base types and examples of data types of
those base types.
</para>

<note>The following kinds of data types defined in this document are omitted from
<specref ref="gql_fig_types"/> due to space constraints: vector types.
</note>

<para>Every data type is either a GQL-object type or a value type. 
Additionally, every data type is either a material data type, a nullable data type, or 
an immaterial data type.
</para>

<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<note>See <specref ref="gql_conc_mat_null_immat_dts"/>.
</note>

<comment>WG3:W26-026R2</comment>
<figure id="gql_fig_types" file="gql_types.svg" padding-after="10pt" width="5.1in">
<figureTitle>Major classes of data types</figureTitle>
</figure>

<comment>WG3:W26-026R2</comment>
<para>A GQL-object type is a data type comprising GQL-objects, and a value type is a data type 
comprising values.
</para>

<comment>WG3:CMN-057R1</comment>
<para>Every GQL-object type defined in this document comprises either only primary objects or
only secondary objects.
</para>

<comment>WG3:CMN-057R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-10-14 Point to outer Subclause instead</comment>
<comment>WG3:W26-026R2</comment>
<note>This document defines certain GQL-objects that do not have a corresponding (constraining) 
GQL-object type that contains them.
See <specref ref="gql_conc_obj"/>.
</note>

<comment>WG3:CMN-057R1</comment>
<note>The property values of GQL-objects are required to be included in certain value types. 
See <specref ref="gql_conc_props_and_spvts"/>.
</note>

<comment>WG3:CMN-057R1</comment>
<note>The property types of graph element types and the column types of binding table types are 
not considered data types.
</note>

<comment>WG3:W26-026R2</comment>
<note>See <specref ref="gql_conc_ot"/>.
</note>

<comment>WG3:CMN-057R1</comment>
<comment>WG3:W26-026R2</comment>
<para>Every regular (non-immaterial) value type defined in this document is included in exactly 
one of the following classes of value types:
</para>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-17</comment>
<ulist>

<comment>WG3:UTC-015</comment>
<comment>Editorial: Stefan Plantikow 2023-03-06 </comment>
<comment>WG3:CMN-057R1</comment>
<item>A dynamic union type is a supertype of two or more static value types.
<note>See <specref ref="gql_conc_dyn_union_type"/>.
</note>
</item>

<comment>WG3:CMN-057R1</comment>
<item>A constructed value type is a data type <repeatdefn ref="gql_constructed__dt_defn"/>
(such as a path value type, a list value type, or a record type).

<note>See <specref ref="gql_conc_constr"/>.
</note>

<note>The field types of record types are not considered data types.
</note>
</item>

<comment>Editorial: Stefan Plantikow, 2022-02-24 WG3:W20-010 P00-USA-411</comment>
<comment>WG3:W23-037</comment>
<comment>WG3:CMN-057R1</comment>
<item>A predefined value type is a value type specified in this document that is 
<repeatdefn ref="gql_predefined__dt_defn"/>.
A value type is predefined even though the user is required (or allowed) to
provide certain parameters when specifying it (<eg/> the precision of a number).
Predefined value types are sometimes called <quote>built-in data types</quote>, though not in this
document.
A reference value type is a predefined <repeatdefn ref="gql_reference_value_type_defn"/>.

<comment>WG3:CMN-057R1</comment>
<note>See <specref ref="gql_conc_vt_predef"/>.
</note>
</item>

</ulist>

<comment>Editorial: Stefan Plantikow, 2023-11-23 Reorder paragraphs</comment>
<comment>WG3:W26-026R2</comment>
<para>The empty type and the null type are the only immaterial value types.
</para>

<comment>WG3:W26-026R2</comment>
<note>See <specref ref="gql_immat_null_empty_dts"/>.
</note>

<comment>WG3:CMN-057R1</comment>
<para>A GQL-implementation may provide additional data types not defined in this document.
</para>

<comment>WG3:CMN-057R1</comment>
<note>Examples of such data types are user-defined data types specified by a standard
or an application, as well as data types defined by the GQL-implementation.
</note>

<comment>WG3:POS-011R1</comment>
<ednote id="PPgql437_1">Some GQL data types miss sections on supported operations.
This should be harmonized.
See <PPref ref="PPgql437"/>.
</ednote>

</bodyMatter>

</subClause2>


<comment>WG3:CMN-057R1</comment>
<subClause2 id="gql_conc_dt_descriptors">
<clauseHeading>Data type descriptors</clauseHeading>

<bodyMatter>

<para>Each data type has an associated data type descriptor.
The content of a data type descriptor is determined by the specific data type that it describes. 
A data type descriptor includes an identification of the data type and all information needed to 
characterize an element of that data type. 
In particular, the descriptor of every data type defined in this document includes
the declared name of the primary base type of the data type.
</para>

<para>A <newterm>constraining GQL-object type</newterm> is an optional data type characteristic of 
a descriptor <symdef>DESCR</symdef> which either constrains instances of the GQL-object type 
described by <sym>DESCR</sym> or the referents of reference values of the reference value type 
described by <sym>DESCR</sym>. 
Instances of such a data type are classified as either open or closed depending the absence or 
presence, respectively, of the characteristic.
</para>

<para><specref ref="gql_value_type"/>, describes the semantic properties of each value type.
</para>

</bodyMatter>

</subClause2>


<comment>WG3:CMN-057R1</comment>
<subClause2 id="gql_conc_name_dt_and_base_type">
<clauseHeading>Naming of data types and base types</clauseHeading>

<bodyMatter>

<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<para>All data types and base types defined in this document are generally referred to by their
<newterm>specification names</newterm>, which are introduced in 
<specref ref="gql_conc_intro_obj_type"/>, 
<specref ref="gql_dyn_union_type_intro"/>,
<specref ref="gql_conc_constr_intro"/>, and
<specref ref="gql_conc_dt_predefined_names"/>.
</para>

<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<para>Every data type defined in this document is specified by any of its 
<newterm>declared names</newterm> (including its <newterm>preferred name</newterm>, which can be 
contingent on <impDef annex="no" code="None"/> provisions) as well as by all relevant additional 
metadata (such as, <eg/> the maximum length of values of certain value types). 
The declared name of a data type is a non-empty sequence of keywords specified in this document.
</para>

<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<para>Every base type defined in this document is specified by its declared name. 
The declared name of a base type is a non-empty sequence of keywords that specifies the base type 
in specific contexts (such as the declared names of base types included in certain data type
descriptors) and comprises a declared base type name prefix that is followed by either 
the word DATA or the word REFERENCE.
</para>

</bodyMatter>

</subClause2>


<comment>WG3:W26-026R2</comment>
<subClause2 id="gql_conc_mat_null_immat_dts">
<clauseHeading>Material, nullable, and immaterial data types</clauseHeading>

<bodyMatter>

<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<para><specref ref="gql_ty_terms_defns"/>, defines a material data type as a data type 
<repeatdefn ref="gql_material__dt_defn"/>.
Every GQL-object type defined in this document is a material data type. 
Two material static data types of different primary base types are always disjoint.
</para>

<para><specref ref="gql_ty_terms_defns"/>, defines a nullable data type as 
a <repeatdefn ref="gql_nullable__dt_defn"/>. 
Every nullable data type defined in this document is a value type. 
The nullable variant and the material variant of a data type <symdef>DT</symdef>, are 
the data types comprising the same material values as <sym>DT</sym> together with or without, 
respectively, the null value, if existing.
</para>

<note>See <specref ref="gql_conc_material_vals"/>.
</note>

<para><specref ref="gql_ty_terms_defns"/>, defines an immaterial data type as 
a <repeatdefn ref="gql_immaterial__dt_defn"/>.
</para>

<note>See <specref ref="gql_immat_null_empty_dts"/>.
</note>

</bodyMatter>

</subClause2>


<comment>WG3:CMN-057R1</comment>
<subClause2 id="gql_conc_most_spec_val_type">
<clauseHeading>Most specific static value type and static base type</clauseHeading>

<bodyMatter>

<comment>WG3:W26-026R2</comment>
<para id="gql_conc_most_spec_val_type_1">The <newterm>most specific static value type</newterm> of 
a material value <symdef>X</symdef> is defined as follows. 
Let <symdef>CANDTSET</symdef> be the set of all value types of the static base type 
<symdef>BT</symdef> of <sym>X</sym> that are supported by the GQL-implementation and
that include <sym>X</sym>. 
The <applySC ref="gql_svt_prec" rules="SR">
<symarg param="NDTSET"><sym>CANDTSET</sym></symarg>
<symresult param="NDTLIST"><symdef>NDTLIST</symdef></symresult>
</applySC>.
The most specific static value type of <sym>X</sym> is well-defined to be the first element of 
the list <sym>NDTLIST</sym>. 
The most specific static value type of the null value is defined as follows.
If the GQL-implementation supports <feature code="GV71"/>, then the most specific static value type
of the null value is the null type; otherwise, the most specific static value type of the 
null value is an <impDef code="ID085"/> static value type.
</para>

<para>The definition of the most specific static value type is based on the notion of the 
static base type of a value. 
The static base type of a material value <symdef>X</symdef> is the common primary base type of
all static value types that include <sym>X</sym>. 
The static base type of all material values defined in this document is well-defined and 
shall remain unchanged for existing and always be well-defined for any additional material values 
introduced by a GQL-implementation extended with additional values and value types. 
The static base type of the null value is the primary base type of the most specific static value
type of the null value.
</para>

</bodyMatter>

</subClause2>


<comment>WG3:CMN-057R1</comment>
<subClause2 id="gql_conc_add_term_dt">
<clauseHeading>Open and closed data types</clauseHeading>

<bodyMatter>

<comment>WG3:CMN-057R1</comment>
<comment>WG3:CMN-057R1 Correction</comment>
<para>The data types of certain primary base types are classified as either 
<newterm>closed</newterm> or <newterm>open</newterm> data types depending on whether they are 
specified with or without, respectively, explicitly providing certain metadata 
(such as, <eg/> the field types of a record type). 
This classification is independent of the nullability of data types, <ie/> a nullable data type 
is open or closed if and only if its material variant is open or closed, respectively, too. 
If a data type <symdef>DT</symdef> is open, then either <sym>DT</sym> or the nullable variant of 
<sym>DT</sym> (if existing) is a super type of all data types of the primary base type of
<sym>DT</sym>.
</para>

<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<para>This document explicitly classifies the following value types as (nullable) open value types,
together with their material, nullable closed, and material closed variants:
</para>

<comment>Editorial: Stefan Plantikow, 2023-03-06 Align list order</comment>
<ulist>

<comment>WG3:CMN-057R1</comment>
<item>The open dynamic union type, which is specified without explicitly providing metadata
indicating its component types.
</item>

<comment>WG3:CMN-057R1</comment>
<item>The open graph, node, and edge reference value types, which are specified without explicitly
providing metadata indicating their constraining GQL-object types.
</item>

<comment>WG3:CMN-057R1</comment>
<item>The open list value type, which is specified without explicitly providing metadata 
indicating its maximum cardinality or its element type.

<note>The list element type of an open list value type is the open dynamic union type.
</note>
</item>

<comment>WG3:CMN-057R1</comment>
<item>The open record type, which is specified without explicitly providing metadata indicating
its field types.
</item>

</ulist>

</bodyMatter>

</subClause2>


<comment>WG3:W26-026R2</comment>
<subClause2 id="gql_conc_add_term_dts">
<clauseHeading>Additional terminology related to data types</clauseHeading>

<bodyMatter>

<para>An atomic data type is a data type comprising only values that are not composed of values of
other data types. 
The existence of an operation (such as TRIM) that is capable of selecting part of an element of 
some data type <symdef>T</symdef> (such as a character string or a datetime value) does not imply 
that <sym>T</sym> is not an atomic data type.
</para>

<para>Two data types, <symdef>T1</symdef> and <symdef>T2</symdef>, are said to be compatible if 
<sym>T1</sym> is assignable to <sym>T2</sym>, <sym>T2</sym> is assignable to <sym>T1</sym>, and 
their descriptors include the same data type name and the same indication regarding the inclusion 
of the null value, if any. 
Additionally,
</para>

<para>Case:
</para>

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>If they are record types, it shall further be the case that the value types of
their corresponding field types are pairwise compatible or that both are open record types.
</item>

<item>If they are list value types, it shall further be the case that their list element types
are compatible.
</item>

<item>If they are reference value types, it shall further be the case that both have 
a constraining GQL-object type and their constraining GQL-object-types are compatible or that 
both have no constraining object type.
</item>

<item>If they are dynamic union types, then there shall exist a mapping from each component type 
<symdef>FCT1</symdef> of <sym>T1</sym> to a component type <symdef>FCT2</symdef> of <sym>T2</sym>
such that <sym>FCT1</sym> is assignable to <sym>FCT2</sym> and a reverse mapping from each 
component type <symdef>RCT2</symdef> of <sym>T2</sym> to a component type <symdef>RCT1</symdef> of 
<sym>T1</sym> such that <sym>RCT2</sym> is assignable to <sym>RCT1</sym>.
</item>

</olist>

</bodyMatter>

</subClause2>

</subClause>


<subClause id="gql_conc_ot">
<clauseHeading>GQL-object types</clauseHeading>

<comment>WG3:CMN-057R1</comment>
<subClause2 id="gql_conc_intro_obj_type">
<clauseHeading>Introduction to GQL-object types and related base types</clauseHeading>

<bodyMatter>

<para>The GQL language defines the following GQL-object object types: 
<newterm>graph types</newterm>, <newterm>node types</newterm> 
(alternatively: <newterm>vertex types</newterm>), <newterm>edges type</newterm>s 
(alternatively: <newterm>relationship types</newterm>), and <newterm>binding table types</newterm>.
</para>

<note>Property types and field types are not considered GQL-object types.
</note>

<para>The declared names of static base types of GQL-object types defined in this document are:
</para>

<ulist>

<item>GRAPH DATA, which specifies the <newterm>graph type base type</newterm>. 
The graph type base type is the base type that comprises all graph types.
</item>

<comment>WG3:W27-013</comment>
<item>The <impDef code="ID090"/> choice of NODE DATA or VERTEX DATA, which specifies the 
<newterm>node type base type</newterm>. 
The node type base type is the base type that comprises all node types.
</item>

<comment>WG3:W27-013</comment>
<comment>Jim Melton, 2025-03-18; ensure "comprise" used correctly</comment>
<item>The <impDef code="ID091"/> choice of EDGE DATA or RELATIONSHIP DATA, which specifies the 
<newterm>edge type base type</newterm>. 
The edge type base type is the base type of all edge types.
</item>

<comment>Jim Melton, 2025-03-18; ensure "comprise" used correctly</comment>
<item>BINDING TABLE DATA, which specifies the <newterm>binding table type base type</newterm>. 
The binding table type base type is the base type of all binding table types.
</item>

</ulist>

<para>For reference purposes:
</para>

<ulist>

<item>The GQL-object types specified with the leading keyword <kw>GRAPH</kw> are referred to as 
graph types and the elements of graph types are referred to as graphs or property graphs. 
The primary base type of all graph types is the graph type base type.
</item>

<item>The GQL-object types specified with the leading keywords <kw>NODE</kw> or <kw>VERTEX</kw> 
are referred to as node types or, alternatively, as vertex types and the elements of node types 
are referred to as nodes or, alternatively, as vertices. 
The primary base type of all node types is the node type base type.
</item>

<item>The GQL-object types specified with the leading keywords <kw>EDGE</kw> or 
<kw>RELATIONSHIP</kw> are referred to as edge types or, alternatively, as relationship types and 
the elements of edge types are referred to as edges or, alternatively, as relationships. 
The primary base type of all edge types is the edge type base type.
</item>

<item>The GQL-object types specified with the leading keywords <kw>BINDING</kw> <kw>TABLE</kw> or 
<kw>TABLE</kw> are referred to as binding table types and the elements of binding table types are 
referred to as binding tables. 
The primary base type of all binding table types is the binding table type base type.
</item>

</ulist>

</bodyMatter>

</subClause2>

<subClause2 id="gql_conc_gt">
<clauseHeading>Graph types and graph element types</clauseHeading>

<subClause3 id="gql_conc_gt_intro">
<clauseHeading>Introduction to graph types and graph element types</clauseHeading>

<bodyMatter>

<comment>WG3:W26-022R2</comment>
<para><specref ref="gql_ty_terms_defns"/> defines a graph type as a GQL-object type describing
a graph in terms of restrictions on its labels, properties, nodes, edges, and topology.
The purpose of a graph type is to constrain the set of nodes and edges that can be contained in
a graph.
</para>

<comment>WG3:W26-022R2 Removed 1 (one) paragraph</comment>

<comment>WG3:W23-029R1</comment>
<comment>WG3:W26-022R2</comment>
<para>A graph type is created in a GQL-schema and is identified by 
a <BNF name="graph type name"/>.
A graph type is a primary object.
</para>

<comment>WG3:W23-029R1</comment>
<comment>WG3:W25-031R2</comment>
<comment>WG3:CMN-019 P00-USA-214</comment>
<para>A graph is of a graph type (<ie/> is included in that graph type) if each of the nodes in 
the graph are of a node type specified in the graph type and each of the edges in the graph are 
of an edge type specified in the graph type. 
Inserting or updating nodes and edges in a graph that has a constraining graph type such that 
the graph would no longer be of that graph type causes an exception condition to be raised:
<raise class="G2"/>.
</para>

<comment>WG3:W23-029R1</comment>
<para>Multiple graphs may reference the same graph type.
</para>

<para>A graph type comprises:
</para>

<ulist>
<comment>WG3:W22-034R1 deleted two list items</comment>

<comment>Email from: Hannes Voigt, 2020-08-20 1539</comment>
<comment>WG3:W26-022R2</comment>
<item>A node type set, which is a set comprising zero or more node types.
</item>

<comment>Email from: Hannes Voigt, 2020-08-20 1539</comment>
<comment>WG3:W26-022R2</comment>
<item>An edge type set, which is a set comprising zero or more edge types. 
</item>

</ulist>

</bodyMatter>

</subClause3>


<comment>WG3:MMX-028R2</comment>
<subClause3 id="gql_graph_type_desc">
<clauseHeading>Graph type descriptors</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-07-23 WG3:MMX-055</comment>
<comment>WG3:W23-030</comment>
<para>A graph type is described by its graph type descriptor that comprises:
</para>

<ulist>

<comment>WG3:W23-029R1</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:W26-022R2</comment>
<item>The declared name of the primary base type of all graph types (GRAPH DATA).
</item>

<comment>WG3:W26-022R2</comment>
<item>The preferred name of graph types (<impDef code="ID089"/> choice of GRAPH or PROPERTY GRAPH).
</item>

<item>The set of node type descriptors (also known as a node type set).
</item>

<item>The set of edge type descriptors (also known as an edge type set).
</item>

<comment>Editorial: Stephen Cannan, 2022-02-26 W20-010 P00-USA-421 and P00-USA-422</comment>
<comment>WG3:OHD-023</comment>
<comment>WG3:W26-022R2</comment>
<item>The node type key label set dictionary that maps node type key label sets to node types
contained in the node type set of this graph type descriptor.
</item>

<comment>Editorial: Stephen Cannan, 2022-02-26 W20-010 P00-USA-422</comment>
<comment>WG3:OHD-023</comment>
<comment>WG3:W26-022R2</comment>
<item>The edge type key label set dictionary that maps edge type key label sets to sets of 
edge types contained in the edge type set of this graph type descriptor.

<comment>WG3:W26-022R2</comment>
<note>Without <feature code="GG25"/>, the edge type key label set dictionary maps every edge type
key label set to a singleton set of edge types.
</note>

</item>

</ulist>

<para>Two graph type descriptors describe equal graph types if they contain:
</para>

<comment>Editorial: Stephen Cannan, 2022-02-26 W20-010 P00-USA-423</comment>
<ulist>
<comment>WG3:W22-034 deleted two list items</comment>

<item>Equal node type sets.
</item>

<item>Equal edge type sets.
</item>

<comment>WG3:W26-022R2</comment>
<item>Equal node type key label set dictionaries.
</item>

<comment>WG3:W26-022R2</comment>
<item>Equal edge type key label set dictionaries.
</item>

</ulist>

<comment>WG3:W23-029R1</comment>
<comment>WG3:W26-022R2</comment>
<para>Two node and edge type key label set dictionaries are equal if and only if they:
</para>

<comment>WG3:W26-022R2</comment>
<ulist>

<comment>WG3:W26-022R2</comment>
<item>Map equal sets of node type key label sets and edge type key label sets,
</item>

<comment>WG3:W26-022R2</comment>
<item>Map each of these node type key label sets to equal node types, and
</item>

<comment>WG3:W26-022R2</comment>
<item>Map each of these edge type key label sets to equal sets of edge types.
</item>

</ulist>

<comment>Editorial: Stefan Plantikow, 2020-07-23 Adjusted for WG3:MMX-055</comment>
<comment>Editorial: Stephen Cannan, 2020-11-05</comment>
<comment>Consequence of WG3:W13-010R1</comment>
<comment>WG3:W23-030</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<para>For every graph type <symdef>GT</symdef> that is a catalog object, the graph type descriptor 
of <sym>GT</sym> is a catalog object descriptor. 
The name of <sym>GT</sym> (also known as graph type name) is the catalog object name of 
<sym>GT</sym>. 
<sym>GT</sym> is a <newterm>named graph type</newterm>.
</para>

</bodyMatter>

</subClause3>


<subClause3 id="gql_conc_ot_node">
<clauseHeading>Node types</clauseHeading>

<bodyMatter>

<para>A <newterm>node type</newterm> is the data type of nodes that have specific labels and that
have specific properties and whose properties have a specific property value type.
</para>

<comment>Email from: Hannes Voigt, 2020-08-20 1539</comment>
<para>Each node type comprises:
</para>

<ulist>

<comment>Email from: Hannes Voigt, 2020-08-20 1539</comment>
<item>A node type label set that comprises a set of zero or more labels.
A label has a name that is an identifier that is unique within the node type.
</item>

<comment>Email from: Hannes Voigt, 2020-08-20 1539</comment>
<comment>WG3:W26-022R2</comment>
<item>A node type property type set that comprises a set of zero or more property types.

<comment>WG3:W26-022R2</comment>
<note>See <specref ref="gql_conc_property_types"/>.
</note>

</item>

</ulist>

<comment>WG3:W26-022R2</comment>
<note>The names of node type labels and of node type property types are in separate namespaces.
That is, a label and a property type can have the same name in a node type.
</note>

<comment>WG3:BER-040R3</comment>
<comment>Editorial: Stephen Cannan 2022-11-13 Improve wording</comment>
<comment>WG3:W26-022R2</comment>
<para>A GQL-implementation is permitted to regard two <BNF name="node type specification"/>s as 
equivalent, if they have the same node type label set and node type property type set,
as permitted by the  Syntax Rules of <specref ref="gql_lbl_set_defn"/>, and
<specref ref="gql_prop_type_set_defn"/>.
When two or more <BNF name="node type specification"/>s are equivalent, the GQL-implementation 
chooses one of these equivalent <BNF name="node type specification"/>s as the normal form 
representing that equivalence class of <BNF name="node type specification"/>s. 
The normal form determines the preferred name of the node type in data type descriptors.
</para>

<comment>WG3:W23-029R1</comment>
<comment>WG3:W25-031R2</comment>
<comment>WG3:CMN-019 P00-USA-027</comment>
<comment>WG3:W26-022R2</comment>
<para>A node <symdef>N</symdef> in a graph is of a node type <symdef>NT</symdef> (<ie/> is included
in <sym>NT</sym>) if the label set of <sym>N</sym> and the node type label set of <sym>NT</sym> are 
the same, the number of properties of <sym>N</sym> and the number of property types of <sym>NT</sym>
are the same, and every property of <sym>N</sym> is of a property type of <sym>NT</sym>.
</para>

<para>A node type is described by the node type descriptor.
The node type descriptor comprises:
</para>

<ulist>

<comment>WG3:UTC-049</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<item>The declared name of the primary base type of all node types (NODE DATA).
</item>

<comment>WG3:W26-022R2</comment>
<item>The preferred name of node types (<impDef code="ID090"/> choice of NODE or VERTEX).
</item>

<item>The set of zero or more labels (also known as a node type label set).
A label has a name that is an identifier that is unique within the node type label set.

<comment>WG3:OHD-015</comment>
<comment>WG3:W23-029R1</comment>
<para>The minimum cardinality of node type label sets is the <impDef code="IL001"/> minimum 
cardinality of node label sets.
</para>

<comment>WG3:OHD-015</comment>
<comment>WG3:W23-029R1</comment>
<para>The maximum cardinality of node type label sets is the <impDef code="IL001"/> maximum 
cardinality of node label sets.
</para>

</item>

<item>The set of zero or more property type descriptors (also known as a node type property 
type set).

<comment>WG3:OHD-015</comment>
<comment>WG3:W23-029R1</comment>
<para>The maximum cardinality of node type property type sets is the <impDef code="IL002"/> 
maximum cardinality of node property type sets.
</para>

</item>

</ulist>

<comment>WG3:CMN-019 P00-USA-027</comment>
<para>Two node type descriptors describe equal node types if they contain equal node type label 
sets and equal node type property type sets.
</para>

</bodyMatter>

</subClause3>


<subClause3 id="gql_conc_ot_edge">
<clauseHeading>Edge types</clauseHeading>

<bodyMatter>

<comment>WG3:W09-036 Editorial license</comment>
<para>An <newterm>edge type</newterm> is the data type of edges that have specific labels and
that have specific properties and whose properties have a specific property value type and
whose endpoints conform to specific node types.
</para>

<comment>Email from: Hannes Voigt, 2020-08-20 1539</comment>
<para>Each edge type comprises:
</para>

<ulist>

<comment>Email from: Hannes Voigt, 2020-08-20 1539</comment>
<item>An edge type label set that comprises a set of zero or more labels.
A label has a name that is an identifier that is unique within the edge type.
</item>

<comment>Email from: Hannes Voigt, 2020-08-20 1539</comment>
<comment>WG3:W26-022R2</comment>
<item>An edge type property type set that comprises a set of zero or more property types.

<comment>WG3:W26-022R2</comment>
<note>See <specref ref="gql_conc_property_types"/>.
</note>

</item>

<comment>WG3:W09-036 Editorial license</comment>
<item>Two (possibly identical) endpoint node types that are node types contained in the same 
graph type.
</item>

<comment>WG3:W27-013</comment>
<item>The indication of whether the edge type is a directed edge type or an undirected edge type
(which is also called the <newterm>directionality</newterm> of the edge type).

<comment>WG3:W09-036 Editorial license</comment>
<comment>WG3:W27-013</comment>
<para>Additionally, a directed edge type identifies one of its endpoint node types as its 
source node type, and the other as its destination node type.
The direction of a directed edge type is from its source node type to its destination node type.
</para>
<comment>WG3:CMN-026 Removed 1 (one) paragraph</comment>

</item>

</ulist>

<note>The names of edge type labels and of edge type property types are in separate namespaces.
That is, a label and a property type can have the same name in an edge type.
</note>

<comment>WG3:BER-040R3</comment>
<comment>WG3:W23-029R1</comment>
<comment>Editorial: Stephen Cannan 2022-11-13 Improve wording</comment>
<comment>WG3:W26-022R2</comment>
<para>A GQL-implementation is permitted to regard two <BNF name="edge type specification"/>s as 
equivalent, if they are either both directed or undirected, have the same endpoint node types,
edge type label sets and edge type property type sets, as permitted by
the Syntax Rules of <specref ref="gql_edge_type_defn"/>, <specref ref="gql_lbl_set_defn"/>, and 
<specref ref="gql_prop_type_set_defn"/>.
When two or more <BNF name="edge type specification"/>s are equivalent, the GQL-implementation 
chooses one of these equivalent <BNF name="edge type specification"/>s as the normal form 
representing that equivalence class of <BNF name="edge type specification"/>s. 
The normal form determines the preferred name of the edge type in data type descriptors.
</para>

<comment>WG3:W23-029R1</comment>
<comment>WG3:W25-031R2</comment>
<comment>WG3:CMN-019 P00-USA-028</comment>
<comment>WG3:W26-022R2</comment>
<para>An edge <symdef>E</symdef> in a graph is of an edge type <symdef>ET</symdef> (<ie/> is
included in <sym>ET</sym>) if the label set of <sym>E</sym> and
the edge type label set of <sym>ET</sym> are the same, the number of properties of <sym>E</sym> and
the number of property types of <sym>ET</sym> are the same, and every property of <sym>E</sym> is
of a property type of <sym>ET</sym>, and one of the following is true:
</para>

<ulist>

<comment>WG3:W26-022R2</comment>
<item><sym>E</sym> and <sym>ET</sym> are directed and
the source and destination endpoints of <sym>E</sym> are of 
the source and destination endpoint node types of <sym>ET</sym>, respectively.
</item>

<comment>WG3:W26-022R2</comment>
<item><sym>E</sym> and <sym>ET</sym> are undirected and the binary relation over <sym>E</sym> and 
<sym>ET</sym> that relates each endpoint in <sym>E</sym> to each of its endpoint node types
in <sym>ET</sym> is left-total and right-total.
</item>

</ulist>

<para>An edge type is described by the edge type descriptor.
The edge type descriptor comprises:
</para>

<ulist>

<comment>WG3:UTC-049</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<item>The declared name of the primary base type of all edge types (EDGE DATA).
</item>

<comment>WG3:W26-022R2</comment>
<item>The preferred name of edge types (<impDef code="ID091"/> choice of EDGE or RELATIONSHIP).
</item>

<item>The set of zero or more labels (also known as an edge type label set).
A label has a name that is an identifier that is unique within the edge type label set.

<comment>WG3:OHD-015</comment>
<comment>WG3:W23-029R1</comment>
<para>The minimum cardinality of edge type label sets is the <impDef code="IL001"/> minimum 
cardinality of edge label sets.
</para>

<comment>WG3:OHD-015</comment>
<comment>WG3:OHD-015</comment>
<para>The maximum cardinality of edge type label sets is the <impDef code="IL001"/> maximum 
cardinality of edge label sets.
</para>

</item>

<item>The set of zero or more property type descriptors (also known as an edge type property 
type set).


<comment>WG3:OHD-015</comment>
<comment>WG3:W23-029R1</comment>
<para>The maximum cardinality of edge type property type sets is the <impDef code="IL002"/>
maximum cardinality of edge property sets.
</para>

</item>

<item>The indication of whether the edge type is directed or undirected.
</item>

<item>Case:

<ulist>

<item>If the edge type is directed, then:

<ulist>

<comment>Editorial: Stephen Cannan, 2022-02-26 WG3:RKE-010 P00-USA-425</comment>
<item>The source node type descriptor.
</item>

<item>The destination node type descriptor.
</item>

</ulist>

</item>

<comment>Editorial: Stephen Cannan, 2022-03-07 WG3:RKE-010 P00-USA-426</comment>
<comment>WG3:W26-022R2</comment>
<item>If the edge type is undirected, then the set of one or two endpoint node type descriptors.

<comment>WG3:W26-022R2</comment>
<note>If the two endpoint node types of an undirected edge type are the same, then the set contains
only one endpoint node type descriptor; otherwise, it contains two endpoint node type descriptors.
</note>

</item>

</ulist>

</item>

</ulist>

<para>Two edge type descriptors describe equal edge types if they contain:
</para>

<ulist>

<comment>Email from: Hannes Voigt, 2020-08-20 1539</comment>
<item>Equal edge type label sets,
</item>

<comment>WG3:CMN-019 P00-USA-029</comment>
<item>Equal edge type property type sets,
</item>

<item>Equal indications whether they are directed or undirected, and
</item>

<item>Case:

<ulist>

<item>If the edge types are directed, then:

<ulist>

<item>Equal source node types and
</item>

<item>Equal destination node types.
</item>

</ulist>

</item>

<comment>Editorial: Stephen Cannan, 2022-03-07 WG3:RKE-010 P00-USA-426</comment>
<item>If the edge types are undirected, then equal sets of endpoint node types.

</item>

</ulist>

</item>

</ulist>

</bodyMatter>

</subClause3>


<comment>WG3:MMX-028R2</comment>
<subClause3 id="gql_conc_property_types">
<clauseHeading>Property types</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2021-04-29 Editorial</comment>
<para>A property type is a pair comprising:
</para>

<comment>WG3:W26-022R2</comment>
<ulist>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>WG3:W26-022R2</comment>
<item>A name, which is an identifier.
</item>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>WG3:W26-022R2</comment>
<comment>Email from: Hannes Voigt, 2023-11-14 1807</comment>
<item>A value type, which can be any supported property value type.

<note>See <specref ref="gql_conc_props_and_spvts"/>.
</note>

</item>

</ulist>

<comment>WG3:W26-022R2</comment>
<para>Two property types are equal if they have equal names and equal value types.
</para>

<comment>WG3:GYD-015</comment>
<para>A property <symdef>P</symdef> is of a property type <symdef>PT</symdef> if <sym>P</sym> 
and <sym>PT</sym> have equal names and the value of <sym>P</sym> is of the value type of 
<sym>PT</sym>.
</para>

<comment>Editorial: Stefan Plantikow, 2021-04-29 Editorial</comment>
<comment>WG3:W26-022R2</comment>
<para>Every property type is described by a property type descriptor that comprises:
</para>

<ulist>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>A name, which is an identifier.
</item>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>A value type, which can be any supported property value type.
</item>

</ulist>

</bodyMatter>

</subClause3>


<subClause3 id="gql_conc_key_label_sets">
<clauseHeading>Key label sets</clauseHeading>

<bodyMatter>

<comment>WG3:W26-022R2</comment>
<para>A key label set is a set of labels.
Key label sets are elements of a graph type.
An element type of a graph type may be associated with a key label set.
An element type that is associated with a key label set is said to be
a <newterm>keyed</newterm> element type.
The key label set that a keyed element type <symdef>KET</symdef> is associated with is said to be
the key label set of <sym>KET</sym>.
An element type that is not associated with a key label set is said to be
a <newterm>structural</newterm> element type.
</para>

<comment>WG3:W26-022R2</comment>
<para>Every keyed node type of a graph type is uniquely identified in the keyed node types
of its graph type by its key label set.
All keyed node types of a graph type appear in the node type key label set dictionary of
the graph type<apos/>s descriptor.
The node type key label set dictionary of a graph type maps each node type key label set to
the keyed node type associated with that key label set.
</para>

<comment>WG3:W26-022R2</comment>
<para>If two keyed edge types <symdef>KET</symdef> and <symdef>OKET</symdef> of
the same graph type have the same key label set, then it holds that <sym>KET</sym> and 
<sym>OKET</sym> have: 
</para>

<ulist>

<comment>WG3:W26-022R2</comment>
<item>Equal edge type label sets,
</item>

<comment>WG3:W26-022R2</comment>
<item>Equal edge type property type sets, and
</item>

<comment>WG3:W26-022R2</comment>
<item>Equal indications of whether they are directed or undirected.
</item>

</ulist>

<comment>WG3:W26-022R2</comment>
<para>All keyed edge types of a graph type appear in the edge type key label set dictionary of
the graph type<apos/>s descriptor.
The edge type key label set dictionary of a graph type maps each edge type key label set to
the set of keyed edge types that are associated with that key label set.
</para>

<comment>WG3:W26-022R2</comment>
<para>If <feature code="GG25"/> is not supported, then every keyed edge type of a graph type is
uniquely identified in the keyed edge types of its graph type by its key label set and
the edge type key label set dictionary of that graph type maps each edge type key label set to
the singleton set comprising the single keyed edge type associated with that key label set.
</para>

</bodyMatter>

</subClause3>


<subClause3 id="gql_conc_struct_consistency_elt_types">
<clauseHeading>Structural consistency of element types</clauseHeading>

<bodyMatter>

<comment>WG3:W26-022R2</comment>
<para>Graph types can only contain element types that are <newterm>structurally consistent</newterm>
with one another and also can only contain edge types that are 
<newterm>structurally endpoint-consistent</newterm> with one another.
</para>

<note>These consistency requirements guarantee that the element types of a graph type do not have
mutually conflicting definitions, as explained in the remainder of this Subclause.
</note>

<comment>WG3:W26-022R2</comment>
<para>Graph types adhere to the following two consistency criteria to ensure structural consistency
of element types and structural endpoint-consistency of edge types:
</para>

<ulist>

<comment>WG3:W26-022R2</comment>
<item><newterm>Key label set implication consistency</newterm>.
</item>

<comment>WG3:W26-022R2</comment>
<item><newterm>Property value type consistency</newterm>.
</item>

</ulist>

<comment>WG3:W26-022R2</comment>
<comment>WG3:GYD-016</comment>
<para>Both consistency criteria rely on the 
<newterm>graph-type specific combination of property value types</newterm> 
to ensure that certain property types of element types of a graph type that have the same name 
also either have the same value type or, if <feature code="GG26"/> is supported, have
value types that can be combined by an application of the Syntax Rules of
<specref ref="gql_gen_combo_vts"/> to obtain a supported property value type.
</para>

<comment>WG3:W26-022R2</comment>
<note>See  <specref ref="gql_gts_combo_vts"/>.
</note>

<comment>WG3:W26-022R2</comment>
<para>Key label set implication consistency considers element types that imply one another.
If the key label set of a keyed node type <symdef>SUPERNT</symdef> is a subset of the label set of
a node type <symdef>SUBNT</symdef>, then <sym>SUBNT</sym> implies <sym>SUPERNT</sym>.
If the key label set of a keyed edge type <symdef>SUPERET</symdef> is a subset of the label set of
an edge type <symdef>SUBET</symdef> and either <sym>SUBET</sym> is structural or the key label sets
of <sym>SUBET</sym> and <sym>SUPERET</sym> are different, then <sym>SUBET</sym> implies
<sym>SUPERET</sym>.
</para>

<comment>WG3:W26-022R2</comment>
<note>See <itemref type="SR" ref="gql_graph_type_SR_imply"/> of
<specref ref="gql_graph_type"/> for the corresponding definition of implication of
element type specifications.
</note>

<comment>WG3:W26-022R2</comment>
<para>If an element type <symdef>SUBELT</symdef> implies another element type
<symdef>SUPERELT</symdef>, then they are structurally consistent, <ie/>
</para>

<ulist>

<comment>WG3:W26-022R2</comment>
<item>Both are node types or both are edge types.
</item>

<comment>WG3:W26-022R2</comment>
<item>The label set of <sym>SUPERELT</sym> is a subset of the label set of <sym>SUBELT</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The set of names of property types of <sym>SUPERELT</sym> is a subset
of the set of names of property types of <sym>SUBELT</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The value type of each property type of <sym>SUPERELT</sym> combines to itself
with the value type of the corresponding property type of <sym>SUBELT</sym> with
the same name under graph-type specific combination of value types.
</item>

</ulist>

<comment>WG3:W26-022R2</comment>
<note>See <itemref type="SR" ref="gql_graph_type_SR_struct_consistent"/> of
<specref ref="gql_graph_type"/> for the corresponding definition of structurally consistent
<BNF name="node type specification"/>s and <BNF name="edge type specification"/>s.
</note>

<comment>WG3:W26-022R2</comment>
<para>If an edge type <symdef>SUBEDGT</symdef> implies another edge type <symdef>SUPEREDGT</symdef>,
then they are structurally endpoint-consistent, <ie/>
</para>

<ulist>

<comment>WG3:W26-022R2</comment>
<item>Both are directed and the endpoint node types of <sym>SUBEDGT</sym> are
structurally consistent with the respective endpoint node types of <sym>SUPEREDGT</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>Both are undirected and the binary relation over the endpoint node types of
<sym>SUBEDGT</sym> and <sym>SUPEREDGT</sym> that comprises all pairs of endpoint node types of
<sym>SUBEDGT</sym> and <sym>SUPEREDGT</sym> whose components are structurally consistent
is both left-total and right-total.
</item>

</ulist>

<comment>WG3:W26-022R2</comment>
<note>See <itemref type="SR" ref="gql_graph_type_SR_struct_ep_consistent"/> of
<specref ref="gql_graph_type"/> for the corresponding definition of structurally endpoint-consistent
<BNF name="edge type specification"/>s.
</note>

<comment>WG3:W26-022R2</comment>
<comment>Email from: Hannes Voigt, 2023-11-14 1807</comment>
<para>Property value type consistency considers element types of a graph type whose property types
share names.
Property value type consistency applies to all element types of a graph type
regardless of whether such element types are keyed or structural.
In a property value type consistent graph type <symdef>GT</symdef>, 
for every name <symdef>PN</symdef> of a property type of some element type of
<sym>GT</sym>, the result of the graph-type specific combination of all value types of 
property types whose name is <sym>PN</sym> of element types of <sym>GT</sym> is 
a supported property value type.
</para>

<comment>WG3:W26-022R2</comment>
<para>If <feature code="GG24"/> is not supported, then all graph types are property value type
consistent; otherwise, <feature code="GG24"/> is supported and it is possible that some graph types
are not property value type consistent.
</para>

</bodyMatter>

</subClause3>

</subClause2>


<subClause2 id="gql_conc_btt">
<clauseHeading>Binding table types</clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-05-04 Reworked</comment>
<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2021-04-29 Editorial</comment>
<comment>Editorial</comment>
<comment>Editorial: Stephen Cannan, 2022-03-27 WG3:RKE-010 P00-USA-427</comment>
<comment>WG3:BER-019</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<comment>WG3:CMN-057R1</comment>
<para>A binding table type is a GQL-object type that describes the records that can occur in 
a binding table that is of that binding table type. 
</para>

<para>Every binding table type is described by a binding table data type descriptor. 
A binding table data type descriptor comprises:
</para>

<ulist>

<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<item>The declared name of the primary base type of all binding table types (BINDING TABLE DATA).
</item>

<comment>WG3:BER-040R3</comment>
<item>The closed material record type.
</item>

</ulist>

<comment>WG3:UTC-086R1</comment>
<para>For every binding table type <symdef>BTT</symdef> with a record type <symdef>RT</symdef>, 
a binding table <symdef>BT</symdef> is of <sym>BTT</sym>, if and only if every record 
<symdef>R</symdef> contained in <sym>BT</sym> is of <sym>RT</sym>.
</para>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<para>In this document, a column is a field type of the record type of a binding table type, 
a column name is the name of a column, and a column type is the value type of a column. 
Hence, a column name identifies the fields of the same name of the records of a binding table.
</para>

<comment>WG3:BER-040R3</comment>
<comment>Editorial: Stephen Cannan 2022-11-13 Improve wording</comment>
<comment>WG3:UTC-086R1</comment>
<para>A GQL-implementation is permitted to regard two <BNF name="binding table type"/>s as 
equivalent, if they have the same record type and indication regarding the inclusion of the null 
value, as permitted by the Syntax Rules of <specref ref="gql_btt"/>.
When two or more <BNF name="binding table type"/>s are equivalent, the GQL-implementation chooses 
one of these equivalent <BNF name="binding table type"/>s as the normal form representing that 
equivalence class of <BNF name="binding table type"/>s.
</para>

<comment>WG3:UTC-086R1</comment>
<para>A <newterm>unit binding table type</newterm> is a binding table type whose record type is 
a unit record type. 
</para>

<comment>WG3:UTC-086R1</comment>
<para>The binding table type of an empty binding table is a unit binding table type unless
specified otherwise.
</para>

</bodyMatter>

</subClause2>


</subClause>


<comment>WG3:UTC-015</comment>
<subClause id="gql_conc_dyn_union_type">
<clauseHeading>Dynamic union types</clauseHeading>

<comment>WG3:CMN-057R1</comment>
<subClause2 id="gql_dyn_union_type_intro">
<clauseHeading>Introduction to dynamic union types and the dynamic base type</clauseHeading>

<bodyMatter>

<comment>WG3:CMN-057R1</comment>
<para>The <newterm>dynamic base type</newterm> is the base type whose declared name is ANY DATA 
and that comprises all value types (including all dynamic union types).
</para>

<comment>WG3:CMN-042</comment>
<para>A <newterm>dynamic union type</newterm> is a value type that comprises values of 
multiple data types. 
Therefore dynamic union types can be used to characterize sites capable of being occupied by 
material values of different static base types (<eg/> can hold both exact numbers and 
character strings). 
The primary base of all dynamic union types is the dynamic base type.
</para>

<para>The conditional application of a General Rule may depend on determining the static base
type or the most specific static value type of a value assigned to a site whose declared type is
a dynamic union type, <eg/> in order to ensure that certain assignments do not violate the
declared types of their target sites.
</para>

<note>Most <BNF name="value expression"/>s defined in this document are oblivious to the existence
of dynamic union types; only certain parts of this document related to, <eg/> comparison,
testing, casting, and store assignment, include additional provisions for correctly handling
dynamic union types. 
See <specref ref="gql_dyn_gen_type_cast"/> regarding the use of <BNF name="value expression"/>s 
with or without operands whose declared type is a dynamic union type.
</note>

</bodyMatter>

</subClause2>


<subClause2 id="gql_dyn_union_type_desc">
<clauseHeading>Dynamic union data type descriptors</clauseHeading>

<bodyMatter>

<para>Every dynamic union type is described by its dynamic union data type descriptor. 
A dynamic union data type descriptor comprises:
</para>

<ulist>

<comment>WG3:CMN-057R1</comment>
<item>The declared name of the primary base type of all dynamic union types (ANY DATA).
</item>

<comment>WG3:W25-025</comment>
<comment>WG3:CMN-057R1</comment>
<item>The preferred name of the dynamic union type.
</item>

<item>The indication of whether the type is open or closed.
</item>

<item>The component types, a finite set of two or more data types.

<comment>WG3:CMN-057R1</comment>
<note>It is possible that a syntactic transformation generates a <BNF name="dynamic union type"/>
that has only exactly one component type. 
However, such a <BNF name="dynamic union type"/> is always replaced by its normal form, <ie/> by 
the normal form of that component type. 
See <specref ref="gql_dyn_union_type_char"/>.
</note>

<comment>Email from: Hannes Voigt, 2024-12-06 0834</comment>
<ednote id="PPgql442_2">Disallowing <BNF name="component type list"/>s that specify only one type
should be considered.
See <PPref ref="PPgql442"/>.
</ednote>
</item>

<comment>WG3:W25-025</comment>
<item>The indication of whether the dynamic union type includes the null value.
</item>

</ulist>

</bodyMatter>

</subClause2>


<subClause2 id="gql_dyn_union_type_char">
<clauseHeading>Characteristics of dynamic union types</clauseHeading>

<bodyMatter>

<comment>WG3:CMN-057R1</comment>
<para>The open nullable dynamic union type is the dynamic union type that comprises all values. 
More generally, a dynamic union type <symdef>DUT</symdef> comprises all values included in at least 
one of the <newterm>component types</newterm> of <sym>DUT</sym>.
</para>

<para>The set of component types of the open dynamic union type is <impDef code="IV012"/> such
that for every static base type, at least one largest supertype of each of the base type<apos/>s
data types supported by the GQL-implementation is included. 
The set of component types of a closed dynamic union type is specified explicitly.
</para>

<para>The indication of whether a dynamic union type <symdef>DUT</symdef> includes the null value 
is defined as follows. 
If at least one of the component types of <sym>DUT</sym> is nullable, then the indication is 
<bool>True</bool>; otherwise, it is <bool>False</bool>.
</para>

<para>A GQL-implementation regards certain <BNF name="dynamic union type"/>s as equivalent, if 
they have the same component types and indications regarding the inclusion of the null value, as
permitted by <specref ref="gql_value_type"/>. 
When two or more <BNF name="dynamic union type"/>s are equivalent, the GQL-implementation chooses 
one of these equivalent <BNF name="dynamic union type"/>s as the normal form representing that 
equivalence class of <BNF name="dynamic union type"/>s.
</para>

<note>The normal form defined in <specref ref="gql_value_type"/>, ensures that effectively
every component type is a static value type and that every dynamic union type whose
component types are the same as the component types of the open dynamic union types are
considered equivalent to the open dynamic union type that has the same nullability
characteristic.
</note>

<para>Furthermore, a <BNF name="dynamic union type"/> whose component type list comprises a single 
static value type <symdef>SVT</symdef> is regarded as equivalent to the normal form of 
<sym>SVT</sym>.
</para>

<comment>WG3:CMN-057R1</comment>
<para>A value <symdef>V</symdef> is assignable to a site whose declared type is a dynamic union 
type <symdef>DUT</symdef> if and only if <sym>V</sym> is assignable to a component type of 
<sym>DUT</sym>. 
If store assignment of a value to a site of a dynamic union type is not possible without loss of 
information, then an exception condition may be raised.
</para>

<note>Every value can be assigned to a site whose declared type is the open dynamic union type.
</note>

</bodyMatter>

</subClause2>


<subClause2 id="gql_dyn_gen_type_cast">
<clauseHeading>Dynamic generation of type tests and casts</clauseHeading>

<subClause3 id="gql_dyn_gen_type_cast_intro">
<clauseHeading>Introduction to dynamic generation of type tests and casts for 
<BNF name="value expression"/>s</clauseHeading>

<bodyMatter>

<comment>WG3:CMN-057R1</comment>
<comment>Editorial: Stefan Plantikow, 2024-04-06 Improve wording</comment>
<para>This document primarily defines the GQL language using a static typing discipline. 
This may be extended through the use of dynamic union types, as defined in 
<specref ref="gql_conc_dyn_union_type"/>. 
However, most Syntax Rules stated in this document that enforce restrictions on the declared type 
of <BNF name="value expression"/>s do not particularly consider <BNF name="value expression"/>s 
<bar note="Editorial: Stefan Plantikow, 2024-04-06 Improve wording"/>
whose declared type is either a dynamic union type or a static open value type.
<endbar/>
</para>

<comment>Editorial: Stefan Plantikow 2023-03-06 </comment>
<comment>WG3:CMN-057R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-01 simulated => hypothetical application</comment>
<para>In order to support GQL-implementations that prefer the use of a dynamic typing discipline,
if a hypothetical application of all relevant Syntax Rules that are not Conformance Rules to
a given <BNF name="GQL-program"/> <symdef>PROGRAM</symdef> of a GQL-request would fail with
a syntax error caused by an unmet requirement on the declared type of an expression being of
a dynamic type or an open value type, then instead the GQL-implementation may
execute a cured variant of <sym>PROGRAM</sym> obtained by the following syntactic transformations.
</para>

<ulist>

<item>Dynamic generation of type tests and strict casts for a <BNF name="value expression"/> 
without operands.
</item>

<item>Dynamic generation of type tests and strict casts for a <BNF name="value expression"/> 
with operands.
</item>

<item>Dynamic generation of additional type tests and lax casts for 
a <BNF name="value expression"/>.
</item>

</ulist>

</bodyMatter>

</subClause3>


<subClause3 id="gql_dyn_gen_type_cast_without">
<clauseHeading>Dynamic generation of type tests and strict casts for 
a <BNF name="value expression"/> without operands</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow 2023-03-06 </comment>
<comment>WG3:CMN-057R1</comment>
<comment>Editorial: Stefan Plantikow, 2024-04-06 Improve wording</comment>
<para>Let <symdef>PROGRAM</symdef> be the <BNF name="GQL-program"/> and let <symdef>VE</symdef> be 
a <BNF name="value expression"/> contained in <sym>PROGRAM</sym> that has no operands and whose
<bar note="Editorial: Stefan Plantikow, 2024-04-06 Improve wording"/>
declared type <symdef>DOT</symdef> is either a dynamic union type or a static open value type.
<endbar/>
</para>

<comment>Editorial: Stefan Plantikow 2023-03-06 </comment>
<comment>Editorial: Stefan Plantikow, 2023-11-01 simulated => hypothetical application</comment>
<para>If a hypothetical application of all relevant Syntax Rules to <sym>PROGRAM</sym> would fail
due to <sym>DOT</sym> not meeting the requirements of the syntactic context of <sym>VE</sym>, then
<sym>PROGRAM</sym> may be cured by replacing <sym>VE</sym> as follows.
</para>

<olist>

<item>Let <symdef>CANDTYPES</symdef> be the set of static value types that meet the requirements of
the syntactic context of <sym>VE</sym> on <sym>DOT</sym>.
</item>

<comment>WG3:UTC-015</comment>
<item>The <applySC ref="gql_svt_prec" rules="SR">
<symarg param="NDTSET"><sym>CANDTYPES</sym></symarg>
<symresult param="NDTLIST"><symdef>VETYPES</symdef></symresult>
</applySC>.
</item>

<comment>WG3:CMN-057R1</comment>
<item>Let <symdef>ARMTYPES</symdef> be the subsequence of <sym>VETYPES</sym> that contains every 
type <symdef>VT</symdef> from <sym>VETYPES</sym> such that:

<olist>

<item><sym>VT</sym> is a subtype of <sym>DOT</sym>.
</item>

<comment>WG3:CMN-057R1</comment>
<item>The following shall be valid according to the Syntax Rules of 
<specref ref="gql_cast_spec"/>:
<code>
CAST ( <sym>VE</sym> <kw>AS</kw> <sym>VT</sym> )
</code>
</item>

</olist>

</item>

<item>Let <symdef>N</symdef> be the number of elements of <sym>ARMTYPES</sym>.
</item>

<comment>WG3:CMN-057R1</comment>
<comment>WG3:W26-037R3</comment>
<item>Let <symdef>VAR</symdef> be a new system-generated regular identifier.

<comment>WG3:W26-037R3</comment>
<note>See <itemref ref="gql_token_sys_gen_id" type="SR"/> of <specref ref="gql_token"/> for 
detailed provisions regarding the construction of system-generated regular identifiers.
</note>

</item>

<item>For each <sym>i</sym>-th <symdef>ARMTYPE</symdef><sub><sym>i</sym></sub> in 
<sym>ARMTYPES</sym>, 1 (one) <leq/> <symdef>i</symdef> <leq/> <sym>N</sym>, 
let <symdef>VE</symdef><sub><sym>i</sym></sub> be:
<code>
<kw>CAST</kw> ( <sym>VAR</sym> <kw>AS</kw> <sym>ARMTYPE</sym><sub><sym>i</sym></sub> )
</code>
</item>

<comment>WG3:GYD-010</comment>
<item>Let <symdef>ERROR</symdef> be an <unDef code="UV003"/> <BNF name="value expression"/> whose
evaluation raises the exception condition: <raise class="22" subclass="G03"/>.
</item>

<item>If <sym>N</sym> is zero, <sym>VE</sym> is replaced by <sym>ERROR</sym>; 
otherwise, it is replaced by:

<code>
<kw>LET</kw> <symdef>VAR</symdef>=<sym>VE</sym> IN
  <kw>CASE</kw> <sym>VAR</sym>
    <kw>WHEN</kw> <kw>IS</kw> <kw>TYPED</kw> <sym>ARMTYPE</sym><sub>1</sub> <kw>THEN</kw> <sym>VE</sym><sub>1</sub>
    <kw>WHEN</kw> <kw>IS</kw> <kw>TYPED</kw> <sym>ARMTYPE</sym><sub>2</sub> <kw>THEN</kw> <sym>VE</sym><sub>2</sub>
    <ellipsis/>
    <kw>WHEN</kw> <kw>IS</kw> <kw>TYPED</kw> <sym>ARMTYPE</sym><sub><sym>N</sym></sub> THEN <sym>VE</sym><sub><sym>N</sym></sub>
    <kw>ELSE</kw> <sym>ERROR</sym>
  END
END
</code>
</item>

</olist>

<note><specref ref="gql_dyn_gen_type_cast_add"/>, specifies additional provisions that allow 
a GQL-implementation to further amend the <BNF name="case expression"/> generated above.
</note>

</bodyMatter>

</subClause3>


<subClause3 id="gql_dyn_gen_type_cast_with">
<clauseHeading>Dynamic generation of type tests and strict casts for 
a <BNF name="value expression"/> with operands</clauseHeading>

<bodyMatter>

<comment>WG3:CMN-057R1</comment>
<para>Let <symdef>PROGRAM</symdef> be the <BNF name="GQL-program"/> and let <symdef>VE</symdef> be 
a <BNF name="value expression"/> contained in <sym>PROGRAM</sym> that has <symdef>NOPS</symdef> 
operands 
<symdef>OP</symdef><sub>1</sub>, <ellipsis/>, <symdef>OP</symdef><sub><sym>NOPS</sym></sub> 
whose respective declared types are 
<symdef>DOPT</symdef><sub>1</sub>, <ellipsis/>, <symdef>DOPT</symdef><sub><sym>NOPS</sym></sub>.
</para>

<comment>Editorial: Stefan Plantikow 2023-03-06 </comment>
<comment>Editorial: Stefan Plantikow, 2023-11-01 simulated => hypothetical application</comment>
<bar note="Editorial: Stefan Plantikow, 2024-04-06 Improve wording"/>
<comment>Editorial: Stefan Plantikow, 2024-04-06 Improve wording</comment>
<para>If a hypothetical application of all relevant Syntax Rules to <sym>PROGRAM</sym> would fail
due to at least one of the declared types of operands of <sym>VE</sym> that is a dynamic union type
or a static open value type being ill-typed, <ie/> not meeting the requirements of
the syntactic context of its respective operand, then <sym>PROGRAM</sym> may be cured by replacing
<sym>VE</sym> as follows.
</para>
<endbar/>

<olist>

<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NOPS</sym>, 
let <symdef>OPTYPES</symdef><sub><sym>i</sym></sub> be determined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>OP</sym><sub><sym>i</sym></sub> is one of the ill-typed operands, then:

<olist>

<comment>WG3:CMN-057R1</comment>
<item>Let <symdef>CANDTYPES</symdef><sub><sym>i</sym></sub> be the set of value types that 
meet the requirements of the syntactic context of <sym>OP</sym><sub><sym>i</sym></sub>.
</item>

<item>The <applySC ref="gql_svt_prec" rules="SR">
<symarg param="NDTSET"><sym>CANDTYPES</sym><sub><sym>i</sym></sub></symarg>
<symresult param="NDTLIST"><symdef>OPTYPES</symdef><sub><sym>i</sym></sub></symresult>
</applySC>.
</item>

</olist>

</item>

<item>Otherwise, let <symdef>OPTYPES</symdef><sub><sym>i</sym></sub> be a list containing the 
null value.
</item>

</olist>

</item>

<comment>WG3:CMN-057R1</comment>
<comment>WG3:W26-037R3</comment>
<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NOPS</sym>, 
let <symdef>VAR</symdef><sub><sym>i</sym></sub> be a new system-generated regular identifier that 
is not contained in <sym>PROGRAM</sym> and not used for naming a catalog object in the GQL-catalog 
and for all 
<symdef>j</symdef>, 1 (one) <leq/> <sym>i</sym> &lt; <sym>j</sym> <leq/> <sym>NOPS</sym>, 
<sym>VAR</sym><sub><sym>i</sym></sub> and <sym>VAR</sym><sub><sym>j</sym></sub> are not equivalent.

<note>See <itemref ref="gql_token_sys_gen_id" type="SR"/> of <specref ref="gql_token"/> for 
detailed provisions regarding the construction of system-generated regular identifiers.
</note>

</item>

<comment>WG3:CMN-057R1</comment>
<item>Let <symdef>COMBOS</symdef> be the ordered cross product 
<sym>OPTYPES</sym><sub><sym>i</sym></sub> <crossProd/> <ellipsis/> <crossProd/> 
<sym>OPTYPES</sym><sub><sym>NOPS</sym></sub>, <ie/> a list of lists of length <sym>NOPS</sym> such 
that <sym>COMBOS</sym> is lexicographically ordered left-to-right as determined by its operands 
understood as defining the ordered alphabet of symbols at each respective position.
Let <symdef>NCOMBOS</symdef> be the cardinality of <sym>COMBOS</sym>.
</item>

<comment>Editorial: Stefan Plantikow 2023-03-06 </comment>
<item>Let <symdef>ARMLIST</symdef> be the list of <BNF name="simple case"/>s that are determined as 
follows.

<para>Case:
</para>

<olist>

<comment>WG3:CMN-057R1</comment>
<item>Initially, <sym>ARMLIST</sym> is the zero-length character string.
</item>

<item>For <symdef>j</symdef>, 1 (one) <leq/> <sym>j</sym> <leq/> <sym>NCOMBOS</sym>, and 
for <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NOPS</sym>, 
let <symdef>COMBOTYPE</symdef><sub><sym>j</sym>, <sym>i</sym></sub> be the <sym>i</sym>-th list 
element of the <sym>j</sym>-th combination of <sym>COMBOS</sym>.
</item>

<item>For <symdef>j</symdef>, 1 (one) <leq/> <sym>j</sym> <leq/> <sym>NCOMBOS</sym>:

<olist>

<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NOPS</sym>, 
let <symdef>COND</symdef><sub><sym>i</sym></sub> and <sym>COP</sym><sub><sym>i</sym></sub> be 
defined as follows:

<olist>

<item>Let <symdef>COPTYPE</symdef> be <sym>COMBOTYPE</sym><sub><sym>j</sym>, <sym>i</sym></sub>.
</item>

<comment>WG3:CMN-019 P00-USA-032</comment>
<item>Let <symdef>COND</symdef><sub><sym>i</sym></sub> be defined as follows. 
If <sym>COPTYPE</sym> is the null value, then <sym>COND</sym><sub><sym>i</sym></sub> is 
<kw>TRUE</kw>; otherwise, <sym>COND</sym><sub><sym>i</sym></sub> is:
<code>
( <sym>VAR</sym><sub><sym>i</sym></sub> <kw>IS</kw> <sym>COPTYPE</sym> )
</code>
</item>

<item>Let <symdef>COP</symdef><sub><sym>i</sym></sub> be defined as follows. 
If <sym>COPTYPE</sym> is the null value, then <sym>COP</sym><sub><sym>i</sym></sub> is
<sym>VAR</sym><sub><sym>i</sym></sub>; otherwise, <sym>VAR</sym><sub><sym>i</sym></sub> is

<code>
<kw>CAST</kw> ( <sym>VAR</sym><sub><sym>i</sym></sub> <kw>AS</kw> <sym>COPTYPE</sym> )
</code>

</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-NLD-050</comment>
<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NOPS</sym>, 
let <symdef>COND</symdef> be the <kw>AND</kw>-concatenation of all 
<sym>COND</sym><sub><sym>i</sym></sub>:

<code>
<sym>COND</sym><sub>1</sub> <kw>AND</kw> <sym>COND</sym><sub>2</sub> <ellipsis/> <kw>AND</kw> <sym>COND</sym><sub><sym>NOPS</sym></sub>
</code>

</item>

<comment>WG3:CMN-019 P00-NLD-050</comment>
<comment>WG3:CMN-057R1</comment>
<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NOPS</sym>, 
let <symdef>NVE</symdef> be <sym>VE</sym> with every <sym>OP</sym><sub><sym>i</sym></sub> replaced 
by <sym>COP</sym><sub><sym>i</sym></sub>.
</item>

<comment>WG3:CMN-057R1</comment>
<item>Let <symdef>ARM</symdef> be:

<code>
<kw>WHEN</kw> <sym>COND</sym> <kw>THEN</kw> <sym>NVE</sym>
</code>

</item>

<comment>Editorial: Stefan Plantikow 2023-03-06 </comment>
<comment>WG3:CMN-057R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-01 simulated => hypothetical application</comment>
<item>If a hypothetical application of the Syntax Rules of <sym>NVE</sym> in
the same syntactic context as <sym>VE</sym> would succeed, then <sym>ARM</sym> is appended to
<sym>ARMLIST</sym>.

<note>This verifies the validity of the generated <BNF name="value expression"/>.
</note>
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:GYD-010</comment>
<item>Let <symdef>ERROR</symdef> be an <unDef code="UV003"/> <BNF name="value expression"/> whose
evaluation raises the exception condition: <raise class="22" subclass="G03"/>.
</item>

<comment>WG3:CMN-057R1</comment>
<item>If <sym>ARMLIST</sym> is the zero-length character string, then <sym>VE</sym> is replaced by 
<sym>ERROR</sym>; otherwise, it is replaced by:

<code>
<kw>LET</kw> <sym>VAR</sym><sub>1</sub>=<sym>OP</sym><sub>1</sub>, <ellipsis/>, <sym>VAR</sym><sub><sym>NOPS</sym></sub>=<sym>OP</sym><sub><sym>NOPS</sym></sub> <kw>IN</kw>
  <kw>CASE</kw>
    <sym>ARMLIST</sym>
    <kw>ELSE</kw> <sym>ERROR</sym>
  <kw>END</kw>
<kw>END</kw></code>
</item>

</olist>

<note><specref ref="gql_dyn_gen_type_cast_add"/>, specifies additional provisions that allow 
a GQL-implementation to further amend the <BNF name="case expression"/> generated above.
</note>

</bodyMatter>

</subClause3>


<subClause3 id="gql_dyn_gen_type_cast_add">
<clauseHeading>Dynamic generation of additional type tests and lax casts for 
a <BNF name="value expression"/></clauseHeading>

<bodyMatter>

<para>The provisions regarding the dynamic generation of type tests and casts for 
a <BNF name="value expression"/> with or without operand only generate strict casts, 
<ie/> casts to one of the value types of its argument value.
</para>

<comment>WG3:CMN-057R1</comment>
<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<comment>Editorial: Stephen Cannan. 2024-04-13 replace symbol</comment>
<para>A GQL-implementation may also generate lax casts, <ie/> casts from 
a <BNF name="value expression"/> <symdef>VE</symdef> contained in a <BNF name="GQL-program"/> to 
a value type <symdef>VT</symdef> that is not including the result of <sym>VE</sym>
as long as <mono><kw>CAST</kw>(<sym>VE</sym> AS <sym>VT</sym>)</mono> is valid according to the 
Syntax Rules of <specref ref="gql_cast_spec"/>. 
The exact manner in which lax casts (and supporting type tests) are generated and included in the 
syntax transforms for the dynamic generation of strict casts is <impDef code="IW018"/>.
</para>

</bodyMatter>

</subClause3>

</subClause2>

</subClause>


<comment>WG3:W23-037</comment>
<subClause id="gql_conc_constr">
<clauseHeading>Constructed value types</clauseHeading>
<comment>WG3:W23-013 One editor's note removed</comment>

<comment>WG3:CMN-057R1</comment>
<subClause2 id="gql_conc_constr_intro">
<clauseHeading>Introduction to constructed value types and related base types</clauseHeading>

<bodyMatter>

<comment>WG3:BER-094R1</comment>
<comment>WG3:W22-036</comment>
<comment>WG3:W24-026R2</comment>
<comment>Editorial: Stefan Plantikow, 2023-03-06 Adjust order</comment>
<comment>WG3:CMN-057R1</comment>
<para>The GQL language defines the following kinds of constructed value types: path value types,
list value types, and record types.
</para>

<comment>WG3:CMN-057R1</comment>
<para>The declared names of static base types of constructed value types defined in this document
are:
</para>

<comment>WG3:CMN-057R1</comment>
<ulist>

<comment>WG3:W27-013</comment>
<item>PATH VALUE DATA, which specifies the <newterm>path value type base type</newterm>. 
The path value type base type is the base type that comprises all path value types.
</item>

<comment>WG3:W27-013</comment>
<item>LIST VALUE DATA, which specifies the <newterm>list value type base type</newterm>. 
The list value type base type is the base type that comprises all list value types.
</item>

<item>RECORD DATA, which specifies the <newterm>record type base type</newterm>. 
The record type base type is the base type that comprises all record types.
</item>

</ulist>

<para>For reference purposes:
</para>

<ulist>

<item>The value types specified with the leading keyword <kw>PATH</kw> are referred to as 
<newterm>path value types</newterm> and the values of path value types are referred to as 
<newterm>path values</newterm>. 
The primary base type of all path value types is the path value type base type.
</item>

<item>The value types specified with the leading keywords <kw>LIST</kw> or <kw>ARRAY</kw> are 
referred to as <newterm>list value types</newterm> and the values of list value types are referred 
to as <newterm>list values</newterm>. 
The value types specified with the leading keywords <kw>GROUP</kw> <kw>LIST</kw> or 
<kw>GROUP</kw> <kw>ARRAY</kw> are referred to as <newterm>group list value types</newterm> and 
their values are referred to as <newterm>group list values</newterm>. 
All other list value types are referred to as <newterm>regular list value types</newterm> and
their values are referred to as <newterm>regular list values</newterm>. 
The primary base type of all list value types is the list value type base type.
</item>

<item>The value types specified with the leading keyword <kw>RECORD</kw> are referred to as 
<newterm>record types</newterm> and the values of record types are referred to as 
<newterm>records</newterm>. 
The primary base type of all record types is the record type base type.
</item>

</ulist>

</bodyMatter>

</subClause2>


<comment>WG3:W24-035R1</comment>
<subClause2 id="gql_conc_path">
<clauseHeading>Path value types</clauseHeading>

<bodyMatter>

<comment>WG3:UTC-080</comment>
<comment>WG3:CMN-057R1</comment>
<para>A material value of a path value type is a path value. 
A path value <symdef>PV</symdef> encapsulates a graph element reference value list value that is 
called the <newterm>path element list</newterm> of <sym>PV</sym>. 
In this document, a <newterm>single-node path value</newterm> is a path value whose path element 
list comprises a single node reference value.
</para>

<comment>Editorial: Stefan Plantikow, 2023-11-28 Correct to match concepts</comment>
<note>A single-node path value is frequently called an <quote>empty path</quote>; the latter term 
has been avoided because of possible confusion of its underlying path element list with an empty
list value, which has no elements (neither node reference values nor edge reference values).
</note>

<comment>WG3:CMN-057R1</comment>
<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<para>If the sequence comprising the nodes and edges referenced by the elements of a graph
element reference value list value in the order in which they appear in the sequence is a path
(in the sense of <specref ref="gql_conc_graph_patt_match_paths"/>), then the sequence is said to 
<newterm>identify a path</newterm>. 
For every path value <symdef>PV</symdef> constructed in this document it holds that if the 
path element list <symdef>PEL</symdef> of <sym>PV</sym> excludes invalidated graph element 
reference values, then <sym>PEL</sym> always identifies a path.
</para>

<para>Every path value type <symdef>PVT</symdef> is described by a path value data type 
descriptor. 
A path value data type descriptor comprises:
</para>

<ulist>

<comment>WG3:CMN-057R1</comment>
<comment>WG3:W27-013</comment>
<item>The declared name of the primary base type of all path value types (PATH VALUE DATA).
</item>

<item>The indication of whether the type contains the null value.
</item>

</ulist>

<comment>Editorial; Jim Melton, 2023-09-04; fix which/that problems</comment>
<comment>Editorial: Stefan Plantikow, 2023-10-29 Added missing path prefix</comment>
<para>The cardinality of a path value <symdef>PV</symdef> of <sym>PVT</sym> is
the cardinality of its path element list <symdef>PEL</symdef>, which is always less than or
equal to the  <impDef code="IL015"/> maximum cardinality of path element lists of path value types. 
Furthermore, the length of <sym>PV</sym> is defined as follows:
If <sym>PEL</sym> contains at least one node reference value, then the length of <sym>PV</sym> is 
the number of elements of <sym>PEL</sym> that are edge reference values; otherwise, the length of 
<sym>PV</sym> is the null value.
</para>

<comment>WG3:W25-031R2</comment>
<comment>WG3:CMN-057R1</comment>
<para>A path value <symdef>P</symdef> is assignable to a site of at least the material path value 
type.
</para>

<comment>WG3:W26-024</comment>
<para>Any two path values are essentially comparable values.
</para>

</bodyMatter>

</subClause2>


<comment>WG3:W24-026R2</comment>
<subClause2 id="gql_conc_lists">
<clauseHeading>List value types</clauseHeading>

<bodyMatter>

<comment>WG3:CMN-019 P00-USA-207</comment>
<comment>WG3:CMN-068</comment>
<para>A material value of a <newterm>list value type</newterm> is a <newterm>list value</newterm>. 
A list value <symdef>L</symdef> is an ordered collection of elements, in which each element is 
associated with exactly one ordinal position in <sym>L</sym>. 
Further, the <newterm>position offset</newterm> of an element of <sym>L</sym> at ordinal position 
<symdef>p</symdef> is <sym>p</sym>&minus;1.
If <symdef>N</symdef> is the cardinality of <sym>L</sym>, then the ordinal position
<symdef>p</symdef> of an element is a positive integer in the range 
1 (one) <leq/> <sym>p</sym> <leq/> <sym>N</sym> and the position offset <symdef>o</symdef> of 
an element is a non-negative integer in the range 0 (zero) <leq/> <sym>o</sym> &lt; <sym>N</sym>.
</para>

<para>Every list value type is described by a list value data type descriptor. 
A list value data type descriptor comprises:
</para>

<ulist>

<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<comment>WG3:W27-013</comment>
<item>The declared name of the primary base type of all list value types (LIST VALUE DATA).
</item>

<comment>Editorial: Stefan Plantikow, 2023-02-23 Changed order of items</comment>
<item>The preferred name of the specific list value type, which is the declared name of the 
normal form of the list value type.
</item>

<comment>WG3:POS-012</comment>
<item>The <newterm>list element type</newterm> of the list value type.
</item>

<comment>WG3:UTC-123R2</comment>
<item>The indication of whether the type is a <newterm>group list value type</newterm> or
a <newterm>regular list value type</newterm>.
A group list value type is a list value type whose values are known to directly or
indirectly originate from an element variable that has group degree of reference,
as detailed in <specref ref="gql_graph_patt_var_ref"/>.
A regular list value type is a list type that is not a group list value type.
</item>

<comment>Editorial: Stefan Plantikow, 2023-02-23 Changed order of items</comment>
<item>The maximum cardinality of the list value type.
</item>

<item>The indication of whether the type contains the null value.
</item>

</ulist>

<comment>WG3:UTC-123R2</comment>
<comment>WG3:CMN-057R1</comment>
<para>If a list value type is a group list value type, then its list element type is either
a node reference value type, an edge reference value type, or a closed dynamic union type whose 
component types comprise either only node reference value types or only edge reference value types.
</para>

<comment>WG3:UTC-123R2</comment>
<comment>Email from: Jeffrey Lovitz, 2023-03-02 1726 WG3 UTC:127R2</comment>
<para>For a list value type <symdef>LVT</symdef>, the indication of whether <sym>LVT</sym> is
a group list value type or a regular list value type is also referred to as 
the <newterm>group characteristic</newterm> of <sym>LVT</sym>.
The <newterm>regular variant</newterm> of a group list value type <symdef>GLVT</symdef> is
a regular list value type that has the same characteristics as <sym>GLVT</sym> except for
the group characteristic.
</para>

<para>The maximum cardinality of a list value type is a positive integer and the maximum
cardinality of a list value type with list element type <symdef>LET</symdef> is less than or equal
to the <impDef code="IL015"/> maximum cardinality for list value types whose list element type is 
<sym>LET</sym>.
</para>

<para>For every list value type <symdef>LT</symdef>, a list value <symdef>L</symdef> is 
a material value of <sym>LT</sym>, if and only if the cardinality of <sym>L</sym> does not exceed 
the maximum cardinality of <sym>LT</sym> and every element of <sym>L</sym> is of the list element 
type of <sym>LT</sym>.
</para>

<para>A GQL-implementation is permitted to regard certain <BNF name="list value type"/>s as 
equivalent, if both have the same list element type and the same indication regarding the inclusion
of the null value, as permitted by the Syntax Rules of <specref ref="gql_value_type"/>. 
When two or more <BNF name="list value type"/>s are equivalent, the GQL-implementation chooses one
of these equivalent <BNF name="list value type"/>s as the normal form representing that equivalence
class of <BNF name="list value type"/>s.
</para>

<comment>WG3:W25-031R2</comment>
<comment>WG3:CMN-057R1</comment>
<para>A list value <symdef>L</symdef> whose declared type <symdef>DT</symdef> is assignable to 
every site that is at least of some material list value type <symdef>LVT</symdef> for which it 
holds that the cardinality of <sym>L</sym> does not exceed the maximum cardinality of 
<sym>LVT</sym>, the list element type of <sym>DT</sym> is assignable to the list element type of 
<sym>LVT</sym>, and if <sym>DT</sym> is a group list value type, then <sym>LVT</sym> is
a group list value type.
</para>

<comment>WG3:W26-024</comment>
<para>Two list values are essentially comparable values if and only if their elements are
essentially comparable values.
</para>

<para>In this document, an <newterm>empty list value</newterm> is a list value of cardinality zero.
</para>

</bodyMatter>

</subClause2>


<subClause2 id="gql_conc_record">
<clauseHeading>Record types</clauseHeading>

<bodyMatter>

<comment>Editorial: Stephen Cannan, 2022-02-26 WG3:RKE-010 P00-USA-434</comment>
<comment>WG3:BER-019</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:W23-009R1 P00-USA-268</comment>
<comment>WG3:UTC-086R1</comment>
<comment>WG3:W26-037R3</comment>
<comment>Editorial: Stefan Plantikow 2023-11-15 Wording</comment>
<para>A material value of a record type is a record.
A record is a set of fields, each such field has a name, which is a character string, and 
a value. 
The names of fields of records that are specified by <BNF name="identifier"/>s are 
the canonical name forms of those <BNF name="identifier"/>s.
The record with zero fields is called the <symdef>unit record</symdef>.
</para>

<comment>WG3:BER-019</comment>
<para>Every record type is described by a record data type descriptor. 
A record data type descriptor comprises:
</para>

<ulist>

<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<item>The declared name of the primary base type of all record types (RECORD DATA).
</item>

<comment>WG3:BER-040R3</comment>
<comment>WG3:W24-026R2</comment>
<item>The indication of whether the type is closed or open.
</item>

<comment>WG3:BER-040R3</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>If the record type is closed, then a (possibly empty) set of field types. 
Each field type is a pair comprising a name, which is an identifier, and a value type.
The name of each field type is unique within the record type.
</item>

<item>The indication of whether the type contains the null value.
</item>

</ulist>

<comment>WG3:W24-026R2</comment>
<comment>WG3:UTC-086R1</comment>
<comment>WG3:W26-037R3</comment>
<para>The cardinality of a record is the cardinality of the set of fields of the record. 
The cardinality of a closed record type is the cardinality of the set of field types of the 
record type.
The cardinality of a record type shall be less than or equal to the <impDef code="IL015"/> 
maximum number of record fields.
</para>

<comment>WG3:W26-022R2 Consequence</comment>
<para>Every field type of a record type is described by a field type descriptor that comprises:
</para>

<ulist>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>WG3:W26-022R2 Consequence</comment>
<item>A name, which is an identifier.
</item>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>WG3:W26-022R2 Consequence</comment>
<item>A value type.
</item>

</ulist>

<comment>WG3:W26-037R3 Consequence</comment>
<para>The names of field types of record types that are specified by 
<BNF name="identifier"/>s are the canonical name forms of those <BNF name="identifier"/>s.
</para>

<comment>WG3:BER-040R3</comment>
<comment>WG3:W23-009R1 P00-USA-270</comment>
<comment>WG3:W24-026R2</comment>
<para>For every record type <symdef>RT</symdef>, a record <symdef>R</symdef> is a material value 
of <sym>RT</sym>, if and only if either <sym>RT</sym> is open or all the following conditions are 
true:
</para>

<ulist>

<item><sym>RT</sym> is closed.
</item>

<item><sym>R</sym> has the same number of fields as <sym>RT</sym> has field types.
</item>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>For every field type in <sym>RT</sym> with name <symdef>FN</symdef> and 
value type <symdef>FVT</symdef>, <sym>R</sym> has a field
whose name is <symdef>FN</symdef> and whose value is of <sym>FVT</sym>.
</item>

</ulist>

<comment>WG3:UTC-086R1</comment>
<para>A <newterm>unit record type</newterm> is a record type that has zero field types. 
The only material value of a unit record type is the unit record.
</para>

<comment>WG3:BER-040R3</comment>
<comment>WG3:W23-009R1 P00-USA-271</comment>
<comment>WG3:W24-026R2</comment>
<para>A GQL-implementation is permitted to regard two <BNF name="record type"/>s as 
equivalent, if they have the same indication regarding the inclusion of records with additional 
fields, set of field types, if present, and indication regarding the inclusion of the null value, 
as permitted by the Syntax Rules of <specref ref="gql_value_type"/>.
When two or more <BNF name="record type"/>s are equivalent, the GQL-implementation chooses one of 
these equivalent <BNF name="record type"/>s as the normal form representing that equivalence class 
of <BNF name="record type"/>s.
</para>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-057R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<comment>Editorial: Correct application of WG3:CMN-057R1</comment>
<para>Two records or record types <symdef>A</symdef> and <symdef>B</symdef> are called 
<newterm>field name-equal</newterm> if and only if there is a bijection that maps every name 
of <sym>A</sym> to an equal name of <sym>B</sym> and every name of <sym>B</sym> to 
an equal name of <sym>A</sym>.
Similarly, <sym>A</sym> and <sym>B</sym> are called <newterm>field name-disjoint</newterm> if and 
only if there are no field names
<symdef>F</symdef><sub><sym>A</sym></sub> of <sym>A</sym> and
<symdef>F</symdef><sub><sym>B</sym></sub> of <sym>B</sym> such that
<sym>F</sym><sub><sym>A</sym></sub> and <sym>F</sym><sub><sym>B</sym></sub> are equal. 
</para>

<comment>WG3:W26-024 Removed 2 paragraphs</comment>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-057R1</comment>
<para>Two closed record types <symdef>RT1</symdef> and <symdef>RT2</symdef> are 
<newterm>field type-combinable</newterm> if and only if all of the following hold:
</para>

<ulist>

<comment>WG3:W26-024</comment>
<item><sym>RT1</sym> and <sym>RT2</sym> are comparable value types.
</item>

<comment>Editorial: Stephen Cannan, 2023-09-01 Apply proper mark-up</comment>
<item>For every pair of field types <symdef>FT1</symdef> from <sym>RT1</sym> and 
<symdef>FT2</symdef> from <sym>RT2</sym> with equal names, 
the <applySC ref="gql_gen_combo_vts" rules="SR" type="asTrial">
<symarg param="DTSET">the set comprising the value types of <sym>FT1</sym> and 
<sym>FT2</sym></symarg>
<symresult param="RESTYPE"><symdef>DT</symdef></symresult>
</applySC>.
</item>

</ulist>

<comment>WG3:UTC-086R1</comment>
<para>The <newterm>combined field types</newterm> <symdef>CFT</symdef> of two field type-combinable
record types <symdef>RT1</symdef> and <symdef>RT2</symdef> are determined as follows.
</para>

<olist>

<item>Let <symdef>FTU</symdef> be the union of the field types of <sym>RT1</sym> and <sym>RT2</sym>.
</item>

<comment>WG3:CMN-043</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>For every non-empty subset of all field types <symdef>FTP</symdef> of <sym>FTU</sym>
whose names are equal:

<olist>

<item>Let <symdef>NAME</symdef> be the name of one of the field types in <sym>FTP</sym>.
</item>

<item>The <applySC ref="gql_gen_combo_vts" rules="SR">
<symarg param="DTSET"><sym>FTP</sym></symarg>
<symresult param="RESTYPE"><symdef>DT</symdef></symresult>
</applySC>.
</item>

<item>The field type with name <sym>NAME</sym> and value type <sym>DT</sym> is added to 
<sym>CFT</sym>.
</item>

</olist>

</item>

</olist>

<comment>WG3:W22-053R2</comment>
<comment>WG3:UTC-086R1</comment>
<para>Given two records <symdef>R1</symdef> and <symdef>R2</symdef>, the phrase 
<newterm>R1 amended with R2</newterm> or similar grammatical variants denotes a new record that 
comprises:
</para>

<ulist>

<comment>WG3:W22-053R2</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>Every field of <sym>R1</sym> whose name differs from the name of every field of <sym>R2</sym>.
</item>

<comment>WG3:W22-053R2</comment>
<item>Every field of <sym>R2</sym>.
</item>

</ulist>

<comment>WG3:UTC-086R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<note>The definition gives precedence to a field <symdef>F2</symdef> in <sym>R2</sym> over a field 
<symdef>F1</symdef> in <sym>R1</sym> if both fields have the same name. 
</note>

<comment>WG3:W22-053R2</comment>
<comment>WG3:W24-026R2</comment>
<comment>WG3:UTC-086R1</comment>
<para>Similarly, given two closed record types <symdef>RT1</symdef> and <symdef>RT2</symdef>, the 
phrase <sym>RT1</sym> <newterm>amended with</newterm> <sym>RT2</sym> or similar grammatical 
variants denotes a new record type <symdef>RT</symdef> that comprises:
</para>

<ulist>

<comment>Editorial: Stefan Plantikow, 2022-08-23 Remove unused symbol</comment>
<comment>WG3:W24-026R2</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>Every field type of <sym>RT1</sym> whose name differs from
the name of every  field type of <sym>RT2</sym>.
</item>

<item>Every field type of <sym>RT2</sym>.
</item>

</ulist>

<comment>WG3:W24-026R2</comment>
<comment>WG3:UTC-086R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<note>The definition gives precedence to a field type <symdef>FT2</symdef> in <sym>RT2</sym> over 
a field type <symdef>FT1</symdef> in <sym>RT1</sym> if both field types have the same name. 
</note>

<comment>WG3:UTC-086R1</comment>
<note>If <sym>R1</sym> and <sym>R2</sym> are records whose closed record types are 
<symdef>RT1</symdef> and <symdef>RT2</symdef>, respectively, then <sym>R1</sym> amended with 
<sym>R2</sym> is included in <sym>RT1</sym> amended with <sym>RT2</sym>.
</note>

<para>If <sym>RT1</sym> and <sym>RT2</sym> are material, then <sym>RT</sym> is material; 
otherwise, <sym>RT</sym> is nullable.
</para>

<comment>WG3:W22-053R2</comment>
<comment>Editorial: Stefan Plantikow, 2022-08-24 Reword phrasing to be more precise</comment>
<comment>WG3:UTC-086R1</comment>
<para>Let <symdef>R</symdef> be a record, let <symdef>RT</symdef> be a closed record type, and 
let <symdef>FS</symdef> be a set of (field) names. 
The phrase <sym>R</sym> <newterm>restricted to the fields identified by</newterm> <sym>FS</sym> or 
similar grammatical variants denotes a new record that comprises every field of <sym>R</sym> whose 
name is in <sym>FS</sym>.
By extension, the phrase <sym>RT</sym> <newterm>restricted to the fields identified by</newterm> 
<sym>FS</sym> or similar grammatical variants denotes a new record type that comprises every field 
type of <sym>RT</sym> whose name is in <sym>FS</sym>. 
If <sym>R</sym> is included in <sym>RT</sym>, then <sym>R</sym> is restricted to the fields 
identified by <sym>FS</sym> is included in <sym>RT</sym> restricted to the fields identified by
<sym>FS</sym>.
</para>

<comment>WG3:UTC-086R1</comment>
<para>Similarly, the phrase <sym>R</sym> <newterm>without the fields identified by</newterm> 
<sym>FS</sym> or similar grammatical variants denotes a new record that comprises every field of 
<sym>R</sym> whose name is not in <sym>FS</sym>.
By extension, the phrase <sym>RT</sym> <newterm>without the fields identified by</newterm> 
<sym>FS</sym> or similar grammatical variants denotes a new record type that comprises every field 
type of <sym>RT</sym> whose name is not in <sym>FS</sym>. 
If <sym>R</sym> is included in <sym>RT</sym>, then <sym>R</sym> without the fields identified by 
<sym>FS</sym> is included in <sym>RT</sym> without the fields identified by <sym>FS</sym>.
</para>

<comment>WG3:W26-024 Removed 3 paragraphs</comment>

<comment>WG3:W26-024</comment>
<para>Two records are essentially comparable values if and only if the two records are
field-name equal and their respective field values are essentially comparable values.
</para>

<comment>WG3:W25-031R2</comment>
<comment>WG3:CMN-057R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<para>A record <symdef>R</symdef> is assignable to a site that is at least of a some 
material record type <symdef>RT</symdef> for which it holds that either <sym>RT</sym> is open or 
it holds that the set of field names of <sym>R</sym> and
the set of field type names of <sym>RT</sym> are the same and
every field of <sym>R</sym> is assignable to the value type of
the field type with the same name of <sym>RT</sym>.
</para>

<comment>Editorial: Stefan Plantikow, 2020-05-04 One editorial note</comment>
</bodyMatter>

</subClause2>
<comment>Editorial: Stefan Plantikow, 2023-03-06 Moved 1 (one) Subclause</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-04 Tuple type</comment>
<comment>WG3:BER-019 Subclause deleted</comment>

</subClause>


<subClause id="gql_conc_vt_predef">
<clauseHeading>Predefined value types</clauseHeading>
<comment>WG3:UTC-117 Deleted 1 (one) editor's note</comment>


<comment>WG3:W12-029: Stefan Plantikow, 2021-06-17</comment>
<comment>WG3:W23-037</comment>
<comment>WG3:CMN-057R1</comment>
<subClause2 id="gql_conc_dt_predefined_names">
<clauseHeading>Introduction to predefined value types and related base types</clauseHeading>

<bodyMatter>

<comment>WG3:CMN-057R1</comment>
<comment>Editorial: Stefan Plantikow 2023-10-09 Use temporal types only</comment>
<comment>WG3:POS-011R1</comment>
<para>The GQL language defines the following kinds of predefined value types: 
<newterm>Boolean type</newterm>s, <newterm>character string type</newterm>s,
<newterm>byte string type</newterm>s, <newterm>numeric type</newterm>s, 
<newterm>temporal type</newterm>s, <newterm>vector types</newterm>,
and reference value types for references to binding tables, graphs, nodes, or edges.
</para>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-17</comment>
<comment>Editorial: Stephen Cannan, 2022-02-26 W20-010 P00-USA-140</comment>
<comment>WG3:RKE-048 Remove one sentence</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<comment>WG3:W26-026R2</comment>
<para>The declared names of static base types of predefined value types defined in this document 
are:
</para>
<ulist>

<comment>WG3:CMN-057R1</comment>
<item>BOOLEAN DATA, which specifies the <newterm>Boolean type base type</newterm>. 
The Boolean type base type is the base type that comprises all Boolean types.
</item>

<comment>WG3:CMN-057R1</comment>
<item>STRING DATA, which specifies the <newterm>character string type base type</newterm>. 
The character string type base type is the base type that comprises all character string types.
</item>

<comment>WG3:CMN-057R1</comment>
<item>BINARY DATA, which specifies the <newterm>byte string type base type</newterm>. 
The byte string type base type is the base type that comprises all byte string types.
</item>

<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<item>EXACT NUMERIC DATA, which specifies the <newterm>exact numeric type base type</newterm>. 
The exact numeric type base type is the base type that comprises all exact numeric types.
</item>

<comment>WG3:CMN-057R1</comment>
<item>FLOAT NUMERIC DATA, which specifies the <newterm>approximate numeric type base type</newterm>.
The approximate numeric type base type is the base type that comprises all approximate numeric 
types.
</item>

<comment>WG3:UTC-117</comment>
<item>TEMPORAL INSTANT DATA, which specifies the <newterm>temporal instant type base type</newterm>.
The temporal instant type base type is the base type that comprises all temporal instant types.
</item>

<comment>WG3:CMN-057R1</comment>
<item>TEMPORAL DURATION DATA, which specifies the 
<newterm>temporal duration type base type</newterm>. 
The temporal duration type base type is the base type that comprises all temporal duration types.
</item>

<comment>WG3:POS-011R1</comment>
<item>VECTOR DATA, which specifies the <newterm>vector base type</newterm>. 
The vector base type is the base type that comprises all vector types.
</item>
   
<comment>WG3:UTC-117</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<item>GRAPH REFERENCE, which specifies the <newterm>graph reference value type base type</newterm>.
The graph reference value type is the base type that comprises all graph reference value types.
</item>

<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<item>TABLE REFERENCE, which specifies the 
<newterm>binding table reference value type base type</newterm>. 
The binding table reference value type is the base type that comprises all binding table reference
value types.
</item>

<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<comment>WG3:W27-013</comment>
<item>The <impDef code="ID090"/> NODE REFERENCE or VERTEX REFERENCE, which specifies the 
<newterm>node reference value type base type</newterm>. 
The node reference value type is the base type that comprises all node reference value types. 
</item>

<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<comment>WG3:W27-013</comment>
<item>The <impDef code="ID091"/> EDGE REFERENCE or RELATIONSHIP REFERENCE, which specifies the 
<newterm>edge reference value type base type</newterm>. 
The edge reference value type is the base type that comprises all edge reference value types.
</item>

<comment>WG3:W26-026R2</comment>
<item>NULL DATA, which specifies the immaterial value type base type. 
The immaterial value type is the base type that comprises all immaterial value types.
</item>

</ulist>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-17</comment>
<para>For reference purposes:
</para>

<ulist>

<comment>Editorial: Stefan Plantikow, 2021-06-23 consistency with WG3:W12-029</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<item>The value types specified with the leading keyword <kw>BOOL</kw> and <kw>BOOLEAN</kw> are 
referred to as <newterm>Boolean types</newterm> and the values of Boolean types are referred to as
<newterm>truth values</newterm>, or, alternatively, as <newterm>Booleans</newterm>.
The primary base type of all Boolean types is the Boolean type base type.
</item>

<comment>WG3:CMN-057R1</comment>
<comment>WG3:W26-026R2</comment>
<item>The value types specified with the leading keyword <kw>STRING</kw>, <kw>CHAR</kw>, and 
<kw>VARCHAR</kw> are referred to as <newterm>character string types</newterm> and the values of 
character string types are referred to as <newterm>character strings</newterm>.
The primary base type of all character string types is the character string type base type.
</item>

<comment>WG3:CMN-057R1</comment>
<item>The value types specified with the leading keyword <kw>BYTES</kw>, <kw>BINARY</kw>, and 
<kw>VARBINARY</kw> are referred to as <newterm>byte string types</newterm> and the values of byte 
string types are referred to as <newterm>byte strings</newterm>.
The primary base type of all byte string types is the byte string type base type.
</item>

<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10</comment>
<item>Exact numeric types and approximate numeric types are collectively referred to as
<newterm>numeric types</newterm>.
Values of numeric types are referred to as <newterm>numbers</newterm>.
The signed exact numeric types and the unsigned exact numeric types are collectively referred
to as <newterm>exact numeric types</newterm>.
Values of exact numeric types are referred to as <newterm>exact numbers</newterm>.
The primary base type of all exact numeric types is the exact numeric type base type.
</item>

<comment>WG3:BER-067R1</comment>
<comment>WG3:CMN-057R1</comment>
<item>The value types specified with the leading keywords <kw>DECIMAL</kw>, <kw>DEC</kw>, 
<kw>SMALLINT</kw>, <kw>SMALL</kw> <kw>INTEGER</kw>, 
<kw>SIGNED</kw> <kw>SMALL</kw> <kw>INTEGER</kw>, <kw>INT</kw>,
<kw>INTEGER</kw>, <kw>SIGNED</kw> <kw>INTEGER</kw>, <kw>INT16</kw>, <kw>INTEGER16</kw>,
<kw>SIGNED</kw> <kw>INTEGER16</kw>, <kw>INT32</kw>, <kw>INTEGER32</kw>, 
<kw>SIGNED</kw> <kw>INTEGER32</kw>, <kw>INT64</kw>, <kw>INTEGER64</kw>, 
<kw>SIGNED</kw> <kw>INTEGER64</kw>, <kw>INT128</kw>, <kw>INTEGER128</kw>, 
<kw>SIGNED</kw> <kw>INTEGER128</kw>, <kw>INT256</kw>, <kw>INTEGER256</kw>, 
<kw>SIGNED</kw> <kw>INTEGER256</kw>, <kw>BIGINT</kw>, 
<kw>BIG</kw> <kw>INTEGER</kw>, and <kw>SIGNED</kw> <kw>BIG</kw> <kw>INTEGER</kw> are collectively 
referred to as <newterm>signed exact numeric types</newterm>.
Values of signed exact numeric types are referred to as <newterm>signed exact numbers</newterm>.
</item>

<comment>WG3:BER-067R1</comment>
<comment>WG3:CMN-057R1</comment>
<item>The value types specified with the leading keywords <kw>USMALLINT</kw>, 
<kw>UNSIGNED</kw> <kw>SMALL</kw> <kw>INTEGER</kw>, <kw>UINT</kw>, 
<kw>UNSIGNED</kw> <kw>INTEGER</kw>, <kw>UINT16</kw>, <kw>UNSIGNED</kw> <kw>INTEGER16</kw>, 
<kw>UINT32</kw>, <kw>UNSIGNED</kw> <kw>INTEGER32</kw>, <kw>UINT64</kw>, 
<kw>UNSIGNED</kw> <kw>INTEGER64</kw>, <kw>UINT128</kw>,
<kw>UNSIGNED</kw> <kw>INTEGER128</kw>, <kw>UINT256</kw>, <kw>UNSIGNED</kw> <kw>INTEGER256</kw>,
<kw>UBIGINT</kw>, and <kw>UNSIGNED</kw> <kw>BIG</kw> <kw>INTEGER</kw> are collectively referred to
as <newterm>unsigned exact numeric types</newterm>.
Values of unsigned exact numeric types are referred to as <newterm>unsigned exact numbers</newterm>.
</item>

<comment>WG3:UTC-015</comment>
<item>Exact numeric types with binary precision in bits and a scale of 0 (zero) are collectively
referred to as (signed or unsigned) <newterm>integer types</newterm>.
Values of (signed or unsigned) integer types are referred to as (signed or unsigned)
<newterm>integer numbers</newterm>, or, alternatively as (signed or unsigned)
<newterm>integers</newterm>.
</item>

<comment>Editorial: Stephen Cannan, 2022-03-07 WG3:RKE-010 P00-USA-143</comment>
<item>Exact numeric types with decimal precision and scale in digits are referred to as
<newterm>decimal types</newterm>.
Values of decimal types are collectively referred to as <newterm>decimal numbers</newterm>.
</item>

<comment>WG3:CMN-057R1</comment>
<item>The value types specified with the leading keywords <kw>FLOAT</kw>, <kw>FLOAT16</kw>, 
<kw>FLOAT32</kw>, <kw>FLOAT64</kw>, <kw>FLOAT128</kw>, <kw>FLOAT256</kw>, <kw>REAL</kw>, 
<kw>DOUBLE</kw>, and <kw>DOUBLE</kw> <kw>PRECISION</kw> are collectively referred to as 
<newterm>approximate numeric types</newterm> and the values of approximate numeric types are known
as <newterm>approximate numbers</newterm>, or, alternatively, as 
 <newterm>floating point numbers</newterm>.
The primary base type of all approximate numeric types is the approximate numeric type base type.
</item> 

<comment>WG3:CMN-048</comment>
<item><newterm>Temporal instant types</newterm> and <newterm>temporal duration types</newterm>
are collectively referred to as temporal types.
</item>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-057R1</comment>
<item>The value types specified with the leading keywords <kw>ZONED</kw> <kw>DATETIME</kw>,
<kw>LOCAL</kw> <kw>DATETIME</kw>, <kw>DATE</kw>, <kw>ZONED</kw> <kw>TIME</kw>, and
<kw>LOCAL</kw> <kw>TIME</kw> are collectively referred to as temporal instant types.
The primary base type of all temporal instant types is the temporal instant type base type.
</item>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-057R1</comment>
<comment>WG3:CMN-048</comment>
<item>The value types specified by <kw>DURATION</kw>(<kw>YEAR</kw> <kw>TO</kw> <kw>MONTH</kw>) and
<kw>DURATION</kw>(<kw>DAY</kw> <kw>TO</kw> <kw>SECOND</kw>) are collectively referred to as
temporal duration types.
The primary base type of all temporal duration types is the temporal duration type base type.
</item>

<comment>WG3:POS-011R1</comment>
<item>The value types specified by VECTOR are referred to as a vector types.
The primary base type of all vector types is the vector base type.
</item>
   
<item>Binding table reference value types, graph reference value types, and graph element
reference value types are collectively referred to as reference value types. 
Values of reference value types are referred to as reference values.
</item>

<comment>WG3:CMN-057R1</comment>
<item>The reference value types specified with the leading keywords 
<kw>BINDING</kw> <kw>TABLE</kw> and <kw>TABLE</kw> are collectively referred to as 
binding table reference values. 
The primary base type of all binding table reference value types is the 
binding table reference type base type.
</item>

<comment>WG3:W25-025</comment>
<comment>WG3:CMN-057R1</comment>
<item>The reference value types specified with the leading keywords 
<kw>ANY</kw> <kw>PROPERTY</kw> <kw>GRAPH</kw>, 
<kw>PROPERTY</kw> <kw>GRAPH</kw>, <kw>ANY</kw> <kw>GRAPH</kw>, and <kw>GRAPH</kw> are collectively 
referred to as graph reference values, or, alternatively, as property graph reference values. 
The primary base type of all graph reference value types is the graph reference type base type.
</item>

<comment>WG3:CMN-019 P00-USA-034</comment>
<item>Node reference value types and edge reference value types are collectively referred to as
graph element reference value types. 
Values of graph element reference value types are referred to as graph element reference values.
</item>

<comment>WG3:W25-025</comment>
<comment>WG3:CMN-057R1</comment>
<item>The reference value types specified with the leading keywords <kw>ANY</kw> <kw>NODE</kw>, 
<kw>NODE</kw>, <kw>ANY</kw> <kw>VERTEX</kw>, and <kw>VERTEX</kw> are collectively referred to as 
node reference values, or, alternatively, as vertex reference values.
The primary base type of all node reference value types is the node reference type base type.
</item>

<comment>WG3:W25-025</comment>
<comment>WG3:CMN-057R1</comment>
<item>The reference value types specified with the leading keywords <kw>ANY</kw> <kw>EDGE</kw>, 
<kw>EDGE</kw>, <kw>ANY</kw> <kw>RELATIONSHIP</kw>, and <kw>RELATIONSHIP</kw> are collectively 
referred to as edge reference values, or, alternatively, as relationship reference values. 
The primary base type of all edge reference value types is the edge reference type base type.
</item>

<comment>WG3:W26-026R2</comment>
<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<item>The value types specified by <kw>NULL</kw>, <kw>NULL</kw> <kw>NOT</kw> <kw>NULL</kw>, and 
<kw>NOTHING</kw> are collectively referred to as immaterial value types. 
The primary base type of all immaterial value types is the immaterial value type base type.
</item>

</ulist>

</bodyMatter>

</subClause2>


<subClause2 id="gql_conc_Boolean">
<clauseHeading>Boolean types</clauseHeading>

<bodyMatter>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19</comment>
<para>The material values of a <newterm>Boolean type</newterm> are the distinct truth values
<bool>True</bool> or <bool>False</bool>.
The truth value <bool>Unknown</bool> is represented by the null value.
</para>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19</comment>
<para>This document does not make a distinction between the null value and the truth value
<bool>Unknown</bool> that is the result of a GQL <BNF name="predicate"/>,
<BNF name="search condition"/>, or <BNF name="boolean value expression"/>;
they may be used interchangeably to mean exactly the same value. 
</para>

<comment>Editorial: Stephen Cannan, 2021-04-02 See WG3:W09-024</comment>
<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19</comment>
<para>Every Boolean type is described by its Boolean data type descriptor.
A Boolean data type descriptor comprises:
</para>

<ulist>

<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<item>The declared name of the primary base type of all Boolean types (BOOLEAN DATA).
</item>

<item>The preferred name of the Boolean type <kw>BOOLEAN</kw>.
</item>

<comment>WG3:CMN-057R1</comment>
<item>The indication of whether the type includes the null value.
</item>

</ulist>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19</comment>
<comment>WG3:BER-040R3</comment>
<para>A GQL-implementation regards certain <BNF name="boolean type"/>s as equivalent, if they have
the same indication regarding the inclusion of the null value, as permitted by the Syntax Rules of
<specref ref="gql_value_type"/>.
When two or more <BNF name="boolean type"/>s are equivalent, the GQL-implementation chooses one of
these equivalent <BNF name="boolean type"/>s as the normal form representing that equivalence class
of <BNF name="boolean type"/>s.
</para>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19</comment>
<comment>Editorial: Stephen Cannan, 2022-02-26 W20-010 P00-USA-438</comment>
<comment>Editorial: Stefan Plantikow, 2022-11-21 WG3:W24-009 502. P00-USA-277</comment>
<comment>WG3:UTC-051</comment>
<comment>WG3:W25-031R2</comment>
<comment>WG3:CMN-057R1</comment>
<para>A truth value is assignable to a site of at least the material Boolean type.
The values <bool>True</bool> and <bool>False</bool> can be assigned to any site having at least
material Boolean type; assignment of <bool>Unknown</bool>, or the null value, is subject to the
nullability of the target.
</para>

<comment>WG3:W23-037</comment>
<note>See <specref ref="gql_conc_nullability"/>.
</note>

<comment>WG3:W24-037</comment>
<comment>WG3:W26-024</comment>
<para>Any two Boolean values are essentially comparable values.
</para>

</bodyMatter>

</subClause2>


<subClause2 id="gql_conc_char_string">
<clauseHeading>Character string types</clauseHeading>

<comment>WG3:W21-058</comment>
<subClause3 id="gql_conc_char_str_intro">
<clauseHeading>Introduction to character strings</clauseHeading>

<bodyMatter>

<comment>WG3:W21-058</comment>
<comment>Editorial: Stefan Plantikow, 2022-10-07 Split sentence</comment>
<comment>WG3:CMN-032</comment>
<comment>WG3:CMN-057R1</comment>
<comment>WG3:GYD-019</comment>
<para>A material value of a <newterm>character string type</newterm> is a character string.
A character string is a possibly zero-length sequence of characters drawn from
the Universal Character Set repertoire specified by <docref ref="Unicode"/>.
</para>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19</comment>
<comment>WG3:CMN-057R1</comment>
<para>A character string has a length that is the number of characters in the sequence.
The length is 0 (zero) or a positive integer.
The maximum length of a character string is <impDef code="IL013"/> but shall be greater than or
equal to 2<super>14</super>&minus;1 = 16383 characters.
</para>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>WG3:CMN-032</comment>
<para>A GQL-implementation may assume that all character strings are normalized in one of
Normalization Form C (NFC), Normalization Form D (NFD), Normalization Form KC (NFKC),
or Normalization Form KD (NFKD).
These normalization forms shall be in accordance with <docref ref="Unicode15"/>.
<BNF name="normalized predicate"/> can be used to verify the normalization form to which 
a particular character string conforms.
Applications can also use <BNF name="normalize function"/> to enforce a particular
<BNF name="normal form"/>.
With the exception of <BNF name="normalize function"/> and <BNF name="normalized predicate"/>, the
result of any operation on an unnormalized character string is <impDef code="IA003"/>.
</para>

<comment>WG3:W23-014</comment>
<para>A GQL-implementation may determine two character strings to be 
<newterm>visually confusable</newterm> with each other using an <impDef code="IW014"/> mechanism. 
A character string shall never be determined to be visually confusable with itself.
</para>

<comment>WG3:W23-014</comment>
<note>This definition deliberately includes the possibility of never determining two character 
strings to be visually confusable with each other.
</note>

<comment>WG3:W23-014</comment>
<note>A major source of visually confusable character strings are homographs.
implementers are advised to consult <docref ref="Unicode36"/> for further information on
visually confusable character strings and homographs.
</note>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19</comment>
<para>Every character string type is described by its character string data type descriptor.
A character string data type descriptor comprises:
</para>

<ulist>

<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<item>The declared name of the primary base type of all character string types (STRING DATA).
</item>

<comment>WG3:W26-026R2</comment>
<item>The preferred name of the character string type (<impDef code="ID023"/> choice of
<kw>STRING</kw>, <kw>CHAR</kw>, or <kw>VARCHAR</kw>).
</item>

<comment>WG3:W26-026R2</comment>
<item>The minimum length in characters of the character string type.
</item>

<item>The maximum length in characters of the character string type.
</item>

<item>The indication of whether the type includes the null value.
</item>

</ulist>

<comment>WG3:W26-026R2</comment>
<para>The minimum length in characters of a character string type is a non-negative integer.
</para>

<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10</comment>
<comment>WG3:OHD-023</comment>
<para>The maximum length in characters of a character string type is a positive integer.
</para>

<comment>WG3:W26-026R2</comment>
<para>Character string types where the minimum length is equal to the maximum length are
<newterm>fixed-length character string type</newterm>s. 
The minimum length and the maximum length of a fixed-length character string type are simply 
referred to as the length of that character string type. 
Character string types where the minimum length is less than the maximum length are
<newterm>variable-length character string type</newterm>s.
</para>

<para>The preferred name of character string types is determined by an <impDef code="ID023"/> 
choice of either STRING as the preferred name of all character string types or,
alternatively, CHAR as the preferred name of all fixed-length character string types and
VARCHAR as the preferred name of all variable-length character string types.
</para>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:W26-026R2</comment>
<para>A GQL-implementation regards certain <BNF name="character string type"/>s as equivalent, if
they have the same minimum length, maximum length, and indication regarding the inclusion of the 
null value, as permitted by the Syntax Rules of <specref ref="gql_value_type"/>.
When two or more <BNF name="character string type"/>s are equivalent, the GQL-implementation 
chooses one of these equivalent <BNF name="character string type"/>s as the normal form 
representing that equivalence class of <BNF name="character string type"/>s.
</para>

<comment>WG3:W24-037</comment>
<comment>WG3:CMN-057R1</comment>
<comment>WG3:W26-024</comment>
<para>Any two character string values are essentially comparable values.
</para>

<comment>WG3:CMN-057R1</comment>
<comment>WG3:W26-026R2</comment>
<para>A character string <symdef>CS</symdef> is assignable to a site that is at least of some 
material character string type <symdef>CST</symdef> if and only if the length of <sym>CS</sym> is 
both greater than or equal to the minimum length and less than or equal to the maximum length of 
<sym>CST</sym>.
</para>

<comment>WG3:CMN-057R1</comment>
<comment>WG3:W26-026R2</comment>
<note>Assuming that the declared type of the site is a closed dynamic union type 
<symdef>DUT</symdef>, it holds that <sym>CS</sym> is assignable to the site if and only if the 
length of <sym>CS</sym> is both greater than or equal to the minimum length as well as 
less than or equal to the maximum length of at least one character string type included in the 
component types of <sym>DUT</sym>.
</note>

<comment>WG3:CMN-057R1</comment>
<comment>WG3:CMN-033</comment>
<comment>WG3:W26-026R2</comment>
<para>If evaluation of a <BNF name="cast specification"/> where the source and target are both 
character strings would result in the loss of non-<BNF name="truncating whitespace"/> characters 
due to truncation, then a warning condition is raised. 
If a store assignment would result in the loss of non-<BNF name="truncating whitespace"/> 
characters due to truncation, then an exception condition is raised.
</para>

</bodyMatter>

</subClause3>


<comment>WG3:W21-058</comment>
<subClause3 id="gql_collation">
<clauseHeading>Collations</clauseHeading>

<bodyMatter>

<comment>WG3:CMN-057R1</comment>
<para><specref ref="gql_val_terms_defns"/>, defines a collation as 
a <repeatdefn ref="gql_collation_defn"/>.
</para>

<comment>WG3:CMN-057R1</comment>
<para>The GQL-implementation defines exactly one <newterm>default collation</newterm> that is used 
in the comparison of character strings and which is defined as the <impDef code="ID022"/> choice 
of one of the following:
</para>

<ulist>

<comment>WG3:CMN-032</comment>
<comment>WG3:CMN-057R1</comment>
<item>UCS_BASIC, the collation in which the ordering is determined entirely by the Unicode 
scalar values of the characters in the character strings being sorted.

<note>The Unicode scalar value of a character is its code point treated as an unsigned integer.
</note>
</item>

<comment>WG3:CMN-032</comment>
<comment>WG3:CMN-057R1</comment>
<item>UNICODE, the collation in which the ordering is determined by applying the 
Unicode Collation Algorithm with the Default Unicode Collation Element Table, in accordance with 
<docref ref="Unicode10"/>.
</item>

<item>An <impDef code="ID022"/> custom collation provided by the GQL-implementation.
</item>

</ulist>

</bodyMatter>

</subClause3>

</subClause2>


<subClause2 id="gql_conc_byte_string">
<clauseHeading>Byte string types</clauseHeading>

<bodyMatter>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19</comment>
<comment>Editorial: Stefan Plantikow, 2022-10-07 Split sentence</comment>
<comment>WG3:CMN-032</comment>
<comment>WG3:CMN-057R1</comment>
<comment>WG3:GYD-019</comment>
<para>A material value of a <newterm>byte string type</newterm> is a byte string.
A byte string is a possibly zero-length sequence of bytes (octets).
</para>

<comment>Editorial: Stefan Plantikow, 2022-06-16 Added 2^16-2= for clarity</comment>
<para>A byte string has a length that is the number of bytes in the sequence.
The length is 0 (zero) or a positive integer.
The maximum length of a byte string is <impDef code="IL013"/> but shall be greater than or equal 
to 2<super>16</super>-2=65534 bytes.
</para>

<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10 notion of - empty byte string</comment>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19 Note on the SQL BINARY VARYING</comment>
<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19</comment>
<para>Every byte string type is described by its byte string data type descriptor.
A byte string data type descriptor comprises:
</para>

<ulist>

<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<item>The declared name of the primary base type of all byte string types (BINARY DATA).
</item>

<comment>WG3:CMN-057R1</comment>
<comment>WG3:W26-026R2</comment>
<item>The preferred name of the byte string type (<impDef code="ID023"/> choice of 
<kw>BINARY</kw>, <kw>BYTES</kw>, or <kw>VARBINARY</kw>).
</item>

<item>The minimum length in bytes of the byte string type.
</item>

<item>The maximum length in bytes of the byte string type.
</item>

<item>The indication of whether the byte string type includes the null value.
</item>

</ulist>

<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10</comment>
<comment>WG3:OHD-023</comment>
<para>The minimum length in bytes of a byte string type is a non-negative integer.
</para>

<comment>WG3:OHD-023</comment>
<para>The maximum length in bytes of a byte string type is a positive integer.
</para>

<comment>WG3:OHD-021</comment>
<comment>WG3:W26-026R2</comment>
<para>Byte string types where the minimum length is equal to the maximum length are
<newterm>fixed-length byte string type</newterm>s. 
The minimum length and the maximum length of a fixed-length byte string type are simply referred to
as the length of that byte string type.
Byte string types where the minimum length is less than the maximum length are
<newterm>variable-length byte string type</newterm>s.
</para>

<comment>WG3:CMN-057R1</comment>
<para>The preferred name of byte string types is determined by an <impDef code="ID023"/> choice 
of either BYTES as the preferred name of all byte string types or, alternatively,
BINARY as the preferred name of all fixed-length byte string types and VARBINARY as the
preferred name of all variable-length byte string types.
</para>

<comment>WG3:BER-040R3</comment>
<comment>WG3:W23-037</comment>
<para>A GQL-implementation regards certain <BNF name="byte string type"/>s as equivalent, if they
have the same minimum length, maximum length and indication regarding the inclusion of the 
null value, as permitted by <specref ref="gql_value_type"/>.
When two or more <BNF name="byte string type"/>s are equivalent, the GQL-implementation chooses 
one of these equivalent <BNF name="byte string type"/>s as the normal form representing that 
equivalence class of <BNF name="byte string type"/>s. 
</para>

<comment>WG3:W24-037</comment>
<comment>WG3:W26-024</comment>
<para>Any two byte string values are essentially comparable values.
</para>

<comment>WG3:BER-040R3</comment>
<comment>WG3:W25-031R2</comment>
<comment>WG3:CMN-057R1</comment>
<comment>WG3:W26-026R2</comment>
<para>A byte string <symdef>BS</symdef> is assignable to a site that is at least of some material
byte string type <symdef>BST</symdef> if and only if the length of <sym>BS</sym> is both greater 
than or equal to the minimum length and less than or equal to the maximum length of 
<symdef>BST</symdef>.
</para>

<comment>WG3:CMN-057R1</comment>
<note>Assuming that the declared type of the site is a closed dynamic union type 
<symdef>DUT</symdef>, it holds that <sym>BS</sym> is assignable to the site if and only if 
the length of <sym>BS</sym> is both greater than or equal to the minimum length as well as 
less than or equal to the maximum length of at least one byte string type included in the 
component types of <sym>DUT</sym>.
</note>

<comment>WG3:CMN-057R1</comment>
<para>If evaluation of a <BNF name="cast specification"/> would result in the loss of bytes due 
to truncation, then a warning condition is raised.
If a store assignment would result in the loss of bytes due to truncation, then 
an exception condition is raised.
</para>

</bodyMatter>

</subClause2>


<comment>Editorial: Stefan Plantikow, 2021-06-29 Split into Subclauses</comment>
<subClause2 id="gql_conc_numeric">
<clauseHeading>Numeric types</clauseHeading>

<comment>Editorial: Stefan Plantikow, 2021-06-29 Split into Subclauses</comment>
<subClause3 id="gql_conc_numeric_intro">
<clauseHeading>Introduction to numbers</clauseHeading>

<bodyMatter>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<para>GQL supports two classes of numeric data:
</para>

<ulist>

<item>Exact numeric data.
</item>

<item>Approximate numeric data.
</item>

</ulist>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<para>Exact numeric data is either signed or unsigned.
Signed numeric data is either non-negative (positive or zero) or negative.
Unsigned numeric data is always non-negative.
Approximate numeric data is always signed.
</para>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>Editorial: Stephen Cannan, 2022-02-25 W20-010 P00-USA-441</comment>
<comment>WG3:W23-037</comment>
<comment>WG3:W26-023</comment>
<para>Numeric types are either <newterm>binary</newterm> or <newterm>decimal</newterm>, 
<ie/> either their material values (numbers) are specified in binary terms with 
a radix of 2 or, respectively, are specified in decimal terms with a radix of 10.
Signed binary exact numeric types are two<apos/>s complement integers.
Binary exact numeric types do not specify a scale factor.
Decimal exact numeric types may specify a scale factor.
Approximate numeric types are always binary numeric types and may specify a scale factor.
</para>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<para>Every <newterm>numeric type</newterm> is described by a numeric data type descriptor.
A numeric data type descriptor comprises: 
</para>

<ulist>

<comment>WG3:UTC-015</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<item>The declared name of the primary base type of the numeric type 
(EXACT NUMERIC DATA for exact numeric types and FLOAT NUMERIC DATA for approximate numeric types).
</item>

<item>The preferred name of the specific numeric type, which is the declared name of the 
normal form of the numeric type. 
</item>

<comment>WG3:W26-023</comment>
<item>The indication of whether numbers of the numeric type are specified in binary or decimal
terms. 
The radix of binary exact numbers is 2, the radix of decimal exact numbers is 10, and
the radix of approximate numbers is always 2.
</item>

<comment>WG3:W26-023</comment>
<item>The precision of the numeric type, which is a positive integer.
</item>

<comment>WG3:W26-023</comment>
<item>The scale of the numeric type, which is a non-negative integer.
</item>

<comment>WG3:W26-023</comment>
<item>The indication of whether the type includes the null value.
</item>

</ulist>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>WG3:BER-040R3</comment>
<comment>Editorial: Stephen Cannan 2022-11-13 Improve wording</comment>
<para>A GQL-implementation is permitted to regard two <BNF name="exact numeric type"/>s as
equivalent, if they have the same precision, scale, radix, and indication regarding the inclusion 
of the null value, as permitted by the Syntax Rules of <specref ref="gql_value_type"/>.
When two or more <BNF name="exact numeric type"/>s are equivalent, the GQL-implementation chooses
one of these equivalent <BNF name="exact numeric type"/>s as the normal form representing that 
equivalence class of <BNF name="exact numeric type"/>s.
The normal form determines the preferred name of the exact numeric type in the numeric data type
descriptor.
</para>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:W23-037</comment>
<comment>Editorial: Stephen Cannan 2022-11-13 Improve wording</comment>
<para>Similarly, a GQL-implementation is permitted to regard two 
<BNF name="approximate numeric type"/>s as equivalent, if they have the same precision, scale, and
indication regarding the inclusion of the null value, as permitted by the Syntax Rules of 
<specref ref="gql_value_type"/>.
When two or more <BNF name="approximate numeric type"/>s are equivalent, the GQL-implementation 
chooses a normal form to represent each equivalence class of 
<BNF name="approximate numeric type"/>s. 
The normal form determines the preferred name of the approximate numeric type in the 
numeric data type descriptor.
</para>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>Editorial: Stefan Plantikow, 2021-06-29 Clarify: This refers to material values</comment>
<para>For every numeric type, the least material value is less than or equal to zero and the
greatest material value is greater than zero.
</para>

</bodyMatter>

</subClause3>


<comment>Editorial: Stefan Plantikow, 2021-06-29 Split into Subclauses</comment>
<subClause3 id="gql_conc_numeric_characteristics">
<clauseHeading>Characteristics of numbers</clauseHeading>

<bodyMatter>

<comment>WG3:BER-067R1</comment>
<comment>WG3:W23-037</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<comment>WG3:W26-023</comment>
<para>A numeric type has a precision <symdef>P</symdef> and a scale <symdef>S</symdef>.
<sym>P</sym> is a positive integer that determines the number of significant digits of numbers of 
the numeric type in a particular radix <symdef>R</symdef>, where <symdef>R</symdef> is either 2 or
10.
<sym>S</sym> is a non-negative integer such that <sym>S</sym> <leq/> <sym>P</sym>.
Every value of a signed binary exact numeric type of scale <sym>S</sym> is of the form
<sym>N</sym> &times; 10<super>&minus;<sym>S</sym></super>, where <symdef>N</symdef> is 
an integer such that &minus;(2<super><sym>P</sym></super>) <leq/> <sym>N</sym> &lt;
2<super><sym>P</sym></super>.
Every value of an unsigned binary exact numeric type of scale <symdef>S</symdef> is representable 
in the form <sym>N</sym> &times; <sym>R</sym><super>&minus;<sym>S</sym></super>, 
where <symdef>N</symdef> is an integer such that 0 (zero) <leq/> <sym>N</sym> &lt; 
<sym>R</sym><super><sym>P</sym></super>.
Every value of a signed decimal exact numeric type of scale <sym>S</sym> is representable in 
the form <sym>N</sym> &times; 10<super>&minus;<sym>S</sym></super>, where <sym>N</sym> is 
an integer such that 
&minus;(10<super><sym>P</sym></super>) &lt; <sym>N</sym> &lt; 10<super><sym>P</sym></super>.
</para>

<note>Not every value in that range is necessarily a value of the type in question.
</note>

<comment>WG3:CMN-019 P00-USA-333</comment>
<comment>WG3:W26-023</comment>
<para>Exact numeric values are effectively specified by an integral part and a fractional part.
The integral part is a signed numeric value that specifies the sign of the numeric value and
the digits before the radix point of the numeric value and the fractional part is 
a non-negative integer that specifies the digits after the radix point of the numeric value. 
The value of an exact number is determined by application of the normal mathematical
interpretation of positional notation to the concatenation of the sign and the digits before
the radix point specified by the integral part, followed by the radix point and the digits after
the radix point specified by the fractional part.
</para>

<ednote id="gql_PP217">Further alignment between the definition of approximate numbers and the
requirements of ISO/IEC 60559:2020 such as support for positive and negative infinity as well as
NaNs and similar issues is needed.
See <PPref ref="PPgql217"/>.
</ednote>

<comment>WG3:BER-010 P00-USA-444</comment>
<comment>WG3:BER-085</comment>
<comment>WG3:W23-037</comment>
<comment>WG3:CMN-019 P00-USA-037</comment>
<comment>WG3:W26-023</comment>
<para>Approximate numeric values are effectively specified by a mantissa and an exponent.
The mantissa is a signed numeric value, and the exponent is a signed integer that specifies the
magnitude of the mantissa.
Approximate numeric values have a precision and a scale.
The precision of approximate numeric values is a positive integer that specifies the number of
significant binary digits in the mantissa.
In this document, the sign of the mantissa is not considered as a significant binary digit for the
purpose of determining the precision of an approximate numeric value.
The scale of approximate numeric values is its exponent size, <ie/> a signed integer that
specifies the number of significant binary digits of the exponent.
In this document, the sign of the exponent is not considered as a significant binary digit for
the purpose of determining the scale of an approximate numeric value.
The value of an approximate number is the mantissa multiplied by a factor determined by the
exponent.
</para>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>Editorial: Stephen Cannan 2021-12-08 Standardize on GQL-implementation</comment>
<comment>Editorial: Stephen Cannan 2023-01-29 Align with Directives Part 2</comment>
<note>A GQL-implementation can choose an internal representation for approximate numeric values 
that implicitly encodes leading bits instead of physically storing them.
Any such implied bits are still part of the mantissa of any value represented using such 
an encoding.
</note>

<comment>WG3:W02-012R1</comment>
<comment>WG3:W26-023</comment>
<para>An <BNF name="exact numeric literal"/> <symdef>ENL</symdef> comprises either 
an <BNF name="unsigned decimal in scientific notation"/> followed by 
an <BNF name="exact number suffix"/>, an <BNF name="unsigned decimal in common notation"/> 
optionally followed by an <BNF name="exact number suffix"/>, 
an <BNF name="unsigned decimal integer"/> followed by an <BNF name="exact number suffix"/>, or 
an <BNF name="unsigned integer"/>.
There is an <BNF name="exact numeric literal"/> <symdef>ENL2</symdef> that 
does not simply contain an <BNF name="unsigned decimal in scientific notation"/> such that 
<sym>ENL2</sym> is equivalent to <sym>ENL</sym> and <sym>ENL2</sym> specifies the same 
exact number as <sym>ENL</sym>.
The declared type of <sym>ENL</sym> is an exact numeric type.
</para>

<comment>WG3:W02-012R1</comment>
<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>WG3:W26-023</comment>
<para>An <BNF name="approximate numeric literal"/> <symdef>ANL</symdef> comprises either 
an <BNF name="unsigned decimal in scientific notation"/> optionally followed by 
an <BNF name="approximate number suffix"/>, an <BNF name="unsigned decimal in common notation"/> 
followed by an <BNF name="approximate number suffix"/>, or 
an <BNF name="unsigned decimal integer"/> followed by an <BNF name="approximate number suffix"/>.
There is an <BNF name="unsigned decimal in scientific notation"/> <symdef>UDSN</symdef> that is 
equivalent to <sym>ANL</sym> and that specifies the same approximate number as <sym>ANL</sym>.
The declared type of <sym>ANL</sym> is an approximate numeric type.
If <symdef>M</symdef> is the value of the <BNF name="mantissa"/> and <symdef>E</symdef> is the 
value of the <BNF name="exponent"/> of <sym>UDSN</sym>, then 
<sym>M</sym> * 10<super><sym>E</sym></super> is the <newterm>apparent value</newterm> of 
<sym>ANL</sym>.
If the declared type of <sym>ANL</sym> is an approximate numeric type, then
the actual value of <sym>ANL</sym> is approximately the apparent value of <sym>ANL</sym>,
according to <impDef code="IA004"/> rules.
</para>

<comment>WG3:W26-023</comment>
<para>An <BNF name="unsigned decimal in scientific notation"/> comprises 
a <BNF name="mantissa"/> that is an <BNF name="unsigned decimal integer"/> or 
an <BNF name="unsigned decimal in common notation"/> of the value, the letter <quote>E</quote> or
<quote>e</quote>, and an <BNF name="exponent"/> that is a <BNF name="signed decimal integer"/> that 
specifies an unsigned number by specifying a mantissa and an exponent. 
An <BNF name="unsigned decimal in common notation"/> comprises either 
an <BNF name="unsigned decimal integer"/>, a <BNF name="period"/> followed by 
an <BNF name="unsigned decimal integer"/>, or an <BNF name="unsigned decimal integer"/> followed by 
a <BNF name="period"/> and an optional <BNF name="unsigned decimal integer"/> that specifies 
an unsigned number by specifying the sequences of digits before and after the decimal point. 
An <BNF name="unsigned integer"/> comprises a sequence of digits that specifies an unsigned integer
in decimal, hexadecimal, octal, or binary terms.
</para>

<comment>WG3:W24-037</comment>
<comment>WG3:W26-024</comment>
<para>Any two numbers are essentially comparable values.
</para>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>WG3:W21-010 P00-USA-438</comment>
<comment>WG3:W25-031R2</comment>
<comment>WG3:CMN-057R1</comment>
<para>A number is assignable to a site of at least material exact numeric type or 
the material approximate numeric type.
If an assignment of some number would result in a loss of its most significant digit, 
an exception condition is raised.
If least significant digits are lost, it is <impDef code="IA021"/> if an exception condition is 
raised or if truncation or rounding occurs.
In the latter case, the choice of whether to truncate or round is <impDef code="IA005"/>.
The rules for arithmetic are specified in <specref ref="gql_numexp"/>.
</para>

<para>Whenever a numeric value is assigned to an exact numeric value site, an approximation of its
value that preserves leading significant digits after rounding or truncating is represented in the
declared type of the target.
The value is converted to have the precision and scale of the target.
The choice of whether to truncate or round is <impDef code="IA005"/>.
</para>

<para>An approximation obtained by truncation of a numeric value <symdef>N</symdef> for an exact
numeric type <symdef>T</symdef> is a value <symdef>V</symdef> in <sym>T</sym> such that <sym>N</sym>
is not closer to zero than <sym>V</sym> and there is no value in <sym>T</sym> between <sym>V</sym>
and <sym>N</sym>. 
</para>

<para>An approximation obtained by rounding of a numeric value <sym>N</sym> for an exact numeric
type <sym>T</sym> is a value <sym>V</sym> in <sym>T</sym> such that the absolute value of the
difference between <sym>N</sym> and the numeric value of <sym>V</sym> is not greater than
half the absolute value of the difference between two successive numeric values in <sym>T</sym>.
If there is more than one such value <sym>V</sym>, then it is <impDef code="IA006"/> which one is
taken.
</para>

<comment>WG3:CMN-025 Stefan Plantikow, 2023-10-04 Removed 1 (one) paragraph</comment>

<para>All numeric values between the smallest and the largest value, inclusive, in a given exact
numeric type have an approximation obtained by rounding or truncation for that type; it is
<impDef code="IA007"/> which other numeric values have such approximations.
</para>

<comment>Editorial: Stefan Plantikow, 2022-02-24 WG3:W20-010 P00-USA-443</comment>
<comment>WG3:BER-067R1</comment>
<para>An approximation obtained by truncation or rounding of a numeric value <sym>N</sym> for 
an approximate numeric type <symdef>T</symdef> is a value <sym>V</sym> in <sym>T</sym> such that 
there is no numeric value in <sym>T</sym> distinct from that of <sym>V</sym> that lies between the 
numeric value of <sym>V</sym> and <sym>N</sym>, inclusive.
If there is more than one such value <sym>V</sym>, then it is <impDef code="IA006"/> which one
is taken.
</para>

<comment>WG3:CMN-025 Stefan Plantikow, 2023-10-04 Removed 1 (one) paragraph</comment>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<para>Whenever a numeric value is assigned to an approximate numeric value site, an approximation of
its value is represented in the declared type of the target. 
The value is converted to have the precision of the target.
</para>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<para>Operations on numbers are performed according to the normal rules of arithmetic, within
<impDef code="IA010"/> limits, except as provided for in <specref ref="gql_numexp"/>.
</para>

</bodyMatter>

</subClause3>


<comment>Editorial: Stefan Plantikow, 2021-06-29 Split into Subclauses</comment>
<subClause3 id="gql_conc_numeric_binary_exact">
<clauseHeading>Binary exact numeric types</clauseHeading>

<bodyMatter>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>Editorial: Stefan Plantikow, 2021-06-29 Split between signed and unsigned</comment>
<para>The signed binary exact numeric types are:
</para>

<comment>WG3:BER-067R1</comment>
<ulist>

<comment>WG3:W26-023</comment>
<item>The <newterm>signed 8-bit integer type</newterm> specified by 
<kw>SIGNED</kw> <kw>INTEGER8</kw> (alternatively: <kw>INTEGER8</kw>, <kw>INT8</kw>) with 
precision 7 and with scale 0 (zero).
</item>

<comment>WG3:W26-023</comment>
<item>The <newterm>signed 16-bit integer type</newterm> specified by 
<kw>SIGNED</kw> <kw>INTEGER16</kw> (alternatively: <kw>INTEGER16</kw>, <kw>INT16</kw>) with 
precision 15 and with scale 0 (zero).
</item>

<comment>WG3:W26-023</comment>
<item>The <newterm>signed 32-bit integer type</newterm> specified by 
<kw>SIGNED</kw> <kw>INTEGER32</kw> (alternatively: <kw>INTEGER32</kw>, <kw>INT32</kw>) with 
precision 31 and with scale 0 (zero).
</item>

<comment>WG3:W26-023</comment>
<item>The <newterm>signed 64-bit integer type</newterm> specified by 
<kw>SIGNED</kw> <kw>INTEGER64</kw> (alternatively: <kw>INTEGER64</kw>, <kw>INT64</kw>) with 
precision 63 and with scale 0 (zero).
</item>

<comment>WG3:W26-023</comment>
<item>The <newterm>signed 128-bit integer type</newterm> specified by 
<kw>SIGNED</kw> <kw>INTEGER128</kw> (alternatively: <kw>INTEGER128</kw>, <kw>INT128</kw>) with 
precision 127 and with scale 0 (zero).
</item>

<comment>WG3:W26-023</comment>
<item>The <newterm>signed 256-bit integer type</newterm> specified by 
<kw>SIGNED</kw> <kw>INTEGER256</kw> (alternatively: <kw>INTEGER256</kw>, <kw>INT256</kw>) with 
precision 255 and with scale 0 (zero).
</item>

<comment>WG3:W26-023</comment>
<item>The <newterm>signed regular integer type</newterm> specified by specified by 
<kw>SIGNED</kw> <kw>INTEGER</kw> (alternatively: <kw>INTEGER</kw>, <kw>INT</kw>) with 
<impDef code="ID028"/> precision greater than or equal to the precision of the 
signed regular integer type  and with scale zero (0).
</item>

<comment>WG3:W26-023</comment>
<item>The <newterm>signed small integer type</newterm> specified by 
<kw>SIGNED</kw> <kw>SMALL</kw> <kw>INTEGER</kw> (alternatively: 
<kw>SMALL</kw> <kw>INTEGER</kw>, <kw>SMALLINT</kw>) with <impDef code="ID028"/> precision less than
or equal to the precision of the signed regular integer type and with scale zero (0).
</item>

<comment>WG3:W26-023</comment>
<item>The <newterm>signed big integer type</newterm> specified by 
<kw>SIGNED</kw> <kw>BIG</kw> <kw>INTEGER</kw> (alternatively: 
<kw>BIG</kw> <kw>INTEGER</kw>, <kw>BIGINT</kw>) with <impDef code="ID028"/>
precision greater than or equal to the precision of the signed regular integer type and 
with scale zero (0).
</item>

<comment>WG3:W26-023</comment>
<item>The <newterm>signed user-specified integer types</newterm> specified by 
<kw>SIGNED</kw> <kw>INTEGER</kw>(<symdef>p</symdef>) (alternatively: 
<kw>INTEGER</kw>(<sym>p</sym>), <kw>INT</kw>(<sym>p</sym>)) with <impDef code="ID028"/> precision 
greater than or equal to <sym>p</sym> and with scale zero (0).
</item>

</ulist>

<comment>Editorial: Stefan Plantikow, 2021-06-29 Split between signed and unsigned</comment>
<para>The unsigned binary exact numeric types are:
</para>

<comment>WG3:BER-067R1</comment>
<ulist>

<comment>WG3:W26-023</comment>
<item>The <newterm>unsigned 8-bit integer type</newterm> specified by 
<kw>UNSIGNED</kw> <kw>INTEGER8</kw> (alternatively: <kw>UINT8</kw>) with precision 8 and 
with scale 0 (zero).
</item>

<comment>WG3:W26-023</comment>
<item>The <newterm>unsigned 16-bit integer type</newterm> specified by 
<kw>UNSIGNED</kw> <kw>INTEGER16</kw> (alternatively: <kw>UINT16</kw>) with precision 16 and 
with scale 0 (zero).
</item>

<comment>WG3:W26-023</comment>
<item>The <newterm>unsigned 32-bit integer type</newterm> specified by 
<kw>UNSIGNED</kw> <kw>INTEGER32</kw> (alternatively: <kw>UINT32</kw>) with precision 32 and 
with scale 0 (zero).
</item>

<comment>WG3:W26-023</comment>
<item>The <newterm>unsigned 64-bit integer type</newterm> specified by 
<kw>UNSIGNED</kw> <kw>INTEGER64</kw> (alternatively: <kw>UINT64</kw>) with precision 64 and 
with scale 0 (zero).
</item>

<comment>WG3:W26-023</comment>
<item>The <newterm>unsigned 128-bit integer type</newterm> specified by 
<kw>UNSIGNED</kw> <kw>INTEGER128</kw> (alternatively: <kw>UINT128</kw>) with precision 128 and 
with scale 0 (zero).
</item>

<comment>WG3:W26-023</comment>
<item>The <newterm>unsigned 256-bit integer type</newterm> specified by 
<kw>UNSIGNED</kw> <kw>INTEGER256</kw> (alternatively: <kw>UINT256</kw>) with precision 256 and 
with scale 0 (zero).
</item>

<comment>WG3:W26-023</comment>
<item>The <newterm>unsigned regular integer type</newterm> specified by 
<kw>UNSIGNED</kw> <kw>INTEGER</kw> (alternatively: <kw>UINT</kw>) with the same precision as 
the precision of the unsigned 32-bit integer type  and with scale zero (0).
</item>

<comment>WG3:W26-023</comment>
<item>The <newterm>unsigned small integer type</newterm> specified by 
<kw>UNSIGNED</kw> <kw>SMALL</kw> <kw>INTEGER</kw> (alternatively: <kw>USMALLINT</kw>) with 
<impDef code="ID028"/> precision less than or equal to the precision of the 
unsigned regular integer type and with scale zero (0).
</item>

<comment>WG3:W26-023</comment>
<item>The <newterm>unsigned big integer type</newterm> specified by 
<kw>UNSIGNED</kw> <kw>BIG</kw> <kw>INTEGER</kw> (alternatively: <kw>UBIGINT</kw>) with 
<impDef code="ID028"/> precision greater than or equal to the precision of the 
unsigned regular integer type and with scale zero (0).
</item>

<comment>WG3:W26-023</comment>
<item>The <newterm>unsigned user-specified integer types</newterm> specified by 
<kw>UNSIGNED</kw> <kw>INTEGER</kw>(<symdef>p</symdef>) (alternatively: <kw>UINT</kw>(<sym>p</sym>)) 
with <impDef code="ID028"/> precision greater than or equal to <sym>p</sym> and with 
scale zero (0).
</item>

</ulist>

</bodyMatter>

</subClause3>


<subClause3 id="gql_conc_numeric_decimal_exact">
<clauseHeading>Decimal exact numeric types</clauseHeading>

<bodyMatter>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<para>The decimal exact numeric types are:
</para>

<ulist>

<comment>WG3:BER-085</comment>
<comment>WG3:W26-023</comment>
<item>The <newterm>regular decimal exact numeric type</newterm> specified by <kw>DECIMAL</kw> 
(alternatively: <kw>DEC</kw>) with <impDef code="ID034"/> precision greater than or equal to 
the precision of the signed regular integer type and with scale 0 (zero).
</item>

<comment>WG3:BER-085</comment>
<comment>WG3:W26-023</comment>
<item>The <newterm>user-specified decimal exact numeric types</newterm> specified by
<kw>DECIMAL</kw>(<symdef>p</symdef>) (alternatively: <kw>DEC</kw>(<sym>p</sym>)) with
<impDef code="ID034"/> precision greater than or equal to <sym>p</sym> and with scale 0 (zero).
</item>

<comment>WG3:BER-085</comment>
<comment>WG3:W26-023</comment>
<item>The <newterm>user-specified decimal exact numeric types</newterm> specified by
<kw>DECIMAL</kw>(<symdef>p</symdef>, <symdef>s</symdef>) (alternatively:
<kw>DEC</kw>(<sym>p</sym>, <sym>s</sym>)) with <impDef code="ID034"/> precision greater than or 
equal to <sym>p</sym> and with <impDef code="ID037"/> scale of <sym>s</sym>.
</item>

</ulist>

</bodyMatter>

</subClause3>


<comment>Editorial: Stefan Plantikow, 2021-06-29 Split into Subclauses</comment>
<subClause3 id="gql_conc_numeric_approximate">
<clauseHeading>Approximate numeric types</clauseHeading>

<bodyMatter>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<para>The approximate numeric types are:
</para>

<comment>WG3:W26-023</comment>
<note>The precision and scale of an approximate numeric type specify the number of 
most significant binary digits except for the sign of the mantissa and, respectively, 
the exponent of approximate numbers of the type.
</note>

<comment>WG3:BER-085</comment>
<comment>WG3:W26-023</comment>
<ulist>

<item>The <newterm>16-bit approximate numeric type</newterm> specified by <kw>FLOAT16</kw> with 
precision 10 and with scale 4.

<note>The material value space of the 16-bit approximate numeric type <kw>FLOAT16</kw> is defined 
to be compatible with the binary16 interchange format of <docref ref="IEEE754"/>.
</note>

</item>

<item>The <newterm>32-bit approximate numeric type</newterm> specified by <kw>FLOAT32</kw> with 
precision 23 and with scale 7.

<note>The material value space of the 32-bit approximate numeric type <kw>FLOAT32</kw> is defined 
to be compatible with the binary32 interchange format of <docref ref="IEEE754"/>.
</note>

</item>

<item>The <newterm>64-bit approximate numeric type</newterm> specified by <kw>FLOAT64</kw> with 
precision 52 and with scale 10.

<note>The material value space of the 64-bit approximate numeric type <kw>FLOAT64</kw> is defined 
to be compatible with the binary64 interchange format of <docref ref="IEEE754"/>.
</note>

</item>

<item>The <newterm>128-bit approximate numeric type</newterm> specified by <kw>FLOAT128</kw> with 
precision 112 and with scale 14.

<note>The material value space of the 128-bit approximate numeric type <kw>FLOAT128</kw> is defined
to be compatible with the binary128 interchange format of <docref ref="IEEE754"/>.
</note>

</item>

<item>The <newterm>256-bit approximate numeric type</newterm> <kw>FLOAT256</kw> with 
precision 236 and with scale 18.

<note>The material value space of the 256-bit approximate numeric type specified by 
<kw>FLOAT256</kw> is defined to be compatible with the binary256 interchange format of 
<docref ref="IEEE754"/>.
</note>

</item>

<item>The <newterm>regular approximate numeric type</newterm> specified by <kw>FLOAT</kw> with
<impDef code="ID037"/> precision greater than or equal to 23 and with <impDef code="ID037"/> 
scale greater than or equal to 7.
</item>

<item>The <newterm>real approximate numeric type</newterm> specified by <kw>REAL</kw> with 
<impDef code="ID037"/> precision less than or equal to the precision of the 
regular approximate numeric type and with <impDef code="ID037"/> scale.
</item>

<item>The <newterm>double approximate numeric type</newterm> specified by <kw>DOUBLE</kw>
(alternatively: <kw>DOUBLE</kw> <kw>PRECISION</kw>) with <impDef code="ID037"/> precision
greater than or equal to the precision of the regular approximate numeric type and
with <impDef code="ID037"/> scale.
</item>

<item>The <newterm>user-specified approximate numeric types</newterm> specified by
<kw>FLOAT</kw>(<symdef>p</symdef>) with <impDef code="ID037"/> precision greater than or
equal to <sym>p</sym> and with <impDef code="ID037"/> scale.
</item>

<item>The user-specified approximate numeric types specified by
<kw>FLOAT</kw>(<symdef>p</symdef>, <symdef>s</symdef>) with <impDef code="ID037"/> precision
greater than or equal to <sym>p</sym> and with <impDef code="ID037"/> scale greater than or 
equal to <sym>s</sym>.
</item>

</ulist>

<comment>WG3:UTC-063</comment>
<comment>WG3:CMN-019 P00-ISO-003</comment>
<comment>WG3:W26-023</comment>
<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<para>If a GQL-implementation supports <feature code="GA01"/>, 
a <BNF name="numeric value expression"/>s on approximate numeric types that would otherwise result 
in exceptions may return additional values.
Any additional value returned shall be one defined by <docref ref="IEEE754"/>.
It is <impDef code="IA025"/> what the effect of these additional values have on the rest of GQL.
However, to the extent that this document and <docref ref="IEEE754"/> provide similar operations, 
it is recommended that the GQL-implementation defines the behavior of such operations on any 
such additionally introduced values to be in accordance with <docref ref="IEEE754"/>.
</para>

</bodyMatter>

</subClause3>

</subClause2>


<subClause2 id="gql_conc_temporal">
<clauseHeading>Temporal types</clauseHeading>


<subClause3 id="gql_conc_temporal_intro">
<clauseHeading>Introduction to temporal data</clauseHeading>

<bodyMatter>

<comment>WG3:UTC-117 Deleted 1 (one) editor's note</comment>

<ednote id="gql_PP185">Relationship to system-versioned graphs needs to be discussed.
See <PPref ref="PPgql185"/>.
</ednote>

<comment>Editorial: Stephen Cannan, 2022-02-26 W20-010 P00-USA-446</comment>
<comment>WG3:UTC-117</comment>
<para>There are two classes of temporal data:
</para>

<ulist>

<item>Temporal instant data.
</item>

<item>Temporal duration data.
</item>

</ulist>

<comment>WG3:UTC-117</comment>
<para>The specifications of temporal types for temporal data reference the formats and operations
that are specified in <docref ref="ISO8601-1_2019"/> and <docref ref="ISO8601-2_2019"/> but also
support the temporal literal formats specified in <docref ref="ISO9075-2_2023"/>.
</para>

<comment>Email from: Keith Hare, 2023-03-01 1358 Deleted 1 (one) paragraph</comment>

<comment>Editorial: Stephen Cannan, 2022-02-26 W20-010 P00-USA-190</comment>
<comment>WG3:CMN-019 P00-ISO-004</comment>
<para>The time scale used for temporal instant data shall conform to <docref ref="UTC-SLS"/>.
</para>

</bodyMatter>

</subClause3>


<subClause3 id="gql_conc_temporal_instants">
<clauseHeading>Temporal instant types</clauseHeading>

<bodyMatter>

<para>The temporal instant types are:
</para>

<comment>Editorial: Stephen Cannan, 2022-02-26 W20-010 P00-USA-445</comment>
<comment>WG3:UTC-117</comment>
<ulist>

<comment>WG3:UTC-117</comment>
<item><kw>ZONED</kw> <kw>DATETIME</kw>

<comment>WG3:UTC-117</comment>
<para>A material value of <kw>ZONED</kw> <kw>DATETIME</kw> is called
a <newterm>zoned datetime</newterm>. 
A zoned datetime represents a temporal instant capturing the date, the time, and the time zone
displacement.
</para>

<note>Equivalent to TIMESTAMP WITH TIME ZONE with nanosecond precision in <SQL/>.
</note>

</item>

<comment>WG3:UTC-117</comment>
<item><kw>LOCAL</kw> <kw>DATETIME</kw>

<comment>WG3:UTC-117</comment>
<para>A material value of <kw>LOCAL</kw> <kw>DATETIME</kw> is called
a <newterm>local datetime</newterm>. 
A local datetime represents a temporal instant capturing the date and the time, but not
the time zone displacement.
</para>

<note>Equivalent to TIMESTAMP WITHOUT TIME ZONE with nanosecond precision in <SQL/>.
</note>

</item>

<comment>WG3:UTC-117</comment>
<item><kw>DATE</kw>

<comment>WG3:UTC-117</comment>
<comment>Editorial: Stephen Cannan, 2023-08-10</comment>
<para>A material value of <kw>DATE</kw> is called a <newterm>date</newterm>.
A date represents a temporal instant capturing the date, but neither the time, nor
the time zone displacement.
</para>

<note>Equivalent to DATE in <SQL/>.
</note>

</item>

<comment>WG3:UTC-117</comment>
<item><kw>ZONED</kw> <kw>TIME</kw>

<comment>Editorial: Stephen Cannan, 2022-02-26 W20-010 P00-USA-447</comment>
<comment>WG3:UTC-117</comment>
<para>A material value of <kw>ZONED</kw> <kw>TIME</kw> is called a <newterm>zoned time</newterm>.
A zoned time represents a temporal instant capturing the time of day and the time zone displacement,
but not the date.
</para>

<note>Equivalent to TIME WITH TIME ZONE with nanosecond precision in <SQL/>.
</note>

</item>

<comment>WG3:UTC-117</comment>
<item><kw>LOCAL</kw> <kw>TIME</kw>

<comment>WG3:UTC-117</comment>
<comment>Editorial: Stephen Cannan, 2023-08-10</comment>
<para>A material value of <kw>LOCAL</kw> <kw>TIME</kw> is called a <newterm>local time</newterm>.
A local time represents a temporal instant capturing the time of day, but neither the date, nor
the time zone displacement.
</para>

<note>Equivalent to TIME WITHOUT TIME ZONE with nanosecond precision in <SQL/>.
</note>

</item>

</ulist>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-019 P00-USA-007</comment>
<para>A <newterm>datetime</newterm> is either a zoned datetime or a local datetime and
a time is either a zoned time or a local time.
</para>

<comment>WG3:UTC-117</comment>
<para>Every temporal instant type is described by a temporal instant data type descriptor. 
A temporal instant data type descriptor comprises:
</para>

<ulist>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-057R1</comment>
<item>The declared name of the primary base type of all temporal instant types 
(TEMPORAL INSTANT DATA).
</item>

<comment>WG3:UTC-117</comment>
<item>The preferred name of the specific temporal instant type, which is the declared name of
the normal form of the temporal instant type.
</item>

<comment>WG3:UTC-117</comment>
<item>The indication of whether the temporal instant values of the type capture
the date.
</item>

<comment>WG3:UTC-117</comment>
<item>The indication of whether the temporal instant values of the type capture
the time of day.
</item>

<comment>WG3:UTC-117</comment>
<item>The indication of whether the temporal instant values of the type include
a time zone displacement.
</item>

<comment>WG3:UTC-117</comment>
<item>The indication of whether the type includes the null value.
</item>

</ulist>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-048</comment>
<para>The format of temporal instant literals shall be either in accordance with
<docref ref="ISO8601-1_2019"/> and <docref ref="ISO8601-2_2019"/> or in accordance with
<docref ref="ISO9075-2_2023"/>.
</para>

<comment>WG3:UTC-117</comment>
<note>See <specref ref="gql_literals"/>.
</note>

<comment>WG3:W25-031R2</comment>
<para>The surface of the earth is divided into zones, called time zones, in which every correct 
clock tells the same time, known as local time. 
Local time is equal to <newterm>Universal Coordinated Time</newterm> (<newterm>UTC</newterm>) plus
the <newterm>time zone displacement</newterm>. 
The time zone displacement is constant throughout a time zone, and can change at the beginning 
and end of Summer Time, where applicable.
</para>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-048</comment>
<para>A time zone is represented by the time zone displacement between the local time and UTC. 
Time zone displacement is defined in <docref ref="ISO8601-1_2019"/> where it is referred to
as time shift.
The representation of a time zone displacement is effectively that of an ISO 8601 time shift.
</para>

<comment>WG3:W25-031R2</comment>
<comment>WG3:CMN-057R1</comment>
<comment>Editorial: Stefan Plantikow, 2025-04-06</comment>
<para>A datetime is assignable to a site of at least the material zoned datetime type or
the material local datetime type. 
<bar note="Editorial: Stefan Plantikow, 2025-04-06"/>
A date is assignable to a site of at least the material date type. 
<endbar/>
A time is assignable to a site of at least the material zoned time type or
the material local time type.
</para>

<comment>WG3:W25-031R2</comment>
<comment>WG3:CMN-048</comment>
<para>For the convenience of users, whenever a zoned datetime is to be implicitly derived from 
a local datetime (for example, in a simple assignment operation), GQL assumes the local
datetime to be given in the current time zone displacement <symdef>CTZD</symdef> (after implicitly
casting <sym>CTZD</sym> as a day and time-based duration), 
subtracts <sym>CTZD</sym> from it to give UTC, and associates <sym>CTZD</sym> to obtain 
the zoned datetime result.
</para>

<comment>WG3:CMN-048</comment>
<note>See <specref ref="gql_conc_temporal_durations"/>.
</note>

<comment>WG3:W25-031R2</comment>
<para>Conversely, whenever a local datetime is to be implicitly derived from a zoned datetime, 
GQL assumes the zoned datetime to be UTC, adds the time zone displacement to it to give local
time, and obtains the local datetime result.
</para>

<comment>WG3:W26-024 Removed 1 (one) paragraph</comment>

<comment>WG3:W26-024</comment>
<para>Temporal instants of the same most specific static value types are
essentially comparable values.
</para>

<comment>WG3:UTC-117 omitted to define</comment>
<para>A GQL-implementation regards certain <BNF name="temporal instant type"/>s as equivalent, if
they have the same indications regarding whether their values capture the date,
whether their values capture the time of day, whether their values include
a time zone displacement, and regarding the inclusion of the null value, as 
permitted by the Syntax Rules of <specref ref="gql_value_type"/>.
When two or more <BNF name="temporal instant type"/>s are equivalent, the GQL-implementation 
chooses one of these equivalent <BNF name="temporal instant type"/>s as the normal form 
representing that equivalence class of <BNF name="temporal instant type"/>s.
The normal form determines the preferred name of the temporal instant type in
the temporal instant data type descriptor.
</para>

</bodyMatter>

</subClause3>


<subClause3 id="gql_conc_temporal_durations">
<clauseHeading>Temporal duration types</clauseHeading>

<bodyMatter>

<comment>Editorial: Stephen Cannan, 2022-03-07 WG3:RKE-010 P00-USA-448</comment>
<comment>WG3:UTC-117</comment>
<comment>Editorial; Jim Melton, 2023-09-04; fix which/that problems</comment>
<comment>Editorial: Stefan Plantikow, 2023-10-10 Adjust for WG3:CMN-048</comment>
<para>The material values of temporal duration types are temporal duration values. 
A temporal duration captures a time difference, <ie/> a temporal amount in specified units
that represents the difference in time between two temporal instants.
It only captures the amount of time between two temporal instants; it does not capture
a start time and an end time.
A temporal duration value can be positive, zero, or negative.
</para>

<comment>WG3:CMN-048 Removed 1 (one) paragraph</comment>

<comment>WG3:CMN-048 Removed 1 (one) list</comment>

<comment>WG3:CMN-048</comment>
<para>Temporal durations capture time differences as exact numeric multiples of a few different
temporal duration units.
Every temporal duration only uses the temporal duration units from exactly one of the following
<newterm>temporal duration unit groups</newterm>:
</para>

<comment>WG3:CMN-048</comment>
<ulist>

<comment>WG3:CMN-048</comment>
<item>The <newterm>year and month-based duration unit group</newterm> which comprises
the following temporal duration units: Years and Months.
</item>

<comment>WG3:CMN-048</comment>
<item>The <newterm>day and time-based duration unit group</newterm> which comprises
the following temporal duration units: Days, Hours, Minutes, Seconds, and Subseconds
(Milliseconds, Microseconds, Nanoseconds).
</item>

</ulist>

<comment>WG3:CMN-048 Removed 1 (one) note</comment>

<comment>WG3:CMN-048</comment>
<note>These temporal duration unit groups are identical to the year-month and day-time interval
classes in <SQL/>.
</note>

<comment>WG3:CMN-048</comment>
<para>A <newterm>year and month-based duration</newterm> is a temporal duration specified using
temporal duration units from the year and month-based duration unit group only.
Similarly, a <newterm>day and time-based duration</newterm> is a temporal duration specified using
temporal duration units from the day and time-based duration unit group only.
</para>

<comment>WG3:CMN-048</comment>
<para>Conversion between temporal duration units is only possible between temporal duration units
from the same temporal duration unit group but not between temporal duration units from different
temporal duration unit groups (other than through applying a temporal duration to a point in time).
</para>

<comment>WG3:UTC-117</comment>
<para>Every temporal duration type is described by a temporal duration data type descriptor. 
A temporal duration data type descriptor comprises:
</para>

<comment>WG3:UTC-117</comment>
<ulist>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-057R1</comment>
<item>The declared name of the primary base type of all temporal duration types 
(TEMPORAL DURATION DATA).
</item>

<comment>WG3:CMN-048</comment>
<item>The temporal duration unit group of temporal durations of the type (one of: year and
month-based duration unit group or day and time-based duration unit group).
</item>

<comment>WG3:UTC-117</comment>
<item>The indication of whether the type includes the null value.
</item>

</ulist>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-048</comment>
<para>The format of temporal duration literals shall be either in accordance with
<docref ref="ISO8601-1_2019"/> and <docref ref="ISO8601-2_2019"/> or in accordance with
<docref ref="ISO9075-2_2023"/>.
</para>

<comment>WG3:UTC-117</comment>
<note>See <specref ref="gql_literals"/>.
</note>

<comment>WG3:CMN-048 Removed 1 (one) paragraph</comment>

<comment>WG3:CMN-048</comment>
<para>A <newterm>year and month-based duration type</newterm> is a temporal duration type 
that specifies the year and month-based duration unit group.
Similarly, a <newterm>day and time-based duration type</newterm> is a temporal duration type 
that specifies the day and time-based duration unit group.
</para>

<comment>WG3:CMN-048</comment>
<para>A year and month-based duration is assignable to a site of at least the material year and
month-based duration type.
Similarly, a day and time-based duration is assignable to a site of at least the material day
and time-based duration type.
</para>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-048</comment>
<comment>WG3:W26-024</comment>
<para>Temporal duration values whose specified units are of the same temporal duration unit group
are essentially comparable values.
</para>

</bodyMatter>

</subClause3>


<subClause3 id="gql_conc_temporal_ops">
<clauseHeading>Operators involving values of temporal types</clauseHeading>

<bodyMatter>

<comment>WG3:UTC-117</comment>
<para><specref ref="gql_conc_temp_ops"/>, specifies the declared types of
arithmetic expressions involving temporal instant, temporal duration, and number operands. 
</para>

<comment>Editorial: Stefan Plantikow, 2023-02-21 WG3:UTC-117 as minuted</comment>
<note>Regarding the subtraction of temporal instants, the difference between two temporal instants
given as <symdef>TI1</symdef> and <symdef>TI2</symdef> and assumed to be specifiable by
the <BNF name="datetime value expression"/>s <symdef>DVE1</symdef> and <symdef>DVE2</symdef>,
respectively, is the result of <kw>DURATION_BETWEEN</kw>(<sym>DVE1</sym>, <sym>DVE2</sym>).
See <specref ref="gql_durvalexp"/>.
</note>

<comment>WG3:UTC-117</comment>
<table id="gql_conc_temp_ops">
<tableTitle>Valid operators involving values of temporal types</tableTitle>

<table-common>

<table-setup numcols="4">
<table-coldef colnum="1" colwidth="1.7in"/>
<table-coldef colnum="2" colwidth="0.9in"/>
<table-coldef colnum="3" colwidth="1.7in"/>
<table-coldef colnum="4" colwidth="1.7in"/>
</table-setup>

<comment>WG3:CMN-019 P00-ISO-029</comment>
<table-heads>
<table-head> Operand 1 </table-head>
<table-head> Operator </table-head>
<table-head> Operand 2 </table-head>
<table-head> Result </table-head>
</table-heads>

</table-common>

<table-body>

<comment>WG3:UTC-117</comment>
<table-row>
<table-cell>temporal instant</table-cell>
<table-cell>-</table-cell>
<table-cell>temporal instant</table-cell>
<table-cell>temporal duration</table-cell>
</table-row>

<comment>WG3:UTC-117</comment>
<table-row>
<table-cell>temporal instant</table-cell>
<table-cell>+ or -</table-cell>
<table-cell>temporal duration</table-cell>
<table-cell>temporal instant</table-cell>
</table-row>

<comment>WG3:UTC-117</comment>
<table-row>
<table-cell>temporal duration</table-cell>
<table-cell>+</table-cell>
<table-cell>temporal instant</table-cell>
<table-cell>temporal instant</table-cell>
</table-row>

<comment>WG3:UTC-117</comment>
<table-row>
<table-cell>temporal duration</table-cell>
<table-cell>+ or -</table-cell>
<table-cell>temporal duration</table-cell>
<table-cell>temporal duration</table-cell>
</table-row>

<comment>WG3:UTC-117</comment>
<table-row>
<table-cell>temporal duration</table-cell>
<table-cell>* or /</table-cell>
<table-cell>number</table-cell>
<table-cell>temporal duration</table-cell>
</table-row>

<comment>WG3:UTC-117</comment>
<table-row>
<table-cell>number</table-cell>
<table-cell>*</table-cell>
<table-cell>temporal duration</table-cell>
<table-cell>temporal duration</table-cell>
</table-row>

</table-body>

</table>

<comment>WG3:UTC-117</comment>
<para>Arithmetic operations involving values of a temporal instant type or
a temporal duration type obey the rules associated with dates and times and yield valid temporal
instant or temporal duration results according to the Gregorian calendar as defined
in <docref ref="ISO8601-1_2019"/>.
</para>

<comment>WG3:UTC-117</comment>
<para>The details of subtracting one temporal instant from another temporal instant are specified
in this document.
The details of other operations involving temporal types are specified in
<docref ref="ISO8601-2_2019"/>.
</para>

<comment>WG3:UTC-117</comment>
<comment>WG3:W26-024</comment>
<para>Operations involving values of a temporal instant type require that the temporal instants
be essentially comparable values.
Operations involving values of a temporal duration type require that the temporal durations
be essentially comparable values.
</para>

<comment>WG3:UTC-117</comment>
<para>Operations involving a temporal instant and a temporal duration preserve
the time zone displacement of the temporal instant operand.
If the temporal instant operand does not include a time zone displacement, then the result
has no time zone displacement.
</para>

<comment>WG3:UTC-117</comment>
<para>Temporal instants and temporal durations that contain seconds have
an <impDef code="IL024"/> maximum seconds precision value that is not less than 6.
</para>

</bodyMatter>

</subClause3>

</subClause2>


<subClause2 id="gql_conc_vt_vec">
<clauseHeading>Vector types</clauseHeading>
   
<subClause3 id="gql_conc_vt_vec_intro">
<clauseHeading>Introduction to vectors</clauseHeading>

<bodyMatter>
 
<comment>WG3:POS-011R1</comment>
<para>A material value of a vector type is called a vector.
A vector contains 1 (one) or more <newterm>coordinates</newterm>.
The number of coordinates of a vector is referred to as
the <newterm>dimension</newterm> of the vector.
The coordinates within a vector are ordered such that each coordinate is assigned
a unique ordinal position,
which is an integer in the range between 1 (one) and the dimension of the vector.
Each coordinate of a given vector has the same declared type,
which is called the coordinate type of vector.
A coordinate type can be either a material <BNF name="numeric type"/> defined in this document or
a material <impDef code="IA011"/> numeric type, which may only be available within vector types.
</para>
   
<comment>WG3:POS-011R1</comment>
<note>While a vector type can be nullable, an individual coordinate of a vector cannot be
the null value.
</note>

<comment>WG3:POS-011R1</comment>
<para>Every vector type is described by its vector data type descriptor.
A vector data type descriptor comprises:
</para>

<ulist>

<item>The declared name of the primary base type of all vector types (VECTOR DATA).
</item>
   
<item>The preferred name of vector type (VECTOR).
</item>
   
<item>The dimension of the vector type.
</item>

<item>The coordinate type of the vector type.
</item>
   
<item>The indication of whether the vector type contains the null value.
</item>   

</ulist>

<comment>WG3:POS-011R1</comment>
<ednote id="PPgql438_1">Support for open vector types needs to be added.
See <PPref ref="PPgql438"/>.
</ednote>

</bodyMatter>

</subClause3>
      
      
<subClause3 id="gql_conc_vt_vec_comp">
<clauseHeading>Comparison and assignment of vectors</clauseHeading>

<bodyMatter>
   
<comment>WG3:POS-011R1</comment>
<para>Two vectors are comparable if and only if they have the same dimension and
their coordinate types are the same.
</para>

<comment>WG3:POS-011R1 Consequence</comment>
<para>A GQL-implementation is permitted to regard certain <BNF name="vector type"/>s as 
equivalent, if both have the same dimension, the same coordinate type, and the same indication
regarding the inclusion of the null value, as permitted by the Syntax Rules of
<specref ref="gql_value_type"/>. 
When two or more <BNF name="vector type"/>s are equivalent, the GQL-implementation chooses one
of these equivalent <BNF name="vector type"/>s as the normal form representing that equivalence
class of <BNF name="vector type"/>s.
</para>

<para>A vector of vector type <symdef>VT1</symdef> is assignable to
a site of vector type <symdef>VT2</symdef> if and only if
the dimension of <sym>VT1</sym> is equal to the dimension of <sym>VT2</sym> and
the coordinate type of <sym>VT1</sym> is the same as the coordinate type of <sym>VT2</sym>.
</para>

<!--
<para>Vector types have a defined order of coordinates.
Comparisons are defined in terms of this order.
This order defines the pairs of corresponding elements from the vectors being compared.
The order of the coordinates of a vector is implicitly defined by
the ordinal position of its coordinates.
In the case of comparison of two vectors <symdef>V1</symdef> and <symdef>V2</symdef>,
the coordinates are compared pairwise in order.
-->
<comment>WG3:POS-011R1</comment>
<para>The vectors of a vector type have an implicitly defined order.
This order is based on the ordinal positions of their coordinates. 
Comparisons rely on this order to pair corresponding coordinates from compared vectors.
Given two comparable vectors <symdef>V1</symdef> and <symdef>V2</symdef>,
it holds that <sym>V1</sym> = <sym>V2</sym> is <bool>True</bool> if and only if
<sym>V1</sym> and <sym>V2</sym> have the same dimension and contain corresponding coordinates
that are pairwise equal.
</para>

</bodyMatter>

</subClause3>


<subClause3 id="gql_conc_vt_vec_ops">
<clauseHeading>Operations involving vectors</clauseHeading>

<bodyMatter>

<comment>WG3:POS-011R1</comment>
<para><BNF name="vector value constructor"/> is an operation that constructs a vector
from a given character string.
</para>   
   
<comment>WG3:POS-011R1</comment>
<para><BNF name="vector serialize"/> is an operation that converts a vector to a character string.
</para>   
   
<comment>WG3:POS-011R1</comment>
<para><BNF name="vector dimension count"/> is an operation that returns the dimension of
the declared type of a given vector as an integer.
</para>   
 
<comment>WG3:POS-011R1</comment>
<para><BNF name="vector distance function"/> is an operation that, given two vectors and a metric,
returns the distance between the two vectors in the given metric as a number.
</para>   

<comment>WG3:POS-011R1</comment>
<note>A <BNF name="vector distance function"/> is not necessarily a metric as
the term is used in mathematics, particularly as in vector spaces.
For example, the result can be negative, it can be zero for two vectors that are not equal, and
it is possible that the triangle inequality does not hold.
Instead, the <BNF name="vector distance function"/>s are the inverses of
vector similarity functions.
In general, the smaller the result of a <BNF name="vector distance function"/>, the more similar 
the two vectors are according the corresponding vector similarity function.
Only the relative order of values returned by <BNF name="vector distance function"/>
can be relied on for distance functions that are not true metrics.
</note>

<comment>WG3:POS-011R1</comment>
<para><BNF name="vector norm function"/> is an operation that, given a vector and a metric,
returns the distance between the vector and the zero vector
(<ie/> the vector whose components each are 0 (zero) in the given metric).
</para>   

</bodyMatter>

</subClause3>

</subClause2>


<comment>Editorial: Stefan Plantikow, 2021-06-17 Adjusted for WG3:W12-029</comment>
<comment>WG3:W23-037</comment>
<subClause2 id="gql_conc_vt_ref">
<clauseHeading>Reference value types</clauseHeading>

<bodyMatter>

<comment>WG3:BER-040R3</comment>
<comment>Editorial: Stefan Plantikow, 2022-08-16 Aligned with W22-053R2</comment>
<comment>Editorial: Stefan Plantikow, 2022-11-21 WG3:W24-009 499. P00-USA-276</comment>
<comment>WG3:CMN-019 P00-USA-007</comment>
<comment>WG3:CMN-057R1</comment>
<para>A material value of a reference value type is a reference value. 
A reference value is a globally resolved reference that effectively represents a reference to some
globally identifiable object (its referent) by opaquely encapsulating its referent<apos/>s
global object identifier. 
</para>

<comment>WG3:BER-040R3</comment>
<comment>WG3:CMN-057R1</comment>
<para>The GQL language supports the following kinds of reference values:
</para>

<comment>WG3:CMN-057R1</comment>
<ulist>

<comment>WG3:W22-051</comment>
<item>Graph reference values whose referents are graphs.
</item>

<comment>Editorial: Stefan Plantikow, 2022-08-17 Added omitted entry</comment>
<item>Binding table reference values whose referents are binding tables.
</item>

<item>Node reference values whose referents are nodes.
</item>

<item>Edge reference values whose referents are edges.
</item>

</ulist>

<para>Every reference value type is described by a reference value data type descriptor. 
A reference value data type descriptor comprises:
</para>

<ulist>

<comment>WG3:OHD-023</comment>
<item>The <newterm>reference base type name</newterm> of the reference value type. 
This name always ends with the word REFERENCE.
</item>

<comment>WG3:UTC-111</comment>
<comment>WG3:POS-012</comment>
<item>The <newterm>object base type name</newterm> of the reference value type. 
This name is the name of the common base type of the GQL-object types of the reference value type.

<note>In this document, the reference base type name and the object base type name of 
a reference value type always have the same base type name prefix.
</note>

</item>

<comment>WG3:W27-013</comment>
<item>The preferred name of the reference value type.
</item>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:UTC-111</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<comment>Email from: Stefan Plantikow, 2023-11-28 1549</comment>
<comment>WG3:POS-012</comment>
<item>The optional <newterm>constraining GQL-object type</newterm> of the reference value type. 
The name of the primary base type of this GQL-object type is the object base type name.

<comment>WG3:W27-013</comment>
<note>In this document, the preferred name of the reference value type and the constraining 
GQL-object type (if any) are the same.
</note>

</item>

<item>The indication of whether the type contains the null value.
</item>

</ulist>

<comment>WG3:W25-031R2</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<comment>WG3:CMN-057R1</comment>
<para>A reference value whose referent is <symdef>O</symdef> is assignable to a site that is 
at least of some material reference value type <symdef>RVT</symdef> whose object base type is 
<symdef>OBT</symdef> if the primary base type of <sym>O</sym> is <sym>OBT</sym> and, 
given that <sym>RVT</sym> has a constraining GQL-object type <symdef>COT</symdef>, it holds that 
<sym>O</sym> is assignable to <sym>COT</sym>.
</para>

</bodyMatter>

</subClause2>


<comment>WG3:W26-026R2</comment>
<subClause2 id="gql_immat_null_empty_dts">
<clauseHeading>Immaterial value types: null type and empty type</clauseHeading>

<bodyMatter>

<para>The immaterial value types defined in this document are the <newterm>null type</newterm> and 
the <newterm>empty type</newterm>.
The null type is the (nullable) value type comprising the (single) null value shared by all
nullable types. 
The empty type is the material variant of the null type. 
Hence, the empty type comprises no values (is the empty set) and a <BNF name="value expression"/> 
whose declared type is the empty type cannot be evaluated. 
In this document, the empty type is primarily used as the declared type of omitted results but it 
may also occur as a column type of an empty binding table in the GQL-catalog. 
Supported property value types are non-immaterial value types by definition.
</para>

<note>See <specref ref="gql_conc_material_vals"/>.
</note>

<para>The null type is a subtype of every nullable value type and the empty type is a subtype of
every value type.
</para>

<para>The immaterial value types are only provided by GQL-implementations that support the
<feature code="GV70"/>. 
In such GQL-implementations, the null type provides a portable most specific value type for 
various values (<eg/> certain constructed values such as empty list values or the null value).
</para>

<para>Every immaterial value type is described by its immaterial data type descriptor. 
An immaterial data type descriptor comprises:
</para>

<ulist>

<item>The declared name of the primary base type of all immaterial types (NULL DATA).
</item>

<item>The preferred name of the immaterial type (NULL for the null type and NOTHING for the
empty type).
</item>

<item>The indication of whether the type includes the null value.
</item>

</ulist>

<para>A GQL-implementation regards certain <BNF name="immaterial value type"/>s as equivalent, 
if they have the same indication regarding the inclusion of the null value, as permitted by the 
Syntax Rules of <specref ref="gql_value_type"/>. 
When two or more <BNF name="immaterial value type"/>s are equivalent, the GQL-implementation 
chooses one of these equivalent <BNF name="immaterial value type"/>s as the normal form 
representing that equivalence class of <BNF name="immaterial value type"/>s.
</para>

<comment>WG3:W26-024</comment>
<comment>WG3:W27-013</comment>
<para>For every value <symdef>V</symdef> it holds that the null value and <sym>V</sym> are 
essentially comparable values.
</para>

<para>A null value is assignable to a site of at least a nullable type. 
The instance occupying a site whose declared type is the empty type cannot be assigned nor 
determined.
</para>

</bodyMatter>

</subClause2>

</subClause>


<comment>Editorial: Stefan Plantikow, 2020-04-07 Adopted from SQL/Foundation</comment>
<subClause id="gql_conc_sites">
<clauseHeading>Sites</clauseHeading>
<comment>WG3:RKE-048 Remove one Editor's Note</comment>

<subClause2 id="gql_conc_sites_gendescr">
<clauseHeading>General description of sites</clauseHeading>

<bodyMatter>

<comment>DBL:LGW-027R2/X3H2-97-146</comment>
<comment>DBL:CWB-119/X3H2-98-174</comment>
<comment>Email from: Phil Brown, 2006-12-11</comment>
<comment>WG3:BER-019</comment>
<comment>WG3:W25-031R2</comment>
<para>A site is a <repeatdefn ref="gql_site_defn"/>.
Every site has a defined degree of persistence, independent of its declared type 
(if it has a declared type).
A site that exists until deliberately destroyed is said to be persistent.
A site that necessarily ceases to exist on completion of a statement,
at the end of a GQL-transaction, or at the end of a GQL-session is said to be temporary.
A site that exists only for as long as necessary to hold a GQL-object or a value
during the execution of an operation is said to be <newterm>transient</newterm>.
</para>

</bodyMatter>

</subClause2>


<subClause2 id="gql_conc_sites_kinds">
<clauseHeading>Static and dynamic sites</clauseHeading>

<bodyMatter>

<comment>WG3:UTC-110</comment>
<comment>WG3:CMN-042</comment>
<comment>WG3:CMN-057R1</comment>
<para>Every site is either a <newterm>static site</newterm> or a <newterm>dynamic site</newterm>.
A static site is a site occupied by an instance known or determined during the application of 
Syntax Rules. 
A dynamic site is a site occupied by instances known or determined during the application of 
General Rules.
</para>

<comment>WG3:UTC-110</comment>
<para>The GQL language defines and interacts with the following kinds of
static sites:
</para>

<ulist>

<item>Session parameters.
</item>

<item>Request parameters.
</item>

<item>Working schemas.
</item>

<item>The values of <BNF name="value specification"/>s.
</item>

<comment>WG3:CMN-042</comment>
<item>Sites that are occupied by primary objects in the GQL-catalog.
</item>

</ulist>

<comment>WG3:UTC-110</comment>
<para>Every other site is a dynamic site.
</para>

</bodyMatter>

</subClause2>


<comment>DBL:BBN-163/X3H2-98-382</comment>
<comment>WG3:W25-031R2</comment>
<subClause2 id="gql_conc_ass_mut">
<clauseHeading>Assignment and store assignment</clauseHeading>

<bodyMatter>

<comment>DBL:LGW-027R2/X3H2-97-146</comment>
<comment>Email from: Phil Brown, 2006-12-11</comment>
<para>The value at a site is set by the operation of assignment.
Assignment initializes or replaces the value at a site <symdef>T</symdef> (known as the target) 
whose declared type is <symdef>DT</symdef> with a new (possibly different) value <symdef>S</symdef>
(known as the source).
</para>

<note>GQL-objects are inserted or removed (<eg/> into the GQL-schema or other GQL-objects) but 
never assigned. 
However, reference values to GQL-objects are subject to provisions regarding assignment.
</note>

<para>There are two kinds of assignment:
</para>

<ulist>

<comment>Editorial; Jim Melton, 2023-09-04; fix which/that problems</comment>
<item>Regular assignment, which is frequently indicated by using the phrases 
<quote><sym>T</sym> is assigned to <sym>S</sym></quote>, 
<quote>the value of <sym>T</sym> is assigned to <sym>S</sym></quote>, or 
<quote>the value of <sym>S</sym> assigned from <sym>T</sym></quote>. 
</item>

<comment>Editorial; Jim Melton, 2023-09-04; fix which/that problems</comment>
<item>Store assignment, which is always performed by explicitly calling the General Rules
of <specref ref="gql_store"/>.
</item>

</ulist>

<para>By default, assignment is regular assignment.
</para>

<para>If <sym>S</sym> is included in <sym>DT</sym>, then <sym>S</sym> is assigned to <sym>T</sym> 
as is. 
If <sym>S</sym> is not included in <sym>DT</sym> but the result <symdef>S1</symdef> of
converting <sym>S</sym> to <sym>DT</sym> using relevant type conversions is defined, then 
<sym>S1</sym> is assigned to <sym>T</sym> (instead of <sym>S</sym>). 
Otherwise, <sym>S</sym> is not assignable to <sym>T</sym>. 
In particular, the null value is only assignable to a site whose declared type is nullable.
</para>

<comment>WG3:CMN-057R1</comment>
<para>The relevant type conversions used depend on the kind of assignment that is being
performed. 
(Regular) assignment applies type conversions that are specified as part of provisions on the 
assignment of values of individual value types in <specref ref="gql_conc_dyn_union_type"/>, 
<specref ref="gql_conc_constr"/>, and <specref ref="gql_conc_vt_predef"/>, while 
store assignment applies the type conversions specified in the General Rules of 
<specref ref="gql_store"/>.
</para>

</bodyMatter>

</subClause2>


<subClause2 id="gql_conc_nullability">
<clauseHeading>Nullability</clauseHeading>

<comment>WG3:UTC-051</comment>
<subClause3 id="gql_conc_nullability_intro">
<clauseHeading>Introduction to nullability</clauseHeading>

<bodyMatter>

<comment>DBL:LGW-027R2/X3H2-97-146</comment>
<comment>Email from: Phil Brown, 2006-12-11</comment>
<comment>WG3:BER-019</comment>
<comment>WG3:UTC-051</comment>
<comment>WG3:CMN-057R1</comment>
<para>Every site has a <newterm>nullability</newterm> characteristic that indicates
whether the site may be occupied by the null value (is <newterm>possibly nullable</newterm>) or
not (is <newterm>known not nullable</newterm>).
A nullability <symdef>N1</symdef> is assignment-aligned to a nullability <symdef>N2</symdef> 
if and only if either <sym>N1</sym> and <sym>N2</sym> are the same nullability or it holds that 
<sym>N1</sym> is known not nullable and <sym>N2</sym> is possibly nullable.
In this document, the nullability of a site <symdef>S</symdef> is defined as follows. 
If the data type descriptor of the declared type <symdef>DT</symdef> of <sym>S</sym> includes 
an indication <symdef>IND</symdef> regarding the inclusion of the null value in <sym>DT</sym>, then
the nullability of <sym>S</sym> is as specified by <sym>IND</sym>; otherwise, <sym>S</sym> is 
known not nullable.
</para>

</bodyMatter>

</subClause3>


<subClause3 id="gql_conc_nullability_req">
<clauseHeading>Nullability requirements</clauseHeading>

<bodyMatter>

<para>If a Syntax Rule requires the declared type <symdef>DT</symdef> of a site <symdef>S</symdef>
to be of some required type <symdef>RT</symdef>, then the nullability of <sym>DT</sym> needs to be 
assignment-aligned with the nullability of <sym>RT</sym>.
</para>

<note>For example, this is the case if <sym>DT</sym> is the material variant of <sym>RT</sym>. 
This is a consequence of subtyping since every material type is a subtype of its nullable variant.
</note>

<ednote id="PPgql356_1">Syntax rules determining the declared type of sites should be revisited to
improve and specify (where lacking) the inference of the nullability of those sites.
See <PPref ref="PPgql356"/>.
</ednote>

</bodyMatter>

</subClause3>


<subClause3 id="gql_conc_nullability_infer">
<clauseHeading>Nullability inference</clauseHeading>

<bodyMatter>

<para>A type stated in this document without explicitly specifying its nullability implies its 
nullable variant by default and accordingly all sites of such a type are possibly nullable. 
However, the implied default nullability of a type of a site may be overridden by the following 
provision.
</para>

<para>If a Syntax Rule <symdef>RULE</symdef> originally determines (infers) the declared type of 
a site <symdef>S</symdef> to be some type <symdef>T</symdef> without explicitly specifying the 
nullability of <sym>T</sym>, then
</para>

<para>Case:
</para>

<olist>

<item>If an <impDef code="IW022"/> mechanism immediately after the determination made by 
<sym>RULE</sym> regarding the nullability of the declared type of <sym>S</sym> establishes that 
the null value is not going to be assigned to <sym>S</sym> by the application of General Rules, 
then the declared type of <sym>S</sym> is specialized to be the material variant of <sym>T</sym> 
(instead of <sym>T</sym>).

<note>This effectively overrides the original determination made by <sym>RULE</sym> regarding the 
nullability of the declared type of <sym>S</sym>.
</note>
</item>

<item>Otherwise, the declared type of <sym>S</sym> (implicitly) is the nullable variant of 
<sym>T</sym>.

<note>This preserves the original determination made by <sym>RULE</sym> regarding the nullability 
of the declared type of <sym>S</sym>.
</note>

</item>

</olist>

<note>These provisions only allow the relaxation of Syntax Rules that determine (infer)
declared types. 
Syntax Rules imposing requirements on declared types of sites are not affected.
</note>

</bodyMatter>

</subClause3>

</subClause2>

</subClause>

</clause>


<clause id="gql_not_conv">
<clauseHeading>Notation and conventions</clauseHeading>

<comment>Editorial: Stephen Cannan 2022-05-24 </comment>
<subClause id="gql_notation_unicode">
<clauseHeading>Notation taken from <docref ref="Unicode"/></clauseHeading>

<bodyMatter>

<para>The notation for the representation of UCS code points and sequences of code points 
is defined in <docref ref="Unicode"/>, Appendix A, <quote>Notational Conventions</quote>.
</para>

<para>In this document, this notation is used only to unambiguously identify characters and is not
meant to imply a specific encoding for any GQL-implementation<apos/>s use of that character.
</para>

</bodyMatter>

</subClause>


<subClause id="gql_notation">
<clauseHeading>Notation</clauseHeading>

<bodyMatter>

<para>The syntactic notation used in this document is an extended version of BNF
(<quote>Backus Normal Form</quote> or <quote>Backus Naur Form</quote>).
</para>

<comment>WG3:CMN-035</comment>
<para>In a BNF language definition, each syntactic element,
known as  a <newterm>BNF non-terminal symbol</newterm>, of the language is defined by means of
a <newterm>production rule</newterm>.
This defines the syntactic element in terms of a formula consisting of the characters,
character strings, and elements that can be used to form an instance,
known as a <newterm>BNF non-terminal instance</newterm>, of it.
</para>

<comment>Editorial: Stephen Cannan, 2021-01-21 Apply required bits of WG3:ARK-011</comment>
<para>In the version of BNF used in this document, the following symbols have the meanings shown in
<specref ref="gql_bnf_descr"/>.
</para>

<table id="gql_bnf_descr">
<tableTitle>Symbols used in BNF</tableTitle>

<table-common>

<table-setup numcols="2">
<table-coldef colnum="1" colwidth="48pt"/>
<table-coldef colnum="2" colwidth="6.0in"/>
</table-setup>

<comment>WG3:CMN-019 P00-ISO-029</comment>
<table-heads>
<table-head> Symbol </table-head>
<table-head> Meaning </table-head>
</table-heads>

</table-common>

<table-body>

<comment>WG3:CMN-035</comment>
<table-row>
<table-cell> <mono>&lt; &gt;</mono> </table-cell>
<table-cell>A character string enclosed in angle brackets is the name of a syntactic element
(<ie/> the name of a BNF non-terminal symbol) of the GQL language.
</table-cell>
</table-row>

<table-row>
<table-cell> <mono>::=</mono> </table-cell>
<table-cell>The definition operator is used in a production rule to separate the element defined by
the rule from its definition.
The element being defined appears to the left of the operator and the formula that defines the 
element appears to the right.
</table-cell>
</table-row>

<table-row>
<table-cell> <mono>[ ]</mono> </table-cell>
<table-cell>Square brackets indicate optional elements in a formula.
The portion of the formula within the brackets may be explicitly specified or may be omitted.
</table-cell>
</table-row>

<table-row>
<table-cell> <mono>{ }</mono> </table-cell>
<table-cell>Braces group elements in a formula.
The portion of the formula within the braces shall be explicitly specified.
</table-cell>
</table-row>

<table-row>
<table-cell> <mono>|</mono> </table-cell>
<table-cell>The alternative operator.
The vertical bar indicates that the portion of the formula following the bar is 
an alternative to the portion preceding the bar.
If the vertical bar appears at a position where it is not enclosed in braces or square brackets, 
it specifies a complete alternative for the element defined by the production rule.
If the vertical bar appears in a portion of a formula enclosed in braces or square brackets,
it specifies alternatives for the content of the innermost pair of such braces or brackets.
</table-cell>
</table-row>

<table-row>
<table-cell> <mono><repeat/></mono> </table-cell>
<table-cell>The ellipsis indicates that the element to which it applies in a formula may be
repeated any number of times.
If the ellipsis appears immediately after a closing brace <quote>}</quote>, then it applies to 
the portion of the formula enclosed between that closing brace and the corresponding opening brace 
<quote>{</quote>.
If an ellipsis appears after any other element, then it applies only to that element.
In Syntax Rules, <!-- Access Rules, --> General Rules, and Conformance Rules, a reference to the 
<emph>n</emph>-th element in such a list assumes the order in which these are specified, unless 
otherwise stated.
</table-cell>
</table-row>

<comment>WG3:W21-059</comment>
<table-row>
<table-cell> <mono>!!</mono> </table-cell>
<table-cell>Introduces either a reference to the Syntax Rules, used when the definition of
a syntactic element is not expressed in BNF, or the Unicode code point or code point sequence
that define the character(s) of the BNF production.
</table-cell>
</table-row>

</table-body>

</table>

<comment>Editorial: Stephen Cannan, 2021-01-21 Compatibility with 9075</comment>
<para>Whitespace is used to separate syntactic elements.
Multiple whitespace characters are treated as a single space.
Apart from those symbols to which special functions were given above, other characters and
character strings in a formula stand for themselves.
In addition, if the symbols to the right of the definition operator in a production consist
entirely of BNF symbols, then those symbols stand for themselves and do not take on their special
meaning.
</para>

<para>Pairs of braces and square brackets may be nested to any depth, and the alternative operator
may appear at any depth within such a nest.
</para>
<comment>Editorial: Stefan Plantikow, 2022-02-21 WG3:W20-010 P00-USA-630, P00-NLD-045</comment>

<comment>Editorial: Stefan Plantikow, Sept 2019</comment>
<comment>Editorial: Stefan Plantikow 2023-10-16 Dropped redundant syntactic</comment>
<para>A character string that forms an instance of a syntactic element may be generated from the
BNF definition of that element by application of the following steps:
</para>

<olist>

<item id="gql_bnf_sel">Select any one option from those defined in the right hand side of 
a production rule for the element, and replace the element with this option.
</item>

<item>Replace each ellipsis and the object to which it applies with one or more instances of that
object.
</item>

<item>For every portion of the character string enclosed in square brackets, either delete the 
brackets and their contents or change the brackets to braces.
</item>

<comment>WG3:CMN-035</comment>
<item>For every portion of the character string enclosed in braces, apply
<itemref ref="gql_bnf_sel" type="step"/> through <itemref ref="gql_bnf_app" type="step"/> to the
substring between the braces, then remove the braces.
</item>

<comment>WG3:CMN-035</comment>
<item id="gql_bnf_app">Apply <itemref ref="gql_bnf_sel" type="step"/> through
<itemref ref="gql_bnf_app" type="step"/> to any element whose BNF definition generates what remains
in the character string.
</item>

</olist>

<comment>WG3:CMN-035</comment>
<para>The expansion or production is complete when there is no further syntactic element
whose BNF definition generates what remains in the character string.
</para>

<comment>WG3:W23-014</comment>
<comment>WG3:CMN-035</comment>
<para>The left normal form derivation of a character string in the GQL source text 
character repertoire that is generated from the BNF definition of
a BNF non-terminal symbol <symdef>NT</symdef> is obtained by applying <itemref ref="gql_bnf_sel"
type="step"/> through <itemref ref="gql_bnf_app" type="step"/> above to <sym>NT</sym>, always
selecting in <itemref ref="gql_bnf_app" type="step"/> the leftmost BNF non-terminal symbol.
</para>

<comment>Editorial: Stefan Plantikow 2023-03-23 Link artifacts</comment>
<para><digitalArtifact type="BNFText"/>
</para>

</bodyMatter>

</subClause>


<subClause id="gql_conv">
<clauseHeading>Conventions</clauseHeading>


<subClause2 id="gql_syntactic_elements">
<clauseHeading>Specification of syntactic elements</clauseHeading>

<bodyMatter>

<para>Syntactic elements are specified in terms of:
</para>

<ulist>

<item><bold>Function</bold>: A short statement of the purpose of the element.
</item>

<item><bold>Format</bold>: A BNF definition of the syntax of the element.
</item>

<item><bold>Syntax Rules</bold>: A specification in English of the syntactic properties of the
element.
These include rules for the following aspects that are specified in the sequence given:

<comment>Editorial: Stephen Cannan, 2022-02-25 W20-010 P00-USA-449</comment>
<ulist>

<item>The expansion of syntactic short-hand forms.
</item>

<item>The normalization of syntactic forms.
</item>

<item>Additional syntactic constraints, not expressed in BNF, that the element shall satisfy.
</item>

<item>The visibility or scope of identifiers.
</item>

<item>Specifying or defining the type of elements.
</item>

</ulist>

</item>

<item><bold>General Rules</bold>: A specification in English of the run-time effect of the element.
Where more than one General Rule is used to specify the effect of an element, the required effect
is that which would be obtained by beginning with the first General Rule and applying the Rules in
numeric sequence unless a Rule is applied that specifies or implies a change in sequence or
termination of the application of the Rules.
Unless otherwise specified or implied by a specific Rule that is applied, application of General
Rules terminates when the last in the sequence has been applied.
</item>

<comment>Editorial: Stephen Cannan, 2021-08-10 Adopt improved wording from SQL/Framework</comment>
<comment>WG3:UTC-048R1</comment>
<item><bold>Conformance Rules</bold>: A specification of how the element shall be supported for
conformance to GQL.
Conformance Rules are effectively a kind of Syntax Rule, differentiated only because of their use to
specify conformance to the GQL language. 
Conformance Rules in a given Subclause are therefore always applied before the Syntax Rules 
of that Subclause, and are not normally applied to the result of syntactic transformations. 
However, in a few cases, Conformance Rules are explicitly applied to syntactic transformations
as defined in the Syntax Rules.
</item>

</ulist>

<comment>Editorial: Stephen Cannan, 2022-02-25 W20-010 P00-USA-450</comment>
<para>The scope of notational symbols is the Subclause in which those symbols are defined.
Within a Subclause, the symbols defined in Syntax Rules<!--, Access Rules, --> or
General Rules can be referenced in other rules provided that they are defined before
being referenced.
</para>

</bodyMatter>

</subClause2>

<comment>WG3:W23-034 One Subclause removed</comment>

<subClause2 id="gql_use_of_terms">
<clauseHeading>Use of terms</clauseHeading>


<subClause3 id="gql_containment">
<clauseHeading>Syntactic containment</clauseHeading>

<bodyMatter>

<para>Let <BNF name="A"/>, <BNF name="B"/>, and <BNF name="C"/> be syntactic elements;
let <symdef>A1</symdef>, <symdef>B1</symdef>, and <symdef>C1</symdef> respectively be instances 
of <BNF name="A"/>, <BNF name="B"/>, and <BNF name="C"/>.
</para>

<para>In a Format, <BNF name="A"/> is said to <newterm>immediately contain</newterm>
<BNF name="B"/> if <BNF name="B"/> appears on the right-hand side of the BNF production rule for
<BNF name="A"/>.
An <BNF name="A"/> is said to <newterm>contain</newterm> or <newterm>specify</newterm>
<BNF name="C"/> if <BNF name="A"/> immediately contains <BNF name="C"/> or if <BNF name="A"/>
immediately contains a <BNF name="B"/> that contains <BNF name="C"/>.
</para>

<para>In GQL language, <sym>A1</sym> is said to <newterm>immediately contain</newterm>
<sym>B1</sym> if <BNF name="A"/> immediately contains <BNF name="B"/> and
<sym>B1</sym> is part of the text of <sym>A1</sym>.
<sym>A1</sym> is said to <newterm>contain</newterm> or <newterm>specify</newterm>
<sym>C1</sym> if <sym>A1</sym> immediately contains <sym>C1</sym> or
if <sym>A1</sym> immediately contains <sym>B1</sym> and <sym>B1</sym> contains <sym>C1</sym>.
If <sym>A1</sym> contains <sym>C1</sym>, then <sym>C1</sym> is <newterm>contained in</newterm>
<sym>A1</sym> and <sym>C1</sym> is <newterm>specified by</newterm> <sym>A1</sym>.
</para>

<para><sym>A1</sym> is said to contain <sym>B1</sym>
<newterm>with an intervening instance of</newterm> <BNF name="C"/> if <sym>A1</sym> contains
<sym>B1</sym> and <sym>A1</sym> contains an instance of <BNF name="C"/> that contains
<sym>B1</sym>.
<sym>A1</sym> is said to contain <sym>B1</sym>
<newterm>without an intervening instance of</newterm> <BNF name="C"/> if <sym>A1</sym> contains
<sym>B1</sym> and <sym>A1</sym> does not contain an instance of <BNF name="C"/> that contains
<sym>B1</sym>.
</para>

<para><sym>A1</sym> <newterm>simply contains</newterm> <sym>B1</sym> if <sym>A1</sym> contains
<sym>B1</sym> without an intervening instance of <BNF name="A"/> or an intervening instance of
<BNF name="B"/>.
If <sym>A1</sym> simply contains <sym>B1</sym>, then <sym>B1</sym> is 
<newterm>simply contained in</newterm> <sym>A1</sym>.
</para>

<comment>WG3:RKE-044R1</comment>
<para><sym>A1</sym> <newterm>directly contains</newterm> <sym>B1</sym> if <sym>A1</sym> contains
<sym>B1</sym> without an intervening instance of <BNF name="procedure body"/>.
If <sym>A1</sym> directly contains <sym>B1</sym>, then <sym>B1</sym> is 
<newterm>directly contained in</newterm> <sym>A1</sym>.
</para>

<para>If an instance of <BNF name="A"/> contains an instance of <BNF name="B"/>,
then <BNF name="B"/> is said to be <newterm>contained in</newterm> <BNF name="A"/> and
<BNF name="A"/> is said to be a <newterm>containing</newterm> production symbol for
<BNF name="B"/>.
If an instance of <BNF name="A"/> simply contains an instance of <BNF name="B"/>,
then <BNF name="B"/> is said to be <newterm>simply contained in</newterm>
<BNF name="A"/> and <BNF name="A"/> is said to be a <newterm>simply containing</newterm>
production symbol for <BNF name="B"/>.
If an instance of <BNF name="A"/> directly contains an instance of <BNF name="B"/>,
then <BNF name="B"/> is said to be <newterm>directly contained in</newterm>
<BNF name="A"/> and <BNF name="A"/> is said to be a <newterm>directly containing</newterm>
production symbol for <BNF name="B"/>.
</para>

<para><sym>A1</sym> is the <newterm>innermost</newterm> <BNF name="A"/> satisfying a condition
<symdef>C</symdef> if <sym>A1</sym> satisfies <sym>C</sym> and <sym>A1</sym> does not contain 
an instance of <BNF name="A"/> that satisfies <sym>C</sym>.
<sym>A1</sym> is the <newterm>outermost</newterm> <BNF name="A"/> satisfying a condition
<sym>C</sym> if <sym>A1</sym> satisfies <sym>C</sym> and <sym>A1</sym> is not contained in 
an instance of <BNF name="A"/> that satisfies <sym>C</sym>.
</para>


<para>In a Format, the verb <quote>to be</quote> (including all its grammatical variants, such as
<quote>is</quote>) is defined as follows.
<BNF name="A"/> is said to be <BNF name="B"/> if there exists a BNF production rule of the form 
<mono><BNF name="A"/> ::= <BNF name="B"/></mono>.
If <BNF name="A"/> is <BNF name="B"/> and <BNF name="B"/> is <BNF name="C"/>, then <BNF name="A"/>
is <BNF name="C"/>.
If <BNF name="A"/> is <BNF name="C"/>, then <BNF name="C"/> is said to <newterm>constitute</newterm>
<BNF name="A"/>.
In GQL language, <symdef>A1</symdef> is said to be <symdef>B1</symdef> if <BNF name="A"/> is
<BNF name="B"/> and the text of <sym>A1</sym> is the text of <sym>B1</sym>.
Conversely, <sym>B1</sym> is said to <newterm>constitute</newterm> <sym>A1</sym> if <sym>A1</sym>
is <sym>B1</sym>.
</para>

</bodyMatter>

</subClause3>


<comment>Editorial: Stephen Cannan, 2023-07-11, Standardize the spelling of keyword</comment>
<subClause3 id="gql_keywords">
<clauseHeading>Keywords and <BNF name="keyword"/>s</clauseHeading>

<bodyMatter>

<para>In the text (including the Format sections) of this document, certain syntax 
elements are used to specify GQL statements and parts of GQL expressions.
Those syntax elements are called <quote>keyword</quote>s.
They are used either to identify the GQL statement being specified or to identify details of the
syntax of statements and expressions.
</para>

<para>In this document, the word <quote>keyword</quote> is used to refer to those syntax 
elements, and the BNF non-terminal symbol <quote><BNF name="keyword"/></quote> is used 
when the definition or use of a keyword in a Format is referenced.
Throughout this document, all keywords are specified using only upper-case letters; 
for example, <quote><kw>MATCH</kw></quote> is a keyword.
</para>

<para>In GQL syntax, a keyword spelled using one or more lower-case letters is equivalent to 
spelling it with every lower-case letter replaced with its corresponding upper-case letter.
For example, <quote>mATch</quote>, when used as a keyword, is identical in effect to 
<quote>MATCH</quote>.
</para>

</bodyMatter>

</subClause3>


<subClause3 id="gql_sr_ar_reqs">
<clauseHeading>Terms denoting rule requirements</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-05-05 Removed mentioning of Access Rules</comment>
<comment>WG3:W10-010R1</comment>
<comment>WG3:W19-017</comment>
<comment>WG3:CMN-061R1</comment>
<para>In the Syntax Rules, the term <newterm>shall</newterm> defines conditions that are required
to be true of syntactically conforming GQL language.
When such conditions depend on the contents or the structure of the GQL-catalog or the descriptors
of GQL-objects reachable via the GQL-catalog, the GQL-session context, or the GQL-request context,
they are required to be true just before the actions specified by the General Rules are performed.
The treatment of language that does not conform to the Formats and Syntax Rules is
<impDef code="IE005"/>.
If any condition required by Syntax Rules is not satisfied when the application of 
General Rules is attempted and the GQL-implementation is neither processing non-conforming GQL
language nor processing conforming GQL language in a non-conforming manner, then an exception
condition is raised as specified in <specref ref="gql_conc_req_exe"/>.
</para>

<!-- To be uncommented when Access Control is defined.
<para>In the Access Rules, the term <newterm>shall</newterm> defines conditions that
are required to be satisfied for the successful application of the General Rules.
If any such condition is not satisfied when the General Rules are applied, then an exception
condition is raised: <raise class="42"/>.
</para>
-->

<comment>Editorial: Stephen Cannan, 2021-03-12 Compatibility with SQL/Framework</comment>
<comment>Editorial: Stephen Cannan, 2025-03-27 Use consistent terminology</comment>
<para>In the Conformance Rules, the term <newterm>shall</newterm> defines conditions that are
required to be satisfied if the named optional Feature is or Features are not supported.
</para>

</bodyMatter>

</subClause3>


<subClause3 id="gql_eval_order">
<clauseHeading>Rule evaluation order</clauseHeading>

<bodyMatter>

<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<para>A conforming GQL-implementation is not required to perform the exact sequence of actions
defined in the General Rules, provided its effect on GQL-data and the GQL-catalog is identical to
the effect of that sequence.
The term <newterm>effectively</newterm> is used to emphasize actions whose effect may
be achieved in other ways by a GQL-implementation.
</para>

<comment>Editorial: Stephen Cannan, 2021-08-10 Adopt improved wording from SQL/Framework</comment>
<comment>WG3:UTC-048R1</comment>
<para>The Conformance Rules for contained syntactic elements are effectively applied at the same 
time as the Conformance Rules for the containing syntactic elements.
Similarly the Syntax Rules <!-- and Access Rules --> for contained syntactic elements are 
effectively applied at the same time as the Syntax Rules <!-- and Access Rules --> for the 
containing syntactic elements.
The General Rules for contained syntactic elements are effectively applied before the
General Rules for the containing syntactic elements.
</para>

<para>Where the precedence of operators is determined by the Formats of this document or by
parentheses, those operators are effectively applied in the order specified by that precedence.
</para>

<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>WG3:CMN-019 P00-ISO-001</comment>
<para>Where the precedence is not determined by the Formats or by parentheses, effective
evaluation of expressions is <emph>generally</emph> performed from left to right.
However, it is <unDef code="US008"/> whether expressions are <emph>actually</emph> evaluated
left to right, particularly when the evaluation of operands or operators causes conditions to be
raised or if the results of the expressions can be determined without completely evaluating all
parts of the expression.
</para>

<comment>Editorial: Stephen Cannan, 2021-08-10 Adopt improved wording from SQL/Framework</comment>
<para>If some syntactic element contains more than one other syntactic element,
then the General Rules for contained elements that appear earlier in the production for the
containing syntactic element are applied before the General Rules for contained elements that
appear later.
</para>

<para>For example, in the production:
</para>

<grammar>

<BNFdef name="A">
<rhs>
<BNF name="B"/>
<BNF name="C"/>
</rhs>
</BNFdef>

<BNFdef name="B">
<rhs>
<repeat/>
</rhs>
</BNFdef>

<BNFdef name="C">
<rhs>
<repeat/>
</rhs>
</BNFdef>

</grammar>

<comment>Editorial: Stephen Cannan, 2021-08-10 Adopt improved wording from SQL/Framework</comment>
<comment>WG3:UTC-048R1</comment>
<para>the Conformance Rules for <BNF name="A"/>, <BNF name="B"/>, and <BNF name="C"/> are 
effectively applied simultaneously.
Similarly the Syntax Rules <!-- and Access Rules --> for <BNF name="A"/>, <BNF name="B"/>, and 
<BNF name="C"/> are effectively applied simultaneously.
The General Rules for <BNF name="B"/> are applied before the General Rules for <BNF name="C"/>,
and the General Rules for <BNF name="A"/> are applied after the General Rules for both
<BNF name="B"/> and <BNF name="C"/>.
</para>

<comment>Editorial: Stephen Cannan, 2020-04-06</comment>
<comment>Editorial: Stephen Cannan, 2021-08-10</comment>
<para>An exception to this rule is when the General Rules of the containing syntactic element
explicitly states when the General Rules of the contained syntactic element are to be applied.
</para>

<comment>Editorial: Stephen Cannan, 2020-10-16 Add helpful hint for the reader</comment>
<comment>WG3:CMN-035</comment>
<note>In this document these exceptions are shown by the presence of a General Rule of the form
<quote>The General Rules of <symdef>xxx</symdef> are applied.</quote> where <sym>xxx</sym> is 
a BNF non-terminal symbol or denotes a BNF non-terminal instance of a BNF non-terminal symbol.
This indicates that <sym>xxx</sym> is evaluated at this point and not at the point implied by 
the general <quote>Rule evaluation order</quote>.
</note>

<para>If the result of an expression or search condition is not dependent on the result of some
part of that expression or search condition, then that part of the expression or search condition
is said to be <newterm>inessential</newterm>.
</para>

<!-- To be uncommented when Access Control is defined.
<para>If an Access Rule pertaining to an inessential part is not satisfied, then the
<raise class="42"/> exception condition is raised regardless of whether or not the inessential 
parts are actually evaluated.
</para>
-->
<comment>Editorial: Stefan Plantikow 2023-02-21</comment>
<para>If evaluation of an inessential part would cause an exception condition to be raised, 
then it is <unDef code="UA004"/> whether that exception condition is raised.
</para>

<para>During the computation of the result of an expression, the GQL-implementation may produce
one or more <newterm>intermediate results</newterm> that are used in determining that result.
The declared type of a site that contains an intermediate result is <unDef code="UV007"/>.
</para>

</bodyMatter>

</subClause3>


<subClause3 id="gql_conditional_rules">
<clauseHeading>Conditional rules</clauseHeading>

<bodyMatter>

<para>A conditional rule is specified with <quote>If</quote> or <quote>Case</quote> conventions.
A rule specified with <quote>Case</quote> conventions includes a list of conditional subrules
using <quote>If</quote> conventions.
The first such <quote>If</quote> subrule whose condition is true is the effective subrule of the
<quote>Case</quote> rule.
The last subrule of a <quote>Case</quote> rule may specify <quote>Otherwise</quote>, in which case
it is the effective subrule of the <quote>Case</quote> rule if no preceding <quote>If</quote>
subrule in the <quote>Case</quote> rule is satisfied.
If the last subrule does not specify <quote>Otherwise</quote>, and if there is no subrule whose
condition is true, then there is no effective subrule of the <quote>Case</quote> rule.
</para>

</bodyMatter>

</subClause3>


<subClause3 id="gql_substitution">
<clauseHeading>Syntactic substitution</clauseHeading>

<bodyMatter>

<para>In the Syntax and General Rules, the phrase <quote><symdef>X</symdef> is implicit</quote>
indicates that the Syntax and General Rules are to be interpreted as if the element <sym>X</sym>
had actually been specified.
Within the Syntax Rules of a given Subclause, it is known whether the element was explicitly
specified or is implicit.
</para>

<para>In the Syntax and General Rules, the phrase 
<quote>the following <BNF name="A"/> is implicit: <symdef>Y</symdef></quote> indicates that 
the Syntax and General Rules are to be interpreted as if a syntactic element <BNF name="A"/> 
containing <sym>Y</sym> had actually been specified.
</para>

<para>In the Syntax Rules and General Rules, the phrase <quote><symdef>former</symdef> is 
equivalent to <symdef>latter</symdef></quote> indicates that the Syntax Rules and General Rules are
to be interpreted as if all instances of <sym>former</sym> in the element had been instances of
<sym>latter</sym>.
</para>

<comment>WG3:CMN-035</comment>
<para>If a BNF non-terminal symbol is referenced in a Subclause (<eg/> to identify
a BNF non-terminal instance by specifying the BNF non-terminal symbol) without specifying how
it is contained in a BNF production that the Subclause defines, then
</para>

<para>Case:
</para>

<ulist>

<item>If the BNF non-terminal symbol is itself defined in the Subclause, then the reference shall
be assumed to be to the occurrence of that BNF non-terminal symbol on the left side of the defining
production.
</item>

<item>Otherwise, the reference shall be assumed to be to a BNF production in which the particular
BNF non-terminal symbol is immediately contained.
</item>

</ulist>

</bodyMatter>

</subClause3>

<comment>BGI-033 as amended in the Minutes</comment>
<subClause3 id="gql_stable_codes">
<clauseHeading>Stability of codes</clauseHeading>

<bodyMatter>

<comment>Editorial: Stephen Cannan, 2025-03-27 Use consistent terminology</comment>
<para>This document defines numerous kinds of codes (<eg/> condition codes, 
optional feature codes, <etc/>). 
Those codes are stated to be 
<quote>stable and can be depended on to remain constant</quote>. 
The phrase <quote>stable and can be depended on to remain constant</quote> means that a code, once 
used in a published document, will not be changed to a different code and will not be re-used for 
a different purpose in a future edition of that document. 
A code, once used in a published document, will be eliminated in a future edition if the code is 
no longer considered relevant to that edition.
</para>

</bodyMatter>

</subClause3>

</subClause2>


<subClause2 id="gql_descriptors">
<clauseHeading>Descriptors</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow, 2020-02-27</comment>
<para>A descriptor is a <repeatdefn ref="gql_descriptor__x_defn"/>.
The concept of descriptor is used in specifying the semantics of GQL.
It is not necessary that any descriptor exist in any particular form in any GQL-environment.
</para>

<comment>WG3:BER-055</comment>
<comment>WG3:W23-030</comment>
<para>Some GQL-objects cannot exist except in the context of other GQL-objects.
For example, nodes cannot exist except within the context of graphs.
Each such object is independently described by its own descriptor, and the descriptor of 
an enabling object (<eg/> graph) is said to <newterm>include</newterm> the descriptor of
each enabled object (<eg/> node or edge).
Conversely, the descriptor of an enabled object is said to <newterm>be included in</newterm> the
descriptor of an enabling object.
</para>

<comment>Editorial: Stefan Plantikow, 2022-11-16 Flipped order of paragraphs</comment>
<para>In other cases, certain GQL-objects cannot exist unless some other GQL-object exists, even
though there is no inclusion relationship.
In general, a descriptor <emph>D1</emph> can be said to depend on, or to be dependent on, some
descriptor <emph>D2</emph>.
</para>

<comment>WG3:W23-030</comment>
<para>Some GQL-objects are also dictionaries that uniquely associate an identifier to certain
enabled objects. 
Such named subobjects are said to be held by such a dictionary. 
The descriptor of a GQL-object that is also a dictionary represents such identifier associations as
a set of <newterm>named subobjects</newterm> whose elements are (identifier, object descriptor) 
pairs. 
The object descriptor in such a pair is considered included in the descriptor of the GQL-object 
that holds it.
</para>

<para>The execution of a statement can result in the creation of many descriptors.
A GQL-object that is created as a result of a statement can depend on other descriptors that
are only created as a result of the execution of that statement.
</para>

<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<para>There are two ways of indicating dependency of one GQL-object on another.
In many cases, the descriptor of the dependent GQL-object is said to
<quote>include the name of</quote> the GQL-object on which it is dependent.
In this case <quote>the name of</quote> is to be understood as meaning
<quote>sufficient information to identify the descriptor of</quote>.
Alternatively, the descriptor of the dependent GQL-object can be said to include text of the
GQL-object on which it is dependent.
However, in such cases, whether the GQL-implementation includes actual text
(with defaults and implications made explicit) or its own style of parse tree is irrelevant;
the validity of the descriptor is clearly <quote>dependent on</quote> the existence of descriptors
of objects that are referenced in it.
</para>

<para>An attempt to destroy a GQL-object, and hence its descriptor, can fail if other descriptors
are dependent on it, depending on how the destruction is specified.
Such an attempt can also fail if the descriptor to be destroyed is included in some other
descriptor.
Destruction of a descriptor results in the destruction of all descriptors included in it, but has
no effect on descriptors on which it is dependent.
</para>

<para>The implementation of some GQL-objects described by descriptors requires the existence of
objects not specified in this document.
Where such objects are required, they are effectively created whenever the associated descriptor
is created and effectively destroyed whenever the associated descriptor is destroyed.
</para>

</bodyMatter>

</subClause2>


<subClause2 id="gql_subclause_subroutine">
<clauseHeading>Subclauses used as subroutines</clauseHeading>

<bodyMatter>

<para>In this document, some Subclauses are defined without explicit syntax to invoke their
semantics.
Such Subclauses, called subroutine Subclauses, typically factor out rules that are required by one
or more other Subclauses and are intended to be invoked by the rules of those other Subclauses.
</para>

<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>Email from: Jan Michels, 2022-02-26 0223</comment>
<para>In other words, the rules of these Subclauses behave as though they were a sort of
definitional <quote>subroutine</quote> that is invoked by other Subclauses.
These subroutine Subclauses are typically specified in a manner that requires information to be
passed to them from their invokers.
The information that is required to be passed is represented as parameters of these subroutine 
Subclauses, and that information is required to be passed in the form of arguments provided by the 
invokers of these subroutine Subclauses.
</para>

<para>Every invocation of a subroutine Subclause shall explicitly provide information for every
required parameter of the subroutine Subclause being invoked.
</para>

<comment>Inspired by WG3:UTC-125</comment>
<para>In Subclauses that have Subclause Signatures, those signatures are followed by
<emph>non-normative</emph> text that documents every parameter and every returned value contained 
in that signature. 
That text is intended solely to assist readers of the document in their understanding of the 
Subclause Signatures and their parameters and returns. 
If the descriptive text and the normative text in those Subclauses disagree, the Subclauses<apos/> 
normative text is authoritative. 
</para>

<comment>Show how Subclause subroutine calls can be identified</comment>
<note>In this document the invocation will occur in the form <quote>The <emph>xxx</emph> 
Rules of Subclause <emph>n.n</emph>, <stringd><emph>aaaaaaa</emph></stringd>, with <ellipsis/> 
</quote>.
</note>

</bodyMatter>

</subClause2>


<comment>WG3:UTC-013</comment>
<subClause2 id="gql_text_typography">
<clauseHeading>Document typography</clauseHeading>

<bodyMatter>

<comment>WG3:UTC-013</comment>
<para>In the text of this document, the following typographic conventions are used:
</para>

<ulist>

<comment>WG3:UTC-013</comment>
<item><emph>Italicized text</emph> is used for several purposes:

<comment>WG3:CMN-019 P00-ISO-029</comment>
<ulist>

<comment>WG3:UTC-013</comment>
<item>representations of GQL truth values (<eg/> <bool>True</bool>); 
</item>

<comment>WG3:UTC-013</comment>
<item>representations of symbolic variables, both their definitions and their uses;
</item>

<comment>WG3:UTC-013</comment>
<item>textual definitions of important terms and concepts.
</item>

</ulist>

</item>

<comment>WG3:UTC-013</comment>
<item><bold>Bold text</bold> is used to display of terms taken from other standards
that display those terms in bold type. 
</item>

<comment>WG3:UTC-013</comment>
<item><underline>Underlined text</underline> is used in the representation of
GQL truth values (<eg/> <bool>True</bool>). 
</item>

</ulist>

</bodyMatter>

</subClause2>


<comment>Document the conventions for hot links; 2025-03-18</comment>
<subClause2 id="gql_doclinks">
<clauseHeading>Document links</clauseHeading>

<bodyMatter>

<comment>Document the conventions for hot links; 2025-03-18</comment>
<para>Electronic versions (that is, PDF versions) of ISO/IEC 39075
are published with extensive and clickable <quote>links</quote> within the document
(<quote>intra-document</quote>).
</para>

<comment>Document the conventions for hot links; 2025-03-18</comment>
<para>The intra-document links are:
</para>

<ulist>

<comment>Document the conventions for hot links; 2025-03-18</comment>
<item>From every use of a BNF non-terminal symbol
(such as <BNF name="procedure specification"/>) to the BNF production
that defines that non-terminal symbol.
</item>

<comment>Document the conventions for hot links; 2025-03-18</comment>
<item>From every reference to a Clause, Annex, or Subclause in the document
(such as <specref ref="gql_text_typography"/>)
to the Clause, Annex, or Subclause in the document. 
</item>

<comment>Document the conventions for hot links; 2025-03-18</comment>
<item>From every reference to a list item (numbered and unnumbered) to
the list item itself. 
There are similar references to individual paragraphs. 
</item>

<comment>Document the conventions for hot links; 2025-03-18</comment>
<item>From every reference to another document to that referenced document<apos/>s
entry in the Normative References or in the Bibliography of <quote>this</quote> document. 
</item>

<comment>Document the conventions for hot links; 2025-03-18</comment>
<item>From every description of an <impDef annex="no" code="None"/> or
<unDef annex="no" code="None"/> aspect of GQL to the Annex that summarizes all such aspects. 
Each entry in that Annex links back to the description in the body of the document. 
</item>

</ulist>

<comment>Document the conventions for hot links; 2025-03-18</comment>
<para>Most intra-document references are displayed in a medium-dark blue color. 
BNF non-terminal symbols are the primary exception to the use of that color. 
</para>

<comment>Document the conventions for hot links; 2025-03-18</comment>
<para>In addition, references to locations on the World-Wide Web (most commonly in
the form of URIs) are presented with underlines (commonly used by Web browsers to
signify a link).
</para>

</bodyMatter>

</subClause2>


<comment>The Subclause "Index typography", was deleted editorially as it no longer</comment>
<comment>reflected the situation after the move to one-pass indexing.</comment>

<comment>Editorial: Stephen Cannan, 2025-03-19 Correct the definition and use of features</comment>
<subClause2 id="gql_featuredescr">
<clauseHeading>Mandatory functionality and optional features</clauseHeading>

<bodyMatter>

<comment>Editorial: Stephen Cannan, 2025-03-19 Correct the definition and use of features</comment>
<para>The <newterm>mandatory functionality</newterm> comprises all the syntax and semantics that 
are not constrained by a Conformance Requirement.
</para>

<comment>Editorial: Stephen Cannan, 2025-03-27 Use consistent terminology</comment>
<para>Optional features are either <newterm>standard-defined features</newterm> or
<impDef annex="no" code="None"/> features.
</para>

<para>Standard-defined features are defined in this document.
<impDef annex="no" code="None" cap="yes"/> features are defined by GQL-implementations
(see <specref ref="gql_extensions_options"/>).
</para>
<comment>Editorial: Stephen Cannan, 2025-03-19 Correct the definition and use of features</comment>
<para>An <newterm>optional feature</newterm> is referenced by a Feature ID and is defined by 
Conformance Requirements that contain that Feature ID. 
A Conformance Requirement is either:
</para>

<ulist>

<item>A Conformance Rule beginning <quote>Without Feature <emph>FEAT</emph>, <ellipsis/></quote>.
</item>

<item>A paragraph, Syntax or General Rule, containing text such as 
<quote>Without Feature <emph>FEAT</emph>, <ellipsis/></quote>”, 
<quote>If the GQL-implementation supports Feature <emph>FEAT</emph>, <ellipsis/></quote>, 
<quote>If the GQL-implementation does not support Feature <emph>FEAT</emph>, <ellipsis/></quote>, 
or equivalent phrases.
</item>

</ulist>

<comment>WG3:SXM-065</comment>
<comment>Editorial: Stephen Cannan 2025-01-08</comment>
<comment>Editorial: Stephen Cannan, 2025-03-19 Correct the definition and use of features</comment>
<para>A Feature ID comprises either a letter followed by three digits or two letters followed 
by two digits.
</para>

<comment>Editorial: Stephen Cannan 2025-01-08</comment>
<para>Feature IDs whose initial letter is <quote>V</quote> are reserved for 
<impDef annex="no" code="None"/> features.
</para>

<comment>Editorial: Stephen Cannan, 2021-08-10</comment>
<comment>Editorial: Stephen Cannan, 2025-03-19 Correct the definition and use of features</comment>
<para>The Feature ID of a standard-defined optional feature is stable and can be depended on to 
remain  constant.
</para>

<comment>WG3:CMN-019 P00-ISO-030</comment>
<comment>Editorial: Stephen Cannan, 2025-03-19 Correct the definition and use of features</comment>
<para>For convenience, all of the optional features defined in this document are collected 
together in a non-normative annex, <specref ref="gql_taxonomy"/>.
</para>

<comment>Editorial: Stephen Cannan, 2025-03-19 Correct the definition and use of features</comment>
<para>The mandatory functionality is not subdivided and has no Feature IDs, but 
an informative annex, <specref ref="gql_mand"/>, is provided in which only the mandatory syntax 
is identified.
</para>

<comment>Editorial: Stephen Cannan, 2025-03-19 Correct the definition and use of features</comment>
<para>Conformance Rules are generally placed in the Subclause that defines the BNF non-terminal
that is controlled by the optional feature.
In those circumstances where the use of a non-terminal is only controlled in a specific
circumstance the Conformance Rule is placed where the non-terminal is used.
This is also done in those circumstances where the fact that the use of the
non-terminal is controlled by the optional feature can be deduced from an inspection of
the Syntax Rules and the Conformance Rules of other Subclauses and the Conformance Rule
is in principle redundant.
As far as possible, other redundancy in the Conformance Rules is avoided.
</para>

</bodyMatter>

</subClause2>

</subClause>

</clause>


<comment>Editorial: Stephen Cannan, 2020-10-12 Reintroduce grammar for GQL-request</comment>
<comment>WG3:W23-014</comment>
<clause id="gql_program">
<clauseHeading><BNF name="GQL-program"/></clauseHeading>

<bodyMatter>

<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:CMN-061R1</comment>
<para>Specify a conforming GQL-program.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-03-10</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-16 Factor out main activity</comment>
<comment>Editorial: Stephen Cannan, 2020-05-14 A program must have some content</comment>
<comment>WG3:W08-013</comment>
<comment>WG3:BER-076</comment>
<comment>WG3:UTC-045R1</comment>
<BNFdef name="GQL-program">
<rhs>
<alt> <BNF name="program activity"/> <opt> <BNF name="session close command"/> </opt> </alt>
<alt> <BNF name="session close command"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-045R1</comment>
<BNFdef name="program activity">
<rhs>
<alt> <BNF name="session activity"/> </alt>
<alt> <BNF name="transaction activity"/> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-04-13 Restructured grammar</comment>
<comment>Editorial: Stephen Cannan, 2020-10-15 Rationalize grammar</comment>
<comment>WG3:W08-013</comment>
<comment>Editorial: Stefan Plantikow, 2021-05-04 Mail from T. Lindaaker</comment>
<comment>WG3:UTC-045R1</comment>
<comment>WG3:CMN-061R1</comment>
<BNFdef name="session activity">
<rhs>
<alt> <BNF name="session reset command"/><repeat/> </alt>
<alt> <BNF name="session set command"/><repeat/> 
<opt> <BNF name="session reset command"/><repeat/> </opt>
</alt> 
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-03-10</comment>
<comment>Editorial: Stephen Cannan, 2020-10-15 Rationalize grammar</comment>
<comment>WG3:W08-013</comment>
<BNFdef name="transaction activity">
<rhs>
<alt> 
<BNF name="start transaction command"/> 
<breakindent/>
<opt> 
<BNF name="procedure specification"/> <opt> <BNF name="end transaction command"/> </opt> 
</opt>
</alt>
<alt> 
<BNF name="procedure specification"/> <opt> <BNF name="end transaction command"/> </opt> 
</alt>
<alt> <BNF name="end transaction command"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-076</comment>
<BNFdef name="end transaction command">
<rhs>
<alt> <BNF name="rollback command"/> </alt>
<alt> <BNF name="commit command"/> </alt>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<comment>WG3:CMN-061R1</comment>
<note>See <specref ref="gql_conc_req_exe"/>, regarding operations performed prior to 
the application of these Syntax Rules.
</note>

<olist>

<comment>WG3:W19-017</comment>
<comment>WG3:CMN-061R1</comment>
<item>Let <symdef>PROG</symdef> be the <BNF name="GQL-program"/>.
</item>

<comment>WG3:CMN-061R1</comment>
<item>Let <symdef>IS</symdef> and <symdef>IG</symdef> be the initial session and the initial graph,
respectively, of <sym>PROG</sym>.

<note>The initial session and the initial graph of a <BNF name="GQL-program"/> are determined by
the Syntax Rules of <specref ref="gql_annot_gql_program"/>.
</note>

</item>

<item>The scope clause of <sym>PROG</sym> is <sym>PROG</sym>.
</item>

<item>For every pair of instances <symdef>I1</symdef> and <symdef>I2</symdef> of 
a <BNF name="non-delimited identifier"/> or a <BNF name="delimited identifier"/> contained in
<sym>PROG</sym>, if <sym>I1</sym> and <sym>I2</sym> are visually confusable with each other, then 
an exception condition is raised: <raise class="42" subclass="004"/>.
</item>

<comment>WG3:W22-035</comment>
<comment>WG3:CMN-061R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<item>Let <symdef>ACSR</symdef> be a (possibly <quote>omitted</quote>)
<BNF name="absolute catalog schema reference"/> defined as follows.

<para>Case:
</para>

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<item>If <sym>IS</sym> is not <quote>omitted</quote> and identifies a GQL-schema,
then <sym>ACSR</sym> is <sym>IS</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<item>Otherwise, <sym>ACSR</sym> is <quote>omitted</quote>.
</item>

</olist>

</item>

<comment>WG3:W22-035</comment>
<comment>WG3:CMN-061R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<item>If <sym>ACSR</sym> is not <quote>omitted</quote>, then:

<olist>

<item>The scope of <sym>ACSR</sym> comprises <sym>PROG</sym>.
</item>

<comment>WG3:CMN-061R1</comment>
<item><sym>PROG</sym> identifies <sym>ACSR</sym> as a working schema reference.
</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-039</comment>
<comment>WG3:CMN-061R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<item>Let <symdef>WGS</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<comment>Editorial: Stefan Plantikow, 2023-02-28 Clarify: undefined current session graph</comment>
<comment>WG3:CMN-061R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use not set and omitted</comment>
<item>If the current session graph is <quote>not set</quote>, then:

<olist>

<item><sym>WGS</sym> is a site occupied by the graph reference value <sym>IG</sym>.
</item>

<item>If the referent of <sym>IG</sym> is a graph that has a constraining graph type 
<symdef>GT</symdef>, then the declared type of <sym>WGS</sym> is the graph reference value type 
whose constraining object type is <sym>GT</sym>; otherwise, the declared type of <sym>WGS</sym> is
the open graph reference value type.
</item>

</olist>

</item>

<comment>Editorial: Stefan Plantikow, 2023-02-28 Clarify: undefined current session graph</comment>
<comment>WG3:CMN-061R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use not set and omitted</comment>
<item>Otherwise, <sym>WGS</sym> is <quote>omitted</quote> and <sym>WGS</sym> is a site
occupied by the graph reference value <sym>IG</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-061R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<item>If <sym>WGS</sym> is not <quote>omitted</quote>, then:

<olist>

<comment>WG3:W20-027R1</comment>
<item>The scope of <sym>WGS</sym> comprises <sym>PROG</sym>.
</item>

<comment>WG3:W20-027R1</comment>
<item><sym>PROG</sym> identifies <sym>WGS</sym> as a working graph site.
</item>

</olist>

</item>

<comment>WG3:BER-019</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>PROG</sym> is the material unit record type.
</item>

<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>PROG</sym> is the material unit binding table type.
</item>
<endbar/>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>WG3:CMN-061R1</comment>
<note>See <specref ref="gql_conc_req_exe"/>, regarding operations performed prior to 
the application of these General Rules.
</note>

<olist>

<comment>WG3:W23-014</comment>
<comment>WG3:UTC-045R1</comment>
<item>If <sym>PROG</sym> simply contains the <BNF name="program activity"/> <symdef>PACT</symdef>, 
then the General Rules of <sym>PACT</sym> are applied.
</item>

<comment>WG3:CMN-061R1</comment>
<item>If <sym>PROG</sym> simply contains the <BNF name="session activity"/> <symdef>SACT</symdef>,
then:

<para>Case:
</para>

<olist>

<item>If the current transaction is <quote>not set</quote>, then:

<olist>

<item>The current transaction is set to a newly initiated GQL-transaction.

<note>This determines the currently active GQL-transaction associated with the GQL-session of 
the currently executing GQL-request.
</note>

</item>

<item>The General Rules of <sym>SACT</sym> are applied.
</item>

<item>The currently active GQL-transaction is terminated and the current transaction is set 
to <quote>not set</quote>.
</item>

</olist>

</item>

<item>Otherwise, the General Rules of <sym>SACT</sym> are applied.
</item>

</olist>

</item>

<comment>WG3:UTC-045R1</comment>
<item>If <sym>PROG</sym> simply contains the <BNF name="session close command"/> 
<symdef>SCC</symdef>, then the General Rules of <sym>SCC</sym> are applied.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-116</comment>
<comment>WG3:CMN-019 P00-NLD-053</comment>
<item>Without <feature code="GT01"/>, conforming GQL language shall not contain 
a <BNF name="start transaction command"/> or an <BNF name="end transaction command"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</clause>


<comment>Editorial: Stefan Plantikow, 2019-10-20</comment>
<clause id="gql_session_mngt">
<clauseHeading>Session management</clauseHeading>

<subClause id="gql_session_set">
<clauseHeading><BNF name="session set command"/></clauseHeading>

<bodyMatter>


<Function>

<comment>Editorial: Stephen Cannan, 2020-04-09</comment>
<comment>WG3:W08-014</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-15 Added setting parameters</comment>
<para>Set values in the session context.
</para>

</Function>


<comment>Editorial: Stefan Plantikow, 2019-19-11</comment>
<comment>Editorial: Stefan Plantikow, 2020-02-05</comment>
<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-02-06</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-14 Made keyword mandatory</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-14 Add set parameter clause</comment>
<comment>WG3:W08-014</comment>
<comment>Editorial: Stefan Plantikow, 2020-07-27 WG3:MMX-055</comment>
<BNFdef name="session set command">
<rhs>
<kw>SESSION</kw> <kw>SET</kw>
<group>
<alt> <BNF name="session set schema clause"/> </alt>
<alt> <BNF name="session set graph clause"/> </alt>
<alt> <BNF name="session set time zone clause"/> </alt>
<alt> <BNF name="session set parameter clause"/> </alt>
</group>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-07-27 session set directory clause</comment>
<comment>Editorial: Stefan Plantikow, 2020-07-27 WG3:MMX-055</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-14 Made keyword mandatory</comment>
<comment>WG3:W13-024: Stefan Plantikow, 2021-07-21</comment>
<BNFdef name="session set schema clause">
<rhs>
<kw>SCHEMA</kw> <BNF name="schema reference"/>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-04-14 Made keyword mandatory</comment>
<comment>WG3:W22-051</comment>
<comment>WG3:UTC-039R1</comment>
<BNFdef name="session set graph clause">
<rhs>
<opt> <kw>PROPERTY</kw> </opt>
<kw>GRAPH</kw>
<BNF name="graph expression"/>
</rhs>
</BNFdef>

<comment>WG3:W08-014</comment>
<BNFdef name="session set time zone clause">
<rhs>
<kw>TIME</kw> <kw>ZONE</kw> <BNF name="set time zone value"/>
</rhs>
</BNFdef>

<comment>WG3:W08-014</comment>
<comment>WG3:CMN-061R1</comment>
<BNFdef name="set time zone value">
<rhs>
<BNF name="time zone string"/>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-04-14 Add set parameter clause</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-05 Pushed IF NOT EXISTS into subproductions</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-09 Made keyword optional</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-09 Add IF NOT EXISTS</comment>
<comment>Editorial: Stephen Cannan, 2020-10-15 Scope for parameters</comment>
<comment>WG3:W21-044 Session parameter flags removed</comment>
<comment>WG3:UTC-045R1</comment>
<BNFdef name="session set parameter clause">
<rhs>
<alt> <BNF name="session set graph parameter clause"/> </alt>
<alt> <BNF name="session set binding table parameter clause"/> </alt>
<alt> <BNF name="session set value parameter clause"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-045R1</comment>
<BNFdef name="session set graph parameter clause">
<rhs>
<opt> <kw>PROPERTY</kw> </opt> <kw>GRAPH</kw> <BNF name="session set parameter name"/>
<BNF name="opt typed graph initializer"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-045R1</comment>
<BNFdef name="session set binding table parameter clause">
<rhs>
<opt> <kw>BINDING</kw> </opt> <kw>TABLE</kw> <BNF name="session set parameter name"/>
<BNF name="opt typed binding table initializer"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-045R1</comment>
<BNFdef name="session set value parameter clause">
<rhs>
<kw>VALUE</kw> <BNF name="session set parameter name"/> <BNF name="opt typed value initializer"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-045R1</comment>
<comment>Interaction between WG3:UTC-045R1 and WG3:UTC-058R3</comment>
<comment>WG3:CMN-061R1</comment>
<BNFdef name="session set parameter name">
<rhs>
<opt> <kw>IF</kw> <kw>NOT</kw> <kw>EXISTS</kw> </opt> <BNF name="session parameter specification"/>
</rhs>
</BNFdef>
<comment>Editorial: Stefan Plantikow, 2020-04-14 Move session parameter flags</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-11 OVERRIDABLE</comment>
<comment>WG3:W21-044 Session parameter flags removed</comment>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:UTC-045R1</comment>
<item>Let <symdef>SSC</symdef> be the <BNF name="session set command"/>.
</item>

<comment>WG3:CMN-061R1</comment>
<item>Let <symdef>PROG</symdef> be the <BNF name="GQL-program"/> that simply contains 
<sym>SSC</sym>.
</item>

<comment>WG3:UTC-045R1</comment>
<comment>Editorial: Stefan Plantikow 2023-02-25 Moved here for consistency</comment>
<comment>WG3:W26-026R2</comment>
<item>The declared type of <sym>SSC</sym> is the empty type.
</item>

<comment>WG3:W13-024: Stefan Plantikow, 2021-07-21</comment>
<comment>WG3:BER-088R1</comment>
<comment>Editorial: Stefan Plantikow, 2022-08-18 Correct to use GQL-schema</comment>
<comment>WG3:UTC-045R1</comment>
<comment>Editorial: Stephen Cannan, 2023-06-20 Correct sym</comment>
<comment>WG3:CMN-061R1</comment>
<item>If <sym>SSC</sym> simply contains the <BNF name="session set schema clause"/> 
<symdef>SSSC</symdef>, then let <symdef>SR</symdef> be the <BNF name="schema reference"/> 
immediately contained in <sym>SSSC</sym>.
</item>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-061R1</comment>
<item>If the <BNF name="set time zone value"/> <symdef>STZV</symdef> is specified, then 
let <symdef>TZD</symdef> be the time zone displacement specified by the 
<BNF name="time zone string"/> immediately contained in <sym>STZV</sym>.
</item>

<comment>WG3:UTC-045R1</comment>
<item>If <sym>SSC</sym> simply contains the <BNF name="session set parameter clause"/>, then:

<olist>

<comment>WG3:CMN-019 P00-USA-041</comment>
<comment>WG3:CMN-061R1</comment>
<item>Let <symdef>SSPN</symdef> be the <BNF name="session set parameter name"/> simply contained in
<sym>SSC</sym>, let <symdef>SPS</symdef> be the <BNF name="session parameter specification"/> 
immediately contained in <sym>SSPN</sym>, and let <symdef>PN</symdef> be the parameter name of 
<sym>SPS</sym>.
</item>

<comment>WG3:CMN-061R1</comment>
<comment>WG3:CMN-061R1</comment>
<item>If <sym>SSPN</sym> contains <kw>IF</kw> <kw>NOT</kw> <kw>EXISTS</kw> and <sym>SPS</sym> 
references a defined session parameter, then no further Syntax Rules of this Subclause are applied.
</item>

<comment>WG3:CMN-061R1</comment>
<item>Let the value type <symdef>PVT</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>SSC</sym> is the <BNF name="session set graph parameter clause"/> 
<symdef>SSGPC</symdef>, then:

<para>Case:
</para>

<olist>

<item>Let <symdef>OTGI</symdef> be the <BNF name="opt typed graph initializer"/> immediately 
contained in <sym>SSGPC</sym> and let <symdef>GI</symdef> be the <BNF name="graph initializer"/> 
immediately contained in <sym>OTGI</sym>.
</item>

<item>Let <symdef>GIT</symdef> be the declared type of <sym>GI</sym>.
</item>

<comment>WG3:CMN-061R1</comment>
<item>Case:

<olist>

<item>If <sym>OTGI</sym> immediately contains a <BNF name="graph reference value type"/>
<symdef>OGT</symdef>, then:

<olist>

<item><sym>GIT</sym> shall be assignable to the type specified by <sym>OGT</sym>.
</item>

<comment>WG3:CMN-061R1</comment>
<item><sym>PVT</sym> is the type specified by <sym>OGT</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-061R1</comment>
<item>Otherwise, <sym>PVT</sym> is <sym>GIT</sym>.
</item>

</olist>

</item>

</olist>

</item>

<item>If <sym>SSC</sym> is the <BNF name="session set binding table parameter clause"/> 
<symdef>SSBTPC</symdef>, then:

<para>Case:
</para>

<olist>

<item>Let <symdef>OTBTI</symdef> be the <BNF name="opt typed binding table initializer"/> 
immediately contained in <sym>SSBTPC</sym> and let <symdef>BTI</symdef> be the 
<BNF name="binding table initializer"/> immediately contained in <sym>OTBTI</sym>.
</item>

<item>Let <symdef>BTIT</symdef> be the declared type of <sym>BTI</sym>.
</item>

<comment>WG3:CMN-061R1</comment>
<item>Case:

<olist>

<item>If <sym>OTBTI</sym> immediately contains a <BNF name="binding table reference value type"/> 
<symdef>OBTT</symdef>, then:

<olist>

<item><sym>BTIT</sym> shall be assignable to the type specified by <sym>OBTT</sym>.
</item>

<comment>WG3:CMN-061R1</comment>
<item><sym>PVT</sym> is the type specified by <sym>OBTT</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-061R1</comment>
<item>Otherwise, <sym>PVT</sym> is <sym>BTIT</sym>.
</item>

</olist>

</item>

</olist>

</item>

<item>If <sym>SSC</sym> is the <BNF name="session set value parameter clause"/> 
<symdef>SSVPC</symdef>, then:

<comment>WG3:CMN-061R1</comment>
<para>Case:
</para>

<olist>

<item>Let <symdef>OTVI</symdef> be the <BNF name="opt typed value initializer"/> immediately 
contained in <sym>SSVPC</sym> and let <symdef>VI</symdef> be the <BNF name="value initializer"/> 
immediately contained in <sym>OTVI</sym>.
</item>

<item>Let <symdef>VIT</symdef> be the declared type of <sym>VI</sym>.
</item>

<comment>WG3:CMN-061R1</comment>
<item>Case:

<olist>

<item>If <sym>OTVI</sym> immediately contains a <BNF name="value type"/> <symdef>OVT</symdef>, 
then:

<olist>

<item><sym>VIT</sym> shall be assignable to the type specified by <sym>OVT</sym>.
</item>

<comment>WG3:CMN-061R1</comment>
<item><sym>PVT</sym> is the type specified by <sym>OVT</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-061R1</comment>
<item>Otherwise, <sym>PVT</sym> is <sym>VIT</sym>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:CMN-061R1</comment>
<item>Case:

<olist>

<item>If <sym>SPS</sym> references a defined session parameter, then <sym>PVT</sym> shall be 
assignable to the parameter value type of <sym>SPS</sym>.
</item>

<item>Otherwise, <sym>SPS</sym> does not reference a defined session parameter.

<para>Case:
</para>

<olist>

<item>If there are other <BNF name="session set command"/>s simply contained in <sym>PROG</sym>
that precede <sym>SSC</sym> in <sym>PROG</sym> and that simply contain 
a <BNF name="session parameter specification"/> whose parameter name is <sym>PN</sym>, then:

<olist>

<item>Let <symdef>DT</symdef> be the declared type of the 
<BNF name="session parameter specification"/> simply contained in the rightmost such 
<BNF name="session set command"/>.
</item>

<item><sym>PVT</sym> shall be assignable to <sym>DT</sym>.
</item>

<item>The declared type of <sym>SPS</sym> is <sym>DT</sym>.
</item>

</olist>

</item>

<item>Otherwise, <sym>SSC</sym> is the initial (leftmost) <BNF name="session set command"/>
simply contained in <sym>PROG</sym> for <sym>SPS</sym> and the declared type of <sym>SPS</sym> 
is <sym>PVT</sym>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W22-051</comment>
<comment>Editorial: Stefan Plantikow, 2022-08-22 Remove unused variable</comment>
<comment>WG3:UTC-039R1 Deleted 1 (one) SR</comment>
<comment>WG3:W21-044 Session parameter flags removed</comment>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>Editorial: Stefan Plantikow, 2020-04-14 Rewritten</comment>
<comment>Editorial: Stefan Plantikow, 2020-07-12 WG3:MMX-055</comment>
<comment>WG3:W13-024: Stefan Plantikow, 2021-07-21</comment>
<comment>WG3:W21-044</comment>
<comment>WG3:UTC-045R1</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<comment>WG3:CMN-061R1</comment>
<item>If <sym>SSC</sym> simply contains the <BNF name="session set schema clause"/>, then 
the current session schema is set to an <BNF name="absolute catalog schema reference"/> that 
identifies the GQL-schema identified by <sym>SR</sym>.
</item>

<comment>WG3:W22-051</comment>
<comment>WG3:UTC-039R1</comment>
<comment>WG3:UTC-045R1</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<comment>WG3:CMN-061R1</comment>
<item>If <sym>SSC</sym> simply contains the <BNF name="session set graph clause"/> 
<symdef>SSGC</symdef>, then the current session graph is set to the graph reference value that is 
the result of the <BNF name="graph expression"/> immediately contained in <sym>SSGC</sym>.
</item>

<comment>WG3:W08-014</comment>
<comment>Email from: Jan Michels, 2022-02-26 0223</comment>
<comment>WG3:UTC-045R1</comment>
<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item>If <sym>SSC</sym> simply contains the <BNF name="session set time zone clause"/>, then
the current session time zone displacement is set to <sym>TZD</sym>.
</item>

<comment>WG3:UTC-045R1</comment>
<item>If <sym>SSC</sym> simply contains the <BNF name="session set parameter clause"/>, then

<para>Case:
</para>

<olist>

<item>If <sym>SSPN</sym> contains <kw>IF</kw> <kw>NOT</kw> <kw>EXISTS</kw> and the current session 
context contains a session parameter with parameter name <sym>PN</sym>, then the current 
application of General Rules of this Subclause resumes with 
<itemref ref="gql_set_sess_parm_end" type="GR"/>.
</item>

<comment>WG3:CMN-061R1</comment>
<item>Let <symdef>PV</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>SSC</sym> is the <BNF name="session set graph parameter clause"/> 
<symdef>SSGPC</symdef>, then <sym>PV</sym> is the result of <sym>GI</sym>.
</item>

<item>If <sym>SSC</sym> is the <BNF name="session set binding table parameter clause"/>
<symdef>SSBTPC</symdef>, then <sym>PV</sym> is the result of <sym>BTI</sym>.
</item>

<item>Otherwise, <sym>SSC</sym> is the <BNF name="session set value parameter clause"/> 
<symdef>SSVPC</symdef> and <sym>PV</sym> is the result of <sym>VI</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-061R1</comment>
<item>Case:

<olist>

<item>If the current session context contains a session parameter <symdef>SP</symdef> with
parameter name <sym>PN</sym>, then <sym>PV</sym> is assigned to the parameter value of 
<sym>SP</sym>.
</item>

<item>Otherwise, a new session parameter with parameter name <sym>PN</sym>, parameter
value <sym>PV</sym>, and parameter value type <sym>PVT</sym> is created in the current session
context.
</item>

</olist>

</item>

</olist>

</item>
<comment>Editorial: Stefan Plantikow, 2020-04-14 Add set parameter clause</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-09 Add IF NOT EXISTS</comment>
<comment>WG3:W21-044</comment>

<comment>WG3:W21-044</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item id="gql_set_sess_parm_end">The current execution outcome is set to a successful outcome with 
an omitted result.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:POS-023R1</comment>
<item>Without <feature code="GS09"/>, conforming GQL language shall not contain 
a <BNF name="session set schema clause"/>.
</item>

<comment>WG3:POS-023R1</comment>
<item>Without<feature code="GS17"/>, conforming GQL language shall not contain 
a <BNF name="session set graph clause"/>.
</item>

<comment>WG3:UTC-045R1</comment>
<item>Without <feature code="GS01"/>, conforming GQL language shall not contain 
a <BNF name="session set graph parameter clause"/>.
</item>

<comment>WG3:UTC-045R1</comment>
<item>Without <feature code="GS02"/>, conforming GQL language shall not contain 
a <BNF name="session set binding table parameter clause"/>.
</item>

<comment>WG3:UTC-045R1</comment>
<item>Without <feature code="GS03"/>, conforming GQL language shall not contain 
a <BNF name="session set value parameter clause"/>.
</item>

<comment>WG3:UTC-100</comment>
<item>Without <feature code="GS10"/>, conforming GQL language shall not contain
a <BNF name="session set binding table parameter clause"/> that contains
a <BNF name="procedure body"/>.
</item>

<comment>WG3:UTC-100</comment>
<item>Without <feature code="GS11"/>, conforming GQL language shall not contain
a <BNF name="session set value parameter clause"/> that contains a <BNF name="procedure body"/>.
</item>

<comment>WG3:UTC-100</comment>
<item>Without <feature code="GS12"/>, conforming GQL language shall not contain
a <BNF name="session set graph parameter clause"/> that simply contains
a <BNF name="graph expression"/> that does not conform to <BNF name="value specification"/> or
is a <BNF name="graph reference"/>.
</item>

<comment>WG3:UTC-100</comment>
<item>Without <feature code="GS13"/>, conforming GQL language shall not contain
a <BNF name="session set binding table parameter clause"/> that simply contains
a <BNF name="binding table expression"/> that does not conform to <BNF name="value specification"/>
or is a <BNF name="binding table reference"/>.
</item>

<comment>WG3:UTC-100</comment>
<item>Without <feature code="GS14"/>, conforming GQL language shall not contain
a <BNF name="session set value parameter clause"/> that simply contains
a <BNF name="value expression"/> that does not conform to <BNF name="value specification"/>.
</item>

<comment>WG3:CMN-070R1</comment>
<item>Without <feature code="GS15"/>, conforming GQL language shall not contain
a <BNF name="session set time zone clause"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:UTC-045R1</comment>
<subClause id="gql_session_reset" newpage="true">
<clauseHeading><BNF name="session reset command"/></clauseHeading>

<bodyMatter>

<Function>

<para>Reset session parameters and characteristics.
</para>

</Function>


<Format>

<grammar>


<comment>WG3:UTC-045R1</comment>
<BNFdef name="session reset command">
<rhs>
<kw>SESSION</kw> <kw>RESET</kw> <opt> <BNF name="session reset arguments"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:CMN-061R1</comment>
<BNFdef name="session reset arguments">
<rhs>
<alt> <opt> <kw>ALL</kw> </opt> 
<group> 
<alt br="no"> <kw>PARAMETERS</kw> </alt> <alt br="no"> <kw>CHARACTERISTICS</kw> </alt> 
</group> 
</alt>
<alt> <kw>SCHEMA</kw> </alt>
<alt> <opt> <kw>PROPERTY</kw> </opt> <kw>GRAPH</kw> </alt>
<alt> <kw>TIME</kw> <kw>ZONE</kw> </alt>
<alt> <opt> <kw>PARAMETER</kw> </opt> <BNF name="session parameter specification"/> </alt>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<item>Let <symdef>SRC</symdef> be the <BNF name="session reset command"/>.
</item>

<item>Case:

<olist>

<item>If <sym>SRC</sym> simply contains <BNF name="session reset arguments"/> <symdef>SRA</symdef>,
then

<para>Case:
</para>

<olist>

<item>If <sym>SRA</sym> is <kw>CHARACTERISTICS</kw> or <kw>PARAMETERS</kw>, then <sym>SRA</sym> is 
effectively replaced by:

<code>
<kw>ALL</kw> <sym>SRA</sym>
</code>

</item>

<item>If <sym>SRA</sym> is <kw>GRAPH</kw>, then <sym>SRA</sym> is effectively replaced by:

<code>
<kw>PROPERTY</kw> <kw>GRAPH</kw>
</code>

</item>

</olist>

</item>

<item>Otherwise, <sym>SRC</sym> is effectively replaced by:

<code>
<kw>SESSION</kw> <kw>RESET</kw> <kw>ALL</kw> <kw>CHARACTERISTICS</kw>
</code>

</item>

</olist>

</item>

<comment>WG3:CMN-061R1</comment>
<comment>WG3:W26-026R2</comment>
<item>If <sym>SRC</sym> simply contains a <BNF name="session parameter specification"/> 
<symdef>SPC</symdef>, then the declared type of <sym>SPC</sym> is the empty type.
</item>

<comment>WG3:W26-026R2</comment>
<item>The declared type of <sym>SRC</sym> is the empty type.
</item>

</olist>

</SyntaxRules>


<GeneralRules>

<olist>

<comment>WG3:CMN-019 P00-USA-352</comment>
<comment>WG3:CMN-061R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<item>If <kw>ALL</kw> <kw>CHARACTERISTICS</kw> or <kw>SCHEMA</kw> is specified and the 
current home schema is not <quote>omitted</quote>, then the current session schema is set to
the current home schema; otherwise, the current session schema is set to <quote>not set</quote>.
</item>

<comment>WG3:CMN-019 P00-USA-352</comment>
<comment>WG3:CMN-061R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<item>If <kw>ALL</kw> <kw>CHARACTERISTICS</kw> or <kw>PROPERTY</kw> <kw>GRAPH</kw> is specified 
and the current home graph is not <quote>omitted</quote>, then the current session graph is set to
the current home graph; otherwise, the current session graph is set to <quote>not set</quote>.
</item>

<comment>WG3:CMN-019 P00-USA-352</comment>
<item>If <kw>ALL</kw> <kw>CHARACTERISTICS</kw> or <kw>TIME</kw> <kw>ZONE</kw> is specified, then 
the current session time zone displacement is set to the <impDef code="ID048"/> default time zone 
displacement.
</item>

<comment>Editorial: Stefan Plantikow 2023-03-15 Correct to use keyword</comment>
<item>If <kw>ALL</kw> <kw>CHARACTERISTICS</kw> or <kw>ALL</kw> <kw>PARAMETERS</kw> is specified, 
then:

<olist>

<comment>WG3:CMN-019 P00-USA-352</comment>
<item>Each session parameter is removed from the current session context.
</item>

<comment>WG3:CMN-019 P00-USA-352</comment>
<item>Each <impDef code="ID049"/> default session parameter is added to the current session context.
</item>

</olist>

</item>

<comment>WG3:CMN-061R1</comment>
<item>If the <BNF name="session parameter specification"/> <symdef>SPS</symdef> is specified, then:

<olist>

<comment>WG3:CMN-061R1</comment>
<item>Let <symdef>PN</symdef> be the parameter name of <sym>SPS</sym>.
</item>

<comment>WG3:CMN-019 P00-USA-352</comment>
<comment>WG3:CMN-061R1</comment>
<item>If the current session context has a session parameter <symdef>SP</symdef> whose parameter
name is <sym>PN</sym>, then <sym>SP</sym> is removed from the current session context.
</item>

<comment>WG3:CMN-019 P00-USA-352</comment>
<comment>WG3:CMN-061R1</comment>
<item>If <sym>PN</sym> specifies the parameter name of an <impDef code="ID049"/> default 
session parameter <symdef>DP</symdef>, then <sym>DP</sym> is added to the current session context.
</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-352</comment>
<item>The current execution outcome is set to a successful outcome with an omitted result.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:CMN-070R1</comment>
<item>Without <feature code="GS04"/>, conforming GQL language shall contain 
a <BNF name="session reset arguments"/>.
</item>

<comment>WG3:CMN-070R1</comment>
<item>Without <feature code="GS04"/>, conforming GQL language shall not contain
a <BNF name="session reset arguments"/> that contains either <kw>PARAMETERS</kw> or
<kw>CHARACTERISTICS</kw>.
</item>

<item>Without <feature code="GS05"/>, conforming GQL language shall not contain 
<kw>SESSION</kw> <kw>RESET</kw> <kw>SCHEMA</kw>.
</item>

<item>Without <feature code="GS06"/>, conforming GQL language shall not contain 
<kw>SESSION</kw> <kw>RESET</kw> <kw>PROPERTY</kw> <kw>GRAPH</kw> or 
<kw>SESSION</kw> <kw>RESET</kw> <kw>GRAPH</kw>.
</item>

<item>Without <feature code="GS07"/>, conforming GQL language shall not contain 
<kw>SESSION</kw> <kw>RESET</kw> <kw>TIME</kw> <kw>ZONE</kw>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-03-15 Correct keyword</comment>
<comment>WG3:POS-030R1</comment>
<item>Without <feature code="GS08"/>, conforming GQL language shall not contain 
<kw>SESSION</kw> <kw>RESET</kw> <kw>ALL</kw> <kw>PARAMETERS</kw>.
</item>

<comment>WG3:CMN-070R1</comment>
<comment>WG3:POS-030R1</comment>
<item>Without <feature code="GS16"/>, conforming GQL language shall not contain
a <BNF name="session reset arguments"/> that contains 
a <BNF name="session parameter specification"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_session_close" newpage="true">
<clauseHeading><BNF name="session close command"/></clauseHeading>

<bodyMatter>


<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<para>Close the current session.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:UTC-045R1</comment>
<BNFdef name="session close command">
<rhs>
<kw>SESSION</kw> <kw>CLOSE</kw>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:UTC-096R1</comment>
<comment>WG3:W26-026R2</comment>
<item>The declared type of the <BNF name="session close command"/> is the empty type.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>Editorial: Stefan Plantikow, 2020-04-14 Added General Rules</comment>
<comment>WG3:CMN-019 P00-USA-353</comment>
<item>The current termination flag is set to <bool>True</bool>.
</item>

<comment>WG3:UTC-096R1</comment>
<comment>WG3:CMN-019 P00-USA-353</comment>
<item>The current execution outcome is set to a successful outcome with an omitted result.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<bar note="WG3:XRH-035"/>
<comment>WG3:XRH-035</comment>
<item>Without <feature code="GS18"/>, conforming GQL language shall not contain 
a <BNF name="session close command"/>.
</item>
<endbar/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:CMN-061R1</comment>
<subClause id="gql_sess_param_spec" newpage="true">
<clauseHeading><BNF name="session parameter specification"/></clauseHeading>

<bodyMatter>

<Function>

<comment>Editorial: Stefan Plantikow, 2023-11-09 Align wording</comment>
<para>Specify a session parameter for a value.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="session parameter specification">
<rhs>
<BNF name="general parameter reference"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<note>The Syntax Rules of <specref ref="gql_annot_gql_program"/> determine whether 
a <BNF name="session parameter specification"/> references a defined session parameter and, 
if that is the case, its parameter name and parameter value type.
</note>

<note>The declared type of a <BNF name="session parameter specification"/> is determined by the
Syntax Rules of <specref ref="gql_session_set"/>, and <specref ref="gql_session_reset"/>.
</note>

<olist>

<None/>

</olist>

</SyntaxRules>


<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>

</clause>


<clause id="gql_tx_mngt">
<clauseHeading>Transaction management</clauseHeading>

<subClause id="gql_tx_start">
<clauseHeading><BNF name="start transaction command"/></clauseHeading>

<bodyMatter>


<Function>

<comment>Editorial: Stefan Plantikow, 2020-04-16 Ending a GQL-transaction moved</comment>
<comment>WG3:W12-010: Stefan Plantikow, 2021-06-15 Removing the implicit transaction flag</comment>
<para>Start a new GQL-transaction and set its characteristics.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="start transaction command">
<rhs>
<kw>START</kw> <kw>TRANSACTION</kw> <opt> <BNF name="transaction characteristics"/> </opt>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:UTC-059</comment>
<item>Let <symdef>TS</symdef> be the <BNF name="start transaction command"/>.
</item>

<comment>WG3:UTC-059</comment>
<item>If <sym>TS</sym> does not simply contain <BNF name="transaction characteristics"/>, then 
an <impDef code="ID006"/> default transaction characteristics that simply contains 
a <BNF name="transaction mode"/> <kw>READ</kw> <kw>WRITE</kw> is implicit.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<item>If a GQL-transaction is currently active, then an exception condition is raised:
<raise class="25" subclass="G01"/>.
</item>

<comment>WG3:UTC-059</comment>
<item>Let <symdef>TC</symdef> be the explicit or implicit <BNF name="transaction characteristics"/>
simply contained in <sym>TS</sym>.
</item>

<comment>WG3:W12-010: Stefan Plantikow, 2021-06-15 Removing the implicit transaction flag</comment>
<comment>WG3:UTC-059</comment>
<item>A new GQL-transaction <symdef>TX</symdef> with the transaction characteristics specified by 
<sym>TC</sym> as its transaction characteristics is initiated.

<note>Every transaction records its transaction characteristics.
</note>

</item>

<item>The current transaction is set to <sym>TX</sym>.

<comment>WG3:RKE-042 Editorial</comment>
<note>This determines <sym>TX</sym> as the currently active GQL-transaction associated with 
the GQL-session of the currently executing GQL-request.
</note>
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-116</comment>
<item>Without <feature code="GT02"/>, conforming GQL language shall not contain
a <BNF name="start transaction command"/> that contains <BNF name="transaction characteristics"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>
<comment>WG3:UTC-076 Deleted 1 (one) Subclause</comment>


<subClause id="gql_tx_chars" newpage="true">
<clauseHeading><BNF name="transaction characteristics"/></clauseHeading>

<bodyMatter>


<Function>

<comment>WG3:RKE-042 Editorial</comment>
<para>Specify GQL-transaction characteristics.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="transaction characteristics">
<rhs>
<BNF name="transaction mode"/>
<opt> <group> <BNF name="comma"/> <BNF name="transaction mode"/> </group><repeat/> </opt>
</rhs>
</BNFdef>

<BNFdef name="transaction mode">
<rhs>
<alt> <BNF name="transaction access mode"/> </alt>
<alt> <BNF name="implementation-defined access mode"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="transaction access mode">
<rhs>
<alt> <kw>READ</kw> <kw>ONLY</kw> </alt>
<alt> <kw>READ</kw> <kw>WRITE</kw> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<bar note="Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references"/>
<BNFdef name="implementation-defined access mode">
<rhs>
<seeTheRules><itemref ref="gql_impDef_acc_mode" type="SR"/></seeTheRules>
</rhs>
</BNFdef>
<endbar/>

</grammar>

</Format>


<SyntaxRules>

<olist>

<item>Let <symdef>TC</symdef> be the <BNF name="transaction characteristics"/>.
</item>

<comment>WG3:UTC-059</comment>
<item><sym>TC</sym> shall contain exactly one <BNF name="transaction access mode"/>.
</item>

<item id="gql_impDef_acc_mode">The Format and Syntax Rules for 
<BNF name="implementation-defined access mode"/> are <impDef code="IE002"/>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_tx_rollback" newpage="true">
<clauseHeading><BNF name="rollback command"/></clauseHeading>

<bodyMatter>


<Function>

<comment>WG3:RKE-042 Editorial</comment>
<para>Terminate the currently active GQL-transaction with rollback.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="rollback command">
<rhs>
<kw>ROLLBACK</kw>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<None/>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:RKE-042</comment>
<item>If the currently active GQL-transaction is part of an encompassing transaction that is 
controlled by an agent other than the GQL-agent and the <BNF name="rollback command"/> is not being
implicitly executed, then an exception condition is raised: <raise class="2D"/>.
</item>

<comment>WG3:RKE-042</comment>
<item>All changes to GQL-data or the GQL-catalog that were made by the currently active
GQL-transaction are canceled.
</item>

<comment>Editorial: Stephen Cannan, 2020-10-16 Improve transaction management</comment>
<comment>WG3:W12-010: Stefan Plantikow, 2021-06-15 Removing the implicit transaction flag</comment>
<comment>WG3:RKE-042</comment>
<comment>WG3:CMN-061R1</comment>
<item>The currently active GQL-transaction is terminated and the current transaction is set to
<quote>not set</quote>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_tx_commit" newpage="true">
<clauseHeading><BNF name="commit command"/></clauseHeading>

<bodyMatter>


<Function>

<comment>WG3:RKE-042</comment>
<para>Terminate the currently active GQL-transaction with commit.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="commit command">
<rhs>
<kw>COMMIT</kw>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<None/>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<item>Case:

<olist>
<comment>WG3:CMN-062 Removed 1 (one) Subrule</comment>

<comment>WG3:RKE-042 Editorial</comment>
<item>If the currently active GQL-transaction is part of an encompassing transaction that is 
controlled by an agent other than the GQL-agent, then an exception condition is raised: 
<raise class="2D"/>.
</item>

<comment>WG3:RKE-042 Editorial</comment>
<item>If any other error preventing commitment of the GQL-transaction has occurred, then any
changes to GQL-data or the GQL-catalog that were made by the currently active GQL-transaction are 
canceled and an exception condition is raised: <raise class="40"/> with an <impDef code="IE008"/> 
subclass value.
</item>

<comment>WG3:RKE-042 Editorial</comment>
<item>Otherwise, any changes to GQL-data or the GQL-catalog that were made by the currently active
GQL-transaction are eligible to be perceived by all subsequent GQL-transactions.
</item>

</olist>

<ednote id="gql_PP011_4">Once constraints are introduced, any changes to GQL-data or
the GQL-catalog made by the currently active GQL-transaction need to be verified here.

See <PPref ref="PPgql011"/>.
</ednote>

</item>

<comment>Editorial: Stephen Cannan, 2020-10-16 Improve transaction management</comment>
<comment>WG3:W12-010: Stefan Plantikow, 2021-06-15 Removing the implicit transaction flag</comment>
<comment>WG3:RKE-042</comment>
<comment>WG3:CMN-061R1</comment>
<item>The currently active GQL-transaction is terminated and the current transaction is set to 
<quote>not set</quote>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>

</clause>


<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<clause id="gql_procedures">
<clauseHeading>Procedure specification</clauseHeading>
<comment>WG3:UTC-077 Deleted 1 (one) editor's note</comment>

<subClause id="gql_procspec">
<clauseHeading><BNF name="procedure specification"/></clauseHeading>

<bodyMatter>

<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-09 Align wording</comment>
<para>Specify the procedural logic of a procedure.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-05-03 named procedure specification</comment>
<BNFdef name="nested procedure specification">
<rhs>
<BNF name="left brace"/>
<BNF name="procedure specification"/>
<BNF name="right brace"/>
</rhs>
</BNFdef>

<comment>WG3:W20-013</comment>
<BNFdef name="procedure specification">
<rhs>
<alt> <BNF name="catalog-modifying procedure specification"/> </alt>
<alt> <BNF name="data-modifying procedure specification"/> </alt>
<alt> <BNF name="query specification"/> </alt>
</rhs>
</BNFdef>
<comment>WG3:RKE-043 Removed unused "nested catalog-modifying procedure specification"</comment>

<BNFdef name="catalog-modifying procedure specification">
<rhs>
<BNF name="procedure body"/>
</rhs>
</BNFdef>

<BNFdef name="nested data-modifying procedure specification">
<rhs>
<BNF name="left brace"/>
<BNF name="data-modifying procedure specification"/>
<BNF name="right brace"/>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-09-26 focused data-modifying procedure specification
</comment>
<BNFdef name="data-modifying procedure specification">
<rhs>
<BNF name="procedure body"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-077</comment>
<comment>Email from: Nathalie Charbel, 2023-03-01 1050</comment>
<BNFdef name="nested query specification">
<rhs>
<BNF name="left brace"/> <BNF name="query specification"/> <BNF name="right brace"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-077</comment>
<BNFdef name="query specification">
<rhs>
<BNF name="procedure body"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<comment>Editorial: Stefan Plantikow, 2020-05-04 Informal Semantics removed</comment>
<SyntaxRules id="gql_procspec_3">

<comment>Editorial: Stefan Plantikow, 2020-05-04 Added SRs</comment>
<comment>WG3:RKE-043</comment>
<olist>

<comment>WG3:UTC-077</comment>
<item>If the <BNF name="nested procedure specification"/> <symdef>NPS</symdef> is specified, then
the declared type of <sym>NPS</sym> is the declared type of
the <BNF name="procedure specification"/> immediately contained in <sym>NPS</sym>.
</item>

<comment>WG3:UTC-077</comment>
<item>If the <BNF name="nested query specification"/> <symdef>NQS</symdef> is specified, then
the declared type of <sym>NQS</sym> is the declared type of the <BNF name="query specification"/>
immediately contained in <sym>NQS</sym>.
</item>

<comment>WG3:UTC-077</comment>
<item>If the <BNF name="nested data-modifying procedure specification"/> <symdef>NDPS</symdef>
is specified, then the declared type of <sym>NDPS</sym> is the declared type of
the <BNF name="data-modifying procedure specification"/> immediately contained in
<sym>NDPS</sym>.
</item>

<item>If the <BNF name="procedure specification"/> <symdef>PS</symdef> is specified, then:

<olist>

<item>Let <symdef>PB</symdef> be the <BNF name="procedure body"/> immediately contained in the
<BNF name="catalog-modifying procedure specification"/>, 
<BNF name="data-modifying procedure specification"/>, or <BNF name="query specification"/>
immediately contained in <sym>PS</sym>.
</item>

<item>Case:

<olist>

<comment>Editorial: Stefan Plantikow, 2022-12-19 Consequence of WG3:W24-009 P00-NLD-003</comment>
<item>If <sym>PB</sym> simply contains a <BNF name="linear catalog-modifying statement"/>, then
<sym>PS</sym> is a <BNF name="catalog-modifying procedure specification"/>. 
</item>

<comment>Editorial: Stefan Plantikow, 2022-12-19 Consequence of WG3:W24-009 P00-NLD-003</comment>
<comment>WG3:GYD-030</comment>
<item>If <sym>PB</sym> simply contains a <BNF name="linear data-modifying statement"/> or 
a <BNF name="conditional statement"/> that simply contains 
a <BNF name="procedure specification"/> that is 
a <BNF name="data-modifying procedure specification"/>, then <sym>PS</sym> is 
a <BNF name="data-modifying procedure specification"/>.

<note>This is a recursive definition.
</note>
</item>

<item>Otherwise, <sym>PS</sym> is a <BNF name="query specification"/>.
</item>

</olist>

</item>

</olist>

</item>

<comment>Editorial: Stefan Plantikow, 2022-12-19 Consequence of WG3:W24-009 P00-NLD-003</comment>
<item>If the <BNF name="catalog-modifying procedure specification"/> <symdef>CPS</symdef> is
specified, then every <BNF name="statement"/> simply contained in <sym>CPS</sym> shall be
a <BNF name="linear catalog-modifying statement"/>.
</item>

<comment>WG3:RKE-015</comment>
<comment>Email from: Karl Schendel, 2022-06-13 1558</comment>
<comment>Editorial: Stefan Plantikow, 2022-12-19 Consequence of WG3:W24-009 P00-NLD-003</comment>
<comment>WG3:GYD-030</comment>
<comment>Editorial: Stephen Cannan, 2024-10-01 Remove unused symbol definition</comment>
<item>If the <BNF name="data-modifying procedure specification"/> <symdef>DPS</symdef> is
specified, then every <BNF name="statement"/> simply contained in <sym>DPS</sym> shall be 
either a <BNF name="linear data-modifying statement"/>,
a <BNF name="composite query statement"/>, or a <BNF name="conditional statement"/> that does not
simply contain a <BNF name="procedure specification"/> that also is 
a <BNF name="catalog-modifying procedure specification"/>. 
</item>

<comment>WG3:GYD-030</comment>
<item>If the <BNF name="query specification"/> <symdef>QS</symdef> is specified, then
every <BNF name="statement"/> simply contained in <sym>QS</sym> shall be either
a <BNF name="composite query statement"/> or a <BNF name="conditional statement"/> that does not 
simply contain a <BNF name="procedure specification"/> that also is 
a <BNF name="catalog-modifying procedure specification"/> or 
a <BNF name="data-modifying procedure specification"/>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>
<comment>WG3:UTC-077 Deleted 1 (one) GR</comment>

<comment>Editorial: Stefan Plantikow, 2020-09-26 focused procedure specification</comment>
<item>If a <BNF name="procedure specification"/> <symdef>PS</symdef> is specified
that is immediately contained in a <BNF name="transaction activity"/>, then:

<comment>Editorial: Stephen Cannan, 2020-10-16 Improve transaction management</comment>
<olist>

<comment>WG3:W08-013</comment>
<item>If no GQL-transaction is active, then a new GQL-transaction <symdef>TX</symdef> is initiated
and the current transaction is set to <sym>TX</sym>.

<comment>WG3:RKE-042 Editorial</comment>
<note>This determines <sym>TX</sym> as the currently active GQL-transaction associated with 
the GQL-session of the currently executing GQL-request.
</note>
</item>

<comment>WG3:BER-022</comment>
<comment>WG3:UTC-047</comment>
<item>If <sym>PS</sym> is a <BNF name="catalog-modifying procedure specification"/> and 
a <BNF name="data-modifying procedure specification"/> has already occurred in the current
transaction and the GQL-implementation does not support <feature code="GP18"/>, then 
an exception is raised: <raise class="25" subclass="G02"/>.
</item>

<comment>WG3:BER-022</comment>
<comment>WG3:UTC-047</comment>
<item>If <sym>PS</sym> is a <BNF name="data-modifying procedure specification"/> and 
a <BNF name="catalog-modifying procedure specification"/> has already occurred in the 
current transaction and the GQL-implementation does not support <feature code="GP18"/>, then 
an exception is raised: <raise class="25" subclass="G02"/>.
</item>
<comment>WG3:UTC-077 Deleted 2 GRs</comment>

<comment>WG3:UTC-047</comment>
<item>If <sym>PS</sym> contains a <BNF name="use graph clause"/> with 
<BNF name="graph expression"/> <symdef>GE2</symdef> and a <BNF name="use graph clause"/> with 
<BNF name="graph expression"/> <symdef>GE1</symdef> has already occurred in the 
current transaction and the result of <sym>GE2</sym> is different from the result of <sym>GE1</sym>
and the GQL-implementation does not support <feature code="GT03"/>, then an exception is raised: 
<raise class="25" subclass="G04"/>.
</item>

</olist>

</item>
<comment>WG3:UTC-077 Deleted 3 GRs</comment>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>
<comment>WG3:UTC-077 Deleted 1 (one) Subclause</comment>


<subClause id="gql_procedure_body" newpage="true">
<clauseHeading><BNF name="procedure body"/></clauseHeading>

<bodyMatter>

<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:BER-019</comment>
<para>Specify the body of a procedure.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-05-19 Parameter terminology reform</comment>
<comment>WG3:W16-040</comment>
<comment>WG3:W19-017</comment>
<comment>Consequence of WG3:W20-013</comment>
<BNFdef name="procedure body">
<rhs>
<opt> <BNF name="at schema clause"/> </opt>
<opt> <BNF name="binding variable definition block"/> </opt>
<BNF name="statement block"/>
</rhs>
</BNFdef>

<comment>WG3:BER-019</comment>
<comment>WG3:UTC-045R1</comment>
<BNFdef name="binding variable definition block">
<rhs>
<BNF name="binding variable definition"/><repeat/>
</rhs>
</BNFdef>

<comment>WG3:UTC-045R1</comment>
<BNFdef name="binding variable definition">
<rhs>
<alt> <BNF name="graph variable definition"/> </alt>
<alt> <BNF name="binding table variable definition"/> </alt>
<alt> <BNF name="value variable definition"/> </alt>
</rhs>
</BNFdef>
<comment>WG3:W16-040</comment>
<comment>WG3:BER-019 BNF deleted</comment>

<comment>WG3:W17-027</comment>
<comment>WG3:UTC-101</comment>
<BNFdef name="statement block">
<rhs>
<BNF name="statement"/>
<opt> <BNF name="next statement"/><repeat/> </opt>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-02-07</comment>
<comment>Editorial: Stefan Plantikow, 2020-07-29 Adjusted for WG3:MMX-055</comment>
<comment>WG3:W19-017 Removed at schema clause</comment>
<comment>Editorial: Stefan Plantikow, 2022-12-19 WG3:W24-009 570. P00-NLD-003</comment>
<comment>WG3:UTC-122</comment>
<comment>WG3:GYD-030</comment>
<BNFdef name="statement">
<rhs>
<alt> <BNF name="linear catalog-modifying statement"/> </alt>
<alt> <BNF name="linear data-modifying statement"/> </alt>
<alt> <BNF name="composite query statement"/> </alt>
<alt> <BNF name="conditional statement"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W17-027</comment>
<comment>WG3:UTC-101</comment>
<BNFdef name="next statement">
<rhs>
<kw>NEXT</kw> <opt> <BNF name="yield clause"/> </opt> <BNF name="statement"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<comment>Editorial: Stefan Plantikow, 2020-05-03 Informal Semantics removed</comment>
<SyntaxRules>

<olist>

<item>Let <symdef>PB</symdef> be the <BNF name="procedure body"/>.
</item>

<comment>WG3:BER-019</comment>
<comment>WG3:UTC-039R1</comment>
<comment>WG3:UTC-045R1</comment>
<comment>WG3:BER-019</comment>
<item>If the <BNF name="binding variable definition block"/> <symdef>BVDBLK</symdef> 
is specified, then:

<olist>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>BVDBLK</sym> is the
incoming working record type of <sym>PB</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>BVDBLK</sym> is the material unit binding table type.
</item>
<endbar/>

<comment>Editorial: Joern Bartels, 2022-06-21 Added definition of m</comment>
<comment>Editorial: Stefan Plantikow, 2023-03-15 Rename variable</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>Let <symdef>BVDSEQ</symdef> be the sequence of <BNF name="binding variable definition"/>s 
immediately contained in <sym>BVDBLK</sym>, let <symdef>N</symdef> be the number of elements 
of <sym>BVDSEQ</sym>.
</item>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of the first 
<BNF name="binding variable definition"/> in <sym>BVDSEQ</sym> is the incoming working record type
of <sym>BVDBLK</sym>.
</item>
<endbar/>

<comment>Editorial: Stefan Plantikow, 2023-03-15 Rename variable</comment>
<comment>WG3:CMN-019 P00-NLD-050</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>For <symdef>j</symdef>, 1 (one) <leq/> <sym>j</sym> <leq/> <sym>N</sym>, 
let <symdef>BVD</symdef><sub><sym>j</sym></sub> be the <sym>j</sym>-th element of 
<sym>BVDSEQ</sym>.
</item>

<comment>WG3:CMN-019 P00-NLD-050</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>For <symdef>j</symdef>, 2 (two) <leq/> <sym>j</sym> <leq/> <sym>N</sym>, 
the incoming working record type of <sym>BVD</sym><sub><sym>j</sym></sub> is 
the outgoing working record type of <sym>BVD</sym><sub><sym>j</sym>-1</sub>.
</item>

<comment>WG3:CMN-047R1</comment>
<comment>WG3:XRH-036</comment>
<item>The outgoing working record type of <sym>BVDBLK</sym> is the
outgoing working record type of <sym>BVD</sym><sub><sym>N</sym></sub>.
</item>

<comment>WG3:XRH-036</comment>
<item>The outgoing working table type of <sym>BVDBLK</sym> is the incoming working table type
of <sym>BVDBLK</sym>.
</item>
<endbar/>

</olist>

</item>

<item>Let <symdef>SBLK</symdef> be the <BNF name="statement block"/>.
</item>

<comment>Editorial: Consequence of WG3:W24-009 P00-NLD-003</comment>
<item>If <sym>SBLK</sym> directly contains a <BNF name="linear catalog-modifying statement"/>, then
<sym>SBLK</sym> shall directly contain at most one <BNF name="statement"/>.
</item>

<item>If <sym>SBLK</sym> directly contains a <BNF name="focused linear query statement"/> or
a <BNF name="focused linear data-modifying statement"/>, then
<sym>SBLK</sym> shall not directly contain an <BNF name="ambient linear query statement"/> or
an <BNF name="ambient linear data-modifying statement"/>.

<comment>WG3:UTC-096R1</comment>
<note>As a consequence of this rule, focused statements and ambient statement are mutually exclusive
within a <BNF name="statement block"/>, so that the following is true as well: 
If <sym>SBLK</sym> directly contains an <BNF name="ambient linear query statement"/> or
an <BNF name="ambient linear data-modifying statement"/>, then <sym>SBLK</sym> does not directly
contain a <BNF name="focused linear query statement"/> or
a <BNF name="focused linear data-modifying statement"/>.
</note>

</item>

<comment>WG3:UTC-096R1 Deleted 1 (one) rule</comment>

<item>If <sym>SBLK</sym> directly contains a <BNF name="linear query statement"/> that is
a <BNF name="select statement"/>, then every <BNF name="linear query statement"/> directly contained
in <sym>SBLK</sym> shall be a <BNF name="select statement"/>.
</item>

<item>If <sym>SBLK</sym> directly contains a <BNF name="linear query statement"/> that contains
a <BNF name="primitive result statement"/>, then every <BNF name="linear query statement"/> directly
contained in <sym>SBLK</sym> shall contain a <BNF name="primitive result statement"/>.
</item>

<comment>WG3:UTC-064 Deleted 1 (one) SR</comment>

<comment>WG3:UTC-101</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>Let <symdef>TSTMSEQ</symdef> be the sequence of <BNF name="next statement"/>s immediately 
contained in <sym>SBLK</sym>, let <symdef>M</symdef> be the number of 
elements of <sym>TSTMSEQ</sym>.
</item>

<comment>WG3:CMN-019 P00-USA-207</comment>
<item>For <symdef>j</symdef>, 0 (zero) <leq/> <sym>j</sym> <leq/> <sym>M</sym>, let the 
<BNF name="statement"/>s <symdef>STM</symdef><sub><sym>j</sym></sub> directly contained in 
<sym>SBLK</sym> be defined as follows:

<olist>

<item><sym>STM</sym><sub>0</sub> is the <BNF name="statement"/> immediately contained in 
<sym>SBLK</sym>.
</item>

<comment>WG3:CMN-019 P00-USA-045</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>For <sym>j</sym>, 1 (one) <leq/> <sym>j</sym> <leq/> <sym>M</sym>, 
<sym>STM</sym><sub><sym>j</sym></sub> is the <BNF name="statement"/> contained in the 
<sym>j</sym>-th element of <sym>TSTMSEQ</sym>.
</item>

</olist>

</item>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>STM</sym><sub>0</sub> 
is defined as follows.
<endbar/>

<para>Case:
</para>

<olist>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>If the <BNF name="binding variable definition block"/> <sym>BVDBLK</sym> was specified, then 
the incoming working record type of <sym>STM</sym><sub>0</sub> is the outgoing working record type
of <sym>BVDBLK</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>Otherwise, the incoming working record type of <sym>STM</sym><sub>0</sub> is the
incoming working record type of <sym>PB</sym>.
</item>

</olist>

</item>

<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>STM</sym><sub>0</sub> is 
the incoming working table type of <sym>PB</sym>.
</item>
<endbar/>

<comment>WG3:CMN-019 P00-USA-207</comment>
<item>For <symdef>j</symdef>, 1 (one) <leq/> <sym>j</sym> <leq/> <sym>M</sym>:

<olist>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>STM</sym><sub><sym>j</sym></sub> is 
the outgoing working record type of <sym>STM</sym><sub><sym>j</sym>-1</sub>.
</item>

<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>STM</sym><sub><sym>j</sym></sub> is 
defined as follows.
<endbar/>

<para>Case:
</para>

<olist>

<item>If the declared type of <sym>STM</sym><sub><sym>j</sym>-1</sub> is 
a binding table type <symdef>BTT</symdef>, then

<para>Case:
</para>

<olist>

<comment>WG3:UTC-101</comment>
<item>If the <BNF name="next statement"/> that directly contains 
<sym>STM</sym><sub><sym>j</sym></sub> also directly contains a <BNF name="yield clause"/> 
<symdef>YC</symdef>, then:

<olist>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>YC</sym> is <sym>BTT</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>STM</sym><sub><sym>j</sym></sub> 
is the declared type of <sym>YC</sym>.
</item>

</olist>

</item>

<comment>WG3:XRH-036</comment>
<item>Otherwise, the incoming working table type of 
<sym>STM</sym><sub><sym>j</sym></sub> is <sym>BTT</sym>.
</item>

</olist>

</item>

<comment>WG3:XRH-036</comment>
<item>Otherwise, the incoming working table type of
<sym>STM</sym><sub><sym>j</sym></sub> is the material unit binding table type.
</item>

</olist>

</item>

<comment>WG3:UTC-096R1</comment>
<comment>Email from: Hannes Voigt, 2023-03-03 1127 WG3:UTC-096R1</comment>
<comment>WG3:XRH-036</comment>
<item>The record type of the incoming working table type of <sym>STM</sym><sub><sym>j</sym></sub> 
and the incoming working record type of <sym>STM</sym><sub><sym>j</sym></sub> shall be
field name-disjoint.
</item>
<endbar/>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-207</comment>
<item>The declared type of <sym>PB</sym> is the declared type of 
<sym>STM</sym><sub><sym>M</sym></sub>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2020-05-03 Added GRs</comment>
<olist>
<comment>WG3:UTC-077 Deleted 1 (one) editor's note</comment>

<comment>Editorial: Stefan Plantikow, 2022-03-25 WG3:RKE-010 P00-NLD-219 Use default rule evaluation
order</comment>
<comment>WG3:BER-019</comment>
<item>If the <BNF name="binding variable definition block"/> <symdef>BVDBLK</symdef> is specified,
then:

<olist>
<comment>WG3:CMN-047 Deleted 1 (one) Subrule</comment>

<comment>WG3:CMN-047R1</comment>
<item>Let <symdef>CONTEXT</symdef> be a new child execution context.
</item>

<comment>WG3:CMN-047R1</comment>
<item>For <symdef>j</symdef>, 1 (one) <leq/> <sym>j</sym> <leq/> <sym>N</sym>,

<para>Case:
</para>

<olist>

<comment>WG3:CMN-047R1</comment>
<item>If <sym>BVD</sym><sub><sym>j</sym></sub> is a <BNF name="graph variable definition"/>, then
the General Rules of <specref ref="gql_varsparams_graph"/> are applied in <sym>CONTEXT</sym>.
</item>

<comment>WG3:CMN-047R1</comment>
<item>If <sym>BVD</sym><sub><sym>j</sym></sub> is 
a <BNF name="binding table variable definition"/>,
then the General Rules of <specref ref="gql_varsparams_bt"/> are applied in <sym>CONTEXT</sym>.
</item>

<comment>WG3:CMN-047R1</comment>
<item>Otherwise, <sym>BVD</sym><sub><sym>j</sym></sub> is a <BNF name="value variable definition"/>
and the General Rules of <specref ref="gql_varsparams_val"/> are applied in <sym>CONTEXT</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-351</comment>
<item>The current working record is set to the working record of <sym>CONTEXT</sym>.
</item>

</olist>

</item>
<comment>WG3:RKE-015 Moved SBLK to SRs</comment>

<comment>WG3:W17-027</comment>
<comment>WG3:BER-019</comment>
<item>The General Rules of <sym>STM</sym><sub>0</sub> are applied.

<comment>WG3:UTC-122</comment>
<comment>WG3:UTC-096R1</comment>
<comment>WG3:CMN-047R1</comment>
<note>Not all statements set a result; instead they possibly modify the current execution 
context.
A result is set by <BNF name="primitive result statement"/>s and by
<BNF name="simple data-modifying statement"/>s to determine
the execution outcome of a GQL-procedure or a top-level <BNF name="statement"/>.
</note>

</item>

<comment>WG3:W17-027</comment>
<comment>WG3:RKE-043</comment>
<comment>WG3:BER-019 One rule deleted</comment>
<comment>Editorial: Stefan Plantikow, 2020-06-09 Moved here</comment>
<comment>Editorial: Stefan Plantikow, 2020-07-12 WG3:MMX-055</comment>
<comment>WG3:W19-017 Moved working schema to SR-time</comment>
<comment>WG3:W17-027</comment>
<comment>WG3:RKE-015 Remove unused symbol "CWG0"</comment>

<comment>WG3:W17-027</comment>
<comment>Editorial: Stephen Cannan 2021-11-28</comment>
<comment>Editorial: Stephen Cannan, 2022-03-06 WG3:RKE-010 P00-USA-478</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>For <symdef>j</symdef>, 1 (one) <leq/> <sym>j</sym> <leq/> <sym>M</sym>:

<olist>
<comment>WG3:RKE-015 Remove unused symbol: "CWGj"</comment>

<item>Case:

<olist>
<comment>Editorial: Stefan Plantikow, 2020-05-12 Corrected index in GRs to be j-1</comment>
<comment>WG3:W20-027R1</comment>
<comment>WG3:RKE-015 Removed one case for result graphs</comment>

<comment>WG3:W20-027R1</comment>
<comment>Editorial: Stefan Plantikow, 2022-03-25 Simplify</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<comment>WG3:CMN-047R1</comment>
<item>If the current execution outcome has a binding table result <symdef>BTR</symdef>, then
the current working table is set to <sym>BTR</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2020-05-12 Editorial reformatting</comment>
<comment>WG3:RKE-015</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item>Otherwise, the current working table is set to a new unit binding table.
</item>

</olist>
<comment>Editorial: Stefan Plantikow, 2022-04-11 Removed two Editor's Notes</comment>

</item>

<comment>WG3:W17-027</comment>
<comment>Editorial: Stefan Plantikow, 2022-03-25 WG3:RKE-010 P00-NLD-219 Wording</comment>
<comment>WG3:BER-019</comment>
<comment>WG3:UTC-101</comment>
<comment>WG3:CMN-019 P00-USA-351 P00-NLD-012</comment>
<item>If the <BNF name="next statement"/> that directly contains 
<sym>STM</sym><sub><sym>j</sym></sub> also directly contains a <BNF name="yield clause"/> 
<symdef>YC</symdef>, then:


<olist>

<comment>Editorial: Stephen Cannan, 2024-03-19 Temporarily replace ApplySC</comment>
<item id="gql_procedure_body_GR3bi">The General Rules of <specref ref="gql_yield"/>, are applied; 
let <symdef>YIELD</symdef> be the result of <sym>YC</sym> after the application of those 
General Rules.
<ednote id="gql_PPgql388">This rule must use the applySC markup.
See <PPref ref="PPgql388"/>.
</ednote>
</item>

<item>The current working table is set to <sym>YIELD</sym>.
</item>

</olist>

</item>

<comment>Editorial: Stefan Plantikow, 2022-03-25 WG3:RKE-010 P00-NLD-219 Wording</comment>
<comment>WG3:BER-019</comment>
<item>The General Rules of <sym>STM</sym><sub><sym>j</sym></sub> are applied.

<comment>WG3:UTC-122</comment>
<comment>WG3:UTC-096R1</comment>
<comment>WG3:CMN-047R1</comment>
<note>Not all statements set a result; instead they possibly modify the current execution 
context.
A result is set by <BNF name="primitive result statement"/>s and by
<BNF name="simple data-modifying statement"/>s to determine
the execution outcome of a GQL-procedure or a top-level <BNF name="statement"/>.
</note>

</item>

</olist>

</item>

<comment>Editorial: Stefan Plantikow, 2020-06-09 Added</comment>
<comment>WG3:W19-017 Moved working schema to SR-time</comment>

<comment>Editorial: Stefan Plantikow, 2022-03-25 Wording</comment>
<comment>WG3:BER-099R1</comment>
<item>The outcome of the application of these General Rules is the current execution outcome.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-039R1</comment>
<item>Without <feature code="GP16"/>, in conforming GQL language,
a <BNF name="procedure body"/> shall not contain an <BNF name="at schema clause"/>.
</item>

<comment>WG3:UTC-039R1</comment>
<item>Without <feature code="GP17"/>, in conforming GQL language,
a <BNF name="procedure body"/> shall not contain a <BNF name="binding variable definition block"/>.
</item>

<comment>WG3:UTC-039R1</comment>
<comment>WG3:CMN-049</comment>
<item>Without <feature code="GP11"/>, in conforming GQL language,
a <BNF name="binding variable definition"/> shall not contain 
a <BNF name="graph variable definition"/>.
</item>

<comment>WG3:UTC-039R1</comment>
<comment>WG3:CMN-049</comment>
<item>Without <feature code="GP08"/>, in conforming GQL language,
a <BNF name="binding variable definition"/> shall not contain
a <BNF name="binding table variable definition"/>.
</item>

<comment>WG3:CMN-019 P00-USA-046</comment>
<comment>WG3:CMN-049</comment>
<item>Without <feature code="GP05"/>, in conforming GQL language,
a <BNF name="binding variable definition"/> shall not contain
a <BNF name="value variable definition"/>.
</item>

<comment>WG3:UTC-039R1</comment>
<comment>WG3:UTC-101</comment>
<item>Without <feature code="GQ20"/>, in conforming GQL language,
a <BNF name="procedure body"/> shall not contain a <BNF name="next statement"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>

</clause>


<comment>WG3:W22-031</comment>
<comment>WG3:W22-054</comment>
<comment>WG3:UTC-045R1</comment>
<clause id="gql_varsparams">
<clauseHeading>Variable definitions</clauseHeading>

<comment>WG3:W22-031</comment>
<comment>WG3:W22-054</comment>
<comment>WG3:UTC-045R1</comment>
<subClause id="gql_varsparams_graph">
<clauseHeading><BNF name="graph variable definition"/></clauseHeading>

<bodyMatter>


<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>Editorial: Stephen Cannan, 2022-03-07 WG3:RKE-010 P00-USA-217</comment>
<comment>WG3:BER-019</comment>
<comment>WG3:W22-054</comment>
<comment>WG3:UTC-045R1</comment>
<para>Define graph variables.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:BER-019</comment>
<comment>WG3:W22-051</comment>
<comment>WG3:W27-011</comment>
<BNFdef name="graph variable definition">
<rhs>
<opt> <kw>PROPERTY</kw> </opt> <kw>GRAPH</kw> <BNF name="binding variable"/> 
<BNF name="opt typed graph initializer"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-045R1</comment>
<BNFdef name="opt typed graph initializer">
<rhs>
<opt> <opt> <BNF name="typed"/> </opt> <BNF name="graph reference value type"/> </opt> 
<BNF name="graph initializer"/>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-06-10 Made optional</comment>
<comment>WG3:W22-051 Two alternatives removed</comment>
<comment>WG3:UTC-045R1</comment>
<BNFdef name="graph initializer">
<rhs>
<BNF name="equals operator"/> <BNF name="graph expression"/> 
</rhs>
</BNFdef>
<comment>WG3:W22-051 Moved "as or equals" to "parameter definition"</comment>
<comment>Editorial: Stefan Plantikow, 2020-07-27 Moved graph variable</comment>

</grammar>
<comment>Editorial: Stefan Plantikow, 2020-11-12</comment>
<comment>WG3:BER-019 One note deleted</comment>

</Format>


<comment>Editorial: Stefan Plantikow, 2020-10-11 Informal Semantics removed</comment>
<SyntaxRules>

<olist>
<comment>WG3:W22-051 deleted one SR</comment>

<comment>WG3:UTC-045R1</comment>
<item>Let <symdef>GVD</symdef> be the <BNF name="graph variable definition"/>.
</item>

<comment>WG3:UTC-045R1</comment>
<comment>WG3:W27-011</comment>
<item>Let <symdef>GN</symdef> be the name of the <BNF name="binding variable"/> simply contained 
in <sym>GVD</sym>.
</item>

<comment>WG3:UTC-045R1</comment>
<item>Let <symdef>OTGI</symdef> be the <BNF name="opt typed graph initializer"/> immediately 
contained in <sym>GVD</sym>.
</item>

<comment>WG3:UTC-045R1</comment>
<item>Let <symdef>GI</symdef> be the <BNF name="graph initializer"/> immediately contained in 
<sym>OTGI</sym>.
</item>

<comment>WG3:UTC-045R1</comment>
<item>The declared type of <sym>GI</sym> is the declared type of the <BNF name="graph expression"/> 
immediately contained in <sym>GI</sym>.
</item>

<comment>WG3:UTC-045R1</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>IWRT</symdef> be the incoming working record type of 
<sym>GVD</sym>.
</item>
<endbar/>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item><sym>IWRT</sym> shall not have a field type whose name is <sym>GN</sym>.
</item>

<comment>WG3:UTC-045R1</comment>
<item>Let the graph reference value type <symdef>GT</symdef> be defined as follows.

<olist>

<item>Let <symdef>GIT</symdef> be the declared type of <sym>GI</sym>.
</item>

<item>Case:

<olist>

<comment>WG3:W22-051</comment>
<item>If <sym>GVD</sym> simply contains a <BNF name="graph reference value type"/> 
<symdef>OGT</symdef> without an intervening instance of <BNF name="graph initializer"/>, then:

<olist>

<comment>WG3:W25-031R2</comment>
<item><sym>GIT</sym> shall be assignable to the graph reference value type specified by 
<sym>OGT</sym>.
</item>

<comment>WG3:W25-031R2</comment>
<item><sym>GT</sym> is the graph reference value type specified by <sym>OGT</sym>.
</item>

</olist>

</item>

<item>Otherwise, <sym>GT</sym> is <sym>GIT</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:OHD-026</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>The outgoing working record type of <sym>GVD</sym> is a record type
comprising all the field types of <sym>IWRT</sym> and one additional field type with
name <sym>GN</sym> and value type <sym>GT</sym>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<comment>Editorial: Stefan Plantikow, 2020-10-11 Added draft GRs</comment>
<GeneralRules>

<olist>
<comment>Editorial: Stefan Plantikow, 2020-11-12 Adjust variable names</comment>
<comment>WG3:BER-019 One rule deleted</comment>

<comment>WG3:W21-044</comment>
<comment>WG3:W22-051</comment>
<comment>WG3:UTC-045R1</comment>
<item>The result of <sym>GI</sym> is the result of the <BNF name="graph expression"/>
immediately contained in <sym>GI</sym>.
</item>

<item>Let <symdef>ROGI</symdef> be the result of <sym>GI</sym>.
</item>

<comment>WG3:BER-019</comment>
<comment>WG3:W25-031R2</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item>A field with name <sym>GN</sym> and value assigned from <sym>ROGI</sym> is added to 
the current working record.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:CMN-049</comment>
<item>Without <feature code="GP12"/>, conforming GQL language shall not contain
a <BNF name="graph variable definition"/> that contains a <BNF name="procedure body"/>.
</item>

<comment>WG3:CMN-049</comment>
<item>Without <feature code="GP13"/>, conforming GQL language shall not contain
a <BNF name="graph variable definition"/> that simply contains a <BNF name="graph expression"/>
that does not conform to <BNF name="value specification"/> or is a <BNF name="graph reference"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>Editorial: Stefan Plantikow, 2020-02-06</comment>
<comment>WG3:W22-031</comment>
<comment>WG3:W22-054</comment>
<comment>WG3:UTC-045R1</comment>
<subClause id="gql_varsparams_bt" newpage="true">
<clauseHeading><BNF name="binding table variable definition"/></clauseHeading>

<bodyMatter>


<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:W22-054</comment>
<comment>WG3:UTC-045R1</comment>
<para>Define binding table variables.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stephen Cannan, 2022-03-07 WG3:RKE-010 P00-USA-466</comment>
<comment>WG3:BER-019</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-045R1</comment>
<comment>WG3:W27-011</comment>
<BNFdef name="binding table variable definition">
<rhs>
<opt> <kw>BINDING</kw> </opt> <kw>TABLE</kw> <BNF name="binding variable"/>
<BNF name="opt typed binding table initializer"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-045R1</comment>
<BNFdef name="opt typed binding table initializer">
<rhs>
<opt> <opt> <BNF name="typed"/> </opt> <BNF name="binding table reference value type"/> </opt>
<BNF name="binding table initializer"/>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-06-10 Made optional</comment>
<comment>WG3:W22-051</comment>
<comment>WG3:UTC-045R1</comment>
<BNFdef name="binding table initializer">
<rhs>
<BNF name="equals operator"/> <BNF name="binding table expression"/> 
</rhs>
</BNFdef>

</grammar>

<comment>Editorial: Stefan Plantikow, 2020-11-12</comment>
<comment>WG3:BER-019 One note deleted</comment>

</Format>


<SyntaxRules>

<olist>
<comment>WG3:W22-051 deleted on SR</comment>

<comment>WG3:UTC-045R1</comment>
<item>Let <symdef>BTVD</symdef> be the <BNF name="binding table variable definition"/>.
</item>

<comment>WG3:UTC-045R1</comment>
<comment>WG3:W27-011</comment>
<item>Let <symdef>BTN</symdef> be the name of the <BNF name="binding variable"/> simply 
contained in <sym>BTVD</sym>.
</item>

<item>Let <symdef>OTBTI</symdef> be the <BNF name="opt typed binding table initializer"/> 
immediately contained in <sym>BTVD</sym>.
</item>

<item>Let <symdef>BTI</symdef> be the <BNF name="binding table initializer"/> immediately contained 
in <sym>OTBTI</sym>.
</item>

<item>The declared type of <sym>BTI</sym> is the declared type of the 
<BNF name="binding table expression"/> immediately contained in <sym>BTI</sym>.
</item>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>IWRT</symdef> be the incoming working record type of
<sym>BTVD</sym>.
</item>
<endbar/>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item><sym>IWRT</sym> shall not have a field type whose name is <sym>BTN</sym>.
</item>

<comment>WG3:UTC-045R1</comment>
<item>Let the binding table reference value type <symdef>BTT</symdef> be defined as follows.

<olist>

<item>Let <symdef>BTIT</symdef> be the declared type of <sym>BTI</sym>.
</item>

<item>Case:

<olist>

<comment>WG3:BER-040R3</comment>
<item>If <sym>BTVD</sym> simply contains a <BNF name="binding table reference value type"/> 
<symdef>OBTT</symdef> without an intervening instance of <BNF name="binding table initializer"/>, 
then:

<olist>

<comment>WG3:W25-031R2</comment>
<item><sym>BTIT</sym> shall be assignable to the binding table reference value type specified by 
<sym>OBTT</sym>.
</item>

<comment>WG3:W25-031R2</comment>
<item><sym>BTT</sym> is the binding table reference value type specified by <sym>OBTT</sym>.
</item>

</olist>

</item>

<item>Otherwise, <sym>BTT</sym> is <sym>BTIT</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:OHD-026</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The outgoing working record type of <sym>BTVD</sym> is a record type
comprising all the field types of <sym>IWRT</sym> and one additional field type with
name <sym>BTN</sym> and value type <sym>BTT</sym>.
</item>
<endbar/>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<comment>Editorial: Stefan Plantikow, 2020-10-11 Added draft GRs</comment>
<GeneralRules>

<olist>
<comment>Editorial: Stefan Plantikow, 2020-11-12 Adjust variable names</comment>
<comment>WG3:BER-019 One rule deleted</comment>

<comment>WG3:W21-044</comment>
<comment>WG3:W22-051</comment>
<comment>WG3:UTC-045R1</comment>
<item>The result of <sym>BTI</sym> is the result of the <BNF name="binding table expression"/>
immediately contained in <sym>BTI</sym>.
</item>

<item>Let <symdef>ROBTI</symdef> be the result of <sym>BTI</sym>.
</item>

<comment>WG3:BER-019</comment>
<comment>WG3:W25-031R2</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item>A field with name <sym>BTN</sym> and value assigned from <sym>ROBTI</sym> is added to the 
current working record.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:CMN-049</comment>
<item>Without <feature code="GP10"/>, conforming GQL language shall not contain
a <BNF name="binding table variable definition"/> that contains a <BNF name="procedure body"/>.
</item>

<comment>WG3:CMN-049</comment>
<item>Without <feature code="GP09"/>, conforming GQL language shall not contain
a <BNF name="binding table variable definition"/> that simply contains
a <BNF name="binding table expression"/> that does not conform to <BNF name="value specification"/>
or is a <BNF name="binding table reference"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W22-031</comment>
<comment>WG3:W22-054</comment>
<comment>WG3:UTC-045R1</comment>
<subClause id="gql_varsparams_val" newpage="true">
<clauseHeading><BNF name="value variable definition"/></clauseHeading>

<bodyMatter>


<Function>

<comment>WG3:W22-054</comment>
<comment>WG3:UTC-045R1</comment>
<para>Define value variables.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-11-12 Made of value type optional</comment>
<comment>WG3:UTC-045R1</comment>
<comment>WG3:W27-011</comment>
<BNFdef name="value variable definition">
<rhs>
<kw>VALUE</kw> <BNF name="binding variable"/> <BNF name="opt typed value initializer"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-045R1</comment>
<BNFdef name="opt typed value initializer">
<rhs>
<opt> <opt> <BNF name="typed"/> </opt> <BNF name="value type"/> </opt>
<BNF name="value initializer"/>
</rhs>
</BNFdef>

<comment>WG3:W22-051 deleted one alternative</comment>
<comment>WG3:UTC-045R1</comment>
<BNFdef name="value initializer">
<rhs>
<BNF name="equals operator"/> <BNF name="value expression"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<comment>Editorial: Stefan Plantikow, 2020-10-11 Informal Semantics removed</comment>
<SyntaxRules>

<olist>

<comment>WG3:UTC-045R1</comment>
<item>Let <symdef>VVD</symdef> be the <BNF name="value variable definition"/>.
</item>

<comment>WG3:UTC-045R1</comment>
<comment>WG3:W27-011</comment>
<item>Let <symdef>VN</symdef> be the name of the <BNF name="binding variable"/> immediately 
contained in <sym>VVD</sym>.
</item>

<comment>WG3:UTC-045R1</comment>
<item>Let <symdef>OTVI</symdef> be the <BNF name="opt typed value initializer"/> immediately 
contained in <sym>VVD</sym>.
</item>

<comment>WG3:UTC-045R1</comment>
<item>Let <symdef>VI</symdef> be the <BNF name="value initializer"/> immediately contained in 
<sym>OTVI</sym>.
</item>

<comment>WG3:UTC-045R1</comment>
<item>The declared type of <sym>VI</sym> is the declared type of the <BNF name="value expression"/>
immediately contained in <sym>VI</sym>.
</item>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>IWRT</symdef> be the incoming working record type of 
<sym>VVD</sym>.
</item>
<endbar/>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item><sym>IWRT</sym> shall not have a field type whose name is <sym>VN</sym>.
</item>

<comment>WG3:UTC-045R1</comment>
<item>Let the value type <symdef>VT</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:UTC-045R1</comment>
<item>Let <symdef>VIT</symdef> be the declared type of <sym>VI</sym>.
</item>

<comment>WG3:UTC-045R1</comment>
<item>Case:

<olist>

<comment>WG3:UTC-045R1</comment>
<item>If <sym>OTVI</sym> immediately contains a <BNF name="value type"/> <symdef>OVT</symdef>, then:

<olist>

<comment>WG3:W24-034R2</comment>
<comment>WG3:W25-031R2</comment>
<item><sym>VIT</sym> shall be assignable to the value type specified by <sym>OVT</sym>.
</item>

<comment>WG3:W25-031R2</comment>
<item><sym>VT</sym> is the value type specified by <sym>OVT</sym>.
</item>

</olist>

</item>

<item>Otherwise, <sym>VT</sym> is <sym>VIT</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:OHD-026</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The outgoing working record type of <sym>VVD</sym> is a record type
comprising all the field types of <sym>IWRT</sym> and one additional field type with
name <sym>VN</sym> and value type <sym>VT</sym>.
</item>
<endbar/>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<comment>Editorial: Stefan Plantikow, 2020-10-11 Added draft GRs</comment>
<GeneralRules>

<olist>
<comment>Editorial: Stefan Plantikow, 2020-11-12 Use unique symbol names</comment>
<comment>WG3:BER-019 One rule deleted</comment>

<comment>WG3:W21-044</comment>
<comment>WG3:W22-051</comment>
<comment>WG3:UTC-045R1</comment>
<item>The result of <sym>VI</sym> is the result of the <BNF name="value expression"/> immediately 
contained in <sym>VI</sym>.
</item>

<comment>WG3:UTC-045R1</comment>
<item>Let <symdef>ROVI</symdef> be the result of <sym>VI</sym>.
</item>

<comment>WG3:W25-031R2</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item>A field with name <sym>VN</sym> and value assigned from <sym>ROVI</sym> is added to 
the current working record.
</item>
<comment>WG3:BER-019 One rule deleted</comment>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:CMN-049</comment>
<item>Without <feature code="GP07"/>, conforming GQL language shall not contain
a <BNF name="value variable definition"/> that contains a <BNF name="procedure body"/>.
</item>

<comment>WG3:CMN-049</comment>
<item>Without <feature code="GP06"/>, conforming GQL language shall not contain
a <BNF name="value variable definition"/> that simply contains a <BNF name="value expression"/>
that does not conform to <BNF name="value specification"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>

</clause>


<comment>WG3:UTC-042 renamed the clause</comment> 
<clause id="gql_objects">
<clauseHeading>Object expressions</clauseHeading>
<comment>WG3:W22-051 deleted "Introduction to object and object type expressions"</comment>

<comment>Editorial: Stefan Plantikow, 2020-03-26</comment>
<subClause id="gql_gexpr">
<clauseHeading><BNF name="graph expression"/></clauseHeading>

<bodyMatter>

<Function>

<comment>WG3:MMX-028R2</comment>
<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:W22-051</comment>
<para>Specify a graph reference value.
</para>

</Function>

<comment>WG3:MMX-028R2</comment>
<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-07-29 Adjusted for WG3:MMX-055</comment>
<comment>WG3:BER-039</comment>
<comment>WG3:W22-051</comment>
<comment>WG3:UTC-039R1</comment>
<comment>WG3:CMN-019 P00-USA-048</comment>
<BNFdef name="graph expression">
<rhs>
<alt> <BNF name="object expression primary"/> </alt>
<alt> <BNF name="graph reference"/> </alt>
<alt> <BNF name="object name or binding variable"/> </alt>
<alt> <BNF name="current graph"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-039R1 Deleted 1 (one) editor's note</comment>

<comment>WG3:UTC-039R1</comment>
<BNFdef name="current graph">
<rhs>
<alt br="no"> <kw>CURRENT_PROPERTY_GRAPH</kw> </alt>
<alt br="no"> <kw>CURRENT_GRAPH</kw> </alt>
</rhs>
</BNFdef>

<comment>WG3:CMN-019 P00-USA-048 1 (one) production removed</comment>

</grammar>

</Format>


<comment>WG3:MMX-028R2</comment>
<SyntaxRules>

<olist>

<comment>WG3:W22-051</comment>
<item>Let <symdef>GE</symdef> be the <BNF name="graph expression"/>.
</item>

<comment>WG3:UTC-039R1 Deleted 3 SRs</comment>

<comment>WG3:CMN-019 P00-USA-048 1 (one) SR removed</comment>

<comment>WG3:UTC-039R1</comment>
<item>If <sym>GE</sym> is an <BNF name="object name or binding variable"/> that is
a <BNF name="regular identifier"/> <symdef>RI</symdef>, then

<para>Case:
</para>

<olist>

<comment>WG3:UTC-039R1</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>If <sym>RI</sym> is a valid <BNF name="binding variable reference"/> whose 
incoming working record type is the incoming working record type of <sym>GE</sym>, then
<sym>GE</sym> is effectively replaced by the <BNF name="object expression primary"/>:
x<code>
<kw>VARIABLE</kw> <sym>RI</sym>
</code>

<comment>WG3:UTC-039R1</comment>
<note><sym>RI</sym> is only a valid <BNF name="binding variable reference"/>, if a binding variable
referenced by <sym>RI</sym> is available to <sym>GE</sym>, <ie/> if 
the incoming working record type of <sym>GE</sym> has a field type whose name is the name of
the referenced binding variable of <sym>RI</sym>, <cf/> <specref ref="gql_var_refs"/>
</note> 

</item>
<endbar/>

<comment>WG3:UTC-039R1</comment>
<item>Otherwise, <sym>GE</sym> is effectively replaced by the <BNF name="graph reference"/>:
<code>
./<sym>RI</sym>
</code>

</item>

</olist>

<comment>WG3:UTC-039R1</comment>
<comment>Email from: Hannes Voigt, 2023-03-01 1200 WG3 UTC-039R1</comment>
<note>This syntax transformation removes <BNF name="object name or binding variable"/> as
an alternative of <BNF name="graph expression"/>, so that this alternative has not to be considered
subsequently.
</note>

</item>

<comment>WG3:UTC-039R1</comment>
<item>The declared type of <sym>GE</sym> is defined as follows.

<para>Case:
</para>

<olist>
<comment>WG3:CMN-019 P00-USA-0481 (one) SR removed</comment>

<comment>WG3:UTC-039R1</comment>
<item>If <sym>GE</sym> implicitly or explicitly specifies <kw>VARIABLE</kw>, then:

<olist>

<item>Let <symdef>VEP</symdef> be the <BNF name="value expression primary"/> simply contained
in <sym>GE</sym>.
</item>

<item>The declared type of <sym>VEP</sym> shall be a material graph reference value type.
</item>

<item>The declared type of <sym>GE</sym> is the declared type of <sym>VEP</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-039R1</comment>
<comment>Editorial; Jim Melton, 2023-09-04; fix which/that problems</comment>
<item>If <sym>GE</sym> is a <BNF name="graph reference"/> <symdef>GR</symdef> that identifies
a graph <symdef>G</symdef>, then:

<para>Case:
</para>

<olist>

<comment>WG3:UTC-039R1</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<item>If <sym>G</sym> has a constraining graph type <symdef>CGT</symdef>, then
the declared type of <sym>GE</sym> is the graph reference value type whose constraining GQL-object
type is <sym>CGT</sym>.
</item>

<comment>WG3:UTC-039R1</comment>
<item>Otherwise, the declared type of <sym>GE</sym> is the open graph reference value type.
</item>

</olist>

</item>

<comment>WG3:UTC-039R1</comment>
<item>Otherwise, <sym>GE</sym> is a <BNF name="current graph"/> and

<olist>

<comment>WG3:CMN-042</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use of omitted</comment>
<item>The current working graph site of <sym>GE</sym> shall not be <quote>omitted</quote>.
</item>

<comment>WG3:CMN-042</comment>
<item>Let <symdef>CWGS</symdef> be the current working graph site of <sym>GE</sym>.
</item>

<comment>WG3:CMN-042</comment>
<item>The declared type of <sym>GE</sym> is the declared type of <sym>CWGS</sym>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>Editorial: Stefan Plantikow, 2020-09-25 Rules moved to: predefined graph parameter
</comment>
<comment>Editorial: Stefan Plantikow, 2020-07-29 WG3:MMX-055</comment>
<comment>Editorial: Stefan Plantikow, 2020-09-25 Rule replaced by general evaluation order
</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-09 Refactor to expression</comment>
<comment>WG3:W22-051</comment>
<item>The result of <sym>GE</sym> is the graph reference value <symdef>GRV</symdef> defined
as follows.

<para>Case:
</para>

<comment>WG3:BER-039</comment>
<olist>
<comment>WG3:CMN-019 P00-USA-048 1 (one) GR removed</comment>

<comment>WG3:UTC-039R1</comment>
<item>If <sym>GE</sym> implicitly or explicitly specifies <kw>VARIABLE</kw>, then <sym>GRV</sym> is
the result of the <BNF name="value expression primary"/> simply contained in <sym>GE</sym>.
</item>

<item>If <sym>GE</sym> simply contains the <BNF name="graph reference"/> <symdef>GR</symdef>, then
<sym>GRV</sym> is a graph reference value whose referent is the graph identified by <sym>GR</sym>.
</item>

<comment>WG3:UTC-039R1</comment>
<comment>WG3:CMN-042</comment>
<item>Otherwise, <sym>GE</sym> is a <BNF name="current graph"/> and <sym>GRV</sym> is
the graph reference value occupying <sym>CWGS</sym>.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-039R1</comment>
<comment>WG3:CMN-019 P00-USA-048</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>Without <feature code="GV60"/>, in conforming GQL language,
a <BNF name="graph expression"/> <symdef>GE</symdef> shall not be
an <BNF name="object name or binding variable"/> that is a <BNF name="regular identifier"/> that
also is a valid <BNF name="binding variable reference"/> whose incoming working record type is 
the incoming working record type of <sym>GE</sym>.

<comment>WG3:UTC-039R1</comment>
<comment>WG3:CMN-042</comment>
<note>Without <feature code="GV60"/>, <BNF name="graph expression"/> is limited to references to
graphs in the catalog and the graph referenced by the current working graph site of
the <BNF name="graph expression"/>.
</note>

</item>
<endbar/>

</olist>

</ConformanceRules>


</bodyMatter>

</subClause>
<comment>WG3:W22-051 deleted one Subclause.</comment>


<subClause id="gql_bte" newpage="true">
<clauseHeading><BNF name="binding table expression"/></clauseHeading>

<bodyMatter>


<Function>

<comment>WG3:W22-051</comment>
<para>Specify a binding table reference value.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:W22-051</comment>
<comment>WG3:UTC-039R1</comment>
<BNFdef name="binding table expression">
<rhs>
<alt> <BNF name="nested binding table query specification"/> </alt>
<alt> <BNF name="object expression primary"/> </alt>
<alt> <BNF name="binding table reference"/> </alt>
<alt> <BNF name="object name or binding variable"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-039R1 Deleted 1 (one) editor's note</comment>

<comment>WG3:W22-051</comment>
<BNFdef name="nested binding table query specification">
<rhs>
<BNF name="nested query specification"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:W22-051</comment>
<item>Let <symdef>BTE</symdef> be the <BNF name="binding table expression"/>.
</item>

<comment>WG3:UTC-039R1 Deleted 3 SRs</comment>

<comment>WG3:W22-051</comment>
<item>The declared type of a <BNF name="nested binding table query specification"/> shall be
a binding table type or a binding table reference value type.
</item>

<comment>WG3:UTC-039R1</comment>
<item>If <sym>BTE</sym> is an <BNF name="object name or binding variable"/> that is
a <BNF name="regular identifier"/> <symdef>RI</symdef>, then

<para>Case:
</para>

<olist>

<comment>WG3:UTC-039R1</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>If <sym>RI</sym> is a valid <BNF name="binding variable reference"/> whose 
incoming working record’s declared type is the incoming working record type of <sym>BTE</sym>, then
<sym>BTE</sym> is effectively replaced by the <BNF name="object expression primary"/>:
<code>
<kw>VARIABLE</kw> <sym>RI</sym>
</code>

<comment>WG3:UTC-039R1</comment>
<note><sym>RI</sym> is only a valid <BNF name="binding variable reference"/>, if a binding variable
referenced by <sym>RI</sym> is available to <sym>BTE</sym>, <ie/> if 
the incoming working record type of <sym>BTE</sym> has a field type whose name is the name of
the referenced binding variable of <sym>RI</sym>, <cf/> <specref ref="gql_var_refs"/>.
</note>
</item>
<endbar/>

<comment>WG3:UTC-039R1</comment>
<item>Otherwise, <sym>BTE</sym> is effectively replaced by 
the <BNF name="binding table reference"/>:
<code>
./<sym>RI</sym>
</code>

</item>

</olist>

<comment>WG3:UTC-039R1</comment>
<comment>Email from: Hannes Voigt, 2023-03-01 1200 WG3 UTC-039R1</comment>
<note>This syntax transformation removes <BNF name="object name or binding variable"/> as
an alternative of <BNF name="binding table expression"/>, so that this alternative has not to be
considered subsequently.
</note>

</item>

<comment>WG3:UTC-039R1</comment>
<item>The declared type of <sym>BTE</sym> is defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:UTC-039R1</comment>
<item>If <sym>BTE</sym> is
a <BNF name="nested binding table query specification"/> <symdef>NBTQS</symdef>, then
the declared type of <sym>BTE</sym> is the declared type of <sym>NBTQS</sym>.
</item>

<comment>WG3:UTC-039R1</comment>
<item>If <sym>BTE</sym> implicitly or explicitly specifies <kw>VARIABLE</kw>, then:

<olist>

<item>Let <symdef>VEP</symdef> be the <BNF name="value expression primary"/>
simply contained in <sym>BTE</sym>.
</item>

<item>The declared type of <sym>VEP</sym> shall be a material binding table reference value type.
</item>

<item>The declared type of <sym>BTE</sym> is the declared type of <sym>VEP</sym>.
</item>


</olist>

</item>

<comment>WG3:UTC-039R1</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<comment>Editorial; Jim Melton, 2023-09-04; fix which/that problems</comment>
<item>If <sym>BTE</sym> is a <BNF name="binding table reference"/> <symdef>BTR</symdef> that
identifies a binding table <symdef>BT</symdef>, then the declared type of <sym>BTE</sym> is
a material binding table reference value type whose constraining GQL-object type is
the binding table type of <sym>BT</sym>.
</item>

</olist>

</item>

</olist>

</SyntaxRules>


<GeneralRules>

<olist>

<comment>WG3:W22-051</comment>
<item>The result of <sym>BTE</sym> is the binding table reference value <symdef>BTRV</symdef>
defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>BTE</sym> simply contains
the <BNF name="nested binding table query specification"/> <sym>NBTQS</sym>, then

<para>Case:
</para>

<olist>

<item>If the result of the <BNF name="nested query specification"/> immediately contained in
<sym>NBTQS</sym> is a binding table reference value <symdef>V</symdef>, then
<sym>BTRV</sym> is <sym>V</sym>.
</item>

<item>Otherwise, <sym>BTRV</sym> is a binding table reference value whose referent is the binding
table that is the result of the <BNF name="nested query specification"/> immediately contained in
<sym>NBTQS</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-039R1</comment>
<item>If <sym>BTE</sym> implicitly or explicitly specifies <kw>VARIABLE</kw>, then <sym>BTRV</sym>
is the result of the <BNF name="value expression primary"/> simply contained in <sym>BTE</sym>.
</item>

<item>If <sym>BTE</sym> simply contains the <BNF name="binding table reference"/> <sym>BTR</sym>,
then <sym>BTRV</sym> is a binding table reference value whose referent is the binding table
identified by <sym>BTR</sym>.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-039R1</comment>
<comment>Email from: Hannes Voigt, 2023-03-01 1200 WG3 UTC-039R1</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>Without <feature code="GV61"/>, in conforming GQL language,
a <BNF name="binding table expression"/> <symdef>BTE</symdef> shall not be
a <BNF name="nested binding table query specification"/> and shall not be
an <BNF name="object name or binding variable"/> that is a <BNF name="regular identifier"/> that
also is a valid <BNF name="binding variable reference"/> whose incoming working record type is 
the incoming working record type of <sym>BTE</sym>.  

<comment>Email from: Hannes Voigt, 2023-03-01 1200 WG3 UTC-039R1</comment>
<note>Without <feature code="GV61"/>, <BNF name="binding table expression"/> is limited to
references to binding tables in the GQL-catalog.
</note>

</item>
<endbar/>

</olist>

</ConformanceRules>


</bodyMatter>

</subClause>
<comment>WG3:UTC-0421 (one) Subclause moved</comment>


<subClause id="gql_objexp_prim" newpage="true">
<clauseHeading><BNF name="object expression primary"/></clauseHeading>

<comment>WG3:UTC-039R1</comment>
<bodyMatter>


<comment>WG3:UTC-039R1</comment>
<Function>

<comment>Editorial consequence of WG3:UTC-039R1</comment>
<para>Specify an <BNF name="object expression primary"/>.
</para>

</Function>


<comment>WG3:UTC-039R1</comment>
<Format>

<grammar>

<comment>WG3:UTC-039R1</comment>
<BNFdef name="object expression primary">
<rhs>
<alt> <kw>VARIABLE</kw> <BNF name="value expression primary"/> </alt>
<alt> <BNF name="parenthesized value expression"/> </alt>
<alt> <BNF name="non-parenthesized value expression primary special case"/> </alt>
</rhs>
</BNFdef> 

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:UTC-039R1</comment>
<item>If an <BNF name="object expression primary"/> <symdef>OEP</symdef> is specified that
does not specify <kw>VARIABLE</kw>, then <sym>OEP</sym> is effectively replaced by:
<code>
<kw>VARIABLE</kw> <sym>OEP</sym>
</code>

<comment>WG3:UTC-039R1</comment>
<note>This syntax transformation removes <BNF name="parenthesized value expression"/> and
<BNF name="non-parenthesized value expression primary special case"/> as alternatives of
<BNF name="object expression primary"/>, so that these alternatives do not have to be considered
subsequently.
</note>
</item>

</olist>

</SyntaxRules>


<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>

<comment>Editorial: Stefan Plantikow, 2020-10-02 Graph type specification</comment>
<comment>Editorial: Stefan Plantikow, 2020-09-26 Biding table specification</comment>
</clause>


<clause id="gql_ddl">
<clauseHeading>Catalog-modifying statements</clauseHeading>
<comment>WG3:W23-013 One editor's note removed</comment>

<ednote id="gql_PP004">The GQL schema and metagraph need to be defined together with the 
statements to manipulate it.
See <PPref ref="PPgql004"/>.
</ednote>

<comment>Editorial: Stefan Plantikow, 2020-09-26 CREATE DIRECTORY removed</comment>
<subClause id="gql_lin_cat_mod_stm">
<clauseHeading><BNF name="linear catalog-modifying statement"/></clauseHeading>

<bodyMatter>

<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:BER-019</comment>
<para>Specify a linear composition of <BNF name="simple catalog-modifying statement"/>s.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="linear catalog-modifying statement">
<rhs>
<BNF name="simple catalog-modifying statement"/><repeat/>
</rhs>
</BNFdef>

<comment>WG3:UTC-122</comment>
<BNFdef name="simple catalog-modifying statement">
<rhs>
<alt> <BNF name="primitive catalog-modifying statement"/> </alt>
<alt> <BNF name="call catalog-modifying procedure statement"/> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-01-28</comment>
<comment>Editorial: Stefan Plantikow, 2020-09-26 Add missing drop statements</comment>
<comment>WG3:W15-018</comment>
<comment>WG3:W16-038</comment>
<comment>WG3:W20-012</comment>
<comment>WG3:BER-020</comment>
<comment>Editorial: Stefan Plantikow, 2023-03-01 Align order with TOC</comment>
<BNFdef name="primitive catalog-modifying statement">
<rhs>
<alt> <BNF name="create schema statement"/> </alt>
<alt> <BNF name="drop schema statement"/> </alt>
<alt> <BNF name="create graph statement"/> </alt>
<alt> <BNF name="drop graph statement"/> </alt>
<alt> <BNF name="create graph type statement"/> </alt>
<alt> <BNF name="drop graph type statement"/> </alt>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<comment>WG3:BER-019</comment>
<olist>

<item>Let <symdef>LCMS</symdef> be the <BNF name="linear catalog-modifying statement"/>.
</item>

<comment>WG3:UTC-096R1 Deleted 4 SRs</comment>

<comment>WG3:UC-096R1</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The outgoing working record type of <sym>LCMS</sym> is the incoming working record type
of <sym>LCMS</sym>.
</item>

<comment>WG3:UC-096R1</comment>
<comment>WG3:XRH-036</comment>
<item>The outgoing working table type of <sym>LCMS</sym> is the incoming working table type
of <sym>LCMS</sym>.
</item>
<endbar/>

<comment>WG3:W26-026R2</comment>
<item>The declared type of <sym>LCMS</sym> is the empty type. 
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:UTC-059</comment>
<item>If the current transaction access mode is <kw>READ</kw> <kw>ONLY</kw>, then an exception 
condition is raised: <raise class="25" subclass="G03"/>.
</item>

<comment>WG3:UTC-096R1</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item>The current execution outcome is set to a successful outcome with an omitted result.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>Editorial: Stefan Plantikow, 2019-10-20</comment>
<subClause id="gql_create_schema" newpage="true">
<clauseHeading><BNF name="create schema statement"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-07-29 Drafted as consequence of WG3:MMX-055</comment>
<bodyMatter>

<comment>WG3:W13-024: Stefan Plantikow, 2021-07-21 Remove previous function</comment>
<comment>WG3:W13-024: Stefan Plantikow, 2021-07-21</comment>
<Function>

<comment>WG3:CMN-019 226. P00-USA-361</comment>
<para>Create a GQL-schema.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-02-07</comment>
<comment>Editorial: Stefan Plantikow, 2020-02-06</comment>
<comment>Editorial: Stefan Plantikow, 2020-09-16 Use singular forms</comment>
<comment>Editorial: Stefan Plantikow, 2020-09-26 catalog schema definition</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-05 Adjusted grammar</comment>


<comment>WG3:UTC-058R3</comment>
<BNFdef name="create schema statement">
<rhs>
<kw>CREATE</kw> <kw>SCHEMA</kw> <opt> <kw>IF</kw> <kw>NOT</kw> <kw>EXISTS</kw> </opt>
<BNF name="catalog schema parent and name"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:W13-024: Stefan Plantikow, 2021-07-21</comment>
<comment>WG3:OHD-032R1</comment>
<item>Let <symdef>CSPN</symdef> be the <BNF name="catalog schema parent and name"/>.
</item>

<comment>WG3:W13-024: Stefan Plantikow, 2021-07-21</comment>
<comment>WG3:OHD-032R1</comment>
<comment>WG3:W23-030</comment>
<item>Let <symdef>ADP</symdef> be the <BNF name="absolute directory path"/> immediately contained 
in <sym>CSPN</sym>.
<sym>ADP</sym> shall identify a GQL-directory.
</item>

<comment>WG3:BER-088R1</comment>
<comment>WG3:W23-030</comment>
<item>Let <symdef>PARENT</symdef> be the GQL-directory identified by <sym>ADP</sym>.
</item>

<comment>WG3:W23-030</comment>
<item>Let <symdef>SN</symdef> be the <BNF name="schema name"/> immediately contained in 
<sym>CSPN</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2021-07-21 Adjusted for WG3:W13-024 as minuted</comment>
<comment>Correct to use GQL-schema</comment>
<item>If <kw>IF</kw> <kw>NOT</kw> <kw>EXISTS</kw> is not specified, then <sym>SN</sym> shall not
identify an existing GQL-schema descriptor in <sym>PARENT</sym>. 
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>Editorial: Stefan Plantikow, 2021-07-21 Adjusted for WG3:W13-024 as minuted</comment>
<comment>Editorial: Stefan Plantikow, 2022-08-18 Correct to use GQL-schema</comment>
<item>If <kw>IF</kw> <kw>NOT</kw> <kw>EXISTS</kw> is specified and <sym>SN</sym> identifies 
an existing GQL-schema descriptor in <sym>PARENT</sym>, then no further General Rules of this 
Subclause are applied. 
</item>

<comment>WG3:W23-030</comment>
<item>Let <symdef>S</symdef> be a new GQL-schema.
</item>

<comment>WG3:W23-030</comment>
<item>The associated GQL-schema descriptor <symdef>SD</symdef> of <sym>S</sym> is created that 
comprises:

<olist>

<comment>WG3:CMN-060</comment>
<item>The session authorization identifier as the owner of <sym>S</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2022-11-16 Reword to use set</comment>
<item>An empty set as the set of named subobjects of <sym>S</sym>.
</item>

</olist>

</item>

<comment>WG3:W23-030</comment>
<item><sym>SD</sym> is inserted into <sym>PARENT</sym> with the name <sym>SN</sym>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-052</comment>
<item>Without <feature code="GC01"/>, conforming GQL language shall not contain 
a <BNF name="create schema statement"/>.
</item>

<comment>WG3:UTC-058R3</comment>
<item>Without <feature code="GC02"/>, conforming GQL language shall not contain 
a <BNF name="create schema statement"/> that includes <kw>IF</kw> <kw>NOT</kw> <kw>EXISTS</kw>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_drop_schema" newpage="true">
<clauseHeading><BNF name="drop schema statement"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-09-27 Add drop schema</comment>
<bodyMatter>

<Function>

<comment>WG3:CMN-019 226. P00-USA-361</comment>
<para>Destroy a GQL-schema.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-10-01 Added parent specification</comment>
<comment>WG3:UTC-058R3</comment>
<BNFdef name="drop schema statement">
<rhs>
<kw>DROP</kw> <kw>SCHEMA</kw> <opt> <kw>IF</kw> <kw>EXISTS</kw> </opt>
<BNF name="catalog schema parent and name"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:CMN-042</comment>
<item>Let <symdef>DSS</symdef> be <BNF name="drop schema statement"/>.
</item>

<comment>Editorial: Stefan Plantikow, 2020-10-01 Added parent specification</comment>
<comment>WG3:OHD-032R1</comment>
<item>Let <symdef>CSPN</symdef> be the <BNF name="catalog schema parent and name"/>.
</item>

<comment>WG3:CMN-042 Removed 1 (one) Syntax Rule</comment>

<comment>WG3:W23-030</comment>
<item>Let <symdef>ADP</symdef> be the <BNF name="absolute directory path"/> immediately contained 
in <sym>CSPN</sym>. 
<sym>ADP</sym> shall identify a GQL-directory.
</item>

<comment>WG3:W23-030</comment>
<item>Let <symdef>PARENT</symdef> be the GQL-directory identified by <sym>ADP</sym>.
</item>

<item>Let <symdef>SN</symdef> be the <BNF name="schema name"/> immediately contained in
<sym>CSPN</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2021-07-21 Adjusted for WG3:W13-024 as minuted</comment>
<comment>Editorial: Stefan Plantikow, 2022-08-18 Correct to use GQL-schema</comment>
<item>If <kw>IF</kw> <kw>EXISTS</kw> is not specified, then <sym>SN</sym> shall identify 
an existing GQL-schema descriptor in <sym>PARENT</sym>.
</item>

<comment>WG3:OHD-032R1</comment>
<item>If <sym>SN</sym> identifies an existing GQL-schema descriptor <symdef>SD</symdef> in
<sym>PARENT</sym>, then:

<olist>

<comment>WG3:CMN-042</comment>
<item>If the current working schema of <sym>DSS</sym> is defined, then <sym>SD</sym> shall not be
the descriptor of the current working schema of <sym>DSS</sym>.
</item>

<item><sym>SD</sym> shall not contain any catalog object descriptors.
</item>


</olist>
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>
<comment>Editorial: Stefan Plantikow, 2020-10-01 Added parent specification</comment>
<comment>WG3:W13-024: Stefan Plantikow, 2021-07-21 3 (Three) GRs removed</comment>

<comment>Editorial: Stefan Plantikow, 2021-07-21 Adjusted for WG3:W13-024</comment>
<comment>Editorial: Stefan Plantikow, 2022-08-18 Correct to use GQL-schema</comment>
<item>If <kw>IF</kw> <kw>EXISTS</kw> is specified and <sym>SN</sym> does not identify an existing
GQL-schema descriptor in <sym>PARENT</sym>, then no further General Rules of this Subclause are
applied.
</item>

<comment>Editorial: Stefan Plantikow, 2022-08-18 Correct to use passive voice</comment>
<comment>WG3:W23-030</comment>
<comment>WG3:W13-024: Stefan Plantikow, 2021-07-21 One editors' note removed</comment>
<item><sym>SD</sym> is removed from <sym>PARENT</sym> under the name <sym>SN</sym> and 
<sym>SD</sym> is destroyed.

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-052</comment>
<item>Without <feature code="GC01"/>, conforming GQL language shall not contain 
a <BNF name="drop schema statement"/>.
</item>

<comment>WG3:UTC-058R3</comment>
<item>Without <feature code="GC02"/>, conforming GQL language shall not contain 
a <BNF name="drop schema statement"/> that includes <kw>IF</kw> <kw>EXISTS</kw>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_create_graph" newpage="true">
<clauseHeading><BNF name="create graph statement"/></clauseHeading>

<bodyMatter>


<Function>

<comment>WG3:MMX-028R2</comment>
<para>Create a graph.
</para>

</Function>


<comment>WG3:MMX-028R2</comment>
<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-09-24 Removed graph keywords</comment>
<comment>WG3:OHD-020</comment>
<comment>WG3:W23-029R1</comment>
<comment>WG3:UTC-058R3</comment>
<BNFdef name="create graph statement">
<rhs>
<kw>CREATE</kw>
<group>
<alt br="no">
<opt> <kw>PROPERTY</kw> </opt> <kw>GRAPH</kw> <opt> <kw>IF</kw> <kw>NOT</kw> <kw>EXISTS</kw> </opt>
</alt>
<alt br="no">
<kw>OR</kw> <kw>REPLACE</kw> <opt> <kw>PROPERTY</kw> </opt> <kw>GRAPH</kw>
</alt>
</group>
<breakindent/>
<BNF name="catalog graph parent and name"/>
<group> 
<alt br="no"> <BNF name="open graph type"/> </alt> <alt br="no"> <BNF name="of graph type"/> </alt> 
</group>
<breakindent/>
<opt> <BNF name="graph source"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:OHD-020</comment>
<comment>WG3:W23-029R1</comment>
<comment>WG3:W25-025</comment>
<BNFdef name="open graph type">
<rhs>
<opt> <BNF name="typed"/> </opt> <kw>ANY</kw> <opt> 
<opt> <kw>PROPERTY</kw> </opt> <kw>GRAPH</kw> </opt>
</rhs>
</BNFdef>

<comment>WG3:W22-051</comment>
<comment>WG3:OHD-020</comment>
<comment>WG3:W25-025</comment>
<BNFdef name="of graph type">
<rhs>
<alt> <BNF name="graph type like graph"/> </alt>
<alt> <opt> <BNF name="typed"/> </opt> <BNF name="graph type reference"/> </alt>
<alt>
<opt> <BNF name="typed"/> </opt> <opt> <opt> <kw>PROPERTY</kw> </opt> <kw>GRAPH</kw> </opt> 
<BNF name="nested graph type specification"/> 
</alt>
</rhs>
</BNFdef>

<comment>WG3:W22-051</comment>
<comment>WG3:W22-051</comment>
<BNFdef name="graph type like graph">
<rhs>
<kw>LIKE</kw> <BNF name="graph expression"/>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-07-29 Added AS</comment>
<comment>Editorial: Stephen Cannan, 2020-08-23 Correct placement of, 2020-07-29 change</comment>
<comment>Editorial: Stefan Plantikow, 2020-09-25 Factored out production</comment>
<comment>WG3:BER-039</comment>
<comment>WG3:W22-051</comment>
<comment>WG3:W22-051</comment>
<BNFdef name="graph source">
<rhs>
<kw>AS</kw> <kw>COPY</kw> <kw>OF</kw> <BNF name="graph expression"/>
</rhs>
</BNFdef>

<comment>WG3:CMN-064</comment>
<ednote id="gql_PP367">Simplified syntax should be considered.

See <PPref ref="PPgql367"/>.
</ednote>

</grammar>

</Format>


<comment>WG3:MMX-028R2</comment>
<SyntaxRules>

<olist>

<comment>WG3:W22-051</comment>
<item>Let <symdef>CGS</symdef> be the <BNF name="create graph statement"/>.
</item>

<comment>WG3:W22-051</comment>
<comment>WG3:OHD-032R1</comment>
<item>Let <symdef>CGPN</symdef> be the <BNF name="catalog graph parent and name"/> immediately 
contained in <sym>CGS</sym>.
</item>

<comment>WG3:W22-051</comment>
<comment>WG3:OHD-032R1</comment>
<item>Let <symdef>COPR</symdef> be the explicit or implicit 
<BNF name="catalog object parent reference"/> immediately contained in <sym>CGPN</sym>.
<sym>COPR</sym> shall identify a GQL-schema.
</item>

<comment>WG3:W23-030</comment>
<item>Let <symdef>SCHEMA</symdef> be the GQL-schema identified by <sym>COPR</sym>.
</item>

<comment>WG3:W23-030</comment>
<item>Let <symdef>GN</symdef> be the <BNF name="graph name"/> immediately contained in 
<sym>CGPN</sym>.
</item>

<comment>WG3:W22-051</comment>
<item>If <sym>CGS</sym> does not immediately contain <kw>IF</kw> <kw>NOT</kw> <kw>EXISTS</kw> or
<kw>OR</kw> <kw>REPLACE</kw>, then <sym>CGPN</sym> shall not identify an existing graph.
</item>

<comment>WG3:CMN-035</comment>
<item>If <sym>CGS</sym> immediately contains an <BNF name="of graph type"/> that immediately
contains the <BNF name="graph type like graph"/> that immediately contains
the <BNF name="graph expression"/> <symdef>OGTGE</symdef>, then:

<olist>

<comment>WG3:CMN-035</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>OGTGE</sym> is the the incoming working record type
of <sym>CGS</sym>.
</item>

<comment>WG3:CMN-035</comment>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>OGTGE</sym> is
the material unit binding table type.
</item>
<endbar/>

</olist>

</item>

<comment>WG3:CMN-035</comment>
<item>If <sym>CGS</sym> immediately contains a <BNF name="graph source"/> that immediately contains
the <BNF name="graph expression"/> <symdef>GSGE</symdef>, then:

<olist>

<comment>WG3:CMN-035</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>GSGE</sym> is the incoming working record type
of <sym>CGS</sym>.
</item>

<comment>WG3:CMN-035</comment>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>GSGE</sym> is
the material unit binding table type.
</item>
<endbar/>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<comment>WG3:MMX-028R2</comment>
<GeneralRules>

<olist>

<comment>WG3:OHD-032R1</comment>
<item>If <kw>IF</kw> <kw>NOT</kw> <kw>EXISTS</kw> is specified and <sym>CGPN</sym> identifies 
an existing graph, then no further General Rules of this Subclause are applied.
</item>

<comment>WG3:W22-051</comment>
<item>If <sym>CGS</sym> immediately contains <kw>OR</kw> <kw>REPLACE</kw> and <sym>CGPN</sym>
identifies an existing graph, then the following <BNF name="drop graph statement"/> is effectively
executed:
<code>
<kw>DROP</kw> <kw>GRAPH</kw> <sym>CGPN</sym>
</code>
</item>

<comment>WG3:W22-051</comment>
<comment>WG3:W26-037R3</comment>
<item>Let <symdef>NGTN</symdef> be the name of a new system-generated identifier that is also 
a <BNF name="graph type name"/> that does not identify an existing catalog object in 
<sym>SCHEMA</sym>.

<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<note>See <itemref ref="gql_token_sys_gen_id" type="SR"/> of <specref ref="gql_token"/> for 
detailed provisions regarding the construction of system-generated regular identifiers.
</note>

</item>

<item>Let <symdef>NCGTPN</symdef> be the <BNF name="catalog graph type parent and name"/>:
<code>
<sym>COPR</sym> <sym>NGTN</sym>
</code>
</item>

<comment>WG3:W22-051</comment>
<comment>WG3:OHD-020</comment>
<item>If <sym>CGS</sym> immediately contains an <BNF name="of graph type"/> that
immediately contains the <BNF name="graph type like graph"/> <symdef>GTLG</symdef>, then 
the following <BNF name="create graph type statement"/> is effectively executed:
<code>
<kw>CREATE</kw> <kw>GRAPH</kw> <kw>TYPE</kw> <sym>NCGTPN</sym> <sym>GTLG</sym>
</code>
</item>

<comment>WG3:W22-051</comment>
<comment>WG3:OHD-020</comment>
<comment>WG3:W23-029R1</comment>
<item>If <sym>CGS</sym> immediately contains an <BNF name="of graph type"/> that
immediately contains the <BNF name="nested graph type specification"/> <symdef>GTS</symdef>, then
the following <BNF name="create graph type statement"/> is effectively executed:
<code>
<kw>CREATE</kw> <kw>GRAPH</kw> <kw>TYPE</kw> <sym>NCGTPN</sym> <sym>GTS</sym>
</code>
</item>

<comment>WG3:W22-051</comment>
<comment>WG3:OHD-020</comment>
<comment>WG3:W23-029R1</comment>
<comment>WG3:CMN-035</comment>
<item>If <sym>CGS</sym> immediately contains a <BNF name="graph source"/> that
immediately contains the <BNF name="graph expression"/> <symdef>GSGE</symdef>, then:

<olist>

<comment>WG3:CMN-035</comment>
<item>Let <symdef>SGRV</symdef> be the result of evaluating <sym>GSGE</sym> in a new child execution
context.
</item>

<comment>WG3:CMN-035</comment>
<item>If the referent of <sym>SGRV</sym> has a constraining graph type and <sym>CGS</sym>
does not immediately contain an <BNF name="open graph type"/>, then the following 
<BNF name="create graph type statement"/> is effectively executed:
<code>
<kw>CREATE</kw> <kw>GRAPH</kw> <kw>TYPE</kw> <sym>NCGTPN</sym> <kw>LIKE</kw> <sym>GSGE</sym>
</code>
</item>

</olist>

</item>

<comment>Editorial: Stephen Cannan, 2022-03-30 WG3:RKE-010 P00-USA-473</comment>
<comment>WG3:W22-034R1 deleted graph label sets and property type sets</comment>
<comment>WG3:W22-051</comment>
<comment>WG3:W23-029R1</comment>
<item>Let <symdef>G</symdef> be a new empty graph.
</item>

<comment>WG3:W22-051</comment>
<comment>WG3:OHD-020</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-12 undefined/omitted</comment>
<item>Let the (possibly <quote>omitted</quote>) graph type <symdef>GT</symdef> be
defined as follows. 

<para>Case:
</para>

<olist>

<comment>WG3:OHD-020</comment>
<comment>WG3:W23-029R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-12 undefined/omitted</comment>
<item>If <sym>CGS</sym> immediately contains an <BNF name="open graph type"/>, then <sym>GT</sym> 
is <quote>omitted</quote>.
</item>

<comment>WG3:OHD-020</comment>
<item>If <sym>CGS</sym> immediately contains an <BNF name="of graph type"/> that immediately 
contains the <BNF name="graph type reference"/> <symdef>GTR</symdef>, then <sym>GT</sym> is 
the graph type identified by <sym>GTR</sym>.
</item>

<item>Otherwise, <sym>GT</sym> is the graph type identified by <sym>NCGTPN</sym>.
</item>

</olist>

</item>

<comment>Editorial: Stefan Plantikow, 2020-07-29 Adjusted</comment>
<comment>WG3:W22-051</comment>
<comment>WG3:OHD-020</comment>
<comment>WG3:W23-029R1</comment>
<comment>WG3:CMN-035</comment>
<item>If <sym>CGS</sym> immediately contains a <BNF name="graph source"/>, then
<sym>G</sym> is populated as follows:

<olist>

<comment>WG3:CMN-035</comment>
<item><symdef>SGRV</symdef> is known to be defined.
</item>

<comment>WG3:CMN-035</comment>
<comment>Editorial: Stephen Cannan, 2020-08-23</comment>
<item>Let <symdef>SG</symdef> be the referent of <sym>SGRV</sym>.
</item>

<comment>WG3:W12-033: Stefan Plantikow</comment>
<comment>Editorial: Stephen Cannan, 2022-03-30 WG3:RKE-010 P00-USA-474</comment>
<comment>WG3:OHD-025</comment>
<item>If <sym>GT</sym> is defined and <sym>SG</sym> is not of graph type <sym>GT</sym>, then 
an exception condition is raised: <raise class="G2"/>.
</item>

<item id="gql_create_graph_copy_elts">Copies of all nodes and edges in <sym>SG</sym> are inserted
into <sym>G</sym>.
Each copy of a node and each copy of an edge is associated with a new global object identifier.
</item>

</olist>
<comment>WG3:W21-059 Informative note removed</comment>

</item>

<comment>WG3:W22-051</comment>
<comment>WG3:W23-030</comment>
<item>The associated graph descriptor <symdef>GD</symdef> of <sym>G</sym> is created such that
the constraining graph type of <sym>GD</sym> is defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W23-029R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<item>If <sym>GT</sym> is not <quote>omitted</quote>, then
the constraining graph type of <sym>GD</sym> is <sym>GT</sym>.
</item>

<comment>WG3:W23-029R1</comment>
<item>Otherwise, <sym>GD</sym> has no constraining graph type.
</item>

</olist>
</item>

<comment>WG3:W23-030</comment>
<item><sym>GD</sym> is inserted into <sym>SCHEMA</sym> with the name <sym>GN</sym>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-052</comment>
<item>Without <feature code="GC04"/>, conforming GQL language shall not contain 
a <BNF name="create graph statement"/>.
</item>

<comment>WG3:UTC-058R3</comment>
<item>Without <feature code="GC05"/>, conforming GQL language shall not contain 
a <BNF name="create graph statement"/> that includes <kw>IF</kw> <kw>NOT</kw> <kw>EXISTS</kw>.
</item>

<comment>WG3:OHD-020</comment>
<item>Without <feature code="GG01"/>, in conforming GQL language, 
a <BNF name="create graph statement"/> shall not contain an <BNF name="open graph type"/>.
</item>

<comment>WG3:OHD-020</comment>
<item>Without <feature code="GG02"/>, in conforming GQL language, 
a <BNF name="create graph statement"/> shall not contain an <BNF name="of graph type"/>.
</item>

<comment>WG3:OHD-020</comment>
<item>Without <feature code="GG03"/>, in conforming GQL language, 
a <BNF name="create graph statement"/> shall not contain an <BNF name="of graph type"/> that
contains a <BNF name="nested graph type specification"/>.
</item>

<comment>WG3:OHD-020</comment>
<item>Without <feature code="GG04"/>, in conforming GQL language, 
a <BNF name="create graph statement"/> shall not contain an <BNF name="of graph type"/> that 
contains a <BNF name="graph type like graph"/>.
</item>

<comment>WG3:OHD-020</comment>
<item>Without <feature code="GG05"/>, in conforming GQL language, 
a <BNF name="create graph statement"/> shall not contain a <BNF name="graph source"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>
<comment>WG3:W22-051 deleted one Subclause.</comment>


<comment>WG3:MMX-028R2</comment>
<subClause id="gql_drop_graph" newpage="true">
<clauseHeading><BNF name="drop graph statement"/></clauseHeading>

<bodyMatter>

<Function>

<para>Destroy a graph.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-09-17 Moved last</comment>
<comment>WG3:UTC-058R3</comment>
<BNFdef name="drop graph statement">
<rhs>
<kw>DROP</kw> <opt> <kw>PROPERTY</kw> </opt> <kw>GRAPH</kw> <opt> <kw>IF</kw> <kw>EXISTS</kw> </opt>
<BNF name="catalog graph parent and name"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>Editorial: Stefan Plantikow, 2020-10-05 Adjusted grammar</comment>
<comment>WG3:W22-051</comment>
<comment>WG3:W23-030</comment>
<item>Let <symdef>DGS</symdef> be the <BNF name="drop graph statement"/> and 
let <symdef>CGPN</symdef> be the <BNF name="catalog graph parent and name"/>.
</item>

<comment>WG3:W22-051</comment>
<comment>WG3:W23-030</comment>
<item>Let <symdef>COPR</symdef> be the explicit or implicit 
<BNF name="catalog object parent reference"/> immediately contained in <sym>CGPN</sym>. 
<sym>COPR</sym> shall identify a GQL-schema.
</item>

<comment>WG3:W23-030</comment>
<item>Let <symdef>SCHEMA</symdef> be the GQL-schema identified by <sym>COPR</sym>.
</item>

<comment>WG3:W23-030</comment>
<item>Let <symdef>GN</symdef> be the <BNF name="graph name"/> immediately contained in 
<sym>CGPN</sym>.
</item>

<comment>WG3:W23-030</comment>
<item>If <sym>DGS</sym> does not immediately contain <kw>IF</kw> <kw>EXISTS</kw>, then 
<sym>CGPN</sym> shall identify an existing graph.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>
<comment>Editorial: Stefan Plantikow, 2020-10-05 Adjusted grammar</comment>
<comment>Editorial: Stephen Cannan, 2022-03-30 WG3:RKE-010 P00-USA-474</comment>
<comment>WG3:W22-051</comment>
<comment>Email from: Keith Hare, 2021-11-16 2002</comment>

<comment>Email from: Hannes Voigt, 2022-08-22 1723 W22</comment>
<item>If <sym>DGS</sym> immediately contains <kw>IF</kw> <kw>EXISTS</kw> and <sym>CGPN</sym> does
not identify an existing graph, then a completion condition is raised:
<raise class="01" subclass="G03"/> and no further General Rules of this Subclause are applied.
</item>
<comment>WG3:W22-051 deleted three rules</comment>

<comment>WG3:W22-051</comment>
<comment>WG3:W23-030</comment>
<item>Let <symdef>G</symdef> be the graph identified by <sym>CGPN</sym> and let <symdef>GD</symdef>
be the graph descriptor of <sym>G</sym>.
</item>

<comment>WG3:W22-051</comment>
<item>Let <symdef>GT</symdef> be the graph type of <sym>G</sym>.
</item>

<comment>WG3:W22-051</comment>
<comment>Editorial: Stefan Plantikow, 2022-08-22 Destroy both object and descriptor</comment>
<comment>WG3:W23-030</comment>
<item><sym>GD</sym> is removed from <sym>SCHEMA</sym> under the name <sym>GN</sym> and 
<sym>GD</sym> is destroyed.
</item>

<comment>WG3:W22-051</comment>
<comment>WG3:W26-037R3</comment>
<item>If the name of <sym>GT</sym> is a system-generated name and <sym>GT</sym> is not 
the graph type of any other graph in the GQL-catalog, then the graph type descriptor of 
<sym>GT</sym> is destroyed.

<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<note>See <itemref ref="gql_token_sys_gen_id" type="SR"/> of <specref ref="gql_token"/> for 
detailed provisions regarding the construction of system-generated regular identifiers.
</note>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-052</comment>
<item>Without <feature code="GC04"/>, conforming GQL language shall not contain 
a <BNF name="drop graph statement"/>.
</item>

<comment>WG3:UTC-058R3</comment>
<item>Without <feature code="GC05"/>, conforming GQL language shall not contain 
a <BNF name="drop graph statement"/> that includes <kw>IF</kw> <kw>EXISTS</kw>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_create_graph_type" newpage="true">
<clauseHeading><BNF name="create graph type statement"/></clauseHeading>

<bodyMatter>


<comment>Editorial: Stefan Plantikow, 2020-10-04 Refactor to use graph type initializer</comment>
<Function>

<comment>WG3:MMX-028R2</comment>
<comment>WG3:BER-021</comment>
<para>Create a graph type.
</para>

</Function>


<comment>WG3:MMX-028R2</comment>
<Format>

<grammar>

<comment>Email from: Hannes Voigt, 2020-08-20 1539</comment>
<comment>WG3:W22-051</comment>
<comment>WG3:UTC-058R3</comment>
<BNFdef name="create graph type statement">
<rhs>
<kw>CREATE</kw>
<breakindent/>
<group>
<alt br="no">
<opt> <kw>PROPERTY</kw> </opt> <kw>GRAPH</kw> <kw>TYPE</kw>
<opt> <kw>IF</kw> <kw>NOT</kw> <kw>EXISTS</kw> </opt>
</alt>
<alt br="no">
<kw>OR</kw> <kw>REPLACE</kw> <opt> <kw>PROPERTY</kw> </opt> <kw>GRAPH</kw> <kw>TYPE</kw>
</alt>
</group>
<breakindent/>
<BNF name="catalog graph type parent and name"/> <BNF name="graph type source"/>
</rhs>
</BNFdef>
<ednote id="gql_PP428">Possible parsing ambiguity.
See <PPref ref="PPgql428"/>.
</ednote>

<comment>WG3:W22-051 deleted one rule</comment>

<comment>WG3:W22-051</comment>
<BNFdef name="graph type source">
<rhs>
<alt> <opt> <kw>AS</kw> </opt> <BNF name="copy of graph type"/> </alt>
<alt> <BNF name="graph type like graph"/> </alt>
<alt> <opt> <kw>AS</kw> </opt> <BNF name="nested graph type specification"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W22-051</comment>
<BNFdef name="copy of graph type">
<rhs>
<kw>COPY</kw> <kw>OF</kw>
<group>
<alt br="no"> <BNF name="graph type reference"/> </alt>
<alt br="no"> <BNF name="external object reference"/> </alt>
</group>
</rhs>
</BNFdef>

</grammar>

</Format>


<comment>WG3:MMX-028R2</comment>
<SyntaxRules>

<olist>

<item>Let <symdef>CGTS</symdef> be the <BNF name="create graph type statement"/> and 
let <symdef>CGTPN</symdef> be the <BNF name="catalog graph type parent and name"/> 
immediately contained in <sym>CGTS</sym>.
</item>

<comment>WG3:W23-030</comment>
<item>Let <symdef>COPR</symdef> be the explicit or implicit
<BNF name="catalog object parent reference"/> immediately contained in <sym>CGTPN</sym>.
<sym>COPR</sym> shall identify a GQL-schema.
</item>

<comment>WG3:W22-051</comment>
<item>Let <symdef>SCHEMA</symdef> be the GQL-schema identified by <sym>COPR</sym>.
</item>

<comment>WG3:W23-030</comment>
<item>Let <symdef>GTN</symdef> be the <BNF name="graph type name"/> immediately contained in 
<sym>CGTPN</sym>.
</item>

<comment>WG3:W23-030</comment>
<item>If <sym>CGTS</sym> does not immediately contain <kw>IF</kw> <kw>NOT</kw> <kw>EXISTS</kw> or 
<kw>OR</kw> <kw>REPLACE</kw>, then <sym>CGTPN</sym> shall not identify an existing graph type.
</item>

<comment>WG3:W22-051</comment>
<item>Let <symdef>GTS</symdef> be the <BNF name="graph type source"/> immediately contained in
<sym>GTS</sym>.
</item>

<comment>WG3:W22-051</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use of omitted</comment>
<item>Let the (possibly <quote>omitted</quote>) graph type <symdef>OGT</symdef> be
defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>GTS</sym> immediately contains
the <BNF name="copy of graph type"/> <symdef>COGT</symdef>, then <sym>OGT</sym> is the graph type
identified by the <BNF name="graph type reference"/> or the <BNF name="external object reference"/>
immediately contained in <sym>COGT</sym>.
</item>

<comment>WG3:W23-029R1</comment>
<comment>WG3:CMN-035</comment>
<item>If <sym>GTS</sym> immediately contains a <BNF name="graph type like graph"/> 
<symdef>GTLG</symdef>, then:

<olist>

<comment>WG3:CMN-035</comment>
<item>Let <symdef>GTSGE</symdef> be the <BNF name="graph expression"/> immediately contained in
<sym>GTLG</sym>.
</item>

<comment>WG3:CMN-035</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>GTSGE</sym> is the incoming working record type 
of <sym>CGTS</sym>.
</item>

<comment>WG3:CMN-035</comment>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>GTSGE</sym> is
the material unit binding table type.
</item>
<endbar/>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<comment>WG3:CMN-035</comment>
<item>The declared type of <sym>GTSGE</sym> shall have a constraining GQL-object type.
</item>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<comment>WG3:CMN-035</comment>
<item><sym>OGT</sym> is the constraining GQL-object type of the declared type of <sym>GTSGE</sym>.
</item>

</olist>

</item>

<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<item>Otherwise, <sym>OGT</sym> is <quote>omitted</quote>.
</item>

</olist>

</item>


</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<comment>WG3:MMX-028R2</comment>
<GeneralRules>

<olist>
<comment>WG3:BER-021 Deleted 2 Rules</comment>
<comment>WG3:W22-051 deleted four rules</comment>

<comment>WG3:OHD-032R1</comment>
<item>If <kw>IF</kw> <kw>NOT</kw> <kw>EXISTS</kw> is specified and <sym>CGTPN</sym> identifies 
an existing graph type, then no further General Rules of this Subclause are applied.
</item>

<item>If <sym>CGTS</sym> immediately contains <kw>OR</kw> <kw>REPLACE</kw> and <sym>CGTPN</sym>
identifies an existing graph type, then the following <BNF name="drop graph type statement"/> is
effectively executed:
<code>
<kw>DROP</kw> <kw>GRAPH</kw> <kw>TYPE</kw> <sym>CGTPN</sym>
</code>
</item>

<comment>WG3:UTC-049</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<item>Let the (possibly <quote>omitted</quote>) graph type <symdef>GT</symdef> and
the graph type descriptor <symdef>GTD</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W23-030</comment>
<comment>WG3:UTC-049</comment>
<item>If <sym>OGT</sym> is not <quote>omitted</quote>, then <sym>GT</sym> is
the graph type described by the graph type descriptor <sym>GTD</sym> comprising:

<olist>

<comment>WG3:UTC-049</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<comment>WG3:W26-022R2</comment>
<item>The declared name of the primary base type of all graph types (GRAPH DATA). 

<note>See <specref ref="gql_graph_type_desc"/>. 
</note>
</item>

<comment>WG3:W26-022R2</comment>
<item>The preferred name of <sym>OGT</sym> as the preferred name.
</item>

<item>A copy of the node type set of <sym>OGT</sym> as the node type set.
</item>

<item>A copy of the edge type set of <sym>OGT</sym> as the edge type set.
</item>

<comment>WG3:W26-022R2</comment>
<item>A copy of the node type key label set dictionary of <sym>OGT</sym> as
the node type key label set dictionary.
</item>

<comment>WG3:W26-022R2</comment>
<item>A copy of the edge type key label set dictionary of <sym>OGT</sym> as
the edge type key label set dictionary.
</item>

</olist>

</item>

<comment>WG3:W23-030</comment>
<comment>WG3:UTC-049</comment>
<item>Otherwise, <sym>GT</sym> is the graph type described by the graph type descriptor
<sym>GTD</sym> that is defined by the <BNF name="nested graph type specification"/> immediately
contained in <sym>GTS</sym>.
</item>

</olist>

</item>

<comment>WG3:W23-030</comment>
<item>The associated graph type descriptor <sym>GTD</sym> of <sym>GT</sym> is created.
</item>

<comment>WG3:W23-030</comment>
<item><sym>GTD</sym> is inserted into <sym>SCHEMA</sym> with the name <sym>GTN</sym>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:OHD-020</comment>
<item>Without <feature code="GG02"/>, conforming GQL language shall not contain 
a <BNF name="create graph type statement"/>.
</item>

<comment>WG3:UTC-058R3</comment>
<item>Without <feature code="GC03"/>, conforming GQL language shall not contain 
a <BNF name="create graph type statement"/> that includes <kw>IF</kw> <kw>NOT</kw> <kw>EXISTS</kw>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>
<comment>WG3:UTC-0426 Subclauses moved</comment>


<comment>WG3:MMX-028R2</comment>
<subClause id="gql_drop_graph_type" newpage="true">
<clauseHeading><BNF name="drop graph type statement"/></clauseHeading>

<bodyMatter>

<Function>

<para>Destroy a graph type.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-09-17 Moved last</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-01 Add parent specification</comment>
<comment>WG3:UTC-058R3</comment>
<BNFdef name="drop graph type statement">
<rhs>
<kw>DROP</kw> <opt> <kw>PROPERTY</kw> </opt> <kw>GRAPH</kw> <kw>TYPE</kw>
<opt> <kw>IF</kw> <kw>EXISTS</kw> </opt>
<BNF name="catalog graph type parent and name"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<item>Let <symdef>DGTS</symdef> be the <BNF name="drop graph type statement"/> and
<symdef>CGTPN</symdef> be the <BNF name="catalog graph type parent and name"/>.
</item>
<comment>WG3:W22-051 deleted five rules</comment>

<comment>WG3:W23-030</comment>
<item>Let <symdef>COPR</symdef> be the explicit or implicit 
<BNF name="catalog object parent reference"/> immediately contained in <sym>CGTPN</sym>. 
<sym>COPR</sym> shall identify a GQL-schema.
</item>

<comment>WG3:W23-030</comment>
<item>Let <symdef>SCHEMA</symdef> be the GQL-schema identified by <sym>COPR</sym>.
</item>

<comment>WG3:W23-030</comment>
<item>Let <symdef>GTN</symdef> be the <BNF name="graph type name"/> immediately contained in 
<sym>CGTPN</sym>.
</item>

<comment>WG3:W22-051</comment>
<item>If <sym>DGTS</sym> does not immediately contain <kw>IF</kw> <kw>EXISTS</kw>, then
<sym>CGTPN</sym> shall identify an existing graph type.
</item>

<comment>WG3:W22-051</comment>
<item>If <symdef>CGTPN</symdef> identifies an existing graph type, then the graph type identified by
<sym>CGTPN</sym> shall not be referenced by any existing graph in the GQL-catalog.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>Email from: Hannes Voigt, 2022-08-22 1723 W22</comment>
<comment>WG3:W22-051</comment>
<item>If <symdef>DGTS</symdef> immediately contains <kw>IF</kw> <kw>EXISTS</kw> and <sym>CGTPN</sym>
does not identify an existing graph type, then a completion condition is raised:
<raise class="01" subclass="G04"/> and no further General Rules of this Subclause are applied.
</item>

<comment>WG3:BER-037</comment>
<comment>WG3:W22-051</comment>
<comment>Editorial: Stefan Plantikow, 2022-08-22 Correct to destroy object and descriptor</comment>
<comment>WG3:W23-030</comment>
<item>Let <symdef>GT</symdef> be the graph type identified by <sym>CGTPN</sym> and 
let <symdef>GTD</symdef> be the graph descriptor of <sym>GT</sym>.
</item>

<comment>WG3:W23-030</comment>
<item><sym>GTD</sym> is removed from <sym>SCHEMA</sym> under the name <sym>GTN</sym> and 
<sym>GTD</sym> is destroyed.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:OHD-020</comment>
<item>Without <feature code="GG02"/>, conforming GQL language shall not contain 
a <BNF name="drop graph type statement"/>.
</item>

<comment>WG3:UTC-058R3</comment>
<item>Without <feature code="GC03"/>, conforming GQL language shall not contain 
a <BNF name="drop graph type statement"/> that includes <kw>IF</kw> <kw>EXISTS</kw>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_call_cat_proc" newpage="true">
<clauseHeading><BNF name="call catalog-modifying procedure statement"/></clauseHeading>

<bodyMatter>


<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:UTC-096R1</comment>
<para>Execute a catalog-modifying procedure.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="call catalog-modifying procedure statement">
<rhs>
<BNF name="call procedure statement"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<comment>Editorial: Stefan Plantikow, 2020-05-11 Informal Semantics removed</comment>
<SyntaxRules>

<olist>

<comment>Editorial: Stefan Plantikow, 2020-10-12 Restrict to catalog-modifying procedures</comment>
<comment>WG3:W22-054</comment>
<item>Let <symdef>CCPS</symdef> be the <BNF name="call catalog-modifying procedure statement"/>,
let <symdef>CPS</symdef> be the <BNF name="call procedure statement"/> immediately contained
in <sym>CCPS</sym>, and let <symdef>PC</symdef> be the <BNF name="procedure call"/> immediately
contained in <sym>CPS</sym>.
</item>

<item>If <sym>PC</sym> is an <BNF name="inline procedure call"/> that immediately contains the
<BNF name="nested procedure specification"/> <symdef>PROC</symdef>, then <sym>PROC</sym> shall
shall immediately contain a <BNF name="catalog-modifying procedure specification"/>.
</item>

<item>If <sym>PC</sym> is a <BNF name="named procedure call"/> that immediately contains the
<BNF name="procedure reference"/> that identifies a procedure <symdef>PROC</symdef>, then 
<sym>PROC</sym> shall have the CATALOG PROCEDURE indication.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2020-05-11 Added GRs</comment>
<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>

</clause>


<clause id="gql_dml">
<clauseHeading>Data-modifying statements</clauseHeading>

<subClause id="gql_lin_data_mod_stm">
<clauseHeading><BNF name="linear data-modifying statement"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-10-08 Integrate conditional statements</comment>
<bodyMatter>


<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:BER-019</comment>
<para>Specify a linear composition of at least one
<BNF name="simple data-modifying statement"/> with <BNF name="simple query statement"/>s 
and <BNF name="simple data-accessing statement"/>s.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="linear data-modifying statement">
<rhs>
<alt> <BNF name="focused linear data-modifying statement"/> </alt>
<alt> <BNF name="ambient linear data-modifying statement"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W20-027R1</comment>
<BNFdef name="focused linear data-modifying statement">
<rhs>
<alt> <BNF name="focused linear data-modifying statement body"/> </alt>
<alt> <BNF name="focused nested data-modifying procedure specification"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W20-027R1</comment>
<comment>WG3:UTC-122</comment>
<BNFdef name="focused linear data-modifying statement body">
<rhs>
<BNF name="use graph clause"/>
<BNF name="simple linear data-accessing statement"/>
<breakindent/>
<opt> <BNF name="primitive result statement"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:W20-027R1</comment>
<BNFdef name="focused nested data-modifying procedure specification">
<rhs>
<BNF name="use graph clause"/> <BNF name="nested data-modifying procedure specification"/>
</rhs>
</BNFdef>

<comment>WG3:W20-027R1</comment>
<comment>WG3:BER-019</comment>
<BNFdef name="ambient linear data-modifying statement">
<rhs>
<alt> <BNF name="ambient linear data-modifying statement body"/> </alt>
<alt> <BNF name="nested data-modifying procedure specification"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:BER-019</comment>
<comment>WG3:W20-027R1</comment>
<BNFdef name="ambient linear data-modifying statement body">
<rhs>
<BNF name="simple linear data-accessing statement"/> 
<opt> <BNF name="primitive result statement"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:W20-027R1</comment>
<BNFdef name="simple linear data-accessing statement">
<rhs>
<BNF name="simple data-accessing statement"/><repeat/>
</rhs>
</BNFdef>

<comment>WG3:UTC-122</comment>
<BNFdef name="simple data-accessing statement">
<rhs>
<alt> <BNF name="simple query statement"/> </alt>
<alt> <BNF name="simple data-modifying statement"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:OHD-024</comment>
<BNFdef name="simple data-modifying statement">
<rhs>
<alt> <BNF name="primitive data-modifying statement"/> </alt>
<alt> <BNF name="call data-modifying procedure statement"/> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-04-23 Added merge statement</comment>
<comment>WG3:BER-050</comment>
<BNFdef name="primitive data-modifying statement">
<rhs>
<alt> <BNF name="insert statement"/> </alt>
<alt> <BNF name="set statement"/> </alt>
<alt> <BNF name="remove statement"/> </alt>
<alt> <BNF name="delete statement"/> </alt>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<comment>WG3:BER-019</comment>
<olist>

<item>Let <symdef>LDMS</symdef> be the <BNF name="linear data-modifying statement"/>.
</item>

<comment>WG3:UTC-009 P00-USA-169</comment>
<comment>WG3:UTC-101</comment>
<item>If the <BNF name="focused linear data-modifying statement body"/> does not immediately
contain a <BNF name="primitive result statement"/>, then <kw>FINISH</kw> is implicit.
</item>

<comment>WG3:UTC-101</comment>
<item>If the <BNF name="ambient linear data-modifying statement body"/> does not immediately
contain a <BNF name="primitive result statement"/>, then <kw>FINISH</kw> is implicit.
</item>

<comment>WG3:UTC-096R1</comment>
<comment>WG3:CMN-019 P00-NLD-050</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>Let <symdef>STMSEQ</symdef> be the sequence of <BNF name="simple data-accessing statement"/>s,
the <BNF name="primitive result statement"/>, and 
the <BNF name="nested data-modifying procedure specification"/>
directly contained in <sym>LDMS</sym>.
Let <symdef>M</symdef> be the number of elements of <sym>STMSEQ</sym>.
For <symdef>j</symdef>, 1 (one) <leq/> <sym>j</sym> <leq/> <sym>M</sym>, 
let <symdef>STM</symdef><sub><sym>j</sym></sub> be the <sym>j</sym>-th element of <sym>STMSEQ</sym>.
</item>

<comment>WG3:UTC-096R1</comment>
<item><sym>STMSEQ</sym> shall contain at least one <BNF name="simple data-modifying statement"/>.
</item>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>STM</sym><sub>1</sub> is 
the incoming working record type of <sym>LDMS</sym>.
</item>

<comment>WG3:UTC-096R1</comment>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>STM</sym><sub>1</sub> is 
the incoming working table type of <sym>LDMS</sym>.
</item>
<endbar/>

<comment>Editorial: Stefan Plantikow 2022-09-15 Correct to use right number phrase</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>For 2 (two) <leq/> <symdef>j</symdef> <leq/> <sym>M</sym>:

<olist>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>STM</sym><sub><sym>j</sym></sub> 
is the outgoing working record type of <sym>STM</sym><sub><sym>j</sym>-1</sub>.
</item>

<comment>WG3:W23-009R1 P00-USA-331</comment>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>STM</sym><sub><sym>j</sym></sub> 
is the outgoing working table type of <sym>STM</sym><sub><sym>j</sym>-1</sub>.
</item>
<endbar/>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-207</comment>
<item>The declared type of <sym>LDMS</sym> is the declared type of 
<sym>STM</sym><sub><sym>M</sym></sub>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2022-03-25 WG3:RKE-010 P00-NLD-219 Use default rule evaluation
order</comment>
<olist>

<comment>WG3:UTC-059</comment>
<item>If the current transaction access mode is <kw>READ</kw> <kw>ONLY</kw>, then an exception 
condition is raised: <raise class="25" subclass="G03"/>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-047</comment>
<item>Without <feature code="GQ01"/>, conforming GQL language shall not contain 
a <BNF name="focused linear data-modifying statement"/>.
</item>

<comment>WG3:UTC-116</comment>
<item>Without <feature code="GD01"/>, conforming GQL language shall not contain 
a <BNF name="simple data-modifying statement"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_insert" newpage="true">
<clauseHeading><BNF name="insert statement"/></clauseHeading>

<bodyMatter>


<Function>

<comment>WG3:CMN-042</comment>
<para>Insert new nodes and edges into a graph.
</para>

</Function>

<ednote id="gql_PP035_insert">Discussion paper WG3:MMX-047 suggests the addition of 
a <quote>Time To Live</quote> option, which would require specified graph elements be deleted 
after a certain time to save storage space.
See <PPref ref="PPgql035"/>.
</ednote>


<Format>

<grammar>

<comment>WG3:JCJ-010R1</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-01</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-20 Removed OPTIONAL INSERT</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-13 Only support OPTIONAL</comment>
<comment>WG3:OHD-012</comment>
<BNFdef name="insert statement">
<rhs>
<kw>INSERT</kw> <BNF name="insert graph pattern"/> 
</rhs>
</BNFdef>

<comment>WG3:W14-013: Stefan Plantikow, 2021-09-15 Add missing editor's note</comment>
<ednote id="gql_PP169_2">Consider allowing a single optional <BNF name="where clause"/>.
See <PPref ref="PPgql169"/>.
</ednote>

</grammar>

</Format>


<SyntaxRules>

<comment>Editorial: Stefan Plantikow, 2020-04-21 Add statement mode</comment>
<olist>

<item>Let <symdef>IS</symdef> be the <BNF name="insert statement"/>.
</item>

<item>Let <symdef>IGP</symdef> be the <BNF name="insert graph pattern"/> immediately contained
in <sym>IS</sym>.
</item>

<comment>WG3:W24-034R2</comment>
<comment>WG3:UTC-094</comment>
<comment>WG3:W26-037R3</comment>
<item>Let <symdef>IDNSET</symdef> be the system-generated variable names of <sym>IGP</sym>.

<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<note>See <itemref ref="gql_token_sys_gen_id" type="SR"/> of <specref ref="gql_token"/> for 
detailed provisions regarding the construction of system-generated regular identifiers.
</note>

</item>
<comment>Editorial: Stefan Plantikow, 2020-05-13 Only support OPTIONAL</comment>
<comment>Editorial: Stephen Cannan, 2020-12-11 Correct symbol and optionality</comment>
<comment>WG3:OHD-012 One SR deleted</comment>
<comment>WG3:OHD-012</comment>
<comment>Editorial: Stefan Plantikow, 2022-10-05 Add WT site</comment>
<comment>WG3:W24-034R2</comment>
<comment>WG3:W06-013</comment>
<comment>WG3:OHD-012 One SR deleted</comment>

<comment>WG3:OHD-012</comment>
<comment>WG3:W24-034R2</comment>
<comment>WG3:UTC-094</comment>
<item>Let <symdef>NEWCOLS</symdef> be a set of columns determined as follows.
For every <BNF name="insert path pattern"/> <symdef>IPP</symdef> immediately contained in
<sym>IGP</sym>, for every insert element pattern <symdef>IEP</symdef> immediately contained in
<sym>IPP</sym> that declares an element variable <symdef>EV</symdef> with name <symdef>EVN</symdef>
that is not a bound insert element pattern:

<note>Insert element patterns and bound insert element patterns are defined in 
<itemref ref="gql_insert_SR_element_pattern" type="SR"/> and 
<itemref ref="gql_insert_SR_bound_element_pattern" type="SR"/> of
<specref ref="gql_insert_graph_pattern"/>.
</note>

<olist>

<item>Let <symdef>COLTYPE</symdef> be determined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W24-034R2</comment>
<item>If <sym>IEP</sym> is an <BNF name="insert node pattern"/>, then <sym>COLTYPE</sym> is
a node reference value type that is determined using an <impDef code="IW012"/> mechanism such that
it includes all reference values to nodes that can be bound to <sym>EV</sym> by <sym>IS</sym>.
</item>

<comment>WG3:W24-034R2</comment>
<item>Otherwise, <sym>IEP</sym> is an <BNF name="insert edge pattern"/> and <sym>COLTYPE</sym> is
an edge reference value type that is determined using an <impDef code="IW012"/> mechanism such that 
it includes all reference values to edges that can be bound to <sym>EV</sym> by <sym>IS</sym>.
</item>

</olist>

</item>

<item>Let <symdef>COL</symdef> be the column whose name is <sym>EVN</sym> and whose type is
<sym>COLTYPE</sym>.
</item>

<comment>WG3:W24-034R2</comment>
<item>Include <sym>COL</sym> in <sym>NEWCOLS</sym>.
</item>

<comment>WG3:W24-034R2</comment>
<item>If <sym>COLTYPE</sym> is a closed graph element reference value type, then for every
<BNF name="property key value pair"/> <symdef>PKVP</symdef> contained in <sym>IEP</sym>:

<olist>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<item>Let <symdef>PT</symdef> be the property type in the constraining GQL-object type of 
<sym>COLTYPE</sym> identified by the <BNF name="property name"/> immediately contained in 
<sym>PKVP</sym>.
</item>

<item>The <applySC ref="gql_store" rules="SR">
<symarg param="TARGET">a transient site of type <sym>PT</sym></symarg>
<symarg param="VALUE">the <BNF name="value expression"/> immediately contained in 
<sym>PKVP</sym></symarg>
</applySC>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:CMN-042</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use of omitted</comment>
<item>The current working graph site of <sym>IS</sym> shall not be <quote>omitted</quote>.
</item>

<comment>WG3:OHD-012</comment>
<comment>WG3:UTC-094</comment>
<comment>WG3:CMN-042</comment>
<item>Let <symdef>CWGS</symdef> be the current working graph site of <sym>IS</sym>.
</item>

<comment>WG3:OHD-028</comment>
<comment>WG3:OHD-028</comment>
<comment>WG3:W24-034R2</comment>
<comment>WG3:UTC-094</comment>
<comment>WG3:CMN-068</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The outgoing working table type of <sym>IS</sym> is the material binding 
table type whose set of columns is the union of all columns of incoming working table type
of <sym>IS</sym> and all columns from <sym>NEWCOLS</sym> without the columns 
identified by <sym>IDNSET</sym>.
</item>

<comment>WG3:OHD-028</comment>
<comment>WG3:XRH-036</comment>
<item>The outgoing working record type of <sym>IS</sym> is the incoming working record type
of <sym>IS</sym>.
</item>
<endbar/>

<comment>WG3:OHD-028</comment>
<comment>WG3:W26-026R2</comment>
<item>The declared type of <sym>IS</sym> is the empty type.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<comment>Editorial: Stefan Plantikow, 2020-04-20 Add GRs</comment>
<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2020-05-12 One GR removed</comment>
<olist>

<item>Let <symdef>TABLE</symdef> be the current working table.
</item>

<comment>WG3:CMN-042</comment>
<item>Let <symdef>CG</symdef> be the graph referenced by <sym>CWGS</sym>.
</item>

<comment>WG3:OHD-012</comment>
<item>Let <symdef>NEW_TABLE</symdef> be a new empty binding table whose columns are the union of
all columns of the declared type of <sym>TABLE</sym> and all columns from <sym>NEWCOLS</sym>.
</item>

<comment>WG3:W12-019</comment>
<item>For every record <symdef>R</symdef> of <sym>TABLE</sym> in a new child execution context
amended with <sym>R</sym>:

<olist>

<comment>WG3:OHD-012</comment>
<item>Let <symdef>CR</symdef> be a new record whose field types are the elements of
<sym>NEWCOLS</sym> and whose fields are determined by processing each
<BNF name="insert path pattern"/> <symdef>IPP</symdef> immediately contained in <sym>IGP</sym>
as follows:

<olist>

<comment>WG3:UTC-094</comment>
<comment>Editorial: Stephen Cannan, 2023-10-13</comment>
<item>For every <BNF name="insert node pattern"/> <symdef>INP</symdef> immediately contained in 
<sym>IPP</sym> that declares an element variable <symdef>EV</symdef> with 
name <symdef>EVN</symdef> that is the defining insert element pattern of <sym>EV</sym>, and
is not a bound insert element pattern:

<note>The defining insert element patterns of an <BNF name="element variable"/> are
defined in <itemref ref="gql_insert_gp_SR_def_ins_patt" type="SR"/> of 
<specref ref="gql_insert_graph_pattern"/>. 
</note>

<olist>

<item>Let the set of node label names <symdef>NLNS</symdef> be determined as follows.

<para>Case:
</para>

<olist>

<comment>Editorial: Stefan Plantikow, 2023-03-15 Wording</comment>
<item>If <sym>INP</sym> immediately contains a <BNF name="label set specification"/>
<symdef>LSS</symdef>, then <sym>NLNS</sym> is the set of label names specified
by <sym>LSS</sym>.
</item>

<item>Otherwise, <sym>NLNS</sym> is the empty set.
</item>

</olist>

</item>

<comment>WG3:OHD-015</comment>
<item>If the cardinality of <sym>NLNS</sym> is less than the <impDef code="IL001"/> node label set
minimum cardinality, then an exception condition is raised: <raise class="22" subclass="G0N"/>.
</item>

<comment>WG3:OHD-015</comment>
<item>If the cardinality of <sym>NLNS</sym> is greater than the <impDef code="IL001"/> node label 
set maximum cardinality, then an exception condition is raised: 
<raise class="22" subclass="G0P"/>.
</item>

<item>Let the set of node properties <symdef>NPS</symdef> be determined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W24-034R2</comment>
<comment>Editorial: Stephen Cannan, 2023-06-20, Correct symdef</comment>
<comment>WG3:CMN-019 P00-USA-050</comment>
<item>If <sym>INP</sym> simply contains a <BNF name="property key value pair list"/>
<symdef>PKVPL</symdef>, then let <symdef>NPS</symdef> be the list of all properties computed as 
follows.
For each <BNF name="property key value pair"/> <symdef>PKVP</symdef> in <sym>PKVPL</sym>:

<olist>

<item>Let <symdef>NPROP</symdef> be a new property.
</item>

<item>The name of <sym>NPROP</sym> is the name specified by the <BNF name="property name"/> 
immediately contained in <sym>PKVP</sym>.
</item>

<comment>WG3:CMN-044</comment>
<item>The <applySC ref="gql_store" rules="GR">
<symarg param="TARGET"><sym>NPROP</sym></symarg>
<symarg param="VALUE">the result of the <BNF name="value expression"/> immediately contained in 
<sym>PKVP</sym></symarg>
</applySC>.
</item>

<item>Include <sym>NPROP</sym> in <sym>NPS</sym>.
</item>

</olist>

</item>

<item>Otherwise, <sym>NPS</sym> is the empty set.
</item>

</olist>

</item>

<comment>WG3:OHD-047</comment>
<item>If the cardinality of <sym>NPS</sym> is greater than the <impDef code="IL002"/>
node property set maximum cardinality, then an exception condition is raised:
<raise class="22" subclass="G0S"/>.
</item>

<comment>WG3:CMN-042</comment>
<item>Schedule the insertion of a new node <symdef>NN</symdef> into <sym>CG</sym>.

<note>Scheduled insertions of new nodes are performed by the application of
<itemref ref="gql_insert_GR_scheduled_nodes" type="GR"/> of this Subclause.
</note>

<olist>

<item><symdef>NN</symdef> is associated with a new global object identifier.
</item>

<comment>WG3:OHD-015</comment>
<item>The node label set of <sym>NN</sym> is <sym>NLNS</sym>.
</item>

<comment>WG3:OHD-015</comment>
<item>The node property set of <sym>NN</sym> is <sym>NPS</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-044</comment>
<item id="gql_insert_GR_INP">Let <symdef>NR</symdef> be a node reference value for <sym>NN</sym>.
The reference value for <sym>INP</sym> is <sym>NR</sym>.
</item>

<comment>WG3:CMN-044</comment>
<item>The field whose name is <sym>EVN</sym> and whose value is <sym>NR</sym> is included in
<sym>CR</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-094</comment>
<comment>WG3:CMN-044</comment>
<item>For every <BNF name="insert edge pattern"/> <symdef>IEP</symdef>
immediately contained in <sym>IPP</sym> that declares an element variable <symdef>EV</symdef> with
name <symdef>EVN</symdef>:

<olist>

<item>Let the set of label names <symdef>ELNS</symdef> is defined as follows.

<para>Case:
</para>

<olist>

<comment>Editorial: Stefan Plantikow, 2023-03-15 Wording</comment>
<item>If <sym>IEP</sym> immediately contains a <BNF name="label set specification"/>
<symdef>LSS</symdef>, then <sym>ELNS</sym> is the set of label names specified
by <sym>LSS</sym>.
</item>

<item>Otherwise, <sym>ELNS</sym> is the empty set.
</item>


</olist>

</item>

<comment>WG3:OHD-015</comment>
<item>If the cardinality of <sym>ELNS</sym> is less than the <impDef code="IL001"/> edge label set
minimum cardinality, then an exception condition is raised: <raise class="22" subclass="G0Q"/>.
</item>

<comment>WG3:OHD-015</comment>
<item>If the cardinality of <sym>ELNS</sym> is greater than the <impDef code="IL001"/> edge label 
set maximum cardinality, then an exception condition is raised: 
<raise class="22" subclass="G0R"/>.
</item>

<item>Let the set of edge properties <symdef>EPS</symdef> be determined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W24-034R2</comment>
<comment>WG3:CMN-019 P00-USA-050</comment>
<item>If <sym>IEP</sym> simply contains a <BNF name="property key value pair list"/>
<symdef>PKVPL</symdef>, then let <symdef>EPS</symdef> be the list of all properties computed
as follows.
For each <BNF name="property key value pair"/> <symdef>PKVP</symdef> in <sym>PKVPL</sym>: 

<olist>

<item>Let <symdef>EPROP</symdef> be a new property.
</item>

<item>The name of <sym>EPROP</sym> is the name specified by the <BNF name="property name"/> 
immediately contained in <sym>PKVP</sym>.
</item>

<comment>WG3:CMN-019 P00-USA-051</comment>
<item>The <applySC ref="gql_store" rules="GR">
<symarg param="TARGET"><sym>EPROP</sym></symarg>
<symarg param="VALUE">the result of the <BNF name="value expression"/> immediately contained in 
<sym>PKVP</sym></symarg>
</applySC>.
</item>

<comment>WG3:CMN-019 P00-USA-050</comment>
<item>Include <sym>EPROP</sym> in <sym>EPS</sym>.
</item>

</olist>

</item>

<item>Otherwise, <sym>EPS</sym> is the empty set.
</item>

</olist>

</item>

<comment>WG3:OHD-047</comment>
<item>If the cardinality of <sym>EPS</sym> is greater than the <impDef code="IL002"/> edge property
set maximum cardinality, then an exception condition is raised:
<raise class="22" subclass="G0T"/>.
</item>

<comment>Editorial: Stephen Cannan, 2023-08-30</comment>
<item>Let the left endpoint <symdef>N_LEFT</symdef> be defined as follows:

<olist>

<comment>Editorial: Stephen Cannan, 2023-08-30</comment>
<item>Let <symdef>INP_LEFT</symdef> be the rightmost <BNF name="insert node pattern"/>
that precedes <sym>IEP</sym> in <sym>IPP</sym>.
</item>

<item>Case:

<olist>

<comment>Editorial: Stephen Cannan, 2023-08-30</comment>
<comment>WG3:CMN-035</comment>
<item>If <sym>INP_LEFT</sym> is a bound insert element pattern, then <sym>N_LEFT</sym> is
the result of the <BNF name="element variable"/> declared by <sym>INP_LEFT</sym>. 

<note>Bound insert element patterns are defined in 
<itemref ref="gql_insert_SR_element_pattern" type="SR"/> and 
<itemref ref="gql_insert_SR_bound_element_pattern" type="SR"/> of
<specref ref="gql_insert_graph_pattern"/>.
</note>

</item>

<comment>Editorial: Stephen Cannan, 2023-08-30</comment>
<comment>WG3:CMN-044</comment>
<item>Otherwise, <sym>N_LEFT</sym> is the reference value for
<sym>INP_LEFT</sym>.

<note>The reference value for <sym>INP_LEFT</sym> is defined by
<itemref type="GR" ref="gql_insert_GR_INP"/>.
</note>

</item>

</olist>

</item>

</olist>

</item>

<comment>Editorial: Stephen Cannan, 2023-08-30</comment>
<item>Let the right endpoint <symdef>N_RIGHT</symdef> be defined as follows:

<olist>

<comment>Editorial: Stephen Cannan, 2023-08-30</comment>
<item>Let <symdef>INP_RIGHT</symdef> be the leftmost <BNF name="insert node pattern"/>
that follows <sym>IEP</sym> in <sym>IPP</sym>.
</item>

<item>Case:

<olist>

<comment>Editorial: Stephen Cannan, 2023-08-30</comment>
<comment>WG3:CMN-035</comment>
<item>If <sym>INP_RIGHT</sym> is a bound insert element pattern, then <sym>N_RIGHT</sym> is
the result of the <BNF name="element variable"/> declared by <sym>INP_RIGHT</sym>.

<note>Bound insert element patterns are defined in 
<itemref ref="gql_insert_SR_bound_element_pattern" type="SR"/> of
<specref ref="gql_insert_graph_pattern"/>.
</note>

</item>

<comment>WG3:CMN-044</comment>
<item>Otherwise, <sym>N_RIGHT</sym> is the reference value for
<sym>INP_RIGHT</sym>.

<note>The reference value for <sym>INP_RIGHT</sym> is defined by
<itemref type="GR" ref="gql_insert_GR_INP"/>.
</note>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-053</comment>
<comment>Editorial: Stephen Cannan, 2023-08-30</comment>
<item>If either <sym>N_LEFT</sym> or <sym>N_RIGHT</sym> is deleted,
then an exception condition is raised: <raise class="G1" subclass="002"/>.
</item>

<comment>Editorial: Stephen Cannan, 2023-08-30</comment>
<comment>WG3:CMN-042</comment>
<item>If either <sym>N_LEFT</sym> or <sym>N_RIGHT</sym> is not
in <sym>CG</sym>, then an exception condition is raised: <raise class="G1" subclass="003"/>.
</item>

<comment>Editorial: Stephen Cannan, 2023-08-30</comment>
<item>If <symdef>N_LEFT</symdef> and <symdef>N_RIGHT</symdef> are both nodes,
then:

<olist>

<item>Let the <BNF name="edge kind"/> <symdef>EK</symdef> be defined as follows.
If <symdef>IEP</symdef> immediately contains a <BNF name="full edge undirected"/>, then
<sym>EK</sym> is <kw>UNDIRECTED</kw>; otherwise, <sym>EK</sym> is <kw>DIRECTED</kw>
</item>

<comment>Email from: Jim Melton 2022-12-08 0219</comment>
<comment>Editorial: Stephen Cannan, 2023-08-30</comment>
<item>Let <symdef>N_LEFT2</symdef> and <symdef>N_RIGHT2</symdef> be defined as follows. 
If <sym>EK</sym> is <kw>DIRECTED</kw> and <sym>IEP</sym> contains
a <BNF name="full edge pointing left"/>, then <sym>N_LEFT2</sym> is
<sym>N_RIGHT</sym> and <sym>N_RIGHT2</sym> is
<sym>N_LEFT</sym>; otherwise, <sym>N_LEFT2</sym> is
<sym>N_LEFT</sym> and <sym>N_RIGHT2</sym> is
<sym>N_RIGHT</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-042</comment>
<item>Schedule the insertion of a new edge <symdef>NE</symdef> into <sym>CG</sym>.

<note>Scheduled insertions of new edges are performed by the application of
<itemref ref="gql_insert_GR_scheduled_edges" type="GR"/> of this Subclause.
</note>

<olist>

<item><symdef>NE</symdef> is associated with a new global object identifier.
</item>

<item>The edge label set of <sym>NE</sym> is <sym>ELNS</sym>.
</item>

<item>The edge property set of <sym>NE</sym> is <sym>EPS</sym>.
</item>

<comment>Email from: Jim Melton 2022-12-08 0219</comment>
<item>If <sym>EK</sym> is <kw>DIRECTED</kw>, then <sym>NE</sym> is a directed edge that connects
the source node <sym>N_LEFT2</sym> to the destination node <sym>N_RIGHT2</sym>; 
otherwise, <sym>EK</sym> is <kw>UNDIRECTED</kw> and <sym>NE</sym> is an undirected edge that 
connects the endpoints <sym>N_LEFT2</sym> and <symdef>N_RIGHT2</symdef>.
</item>

</olist>

</item>

<item>Let <symdef>ER</symdef> be the edge reference value for <sym>NE</sym>.
</item>

<item>The field whose name is <sym>EVN</sym> and whose value is <sym>ER</sym> is included
in <sym>CR</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:OHD-012</comment>
<item>Let <symdef>NR</symdef> be a new record constructed by amending <sym>R</sym> with
<sym>CR</sym>.
</item>

<comment>WG3:OHD-012</comment>
<item>Append <symdef>NR</symdef> to <sym>NEW_TABLE</sym>.
</item>

</olist>

</item>

<comment>WG3:OHD-012</comment>
<item id="gql_insert_GR_scheduled_nodes">Perform all scheduled insertions of new nodes.
</item>

<comment>WG3:OHD-012</comment>
<item id="gql_insert_GR_scheduled_edges">Perform all scheduled insertions of new edges.
</item>

<comment>WG3:OHD-025</comment>
<comment>WG3:CMN-042</comment>
<item>If <sym>CG</sym> has a graph type <symdef>GT</symdef> and <sym>CG</sym> is not of graph 
type <sym>GT</sym>, then an exception condition is raised: <raise class="G2"/>.
</item>

<comment>WG3:W24-034R2</comment>
<comment>WG3:UTC-094</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<comment>WG3:CMN-068</comment>
<item>The current working table is set to a copy of <sym>NEW_TABLE</sym> without the columns 
identified by <sym>IDNSET</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2020-06-08 Changed to unit</comment>
<comment>WG3:W12-019</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item>The current execution outcome is set to a successful outcome with an omitted result.
</item>

</olist>

</GeneralRules>

<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_set_stmt" newpage="true">
<clauseHeading><BNF name="set statement"/></clauseHeading>

<bodyMatter>


<Function>

<para>Set graph element properties and labels.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-04-01</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-13 Add set item list</comment>
<comment>WG3:BER-036</comment>
<BNFdef name="set statement">
<rhs>
<kw>SET</kw> <BNF name="set item list"/> 
</rhs>
</BNFdef>

<BNFdef name="set item list">
<rhs>
<BNF name="set item"/>
<opt> <group> <BNF name="comma"/> <BNF name="set item"/> </group><repeat/> </opt>
</rhs>
</BNFdef>


<comment>Editorial: Stephen Cannan, 2022-03-05 WG3:RKE-010 P00-USA-480</comment>
<BNFdef name="set item">
<rhs>
<alt> <BNF name="set property item"/> </alt>
<alt> <BNF name="set all properties item"/> </alt>
<alt> <BNF name="set label item"/> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-04-13 Added IF NOT EXISTS</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-13 IF NOT EXISTS replaced by when clause</comment>
<comment>WG3:W22-053R2</comment>
<BNFdef name="set property item">
<rhs>
<BNF name="binding variable reference"/> <BNF name="period"/> <BNF name="property name"/>
<BNF name="equals operator"/>
<BNF name="value expression"/>
</rhs>
</BNFdef>

<comment>WG3:BER-036R1</comment>
<comment>WG3:W22-053R2</comment>
<BNFdef name="set all properties item">
<rhs>
<BNF name="binding variable reference"/> <BNF name="equals operator"/>
<breakindent/>
<BNF name="left brace"/> <opt> <BNF name="property key value pair list"/> </opt> 
<BNF name="right brace"/>
</rhs>
</BNFdef>

<comment>WG3:BER-036</comment>
<comment>WG3:W22-053R2</comment>
<comment>WG3:W25-026</comment>
<BNFdef name="set label item">
<rhs>
<BNF name="binding variable reference"/> <BNF name="is or colon"/> <BNF name="label name"/>
</rhs>
</BNFdef>
<comment>WG3:OHD-012 One production deleted</comment>

<comment>WG3:W14-013: Stefan Plantikow, 2021-09-15 Add missing editor's note</comment>
<ednote id="gql_PP169_4">Consider allowing a single optional <BNF name="where clause"/>.
See <PPref ref="PPgql169"/>.
</ednote>

</grammar>

</Format>


<SyntaxRules>

<comment>Editorial: Stefan Plantikow, 2020-05-13 Add SRs</comment>
<olist>

<item>Let <symdef>SS</symdef> be the <BNF name="set statement"/>.
</item>

<item>Let <symdef>SIL</symdef> be the <BNF name="set item list"/> immediately contained
in <sym>SS</sym>.
</item>

<comment>WG3:BER-036</comment>
<item>For every <BNF name="set item"/> <symdef>SI</symdef> immediately contained in <sym>SIL</sym>,

<para>Case:
</para>

<olist>

<item>If <sym>SI</sym> immediately contains a <BNF name="set property item"/> <symdef>SPI</symdef>, 
then:

<olist>

<comment>WG3:CMN-035</comment>
<item>Let <symdef>BVR</symdef> be the <BNF name="binding variable reference"/> immediately contained
in <sym>SPI</sym>.
</item>

<comment>WG3:CMN-035</comment>
<item>Let <symdef>VE</symdef> be the <BNF name="value expression"/> immediately contained
in <sym>SPI</sym>.
</item>

<comment>WG3:W22-053R2</comment>
<comment>WG3:W24-034R2</comment>
<comment>WG3:CMN-019 P00-USA-054</comment>
<comment>WG3:CMN-035</comment>
<item>The declared type of <symdef>BVR</symdef> shall be a graph element reference value type.
</item>

<comment>WG3:W24-026R2</comment>
<comment>WG3:W24-034R2</comment>
<comment>WG3:CMN-035</comment>
<item>The declared type of <symdef>VE</symdef> immediately shall be a supported property value type.
</item>

<comment>WG3:W24-034R2</comment>
<comment>WG3:CMN-019 P00-USA-056</comment>
<item>If the declared type of <sym>BVR</sym> is a closed graph element reference value type
<symdef>ERVT</symdef>, then:

<olist>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<item>Let <symdef>PT</symdef> be the property type in the constraining GQL-object type of 
<sym>ERVT</sym> identified by the <BNF name="property name"/> immediately contained in 
<sym>SPI</sym>.
</item>

<item>The <applySC ref="gql_store" rules="SR">
<symarg param="TARGET">a transient site of type <sym>PT</sym></symarg>
<symarg param="VALUE"><sym>VE</sym></symarg>
</applySC>.
</item>

</olist>

</item>

</olist>

</item>

<item>If <sym>SI</sym> immediately contains a <BNF name="set all properties item"/> 
<symdef>SAPI</symdef>, then:

<olist>

<comment>WG3:CMN-035</comment>
<item>Let <symdef>BVR</symdef> be the <BNF name="binding variable reference"/> immediately contained
in <sym>SAPI</sym>.
</item>

<comment>WG3:W22-053R2</comment>
<comment>WG3:W24-034R2</comment>
<comment>WG3:CMN-019 P00-USA-054</comment>
<comment>WG3:CMN-035</comment>
<item>The declared type of <symdef>BVR</symdef> shall be a graph element reference value type.
</item>

<comment>WG3:BER-036R1</comment>
<comment>WG3:W24-026R2</comment>
<comment>WG3:W24-034R2</comment>
<item>For every <BNF name="property key value pair"/> <symdef>PKVP</symdef> immediately contained 
in <sym>SAPI</sym>:

<olist>

<comment>WG3:CMN-035</comment>
<item>Let <symdef>VE</symdef> be the <BNF name="value expression"/> immediately contained in
<sym>PKVP</sym>.
</item>

<comment>WG3:CMN-035</comment>
<item>The declared type of <sym>VE</sym> shall be a supported property value type.
</item>

<comment>WG3:W24-034R2</comment>
<comment>WG3:CMN-019 P00-USA-056</comment>
<item>If the declared type of <sym>BVR</sym> is a closed graph element reference value type 
<symdef>ERVT</symdef>, then:

<olist>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<item>Let <symdef>PT</symdef> be the property type in the constraining GQL-object type of
<sym>ERVT</sym> identified by the <BNF name="property name"/> immediately contained in 
<sym>PKVP</sym>.
</item>

<item>The <applySC ref="gql_store" rules="SR">
<symarg param="TARGET">a transient site of type <sym>PT</sym></symarg>
<symarg param="VALUE"><sym>VE</sym></symarg>
</applySC>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:BER-036</comment>
<comment>WG3:W22-053R2</comment>
<comment>WG3:CMN-019 P00-USA-054</comment>
<item>If <sym>SI</sym> immediately contains a <BNF name="set label item"/> <symdef>SLI</symdef>, 
then the declared type of the <BNF name="binding variable reference"/> immediately contained in 
<sym>SLI</sym> shall be a graph element reference value type.
</item>

</olist>

</item>

<comment>WG3:W22-053R2</comment>
<comment>WG3:UTC-094</comment>
<item>No <BNF name="set property item"/> immediately contained in <sym>SIL</sym> shall
immediately contain a <BNF name="binding variable reference"/> and <BNF name="property name"/> 
that are both equivalent to the <BNF name="binding variable reference"/> and 
<BNF name="property name"/> immediately contained in a different <BNF name="set property item"/>.
</item>

<comment>WG3:W22-053R2</comment>
<comment>WG3:UTC-094</comment>
<item>No <BNF name="set all properties item"/> immediately contained in <sym>SIL</sym> shall 
immediately contain a <BNF name="binding variable reference"/> that is equivalent to the
<BNF name="binding variable reference"/> of any other <BNF name="set all properties item"/> or 
<BNF name="set property item"/> in <sym>SIL</sym>.
</item>

<comment>WG3:UTC-094</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The outgoing working table type of <sym>SS</sym> is the incoming working table type
of <sym>SS</sym>.
</item>

<comment>WG3:UTC-094</comment>
<comment>WG3:XRH-036</comment>
<item>The outgoing working record type of <sym>SS</sym> is the incoming working record type
of <sym>SS</sym>.
</item>
<endbar/>

<comment>WG3:UTC-094</comment>
<comment>WG3:W26-026R2</comment>
<item>The declared type of <sym>SS</sym> is the empty type.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2020-04-21 Added GRs</comment>
<olist>

<comment>Editorial: Stefan Plantikow, 2020-05-13 Adjusted for SRs</comment>
<item>Let <symdef>TABLE</symdef> be the current working table.
</item>

<comment>WG3:CMN-019 P00-USA-207</comment>
<item>Let <symdef>N</symdef> be the number of records of <sym>TABLE</sym>.
Let <symdef>M</symdef> be the number of <BNF name="set item"/>s immediately contained in 
<sym>SIL</sym>.
</item>

<comment>WG3:CMN-044</comment>
<item>For each <symdef>j</symdef>-th <BNF name="set item"/>
<symdef>SI</symdef><sub><sym>j</sym></sub>, 1 (one) <leq/> <sym>j</sym> <leq/> <sym>M</sym>, 
let <symdef>P</symdef><sub><sym>j</sym></sub> be defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:CMN-044</comment>
<item>If <sym>SI</sym><sub><sym>j</sym></sub> immediately contains
a <BNF name="set all properties item"/> <symdef>SAPI</symdef><sub><sym>j</sym></sub>, then
<sym>P</sym><sub><sym>j</sym></sub> is the number of <BNF name="property key value pair"/>s that are
immediately contained in <sym>SAPI</sym><sub><sym>j</sym></sub>.
</item>

<comment>WG3:CMN-044</comment>
<item>Otherwise, <sym>P</sym><sub><sym>j</sym></sub> is 1 (one).
</item>

</olist>

</item>

<comment>WG3:CMN-044</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<item>For each <symdef>j</symdef>-th <BNF name="set item"/>
<symdef>SI</symdef><sub><sym>j</sym></sub>, 1 (one) <leq/> <sym>j</sym> <leq/> <sym>M</sym>,
let the (possibly <quote>omitted</quote>) property name
<symdef>PN</symdef><sub><sym>j</sym>,<sym>k</sym></sub>,
1 (one) <leq/> <sym>k</sym> <leq/> <sym>P</sym><sub><sym>j</sym></sub> be defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:CMN-044</comment>
<item>If <sym>SI</sym><sub><sym>j</sym></sub> immediately contains
a <BNF name="set property item"/> <sym>SPI</sym><sub><sym>j</sym></sub>, then
<sym>PN</sym><sub><sym>j</sym>,<sym>k</sym></sub> is the name specified by
the <BNF name="property name"/> immediately contained in <sym>SPI</sym><sub><sym>j</sym></sub>. 
</item>

<comment>WG3:CMN-044</comment>
<item>If <sym>SI</sym><sub><sym>j</sym></sub> immediately contains
a <BNF name="set all properties item"/> <symdef>SAPI</symdef><sub><sym>j</sym></sub>, then
<sym>PN</sym><sub><sym>j</sym>,<sym>k</sym></sub> is the name specified by
the <BNF name="property name"/> immediately contained in
the <sym>k</sym>-th <BNF name="property key value pair"/> simply contained in
<sym>SAPI</sym><sub><sym>j</sym></sub>.
</item>

<comment>WG3:CMN-044</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<item>Otherwise, <sym>PN</sym><sub><sym>j</sym>,<sym>k</sym></sub> is <quote>omitted</quote>.
</item>

</olist>

</item>

<comment>WG3:CMN-044</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<item>For each <symdef>j</symdef>-th <BNF name="set item"/>
<symdef>SI</symdef><sub><sym>j</sym></sub>, 1 (one) <leq/> <sym>j</sym> <leq/> <sym>M</sym>,
let the (possibly <quote>omitted</quote>) label <symdef>LN</symdef><sub><sym>j</sym></sub> be
defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:CMN-044</comment>
<item>If <sym>SI</sym><sub><sym>j</sym></sub> immediately contains
a <BNF name="set label item"/> <symdef>SLI</symdef><sub><sym>j</sym></sub>, then
<sym>LN</sym><sub><sym>j</sym></sub> is the label specified by the <BNF name="label name"/> that 
is simply contained in <sym>SLI</sym><sub><sym>j</sym></sub>.
</item>

<comment>WG3:CMN-044</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<item>Otherwise, <sym>LN</sym><sub><sym>j</sym></sub> is <quote>omitted</quote>.
</item>

</olist>
</item>

<comment>WG3:W12-019</comment>
<comment>Editorial: Stephen Cannan, 2022-03-06 WG3:RKE-010 P00-USA-481</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item id="gql_set_gr_filtered">For each <sym>i</sym>-th record 
<symdef>R</symdef><sub><sym>i</sym></sub>, 1 (one) <leq/> <symdef>i</symdef> <leq/> <sym>N</sym>,
of <sym>TABLE</sym>, in a new child execution context amended with 
<sym>R</sym><sub><sym>i</sym></sub>:

<olist>

<comment>Editorial: Stephen Cannan, 2023-06-20, Correct symdef</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<comment>WG3:CMN-044</comment>
<comment>WG3:CMN-044 Removed 3 (three) Subrules </comment>
<item>For each <sym>j</sym>-th <BNF name="set item"/> <symdef>SI</symdef><sub><sym>j</sym></sub>, 
1 (one) <leq/> <symdef>j</symdef> <leq/> <sym>M</sym>, immediately contained in <sym>SIL</sym>,
let <symdef>GE</symdef><sub><sym>i</sym>,<sym>j</sym></sub> be the value of
the <BNF name="binding variable reference"/> simply contained in
<sym>SI</sym><sub><sym>j</sym></sub>.
</item>

<comment>Editorial: Stephen Cannan, 2022-03-06 WG3:RKE-010 P00-USA-481</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<comment>WG3:CMN-044</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<item>For each <sym>j</sym>-th <BNF name="set item"/> <symdef>SI</symdef><sub><sym>j</sym></sub>, 
1 (one) <leq/> <symdef>j</symdef> <leq/> <sym>M</sym>, immediately contained in <sym>SIL</sym>,
let the (possibly <quote>omitted</quote>) property value 
<sym>PV</sym><sub><sym>i</sym>,<sym>j</sym>,<sym>k</sym></sub>,
1 (one) <leq/> <symdef>k</symdef> <leq/> <sym>P</sym><sub><sym>j</sym></sub> be
defined as follows.

<para>Case:
</para>

<olist>

<comment>Remark Karl Schendel regarding simply contains (see SXM001 item 13.2)</comment>
<comment>WG3:CMN-044</comment>
<item>If <sym>SI</sym><sub><sym>j</sym></sub> immediately contains
a <BNF name="set property item"/> <symdef>SPI</symdef><sub><sym>j</sym></sub>, then
<symdef>PV</symdef><sub><sym>i</sym>,<sym>j</sym>,<sym>k</sym></sub> is
the result of the <BNF name="value expression"/> immediately contained in
<sym>SPI</sym><sub><sym>j</sym></sub>.
</item>

<comment>Remark Karl Schendel regarding simply contains (see SXM001 item 13.2)</comment>
<comment>WG3:BER-036R1</comment>
<comment>WG3:CMN-044</comment>
<item>If <sym>SI</sym><sub><sym>j</sym></sub> immediately contains
a <BNF name="set all properties item"/> <symdef>SAPI</symdef><sub><sym>j</sym></sub>, then
<symdef>PV</symdef><sub><sym>i</sym>,<sym>j</sym>,<sym>k</sym></sub> is the result of 
the <BNF name="value expression"/> immediately contained in
the <sym>k</sym>-th <BNF name="property key value pair"/> simply contained in
<sym>SAPI</sym><sub><sym>j</sym></sub>.
</item>

<comment>WG3:CMN-044</comment>
<item>Otherwise, <symdef>PV</symdef><sub><sym>i</sym>,<sym>j</sym>,<sym>k</sym></sub> is
<quote>omitted</quote>.
</item>

</olist>

</item>
<comment>WG3:CMN-044 Removed 1 (one) Subrule</comment>

</olist>

</item>

<comment>WG3:BER-036</comment>
<comment>WG3:UTC-094</comment>
<comment>WG3:CMN-044</comment>
<item>If there are two or more equivalent pairs
<symdef>PNGE</symdef><sub><sym>i</sym>,<sym>j</sym>,<sym>k</sym></sub> 
of property name <symdef>PN</symdef><sub><sym>j</sym>,<sym>k</sym></sub> and graph element 
<symdef>GE</symdef><sub><sym>i</sym>,<sym>j</sym></sub>,
1 (one) <leq/> <symdef>i</symdef> <leq/> <sym>N</sym>,
1 (one) <leq/> <symdef>j</symdef> <leq/> <sym>M</sym>,
and 1 (one) <leq/> <symdef>k</symdef> <leq/> <sym>P</sym><sub><sym>j</sym></sub> where
<sym>PN</sym><sub><sym>j</sym>,<sym>k</sym></sub> is defined, then it is <impDef code="IA017"/>
which one of the following occurs:
<olist>

<item>An exception condition is raised: <raise class="22" subclass="G0M"/>.
</item>

<comment>WG3:CMN-044</comment>
<item>An <unDef code="UV009"/> choice of one of the equivalent pairs 
<sym>PNGE</sym><sub><sym>i</sym>,<sym>j</sym>,<sym>k</sym></sub> is made and the corresponding 
<sym>PV</sym><sub><sym>i</sym>,<sym>j</sym>,<sym>k</sym></sub> is used to perform the assignment to 
<sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub>.
</item>

</olist>

</item>

<comment>WG3:W12-019</comment>
<comment>Editorial: Stephen Cannan, 2022-03-06 WG3:RKE-010 P00-USA-481</comment>
<comment>WG3:BER-036</comment>
<item>For each <sym>i</sym>-th record <symdef>R</symdef><sub><sym>i</sym></sub>,
1 (one) <leq/> <symdef>i</symdef> <leq/> <sym>N</sym>, of <sym>TABLE</sym>
(using the same order as <itemref type="GR" ref="gql_set_gr_filtered"/>),
perform the following data-modifying operations
in a new child execution context amended with <symdef>R</symdef><sub><sym>i</sym></sub>
for each <sym>j</sym>-th <BNF name="set item"/> <symdef>SI</symdef><sub><sym>j</sym></sub>, 
1 (one) <leq/> <symdef>j</symdef> <leq/> <sym>M</sym>, immediately contained in <sym>SIL</sym>.
If <sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub> is not the null value, then

<para>Case:
</para>

<olist>

<comment>WG3:CMN-044</comment>
<item>If <sym>SI</sym><sub><sym>j</sym></sub> immediately contains 
a <BNF name="set property item"/> <symdef>SPI</symdef><sub><sym>j</sym></sub>, then
the <applySC ref="gql_store" rules="GR">
<symarg param="TARGET">the property <sym>PN</sym><sub><sym>i</sym>,<sym>j</sym>,1</sub> of 
<sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub></symarg>
<symarg param="VALUE"><sym>PV</sym><sub><sym>i</sym>,<sym>j</sym>,1</sub></symarg>
</applySC>.
</item>

<item>If <sym>SI</sym><sub><sym>j</sym></sub> immediately contains 
a <BNF name="set all properties item"/> <symdef>SAPI</symdef><sub><sym>j</sym></sub>, then:

<comment>WG3:BER-036R1</comment>
<olist>

<comment>WG3:CMN-019 P00-USA-351</comment>
<item>All properties of <sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub> are removed.
</item>
<comment>WG3:CMN-044 Removed 1 (one) Subrule</comment>

<comment>WG3:CMN-019 P00-USA-207</comment>
<comment>WG3:CMN-044</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 WG3:CMN-044 Correction</comment>
<item>For each <BNF name="property key value pair"/> <sym>PKVP</sym><sub><sym>k</sym></sub>,
1 (one) <leq/> <symdef>k</symdef> <leq/> <sym>P</sym><sub><sym>j</sym></sub>,
immediately contained in <sym>SAPI</sym><sub><sym>j</sym></sub>,
the <applySC ref="gql_store" rules="GR">
<symarg param="TARGET">the property <sym>PN</sym><sub><sym>j</sym>,<sym>k</sym></sub> of 
<sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub></symarg>
<symarg param="VALUE"><sym>PV</sym><sub><sym>i</sym>,<sym>j</sym>,<sym>k</sym></sub></symarg>
</applySC>.
</item>

</olist>

</item>

<comment>WG3:OHD-015</comment>
<comment>WG3:W25-026</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 WG3:CMN-044 Correction</comment>
<item>If <sym>SI</sym><sub><sym>j</sym></sub> immediately contains a <BNF name="set label item"/>,
and <sym>LN</sym><sub><sym>j</sym></sub> is not contained in the label set of 
<sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub>, then
<sym>LN</sym><sub><sym>j</sym></sub> is added to the label set of 
<sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub>.
</item>

<comment>WG3:OHD-015</comment>
<comment>WG3:CMN-044</comment>
<item>If <sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub> is a node and the cardinality of 
the node label set of <sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub> is greater than the 
<impDef code="IL001"/> node label set maximum cardinality, then an exception condition is raised:
<raise class="22" subclass="G0P"/>.
</item>

<comment>WG3:OHD-047</comment>
<item>If <sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub> is a node and the cardinality of 
the node property set of <sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub> is greater than the 
<impDef code="IL002"/> node property set maximum cardinality, then an exception condition is raised:
<raise class="22" subclass="G0S"/>.
</item>

<comment>WG3:OHD-015</comment>
<comment>WG3:CMN-044</comment>
<item>If <sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub> is an edge and the cardinality of 
the edge label set of <sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub> is greater than the 
<impDef code="IL001"/> edge label set maximum cardinality, then an exception condition is raised:
<raise class="22" subclass="G0R"/>.
</item>

<comment>WG3:OHD-047</comment>
<item>If <sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub> is an edge and the cardinality of 
the edge property set of <sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub> is greater than the 
<impDef code="IL002"/> edge property set maximum cardinality, then an exception condition is raised:
<raise class="22" subclass="G0T"/>.
</item>

</olist>

</item>

<comment>WG3:OHD-025</comment>
<comment>Editorial: Stefan Plantikow, 2023-10-03 Use constraining graph type</comment>
<item>Let <symdef>CG</symdef> be the graph that contains 
<sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub>. 
If <sym>CG</sym> has a constraining graph type but <sym>CG</sym> is not of that graph type, then
an exception condition is raised: <raise class="G2"/>.
</item>

<comment>Editorial: Stefan Plantikow, 2020-06-08 Changed to unit</comment>
<comment>WG3:W12-019</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item>The current execution outcome is set to a successful outcome with an omitted result.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:OHD-025</comment>
<item>Without <feature code="GD02"/>, conforming GQL language shall not contain 
a <BNF name="set item"/> that is a <BNF name="set label item"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_remove" newpage="true">
<clauseHeading><BNF name="remove statement"/></clauseHeading>

<bodyMatter>


<Function>

<para>Remove graph element properties and labels.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-04-01</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-13 Add remove item list</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-13 Changed to when clause</comment>
<comment>WG3:BER-036</comment>
<BNFdef name="remove statement">
<rhs>
<kw>REMOVE</kw> <BNF name="remove item list"/> 
</rhs>
</BNFdef>

<BNFdef name="remove item list">
<rhs>
<BNF name="remove item"/>
<opt> <group> <BNF name="comma"/> <BNF name="remove item"/> </group><repeat/> </opt>
</rhs>
</BNFdef>


<BNFdef name="remove item">
<rhs>
<alt br="no"> <BNF name="remove property item"/> </alt>
<alt br="no"> <BNF name="remove label item"/> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-04-13 Added IF NOT EXISTS</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-13 IF NOT EXISTS replaced by when clause</comment>
<comment>WG3:W22-053R2</comment>
<BNFdef name="remove property item">
<rhs>
<BNF name="binding variable reference"/> <BNF name="period"/> <BNF name="property name"/>
</rhs>
</BNFdef>

<comment>WG3:BER-036</comment>
<comment>WG3:W22-053R2</comment>
<comment>WG3:W25-026</comment>
<BNFdef name="remove label item">
<rhs>
<BNF name="binding variable reference"/> <BNF name="is or colon"/> <BNF name="label name"/>
</rhs>
</BNFdef>

<comment>WG3:W14-013: Stefan Plantikow, 2021-09-15 Add missing editor's note</comment>
<ednote id="gql_PP169_5">Consider allowing a single optional <BNF name="where clause"/>.
See <PPref ref="PPgql169"/>.
</ednote>

</grammar>

</Format>


<SyntaxRules>

<comment>Editorial: Stefan Plantikow, 2020-05-13 Add SRs</comment>
<olist>

<item>Let <symdef>RS</symdef> be the <BNF name="remove statement"/>.
</item>

<item>Let <symdef>RIL</symdef> be the <BNF name="remove item list"/> immediately contained
in <sym>RS</sym>.
</item>

<comment>WG3:BER-036</comment>
<comment>WG3:W22-053R2</comment>
<comment>WG3:CMN-019 P00-USA-064</comment>
<item>For every <BNF name="remove item"/> <symdef>RI</symdef> immediately contained in 
<sym>RIL</sym>, the declared type of the <BNF name="binding variable reference"/> immediately 
contained in <sym>RI</sym> shall be a graph element reference value type.
</item>


<comment>WG3:UTC-094</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The outgoing working table type of <sym>RS</sym> is the incoming working table type
of <sym>RS</sym>.
</item>

<comment>WG3:UTC-094</comment>
<comment>WG3:XRH-036</comment>
<item>The outgoing working record type of <sym>RS</sym> is the incoming working record type
of <sym>RS</sym>.
</item>
<endbar/>

<comment>WG3:UTC-094</comment>
<comment>WG3:W26-026R2</comment>
<item>The declared type of <sym>RS</sym> is the empty type.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2020-04-21 Added GRs</comment>
<olist>

<comment>Editorial: Stefan Plantikow, 2020-05-13 Adjusted for SRs</comment>
<item>Let <symdef>TABLE</symdef> be the current working table.
</item>

<comment>WG3:CMN-019 P00-USA-207</comment>
<item>Let <symdef>N</symdef> be the number of records of <sym>TABLE</sym> and 
let <symdef>M</symdef> be the number of <BNF name="remove item"/>s immediately contained in 
<sym>RIL</sym>.
</item>

<comment>WG3:W12-019</comment>
<comment>Editorial: Stephen Cannan, 2022-03-06 WG3:RKE-010 P00-USA-481</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item id="gql_remove_gr_filtered">For each <symdef>i</symdef>-th record 
<symdef>R</symdef><sub><sym>i</sym></sub>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>, 
of <sym>TABLE</sym> in a new child execution context amended with 
<sym>R</sym><sub><sym>i</sym></sub>:

<olist>

<comment>Editorial: Stephen Cannan, 2023-06-20, Correct symdef</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<comment>WG3:CMN-044</comment>
<item>For each <symdef>j</symdef>-th <BNF name="remove item"/> 
<symdef>RI</symdef><sub><sym>j</sym></sub>, 1 (one) <leq/> <sym>j</sym> <leq/> <sym>M</sym>,
immediately contained in <sym>RIL</sym>,
let <symdef>GE</symdef><sub><sym>i</sym>,<sym>j</sym></sub> be the value of
the <BNF name="binding variable reference"/> simply contained in
<sym>RI</sym><sub><sym>j</sym></sub>.
</item>

<comment>Remark Karl Schendel regarding simply contains (see SXM001 item 13.2)</comment>
<comment>Editorial: Stephen Cannan, 2022-03-06 WG3:RKE-010 P00-USA-481</comment>
<comment>WG3:RKE-027 P16-USA-747</comment>
<comment>WG3:W25-026</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<item>For each <symdef>j</symdef>-th <BNF name="remove item"/> 
<symdef>RI</symdef><sub><sym>j</sym></sub>, 1 (one) <leq/> <sym>j</sym> <leq/> <sym>M</sym>,
immediately contained in <sym>RS</sym>, if <sym>RI</sym><sub><sym>j</sym></sub> 
immediately contains a <BNF name="remove label item"/> <symdef>RLI</symdef><sub><sym>j</sym></sub>,
then let <symdef>LN</symdef><sub><sym>j</sym></sub> be the <BNF name="label name"/> 
simply contained in <sym>RLI</sym><sub><sym>j</sym></sub>;
otherwise, let <symdef>LN</symdef><sub><sym>j</sym></sub> be <quote>omitted</quote>.
</item>

</olist>

</item>

<comment>WG3:W12-019</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>For each <symdef>i</symdef>-th record <symdef>R</symdef><sub><sym>i</sym></sub>,
1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>, of <sym>TABLE</sym>
(using the same order as <itemref type="GR" ref="gql_remove_gr_filtered"/>),
perform the following data-modifying operations
in a new child execution context amended with <sym>R</sym><sub><sym>i</sym></sub>
for each <sym>j</sym>-th <BNF name="remove item"/> <symdef>RI</symdef><sub><sym>j</sym></sub>, 
1 (one) <leq/> <symdef>j</symdef> <leq/> <sym>M</sym>, immediately contained in <sym>RIL</sym>.

<para>Case:
</para>

<olist>

<comment>Remark Karl Schendel regarding simply contains (see SXM001 item 13.2)</comment>
<comment>Editorial: Stephen Cannan, 2020-05-13</comment>
<comment>WG3:W23-009R1 P00-GBR-041 and P00-USA-108</comment>
<comment>WG3:CMN-019 P00-USA-066</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item>If <sym>RI</sym><sub><sym>j</sym></sub> immediately contains
a <BNF name="remove property item"/> <symdef>RPI</symdef><sub><sym>j</sym></sub>, then
let <symdef>PN</symdef><sub><sym>j</sym></sub> be
the <BNF name="property name"/> immediately contained in <sym>RPI</sym><sub><sym>j</sym></sub>.
If <sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub> is not the null value and 
a property <sym>PN</sym><sub><sym>j</sym></sub> is contained in the property set of
<sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub>, then the property 
<sym>PN</sym><sub><sym>j</sym></sub> is removed from the property set of
<sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub>.
</item>

<comment>Remark Karl Schendel regarding simply contains (see SXM001 item 13.2)</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-13 Corrected LN{i,j}</comment>
<comment>Editorial: Stephen Cannan, 2020-05-13</comment>
<comment>WG3:OHD-015</comment>
<item>If <sym>RI</sym><sub><sym>j</sym></sub> immediately contains 
a <BNF name="remove label item"/> and <sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub> is not 
the null value, then:

<olist>

<comment>WG3:OHD-015</comment>
<comment>WG3:W25-026</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item>If <sym>LN</sym><sub><sym>j</sym></sub> is contained in the label set of
<sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub>, then <sym>LN</sym><sub><sym>j</sym></sub> is
removed from the label set of <sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub>.
</item>

<comment>WG3:OHD-015</comment>
<comment>WG3:W25-026</comment>
<item>If <sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub> is a node and the cardinality of 
the label set of <sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub> is less than the 
<impDef code="IL001"/> node label set minimum cardinality, then an exception condition is raised:
<raise class="22" subclass="G0N"/>.
</item>

<comment>WG3:OHD-015</comment>
<comment>WG3:W25-026</comment>
<item>If <sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub> is an edge and the cardinality of 
the label set of <sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub> is less than the 
<impDef code="IL001"/> edge label set minimum cardinality, then an exception condition is raised:
<raise class="22" subclass="G0Q"/>.
</item>

</olist>

</item>

<comment>WG3:OHD-025</comment>
<comment>Editorial: Stefan Plantikow, 2023-10-03 Use constraining graph type</comment>
<item>Let <symdef>CG</symdef> be the graph that contains 
<sym>GE</sym><sub><sym>i</sym>,<sym>j</sym></sub>. 
If <sym>CG</sym> has a constraining graph type but <sym>CG</sym> is not of that graph type, then 
an exception condition is raised: <raise class="G2"/>.
</item>

</olist>

</item>

<comment>Editorial: Stefan Plantikow, 2020-06-08 Changed to unit</comment>
<comment>WG3:W12-019</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item>The current execution outcome is set to a successful outcome with an omitted result.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:OHD-025</comment>
<item>Without <feature code="GD02"/>, conforming GQL language shall not contain 
a <BNF name="remove item"/> that is a <BNF name="remove label item"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_delete" newpage="true">
<clauseHeading><BNF name="delete statement"/></clauseHeading>

<bodyMatter>


<Function>

<para>Delete graph elements.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-04-01</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-21 Use binding instead of graph pattern variable
</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-13 Add delete item list</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-13 Use when clause</comment>
<comment>WG3:W22-042</comment>
<BNFdef name="delete statement">
<rhs>
<opt> <alt br="no"> <kw>DETACH</kw> </alt> <alt br="no"> <kw>NODETACH</kw> </alt> </opt> 
<kw>DELETE</kw> <BNF name="delete item list"/> 
</rhs>
</BNFdef>

<BNFdef name="delete item list">
<rhs>
<BNF name="delete item"/>
<opt> <group> <BNF name="comma"/> <BNF name="delete item"/> </group><repeat/> </opt>
</rhs>
</BNFdef>

<BNFdef name="delete item">
<rhs>
<BNF name="value expression"/>
</rhs>
</BNFdef>

<comment>WG3:W14-013: Stefan Plantikow, 2021-09-15 Add missing editor's note</comment>
<ednote id="gql_PP169_6">Consider allowing a single optional <BNF name="where clause"/>.
See <PPref ref="PPgql169"/>.
</ednote>

 
</grammar>

</Format>


<SyntaxRules>

<comment>Editorial: Stefan Plantikow, 2020-05-13 Add SRs</comment>
<olist>

<item>Let <symdef>DS</symdef> be the <BNF name="delete statement"/>.
</item>

<item>Let <symdef>DIL</symdef> be the <BNF name="delete item list"/> immediately contained
in <sym>DS</sym>.
</item>

<comment>WG3:CMN-042</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 omitted</comment>
<item>The current working graph site of <sym>DS</sym> shall not be <quote>omitted</quote>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-02-24 Resolve GQL-305</comment>
<comment>WG3:CMN-042</comment>
<item>Let <symdef>CWGS</symdef> be the current working graph site of <sym>DS</sym>.
</item>

<comment>WG3:W22-042</comment>
<comment>WG3:UTC-094</comment>
<comment>WG3:CMN-019 P00-USA-067</comment>
<item>The declared type for every <BNF name="value expression"/> simply contained in 
<sym>DIL</sym> shall be a graph element reference value type.
</item>

<comment>WG3:UTC-094</comment>
<item>If <sym>DS</sym> does not specify <kw>DETACH</kw> or <kw>NODETACH</kw>, then 
<kw>NODETACH</kw> is implicit.
</item>

<comment>WG3:UTC-094</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The outgoing working table type of <sym>DS</sym> is the incoming working table type
of <sym>DS</sym>.
</item>

<comment>WG3:UTC-094</comment>
<comment>WG3:XRH-036</comment>
<item>The outgoing working record type of <sym>DS</sym> is the incoming working record type
of <sym>DS</sym>.
</item>
<endbar/>

<comment>WG3:UTC-094</comment>
<comment>WG3:W26-026R2</comment>
<item>The declared type of <sym>DS</sym> is the empty type.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2020-04-21 Add GRs</comment>
<olist>

<comment>Editorial: Stefan Plantikow, 2020-05-13 Moved to SRs</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-13 Adjusted GRs</comment>
<item>Let <symdef>TABLE</symdef> be the current working table.
</item>

<comment>WG3:CMN-042</comment>
<item>Let <symdef>CG</symdef> be the graph referenced by <sym>CWGS</sym>.
</item>

<comment>WG3:UTC-094</comment>
<item>Let <symdef>NODES</symdef> be an empty set. 
Let <symdef>EDGES</symdef> be an empty set.
</item>

<comment>WG3:UTC-094</comment>
<item>For each record <symdef>R</symdef> of <sym>TABLE</sym> in a new child execution context 
amended with <sym>R</sym>:

<olist>

<comment>WG3:W22-042</comment>
<item>For each <BNF name="delete item"/> <symdef>DI</symdef> immediately contained in 
<sym>DIL</sym>:

<olist>

<item>Let the value <symdef>V</symdef> be the result of the <BNF name="value expression"/> 
immediately contained in <sym>DI</sym>.
</item>

<item>Case:

<olist>

<comment>WG3:CMN-019 P00-USA-351</comment>
<comment>WG3:W26-031</comment>
<item>If <sym>V</sym> is a reference value to an edge <symdef>E</symdef> and <sym>V</sym> is not 
invalidated, then <sym>E</sym> is added to <sym>EDGES</sym>.
</item>

<comment>WG3:W26-031</comment>
<item>If <sym>V</sym> is a reference value to a node <symdef>N</symdef> and <sym>V</sym> is not 
invalidated, then:
<olist>

<comment>WG3:CMN-019 P00-USA-351</comment>
<item><sym>N</sym> is added to <sym>NODES</sym>.
</item>

<comment>WG3:CMN-019 P00-USA-351</comment>
<item>If <kw>DETACH</kw> is specified, then all edges connected to <sym>N</sym> are added to 
<sym>EDGES</sym>.
</item>

</olist>
 
</item>
<comment>WG3:CMN-019 P00-USA-068 One GR removed</comment>

<item>Otherwise, <sym>V</sym> is the null value.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-069</comment>
<item>For every node <symdef>N</symdef> in <sym>NODES</sym>, if any edge connected to <sym>N</sym>
is not in <sym>EDGES</sym>, then an exception condition is raised:
<raise class="G1" subclass="001"/>.
</item>

<comment>WG3:OHD-025</comment>
<comment>WG3:UTC-094</comment>
<comment>Editorial: Stefan Plantikow, 2023-02-24 Resolve GQL-305</comment>
<item>Let <symdef>CG1</symdef> be a copy of <sym>CG</sym> with all members of <sym>EDGES</sym> and 
all members of <sym>NODES</sym> deleted. 
If <sym>CG</sym> has a graph type <symdef>GT</symdef> and <sym>CG1</sym> is not of graph type 
<sym>GT</sym>, then an exception condition is raised: <raise class="G2"/>.

<comment>Editorial: Stephen Cannan 2023-01-29 Align with Directives Part 2</comment>
<note>This document does not currently specify a situation in which the above exception would be 
triggered.
However, it is included as it is expected that <impDef annex="no" code="None"/> extensions and/or 
future editions of this document will define such situations.
</note>

</item>

<comment>WG3:CMN-019 P00-USA-351</comment>
<item>All members of <sym>EDGES</sym> and all members of <sym>NODES</sym> are deleted from 
<sym>CG</sym>.

<note>The effect of this is that all graph elements referenced by the results of evaluating the 
<BNF name="delete statement"/>, for all records in the current working table, are deleted 
atomically. 
If any such graph element cannot be deleted, then no other graph element will be deleted.
</note>

</item>

<comment>Editorial: Stefan Plantikow, 2020-06-08 Changed to unit</comment>
<comment>WG3:W12-019</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item>The current execution outcome is set to a successful outcome with an omitted result.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:CMN-044</comment>
<item>Without <feature code="GD03"/>, conforming GQL language shall not contain
a <BNF name="delete item"/> that contains a <BNF name="procedure body"/>.
</item>

<comment>WG3:CMN-044</comment>
<item>Without <feature code="GD04"/>, conforming GQL language shall not contain
a <BNF name="delete item"/> that simply contains a <BNF name="value expression"/> that is not
a <BNF name="binding variable reference"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_call_data_proc" newpage="true">
<clauseHeading><BNF name="call data-modifying procedure statement"/></clauseHeading>

<bodyMatter>


<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:UTC-096R1</comment>
<para>Execute a data-modifying procedure.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="call data-modifying procedure statement">
<rhs>
<BNF name="call procedure statement"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>Editorial: Stefan Plantikow, 2020-10-12 Restrict to data-modifying procedures</comment>
<comment>WG3:W22-054</comment>
<item>Let <symdef>CDPS</symdef> be the <BNF name="call data-modifying procedure statement"/>,
let <symdef>CPS</symdef> be the <BNF name="call procedure statement"/> immediately contained
in <sym>CDPS</sym>, and let <symdef>PC</symdef> be the <BNF name="procedure call"/> immediately
contained in <sym>CPS</sym>.
</item>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>If <sym>PC</sym> is an <BNF name="inline procedure call"/> that immediately contains the
<BNF name="nested procedure specification"/> <symdef>PROC</symdef>, then <sym>PROC</sym> shall
immediately contain a <BNF name="data-modifying procedure specification"/>.
</item>

<item>If <sym>PC</sym> is a <BNF name="named procedure call"/> that immediately contains the
<BNF name="procedure reference"/> that identifies a procedure <symdef>PROC</symdef>, then 
<sym>PROC</sym> shall have the DATA PROCEDURE indication.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2020-05-11 Added GRs</comment>
<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>

</clause>


<clause id="gql_dql">
<clauseHeading>Query statements</clauseHeading>

<subClause id="gql_stm_comp_query_stm">
<clauseHeading><BNF name="composite query statement"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-05-03 Added composite query statement</comment>
<bodyMatter>

<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:BER-019</comment>
<comment>WG3:W23-009R1 P00-USA-337</comment>
<para>Set the current working table to the result of a <BNF name="composite query expression"/>.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="composite query statement">
<rhs>
<BNF name="composite query expression"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<comment>WG3:BER-019</comment>
<olist>

<item>Let <symdef>CQS</symdef> be the <BNF name="composite query statement"/> and 
let <symdef>CQE</symdef> be the <BNF name="composite query expression"/> immediately contained 
in <sym>CQS</sym>.
</item>
<comment>WG3:UTC-096R1 Deleted 2 SRs</comment>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The outgoing working record type of <sym>CQS</sym> is the incoming working record type
of <sym>CQS</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>The outgoing working table type of <sym>CQS</sym> is the declared type of <sym>CQE</sym>.
</item>
<endbar/>

<item>The declared type of <sym>CQS</sym> is the declared type of <sym>CQE</sym>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules> 
-->


<GeneralRules>

<olist>

<comment>WG3:BER-019 One rule deleted</comment>

<comment>Editorial: Stefan Plantikow, 2022-03-25 WG3:RKE-010 P00-NLD-219 Simplify application of GRs
</comment>
<comment>WG3:UTC-013 P00-USA-338</comment>
<comment>Email from: Hannes Voigt, 2023-03-03 1127 WG3:UTC-096R1</comment>
<item>Let <symdef>NEW_TABLE</symdef> be the result of <sym>CQE</sym>.
</item>

<comment>WG3:CMN-019 P00-USA-351</comment>
<item>The current working table is set to <sym>NEW_TABLE</sym>.
</item>

<comment>WG3:W15-017</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item>The current execution outcome is set to a successful outcome with <sym>NEW_TABLE</sym> as its
result.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_stm_comp_query_expr" newpage="true">
<clauseHeading><BNF name="composite query expression"/></clauseHeading>

<bodyMatter>

<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:UTC-096R1</comment>
<para>Specify binding table compositions.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:UTC-096R1</comment>
<BNFdef name="composite query expression">
<rhs>
<alt>
<BNF name="composite query expression"/> <BNF name="query conjunction"/>
<BNF name="composite query primary"/>
</alt>
<alt> <BNF name="composite query primary"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="query conjunction">
<rhs>
<alt> <BNF name="set operator"/> </alt>
<alt> <kw>OTHERWISE</kw> </alt>
</rhs>
</BNFdef>

<comment>WG3:W15-017</comment>
<BNFdef name="set operator">
<rhs>
<alt> <kw>UNION</kw> <opt> <BNF name="set quantifier"/> </opt> </alt>
<alt> <kw>EXCEPT</kw> <opt> <BNF name="set quantifier"/> </opt> </alt>
<alt> <kw>INTERSECT</kw> <opt> <BNF name="set quantifier"/> </opt> </alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-096R1</comment>
<BNFdef name="composite query primary">
<rhs>
<BNF name="linear query statement"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:W15-017</comment>
<item>If <BNF name="set operator"/> is specified and <BNF name="set quantifier"/> 
is not specified, then <kw>DISTINCT</kw> is implicit.
</item>

<item>Let <symdef>CQE</symdef> be the <BNF name="composite query expression"/>.
</item>

<comment>WG3:W15-017</comment>
<comment>WG3:RKE-044R1</comment>
<comment>WG3:W23-009R1 P00-USA-112 and P00-USA-340</comment>
<item>If a <BNF name="query conjunction"/> <symdef>QC</symdef> is immediately contained in 
<sym>CQE</sym>, then every <BNF name="query conjunction"/> directly contained in <sym>CQE</sym>
shall be <sym>QC</sym>.
</item>

<comment>WG3:RKE-044R1</comment>
<item>If <sym>CQE</sym> directly contains a <BNF name="focused linear query statement"/>, then
<sym>CQE</sym> shall not directly contain an <BNF name="ambient linear query statement"/>.

<comment>WG3:UTC-096R1</comment>
<note>As a consequence of this rule, focused statements and ambient statement are mutually exclusive
within a <BNF name="composite query expression"/>, so that the following is true as well:
If <sym>CQE</sym> directly contains an <BNF name="ambient linear query statement"/>, then
<sym>CQE</sym> does not directly contain a <BNF name="focused linear query statement"/>.
</note>
</item>
<comment>WG3:UTC-096R1 Deleted 1 (one) SR</comment>

<comment>WG3:RKE-015</comment>
<comment>WG3:UTC-101</comment>
<comment>WG3:UTC-064</comment>
<comment>WG3:UTC-096R1</comment>
<item>If <sym>CQE</sym> directly contains a <BNF name="primitive result statement"/> that is
<kw>FINISH</kw>, then <sym>CQE</sym> shall directly contain at most one
<BNF name="composite query primary"/>.
</item>

<comment>WG3:OHD-028</comment>
<comment>WG3:OHD-028</comment>
<comment>WG3:UTC-096R1</comment>
<item>Let <symdef>CQP</symdef> be the <BNF name="composite query primary"/> immediately contained
in <sym>CQE</sym>.
</item>

<comment>WG3:UTC-096R1</comment>
<item>Let <symdef>LQS</symdef> be the <BNF name="linear query statement"/> immediately contained
in <sym>CQP</sym>.
</item>

<comment>WG3:OHD-028</comment>
<comment>Email from: Hannes Voigt, 2023-03-03 1127 WG3:UTC-096R1</comment>
<comment>WG3:CMN-019 253. P00-USA-071</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>LQS</sym> is the incoming working record type
of <sym>CQE</sym>.
</item>

<comment>WG3:OHD-028</comment>
<comment>Email from: Hannes Voigt, 2023-03-03 1127 WG3:UTC-096R1</comment>
<comment>WG3:CMN-019 253. P00-USA-071</comment>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>LQS</sym> is the incoming working table type
of <sym>CQE</sym>.
</item>
<endbar/>

<comment>Email from: Hannes Voigt, 2023-03-03 1127 WG3:UTC-096R1 Deleted 1 (one) SR</comment>

<comment>WG3:OHD-028</comment>
<item>Case:

<olist>

<item>If <BNF name="query conjunction"/> is specified, then:

<olist>

<item>Let <symdef>ICQE</symdef> be the <BNF name="composite query expression"/> immediately 
contained in <sym>CQE</sym>.
</item>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>ICQE</sym> is the
incoming working record type of <sym>CQE</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>ICQE</sym> is incoming working table type
of <sym>CQE</sym>.
</item>

<comment>Email from: Hannes Voigt, 2023-03-03 1127 WG3:UTC-096R1</comment>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>FCQE</symdef> be the set of the columns of the the outgoing working table type
of <sym>ICQE</sym> and let <symdef>FLQE</symdef> be the set of the columns of the
outgoing working table type of <sym>CQP</sym>.
</item>
<endbar/>

<comment>WG3:UTC-086R1</comment>
<item><sym>FCQE</sym> and <sym>FLQE</sym> shall be column name-equal and column-combinable.
</item>

<comment>WG3:UTC-086R1</comment>
<item>Let <symdef>COLS</symdef> be the combined columns of <sym>FCQE</sym> and <sym>FLQE</sym>.
</item>
<comment>WG3:W26-024 Removed 2 Subrules</comment>

<comment>WG3:W26-024</comment>
<item>If <BNF name="set operator"/> is <kw>UNION</kw> <kw>DISTINCT</kw>,
<kw>EXCEPT</kw> <kw>ALL</kw>, <kw>EXCEPT</kw> <kw>DISTINCT</kw>, <kw>INTERSECT</kw> <kw>ALL</kw>, or
<kw>INTERSECT</kw> <kw>DISTINCT</kw>, then:

<olist>

<comment>WG3:W26-024</comment>
<item>There shall be no column <symdef>COL</symdef> in <sym>COLS</sym> such that all of 
the following is true:

<olist>

<comment>WG3:W26-024</comment>
<item>The value type of <sym>COL</sym> is a dynamic union type <symdef>DUT</symdef>.
</item>

<comment>WG3:W26-024</comment>
<item>There exists a pair of different component types <symdef>CT1</symdef> and <symdef>CT2</symdef>
of <sym>DUT</sym> such that <sym>CT1</sym> and <sym>CT2</sym> are not comparable value types.
</item>

</olist>

</item>

<comment>WG3:W26-024</comment>
<item>Each column in <sym>COLS</sym> is an operand of a grouping operation.
The Syntax Rules and Conformance Rules of <specref ref="gql_grouping_ops"/>, apply.
</item>

</olist>

</item>

<comment>WG3:UTC-050</comment>
<comment>WG3:UTC-096R1</comment>
<item>The declared type of <sym>CQE</sym> is the material binding
table whose set of columns is <sym>COLS</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-096R1</comment>
<item>Otherwise, the declared type of <sym>CQE</sym> is the declared type of
the outgoing working table of <sym>CQP</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-096R1 Deleted 2 SRs</comment>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:UTC-096R1</comment>
<item>The result of <sym>CQP</sym> is the result of <sym>LQS</sym>.
</item>

<item>Case:

<olist>

<item>If <BNF name="query conjunction"/> is specified, then:

<olist>

<comment>Editorial: Stefan Plantikow, 2022-10-07 Adjusted wording</comment>
<item>Let <symdef>ICQER</symdef> be the binding table that is the result of <sym>ICQE</sym>.
</item>

<comment>WG3:UTC-096R1</comment>
<item>Let <symdef>CQPR</symdef> be the binding table that is the result of <sym>CQP</sym>.
</item>

<comment>WG3:OHD-028</comment>
<comment>WG3:W26-024</comment>
<item>Let <symdef>FCQER</symdef> be a binding table determined as follows.

<para>Case:
</para>

<olist>

<item>If <kw>UNION</kw> <kw>DISTINCT</kw>, <kw>EXCEPT</kw> <kw>ALL</kw>,
<kw>EXCEPT</kw> <kw>DISTINCT</kw>, <kw>INTERSECT</kw> <kw>ALL</kw>, or
<kw>INTERSECT</kw> <kw>DISTINCT</kw> is specified, and there exists
a record <symdef>R1</symdef> of <sym>ICQER</sym> and
a record <symdef>R2</symdef> of <sym>CQPR</sym> such that <sym>R1</sym> and <sym>R2</sym> are
not comparable values, then an exception condition is raised: 
<raise class="22" subclass="G04"/>.
</item>

<comment>WG3:OHD-028</comment>
<comment>WG3:W26-024</comment>
<comment>WG3:W26-024 Consequence of reducing nesting</comment>
<item id="gql_qexp_GR_Rdup">If <BNF name="set operator"/> is specified, then
<sym>FCQER</sym> is new binding table whose columns are <sym>COLS</sym> and whose
records are determined by considering each record <symdef>R</symdef> that is
a duplicate of some record in <sym>ICQER</sym> or of some record in <sym>CQPR</sym> or both:

<olist>

<comment>WG3:UTC-096R1</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>Let <symdef>M</symdef> be 
the number of duplicates of <sym>R</sym> in <sym>ICQER</sym> and let <symdef>N</symdef> be 
the number of duplicates of <sym>R</sym> in <sym>CQPR</sym>, 
where <sym>M</sym> <geq/> 0 (zero) and <sym>N</sym> <geq/> 0 (zero).
</item>

<item>If <kw>DISTINCT</kw> is specified or implicit, then

<para>Case:
</para>

<olist>

<item>If <kw>UNION</kw> is  specified, then <sym>FCQER</sym> contains exactly one duplicate of 
<sym>R</sym>.

<note><sym>R</sym> exists as a result of <itemref type="GR" ref="gql_qexp_GR_Rdup"/>, 
guaranteeing that <sym>FCQER</sym> always contains a duplicate of <sym>R</sym>.
</note>

</item>

<item>If <kw>EXCEPT</kw> is specified, then

<para>Case:
</para>

<olist>

<comment>WG3:CMN-019 P00-USA-207</comment>
<item>If <sym>M</sym> &gt; 0 (zero) and <sym>N</sym> = 0 (zero), then <sym>FCQER</sym> contains 
exactly one duplicate of <sym>R</sym>.
</item>

<item>Otherwise, <sym>FCQER</sym> contains no duplicate of <sym>R</sym>.
</item>

</olist>

</item>

<item>If <kw>INTERSECT</kw> is specified, then

<para>Case:
</para>

<olist>

<comment>WG3:CMN-019 P00-USA-207</comment>
<item>If <sym>M</sym> &gt; 0 (zero) and <sym>N</sym> &gt; 0 (zero), then <sym>FCQER</sym> contains 
exactly one duplicate of <sym>R</sym>.
</item>

<item>Otherwise, <sym>FCQER</sym> contains no duplicates of <sym>R</sym>.
</item>

</olist>

</item>

</olist>

</item>

<item>If <kw>ALL</kw> is specified, then

<para>Case:
</para>

<olist>

<comment>WG3:CMN-019 P00-USA-207</comment>
<item>If <kw>UNION</kw> is specified, then the number of duplicates of <sym>R</sym>
that <sym>FCQER</sym> contains is (<sym>M</sym> + <sym>N</sym>).
</item>

<comment>WG3:CMN-019 P00-USA-207</comment>
<item>If <kw>EXCEPT</kw> is specified, then the number of duplicates of <sym>R</sym> 
that <sym>FCQER</sym> contains is the maximum of (<sym>M</sym> &minus; <sym>N</sym>) and 0 (zero).
</item>

<comment>WG3:CMN-019 P00-USA-207</comment>
<item>If <kw>INTERSECT</kw> is specified, then the number of duplicates of <sym>R</sym> 
that <sym>FCQER</sym> contains is the minimum of <sym>M</sym> and <sym>N</sym>.
</item>

</olist>

</item>

</olist>

</item>

<item>If <kw>OTHERWISE</kw> is specified, then

<para>Case:
</para>

<olist>

<item>If <sym>ICQER</sym> contains at least one record, then <symdef>FCQER</symdef> is
<sym>ICQER</sym>.
</item>

<comment>WG3:UTC-096R1</comment>
<item>Otherwise, <symdef>FCQER</symdef> is <sym>CQPR</sym>.
</item>

</olist>

</item>


</olist>
</item>

<comment>WG3:UTC-096R1</comment>
<item>The result of <sym>CQE</sym> is <sym>FCQER</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-096R1</comment>
<comment>Email from: Hannes Voigt, 2023-03-03 1127 WG3:UTC-096R1</comment>
<item>Otherwise, the result of <sym>CQE</sym> is the result of <sym>CQP</sym>.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-060</comment>
<item>Without <feature code="GQ02"/>, conforming GQL language shall not contain 
a <BNF name="composite query expression"/> that immediately contains 
a <BNF name="query conjunction"/> <kw>OTHERWISE</kw>.
</item>

<comment>WG3:UTC-060</comment>
<item>Without <feature code="GQ03"/>, conforming GQL language shall not contain 
a <BNF name="composite query expression"/> that immediately contains 
a <BNF name="query conjunction"/> <kw>UNION</kw>.
</item>

<comment>WG3:UTC-060</comment>
<item>Without <feature code="GQ04"/>, conforming GQL language shall not contain 
a <BNF name="composite query expression"/> that immediately contains 
a <BNF name="query conjunction"/> <kw>EXCEPT</kw>.
</item>

<comment>WG3:UTC-060</comment>
<item>Without <feature code="GQ05"/>, conforming GQL language shall not contain 
a <BNF name="composite query expression"/> that immediately contains 
a <BNF name="query conjunction"/> <kw>EXCEPT</kw> <kw>ALL</kw>.
</item>

<comment>WG3:UTC-060</comment>
<item>Without <feature code="GQ06"/>, conforming GQL language shall not contain 
a <BNF name="composite query expression"/> that immediately contains 
a <BNF name="query conjunction"/> <kw>INTERSECT</kw>.
</item>

<comment>WG3:UTC-060</comment>
<item>Without <feature code="GQ07"/>, conforming GQL language shall not contain 
a <BNF name="composite query expression"/> that immediately contains 
a <BNF name="query conjunction"/> <kw>INTERSECT</kw> <kw>ALL</kw>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>
<comment>WG3:UTC-096R1 Deleted 1 (one) Subclause</comment>


<comment>WG3:UTC-122</comment>
<subClause id="gql_stm_lin_query_stm" newpage="true">
<clauseHeading><BNF name="linear query statement"/> and 
<BNF name="simple query statement"/></clauseHeading>

<bodyMatter>

<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:BER-019</comment>
<para>Specify a linear composition of <BNF name="simple query statement"/>s that returns a result.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="linear query statement">
<rhs>
<alt> <BNF name="focused linear query statement"/> </alt>
<alt> <BNF name="ambient linear query statement"/> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-09-14 Only allow direct nesting with single FROM
</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-08 Factor out body</comment>
<comment>WG3:W15-017</comment>
<comment>WG3:W20-027R1</comment>
<BNFdef name="focused linear query statement">
<rhs>
<alt> 
<opt> <BNF name="focused linear query statement part"/><repeat/> </opt> 
<breakindent/>
<BNF name="focused linear query and primitive result statement part"/>
</alt>
<alt> <BNF name="focused primitive result statement"/> </alt>
<alt> <BNF name="focused nested query specification"/> </alt>
<alt> <BNF name="select statement"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W20-027R1</comment>
<BNFdef name="focused linear query statement part">
<rhs>
<BNF name="use graph clause"/> <BNF name="simple linear query statement"/> 
</rhs>
</BNFdef>

<comment>WG3:W20-027R1</comment>
<BNFdef name="focused linear query and primitive result statement part">
<rhs>
<BNF name="use graph clause"/> <BNF name="simple linear query statement"/> 
<BNF name="primitive result statement"/> 
</rhs>
</BNFdef>

<comment>WG3:W20-027R1</comment>
<BNFdef name="focused primitive result statement">
<rhs>
<BNF name="use graph clause"/> <BNF name="primitive result statement"/> 
</rhs>
</BNFdef>

<comment>WG3:W20-027R1</comment>
<BNFdef name="focused nested query specification">
<rhs>
<BNF name="use graph clause"/> <BNF name="nested query specification"/> 
</rhs>
</BNFdef>

<comment>WG3:W15-017</comment>
<BNFdef name="ambient linear query statement">
<rhs>
<alt> 
<opt> <BNF name="simple linear query statement"/> </opt> 
<BNF name="primitive result statement"/> 
</alt>
<alt> <BNF name="nested query specification"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="simple linear query statement">
<rhs>
<BNF name="simple query statement"/><repeat/>
</rhs>
</BNFdef>

<comment>WG3:UTC-122</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-03 Adjusted grammar</comment>
<comment>WG3:W22-055</comment>
<comment>WG3:W23-015</comment>
<BNFdef name="simple query statement">
<rhs>
<alt> <BNF name="primitive query statement"/> </alt>
<alt> <BNF name="call query statement"/> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-05-05 unnest -> unwind</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-12 Add filter statement</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-14 Add let statement</comment>
<comment>WG3:W22-055</comment>
<comment>WG3:W24-036R1</comment>
<BNFdef name="primitive query statement">
<rhs>
<alt> <BNF name="match statement"/> </alt>
<alt> <BNF name="let statement"/> </alt>
<alt> <BNF name="for statement"/> </alt>
<alt> <BNF name="filter statement"/> </alt>
<alt> <BNF name="order by and page statement"/> </alt>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<comment>WG3:BER-019</comment>
<olist>

<item>Let <symdef>LQS</symdef> be the <BNF name="linear query statement"/>.
</item>

<comment>WG3:W23-009R1 P00-USA-114</comment>
<comment>WG3:W23-009R1 P00-USA-344</comment>
<comment>WG3:CMN-019 P00-NLD-050</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>Let <symdef>STMSEQ</symdef> be the sequence of <BNF name="simple query statement"/>s, 
the <BNF name="primitive result statement"/>, the <BNF name="nested query specification"/>, 
and the <BNF name="select statement"/> directly contained in <sym>LQS</sym>.
Let <symdef>N</symdef> be the number of elements of <sym>STMSEQ</sym>.
For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>, 
let <symdef>STM</symdef><sub><sym>i</sym></sub> be the <sym>i</sym>-th element of <sym>STMSEQ</sym>.
</item>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>STM</sym><sub>1</sub> is 
the incoming working record type of <sym>LQS</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>STM</sym><sub>1</sub> is 
the incoming working table type of <sym>LQS</sym>.
</item>
<endbar/>

<comment>Editorial: Stefan Plantikow 2022-09-15 Correct to use right number phrase</comment>
<comment>WG3:W23-009R1 P00-USA-344</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>For 2 (two) <leq/> <symdef>i</symdef> <leq/> <sym>N</sym>:

<olist>

<comment>WG3:W23-009R1 P00-USA-344</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>STM</sym><sub><sym>i</sym></sub> 
is the outgoing working record type of <sym>STM</sym><sub><sym>i</sym>-1</sub>.
</item>

<comment>WG3:W23-009R1 P00-USA-344</comment>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>STM</sym><sub><sym>i</sym></sub> 
is the outgoing working table type of <sym>STM</sym><sub><sym>i</sym>-1</sub>.
</item>
<endbar/>

</olist>

</item>

<comment>WG3:W23-009R1 P00-USA-344</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>The declared type of <sym>LQS</sym> is the declared type of 
<sym>STM</sym><sub><sym>N</sym></sub>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2022-03-25 WG3:RKE-010 P00-NLD-219 Use default rule evaluation
order</comment>
<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-047</comment>
<item>Without <feature code="GQ01"/>, conforming GQL language shall not contain 
a <BNF name="focused linear query statement"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W22-055</comment>
<subClause id="gql_match" newpage="true">
<clauseHeading><BNF name="match statement"/></clauseHeading>

<bodyMatter>


<Function>

<comment>Editorial: Stefan Plantikow, 2020-04-23 Reworded</comment>
<para>Expand the current working table with matches from a graph pattern.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-02-07</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-27 yield clause moved</comment>
<comment>WG3:W22-053R2</comment>
<comment>WG3:W23-015</comment>
<comment>WG3:UTC-046</comment>
<BNFdef name="match statement">
<rhs>
<alt> <BNF name="simple match statement"/> </alt>
<alt> <BNF name="optional match statement"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-046</comment>
<BNFdef name="simple match statement">
<rhs>
<kw>MATCH</kw> <BNF name="graph pattern binding table"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-046</comment>
<BNFdef name="optional match statement">
<rhs>
<kw>OPTIONAL</kw> <BNF name="optional operand"/> 
</rhs>
</BNFdef>

<comment>WG3:UTC-046</comment>
<BNFdef name="optional operand">
<rhs>
<alt> <BNF name="simple match statement"/> </alt>
<alt> <BNF name="left brace"/> <BNF name="match statement block"/> <BNF name="right brace"/> </alt>
<alt> <BNF name="left paren"/> <BNF name="match statement block"/> <BNF name="right paren"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-046</comment>
<BNFdef name="match statement block">
<rhs>
<BNF name="match statement"/><repeat/>
</rhs>
</BNFdef>

</grammar>

</Format>


<comment>Editorial: Stephen Cannan, 2020-04-04</comment>
<SyntaxRules>

<comment>WG3:UTC-087R2 Deleted 1 (one) editor's note</comment>

<olist>

<item>Let <symdef>MS</symdef> be the <BNF name="match statement"/>.
</item>

<comment>Email from: Fred Zemke, 2023-03-01 1945 Moved 1 (one) SR</comment>
<comment>WG3:W23-015 One SR removed</comment>

<comment>WG3:UTC-087R2</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>IWRT</symdef> be the incoming working record type of <sym>MS</sym> and 
let <symdef>IWRTFNS</symdef> be the set of field type names of <sym>IWRT</sym>.
</item>

<comment>WG3:UTC-087R2</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>IWTTRT</symdef> be the record type of the incoming working table type
of <sym>MS</sym> and 
let <symdef>IWTTRTFNS</symdef> be the set of field type names of <sym>IWTTRT</sym>.
</item>
<endbar/>

<comment>Email from: Fred Zemke, 2023-03-01 1945 Moved 1 (one) SR in consequence</comment>

<comment>WG3:UTC-046</comment>
<item>If <sym>MS</sym> immediately contains <BNF name="optional match statement"/>, then:

<comment>WG3:W23-015</comment>
<olist>

<comment>WG3:W23-015</comment>
<comment>WG3:UTC-087R2</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>IFNS</symdef> be the union of <sym>IWRTFNS</sym> and <sym>IWTTRTFNS</sym>.
</item>
<endbar/>

<comment>WG3:W23-015</comment>
<comment>WG3:UTC-087R2</comment>
<comment>WG3:W26-037R3</comment>
<item>Let <symdef>IBVRL</symdef> be a comma-separated list of all incoming
<BNF name="binding variable reference"/>s corresponding to <BNF name="binding variable"/>s 
whose names are in <sym>IFNS</sym>.
</item>

<comment>WG3:UTC-046</comment>
<item>A <BNF name="graph pattern binding table"/> <symdef>T</symdef> supplies output bindings to
a <BNF name="match statement"/> <symdef>S</symdef> if at least one of the following is true:

<olist>

<comment>Email from: Fred Zemke, 2023-03-01 1945</comment>
<item><sym>S</sym> is a <BNF name="simple match statement"/> that immediately contains <sym>T</sym>.
</item>

<comment>Email from: Fred Zemke, 2023-03-01 1945</comment>
<item><sym>S</sym> is an <BNF name="optional match statement"/> whose <BNF name="optional operand"/>
is a <BNF name="simple match statement"/> that immediately contains <sym>T</sym>.
</item>

<item><sym>S</sym> is an <BNF name="optional match statement"/> whose <BNF name="optional operand"/>
immediately contains a <BNF name="match statement block"/> <symdef>B</symdef> and <sym>T</sym>
supplies output bindings to a <BNF name="match statement"/> immediately contained in <sym>B</sym>.
</item>

</olist>

<note>This is a recursive definition.
An <BNF name="exists predicate"/> contained in <sym>S</sym> provides an example of
a <BNF name="graph pattern binding table"/> that does not supply output bindings to <sym>S</sym>.
</note>

</item>

<comment>WG3:W23-015</comment>
<comment>WG3:UTC-087R2</comment>
<comment>WG3:W26-037R3</comment>
<item>Let <symdef>OBVRL</symdef> be a comma-separated list of
<BNF name="binding variable reference"/>s corresponding to <BNF name="binding variable"/>s whose
names are column names of the declared type of any <BNF name="graph pattern binding table"/> that
supplies output bindings to <sym>MS</sym> that are not included in <sym>IFNS</sym>.
</item>

<comment>WG3:UTC-046</comment>
<item>Let <symdef>RETURN</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>OBVRL</sym> is the empty list, then <sym>RETURN</sym> is:
<code>
<kw>RETURN</kw> <kw>NO</kw> <kw>BINDINGS</kw>
</code>
</item>

<comment>Editorial: Stefan Plantikow, 2023-11-12 non-empty</comment>
<item>Otherwise, <sym>OBVRL</sym> is non-empty and <sym>RETURN</sym> is:

<code>
<kw>RETURN</kw> <sym>OBVRL</sym>
</code>

</item>

</olist>

</item>
<comment>WG3:UTC-046 Deleted 1 (one) SR</comment>

<comment>WG3:UTC-046</comment>
<item>Let <symdef>OO</symdef> be the <BNF name="optional operand"/> simply contained in
<sym>MS</sym>.

<para>Case:
</para>

<olist>

<comment>WG3:UTC-046</comment>
<item>If <sym>OO</sym> immediately contains
a <BNF name="simple match statement"/> <symdef>SMS</symdef>, then <sym>MS</sym> is effectively 
replaced by:
<code>
<kw>OPTIONAL</kw> <kw>CALL</kw> (<sym>IBVRL</sym>) { 
  <sym>SMS</sym>
  <sym>RETURN</sym> 
}
</code>
</item>

<comment>WG3:UTC-046</comment>
<item>If <sym>OO</sym> immediately contains
a <BNF name="match statement block"/> <symdef>MSB</symdef>, then <sym>MS</sym> is effectively 
replaced by:
<code>
<kw>OPTIONAL</kw> <kw>CALL</kw> (<sym>IBVRL</sym>) { 
  <sym>MSB</sym>
  <sym>RETURN</sym> 
}
</code>

<comment>WG3:CMN-019 P00-ISO-023</comment>
<note>This transformation is applied recursively if <sym>MSB</sym> contains one or more nested
<BNF name="optional match statement"/>s.
<sym>IBVRL</sym> and <sym>OBVRL</sym> are computed separately for each transformation.
</note>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:UTC-046</comment>
<item>If <sym>MS</sym> is a <BNF name="simple match statement"/>, then:

<olist>

<comment>Email from: Fred Zemke, 2023-03-01 1945</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-18 Added GRs</comment>
<comment>WG3:W22-053R2</comment>
<comment>WG3:UTC-087R2 Required moving back here</comment>
<comment>WG3:UTC-0872R2</comment>
<item id="gql_match_SR_GPBT">Let <symdef>GPBT</symdef> be
the <BNF name="graph pattern binding table"/> simply contained in <sym>MS</sym>.
</item>

<comment>WG3:UTC-087R2</comment>
<comment>WG3:OHD-039</comment>
<comment>WG3:W24-029</comment>
<comment>Email from: Fred Zemke, 2023-03-01 1945</comment>
<item>Let <symdef>GPBTRT</symdef> be the record type of the declared type of <sym>GPBT</sym>.
</item>

<comment>WG3:OHD-039</comment>
<comment>WG3:UTC-087R2</comment>
<comment>WG3:UTC-087R2</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The outgoing working record type of <sym>MS</sym> is <sym>IWRT</sym> amended
with the record type that is <sym>GPBTRT</sym> restricted to the fields identified by
<sym>IWRTFNS</sym>.

<comment>Editorial: Stefan Plantikow, 2022-10-07 Made more precise</comment>
<comment>Editorial: Stephen Cannan 2023-01-29 Align with Directives Part 2</comment>
<comment>WG3:XRH-036</comment>
<note>It is possible that the declared type of a graph pattern variable changes by changing
the corresponding incoming working record type or the corresponding incoming working table type 
at certain sites. 
</note>

</item>

<comment>WG3:W22-053R2</comment>
<comment>WG3:OHD-039</comment>
<comment>WG3:UTC-087R2</comment>
<comment>WG3:XRH-036</comment>
<item>The outgoing working table type of <sym>MS</sym> is the binding table type
whose record type is <sym>IWTTRT</sym> amended with the record type that is <sym>GPBTRT</sym> 
without the fields identified by <sym>IWRTFNS</sym>.

<comment>Editorial: Stefan Plantikow, 2022-10-07 Made more precise</comment>
<comment>Editorial: Stephen Cannan 2023-01-29 Align with Directives Part 2</comment>
<comment>WG3:XRH-036</comment>
<note>It is possible that the declared type of a graph pattern variable changes by changing
the corresponding incoming working record type or the corresponding incoming working table type
at certain sites. 
</note>
<endbar/>

</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-072</comment>
<comment>WG3:W26-026R2</comment>
<item>The declared type of <sym>MS</sym> is the empty type.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:OHD-039</comment>
<comment>WG3:UTC-087R2</comment>
<comment>WG3:CMN-068</comment>
<item>Let <symdef>NEW_TABLE</symdef> be a copy of the result of <sym>GPBT</sym> without the columns
identified by <sym>IWRTFNS</sym>.

<note>After the application of all Syntax Rules, <sym>MS</sym> is
a <BNF name="simple match statement"/> and thus <sym>GPBT</sym> is available here as defined
by <itemref type="SR" ref="gql_match_SR_GPBT"/>.
</note>

</item>

<comment>WG3:W22-053R2</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item>The current working table is set to <sym>NEW_TABLE</sym>.
</item>

<comment>WG3:CMN-019 P00-USA-351</comment>
<item>The current execution outcome is set to a successful outcome with an omitted result.
</item>

</olist>

</GeneralRules>

<ConformanceRules>

<olist>

<comment>WG3:UTC-046</comment>
<comment>WG3:CMN-019 P00-USA-073</comment>
<item>Without <feature code="GQ21"/>, conforming GQL language shall not contain
an <BNF name="optional match statement"/> that contains a <BNF name="match statement block"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W22-055</comment>
<subClause id="gql_call_query" newpage="true">
<clauseHeading><BNF name="call query statement"/></clauseHeading>

<bodyMatter>

<comment>WG3:W23-013 One editor's note removed</comment>

<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:UTC-096R1</comment>
<para>Execute a query.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="call query statement">
<rhs>
<BNF name="call procedure statement"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<comment>Editorial: Stefan Plantikow, 2020-05-11 Informal Semantics removed</comment>
<SyntaxRules>

<olist>

<comment>WG3:W22-054</comment>
<item>Let <symdef>CQS</symdef> be the <BNF name="call query statement"/>,
let <symdef>CPS</symdef> be the <BNF name="call procedure statement"/> immediately contained
in <sym>CQS</sym>, and let <symdef>PC</symdef> be the <BNF name="procedure call"/> immediately
contained in <sym>CPS</sym>.
</item>

<comment>WG3:UTC-096R1</comment>
<item>If <sym>PC</sym> is an <BNF name="inline procedure call"/> that immediately contains the
<BNF name="nested procedure specification"/> <symdef>PROC</symdef>, then <sym>PROC</sym> shall
immediately contain a <BNF name="query specification"/>.
</item>

<item>If <sym>PC</sym> is a <BNF name="named procedure call"/> that immediately contains the
<BNF name="procedure reference"/> that identifies a procedure <symdef>PROC</symdef>, then 
<sym>PROC</sym> shall have the QUERY PROCEDURE indication.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2020-05-11 Added GRs</comment>
<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>
<comment>WG3:W23-015 Two Subclauses removed</comment>


<comment>WG3:W22-055</comment>
<subClause id="gql_filter" newpage="true">
<clauseHeading><BNF name="filter statement"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-05-12 Add filter statement</comment>
<bodyMatter>
<comment>WG3:W14-013</comment>

<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<para>Select a subset of the records of the current working table.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-05-17 Removed statement mode</comment>
<BNFdef name="filter statement">
<rhs>
<kw>FILTER</kw> 
<group>
<alt br="no"> <BNF name="where clause"/> </alt>
<alt br="no"> <BNF name="search condition"/> </alt>
</group>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<item>Let <symdef>FS</symdef> be the <BNF name="filter statement"/>.
</item>

<comment>Editorial: Stefan Plantikow, 2020-10-06 Fix: Replaced FS with FILTER</comment>
<item>If <sym>FS</sym> immediately contains the <BNF name="search condition"/> <symdef>SC</symdef>,
then it is effectively replaced by the <BNF name="filter statement"/>:
<code>
<kw>FILTER</kw> <kw>WHERE</kw> <sym>SC</sym>
</code>
</item>

<comment>WG3:BER-019</comment>
<item>Let <symdef>WC</symdef> be the <BNF name="where clause"/> immediately contained 
in <sym>FS</sym>.
</item>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>IWRT</symdef> be the incoming working record type of
<sym>FS</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>Let <symdef>IWTT</symdef> be the incoming working table type of
<sym>FS</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>WC</sym> is <sym>IWRT</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>WC</sym> is <sym>IWTT</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>The outgoing working record type of <sym>FS</sym> is <sym>IWRT</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>The outgoing working table type of <sym>FS</sym> is <sym>IWTT</sym>.
</item>
<endbar/>

<comment>WG3:UTC-096R1</comment>
<comment>WG3:W26-026R2</comment>
<item>The declared type of <sym>FS</sym> is the empty type.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>Editorial: Stefan Plantikow, 2022-03-25 WG3:RKE-010 P00-NLD-219 Simplify application of GRs
</comment>
<comment>WG3:BER-019 One rule deleted</comment>

<comment>WG3:CMN-019 P00-USA-351</comment>
<item>The current working table is set to the result of <sym>WC</sym>.
</item>

<comment>WG3:UTC-096R1</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item>The current execution outcome is set to a successful outcome with an omitted result.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-060</comment>
<item>Without <feature code="GQ08"/>, conforming GQL language shall not contain 
a <BNF name="filter statement"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W22-055</comment>
<subClause id="gql_let" newpage="true">
<clauseHeading><BNF name="let statement"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-05-12 Add let statement</comment>
<bodyMatter>

<Function>

<para>Add columns to the current working table.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-09-26 Reworked grammar</comment>
<comment>WG3:W22-030</comment>
<BNFdef name="let statement">
<rhs>
<kw>LET</kw> <BNF name="let variable definition list"/>
</rhs>
</BNFdef>

<comment>WG3:RKE-037</comment>
<comment>WG3:W22-030</comment>
<BNFdef name="let variable definition list">
<rhs>
<BNF name="let variable definition"/>
<opt>
<group> <BNF name="comma"/> <BNF name="let variable definition"/> </group><repeat/>
</opt>
</rhs>
</BNFdef>

<comment>WG3:W22-030</comment>
<comment>WG3:W27-011</comment>
<bar note="WG3:XRH-040"/>
<comment>WG3:XRH-040</comment>
<BNFdef name="let variable definition">
<rhs>
<alt> <BNF name="value variable definition"/> </alt>
<alt>
<BNF name="binding variable"/> 
<opt> <BNF name="typed"/> <opt> <BNF name="value type"/> </opt> </opt> 
<BNF name="equals operator"/> <BNF name="value expression"/> 
</alt>
</rhs>
</BNFdef>
<endbar/>

</grammar>

</Format>


<SyntaxRules>

<comment>Editorial: Stefan Plantikow, 2020-09-26 Completely define by SRs</comment>
<olist>

<comment>WG3:W22-030</comment>
<comment>WG3:UTC-087R2</comment>
<item>Let <symdef>LS</symdef> be the <BNF name="let statement"/>.
</item>

<item>Let <symdef>LVDL</symdef> be the <BNF name="let variable definition list"/> immediately 
contained in <sym>LS</sym>.
</item>

<comment>WG3:W22-030</comment>
<comment>WG3:W27-011</comment>
<item>For every <BNF name="let variable definition"/> <symdef>LVD</symdef> immediately contained 
in <sym>LVDL</sym> and that immediately contains a <BNF name="binding variable"/>, 
<sym>LVD</sym> is effectively replaced by:

<code>
<kw>VALUE</kw> <sym>LVD</sym>
</code>
</item>

<comment>WG3:UTC-087R2</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>IWRT</symdef> be the incoming working record type of <sym>LS</sym> and 
let <symdef>IWRTFNS</symdef> be the set of field type names of <sym>IWRT</sym>.
</item>

<comment>WG3:UTC-087R2</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>IWTTRT</symdef> be the record type of the incoming working table type
of <sym>LS</sym> and let <symdef>IWTTRTFNS</symdef> be the set of field type names of 
<sym>IWTTRT</sym>.
</item>

<comment>WG3:UTC-087R2</comment>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>IFNS</symdef> be the union of <sym>IWRTFNS</sym> and <sym>IWTTRTFNS</sym>.
</item>
<endbar/>

<comment>WG3:W27-012</comment>
<item id="gql_let_btrns">The name of every <BNF name="binding variable reference"/> contained in 
<sym>LS</sym> shall be in <sym>IFNS</sym>.
</item>

<comment>WG3:W24-029</comment>
<comment>WG3:UTC-087R2</comment>
<comment>WG3:W26-037R3</comment>
<item>Let <symdef>IBVRL</symdef> be a comma-separated list of all incoming
<BNF name="binding variable reference"/>s corresponding to <BNF name="binding variable"/>s 
whose names are in <sym>IFNS</sym>.
</item>

<comment>WG3:W22-030</comment>
<comment>Editorial: Stefan Plantikow, 2023-03-09 Consistent wording</comment>
<comment>WG3:W27-012</comment>
<item>Let the <BNF name="binding variable definition block"/> <symdef>BVDBLK</symdef> be the 
space-separated concatenation of all <BNF name="let variable definition"/>s immediately contained 
in <sym>LVDL</sym> in the order of their occurrence in <sym>LVDL</sym>.
</item>

<comment>WG3:W22-030</comment>
<comment>WG3:W27-011</comment>
<bar note="WG3:XRH-020"/>
<comment>WG3:XRH-020</comment>
<item>Let the <BNF name="return item list"/> <symdef>RIL</symdef> be the comma-separated list of 
all <BNF name="binding variable"/>s that are immediately contained in 
a <BNF name="let variable definition"/> immediately contained in <sym>LVDL</sym>.
</item>
<endbar/>

<comment>WG3:W22-030</comment>
<item id="gql_let_SR_syntax_trans"><sym>LS</sym> is effectively replaced by:

<comment>WG3:W24-029</comment>
<code>
<kw>CALL</kw> (<sym>IBVRL</sym>) {
  <sym>BVDBLK</sym>
  <kw>RETURN</kw> <sym>RIL</sym>
}
</code>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>Editorial: Stefan Plantikow, 2020-09-26 All GRs replaced by SRs</comment>
<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-060</comment>
<item>Without <feature code="GQ09"/>, conforming GQL language shall not contain 
a <BNF name="let statement"/>.
</item>

<bar note="WG3:XRH-020"/>
<comment>WG3:XRH-020</comment>
<item>Without <feature code="GP05"/>, in conforming GQL language, a <BNF name="let statement"/> 
shall not contain a <BNF name="value variable definition"/>.
</item>
<endbar/>

<bar note="WG3:XRH-040"/>
<comment>WG3:XRH-040</comment>
<item>Without <feature code="GP05"/>, in conforming GQL language, 
a <BNF name="let variable definition"/> shall not immediately contain a <BNF name="value type"/>.
</item>
<endbar/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W22-055</comment>
<subClause id="gql_for" newpage="true">
<clauseHeading><BNF name="for statement"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-05-17 Choose neutral keyword</comment>
<bodyMatter>
<comment>WG3:W23-013 One editor's note removed</comment>

<Function>

<comment>Editorial: Stefan Plantikow, 2020-05-05 unnest -> for</comment>
<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:UTC-088</comment>
<comment>WG3:CMN-068</comment>
<para>Unnest a list or a binding table by expanding the current working table.
</para>

<comment>WG3:W23-013 One editor's note removed</comment>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-05-05 unnest -> for</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-10 Rework grammar</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-06 Added search predicate</comment>
<comment>WG3:W23-015</comment>
<comment>WG3:UTC-088</comment>
<BNFdef name="for statement">
<rhs>
<kw>FOR</kw> <BNF name="for item"/>
<opt> <BNF name="for ordinality or offset"/> </opt>
</rhs>
</BNFdef>
<comment>WG3:UTC-088 Deleted 1 (one) production</comment>

<comment>Editorial: Stefan Plantikow, 2020-02-07</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-18 Changed order to accommodate use of FOR</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-07 Changed to use collection values</comment>
<comment>Consequence of WG3:BER-094R1</comment>
<comment>WG3:CMN-068</comment>
<BNFdef name="for item">
<rhs>
<BNF name="for item alias" /> <BNF name="for item source" /> 
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-05-18 Changed order to accommodate use of FOR</comment>
<comment>WG3:W27-011</comment>
<BNFdef name="for item alias">
<rhs>
<BNF name="binding variable"/> <kw>IN</kw>
</rhs>
</BNFdef>

<comment>WG3:CMN-068</comment>
<BNFdef name="for item source">
<rhs>
<alt> <BNF name="list value expression"/> </alt>
<alt> <BNF name="binding table reference value expression"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-088</comment>
<comment>WG3:W27-011</comment>
<BNFdef name="for ordinality or offset">
<rhs>
<kw>WITH</kw> 
<group>
<alt br="no"> <kw>ORDINALITY</kw> </alt>
<alt br="no"> <kw>OFFSET</kw> </alt>
</group>
<BNF name="binding variable"/>
</rhs>
</BNFdef>
<comment>WG3:UTC-088 Deleted 1 (one) editor's note</comment>

</grammar>

</Format>


<comment>Editorial: Stefan Plantikow, 2020-05-10 Informal Semantics removed</comment>
<SyntaxRules>
<comment>WG3:UTC-088 Deleted 1 (one) editor's note</comment>

<olist>

<comment>Editorial: Stefan Plantikow, 2020-05-05 unnest -> for</comment>
<item>Let <symdef>FS</symdef> be the <BNF name="for statement"/>.
</item>
<comment>WG3:UTC-088 Deleted 1 (one) SR</comment>

<comment>WG3:UTC-088</comment>
<item>Let <symdef>FI</symdef> be the <BNF name="for item"/> immediately contained in <sym>FS</sym>.
</item>

<item>Let <symdef>FIA</symdef> be the <BNF name="for item alias"/> immediately contained in
<sym>FI</sym>.
</item>

<comment>WG3:W27-011</comment>
<item>Let <symdef>ANAME</symdef> be the name of the <BNF name="binding variable"/>
immediately contained in <sym>FIA</sym>. 
</item>

<comment>WG3:CMN-068</comment>
<item>Let <symdef>FIS</symdef> be the <BNF name="for item source"/> immediately contained in
<sym>FI</sym>.
</item>

<comment>WG3:W11-013</comment>
<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10 Standardize terms</comment>
<comment>Editorial: Stephen Cannan, 2022-05-04 Use standard phrasing</comment>
<item>If <BNF name="for ordinality or offset"/> is specified, then let <symdef>FOO</symdef> be
the <BNF name="for ordinality or offset"/>; 
otherwise, let <symdef>FOO</symdef> be the zero-length character string.
</item>
<comment>WG3:W23-015 One SR removed</comment>
<comment>WG3:W23-015 One SR removed</comment>
<comment>WG3:UTC-088 Deleted 2 SRs</comment>

<comment>WG3:UTC-088</comment>
<comment>WG3:CMN-068</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>FIS</sym> is the incoming working record type
of <sym>FS</sym> amended with the record type of the incoming working table type of <sym>FS</sym>.
</item>

<comment>WG3:CMN-068</comment>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>FIS</sym> is
the material unit binding table type.
</item>

<comment>WG3:XRH-036</comment>
<item>The outgoing working record type of <sym>FS</sym> is the incoming working record type
of <sym>FS</sym>.
</item>
<endbar/>

<item>Let the character string <symdef>PNAME</symdef> and the closed record type
<symdef>NEW_FIELDS_RT</symdef> be defined as follows.

<olist>

<comment>WG3:CMN-068</comment>
<item>Let <symdef>SDT</symdef> be defined as follows.
If <sym>FIS</sym> immediately contains a <BNF name="list value expression"/> <symdef>LVE</symdef>, 
then <sym>SDT</sym> is the list element type of the declared type of <sym>LVE</sym>;
otherwise, <sym>FIS</sym> immediately contains 
<BNF name="binding table reference value expression"/> <symdef>BTRVE</symdef> and <sym>SDT</sym> 
is the record type of the declared type of <sym>BTRVE</sym>.
</item>

<comment>WG3:CMN-068</comment>
<item>Let <symdef>EFT</symdef> be the field type whose name is <sym>ANAME</sym> and
whose value type is <sym>SDT</sym>.
</item>

<item>Case:

<olist>

<item>If <sym>FOO</sym> is not the zero-length character string, then:

<olist>

<comment>WG3:W27-011</comment>
<item><symdef>PNAME</symdef> is the name of the <BNF name="binding variable"/>
immediately contained in <sym>FOO</sym>. 
</item>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item><sym>PNAME</sym> shall not be equal to the name of <sym>EFT</sym>.
</item>

<item>Let the value type <symdef>PVT</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:CMN-068</comment>
<item>If <sym>FOO</sym> immediately contains <kw>WITH</kw> <kw>ORDINALITY</kw>, then <sym>PVT</sym>
is the <impDef code="ID057"/> exact numeric type with scale 0 (zero) of list element ordinal 
positions.
</item>

<comment>WG3:CMN-068</comment>
<item>Otherwise, <sym>FOO</sym> immediately contains <kw>WITH</kw> <kw>OFFSET</kw> and 
<sym>PVT</sym> is the <impDef code="ID058"/> exact numeric type with scale 0 (zero) of list 
element position offsets.
</item>

</olist>

</item>

<item>Let <symdef>PFT</symdef> be the field type whose name is <sym>PNAME</sym> and whose value type
is <sym>PVT</sym>. 
</item>

<item>The field types of <sym>NEW_FIELDS_RT</sym> comprise <sym>EFT</sym> and <sym>PFT</sym>.
</item>

</olist>

</item>

<item>Otherwise, <sym>PNAME</sym> is the zero-length character string and
the field types of <sym>NEW_FIELDS_RT</sym> comprise <sym>EFT</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:CMN-068</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>SDT</sym> and
<sym>NEW_FIELDS_RT</sym> shall be field name-disjoint.
</item>

<comment>Email from: Nathalie Charbel, 2023-03-01 1050</comment>
<comment>WG3:XRH-036</comment>
<item>The outgoing working table type of <sym>FS</sym> is the binding table type
whose record type is the record type of the incoming working table type
of <sym>FS</sym> amended with <sym>NEW_FIELDS_RT</sym>.
</item>
<endbar/>

<comment>WG3:W26-026R2</comment>
<item>The declared type of <sym>FS</sym> is the empty type.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2020-05-10 Added GRs</comment>
<olist>

<comment>WG3:W25-023</comment>
<item>Let <symdef>NEW_TABLE</symdef> be a new binding table whose type is the declared type of
the outgoing working table of <sym>FS</sym>.
</item>
<comment>WG3:UTC-088 Deleted 1 (one) GR</comment>

<comment>WG3:UTC-088</comment>
<comment>WG3:W25-023</comment>
<comment>WG3:CMN-057R1</comment>
<item>For each record <symdef>R</symdef> of the current working table in a new child execution 
context amended with <sym>R</sym> whose working table is the new empty binding table whose columns 
are the field types of <sym>NEW_FIELDS_RT</sym>:

<olist>

<comment>Editorial: Stefan Plantikow, 2020-10-07 Adjusted</comment>
<comment>Editorial: Stephen Cannan, 2022-03-06 WG3:RKE-010 P00-USA-481</comment>
<comment>Editorial: Stefan Plantikow, 2022-03-25 Simplify</comment>
<comment>WG3:UTC-088</comment>
<comment>WG3:CMN-068</comment>
<item>Let <symdef>FISR</symdef> be the result of <sym>FIS</sym>.
</item>

<comment>Editorial: Stephen Cannan, 2022-03-06 WG3:RKE-010 P00-USA-481</comment>
<comment>WG3:UTC-088</comment>
<comment>WG3:CMN-068</comment>
<item>Let the sequence of values <symdef>VALS</symdef> and the non-negative integer
<symdef>NVALS</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<comment>Editorial: Stefan Plantikow, 2020-10-07 Adjusted</comment>
<comment>WG3:W23-009R1 P00-GBR-015</comment>
<comment>WG3:UTC-088</comment>
<comment>WG3:CMN-068</comment>
<item>If <sym>FISR</sym> is a list value <symdef>LV</symdef>, then <sym>VALS</sym> is <sym>LV</sym>
and <sym>NVALS</sym> is the cardinality of <sym>LV</sym>.
</item>

<comment>WG3:CMN-068</comment>
<item>If <sym>FISR</sym> is a binding table reference value whose referent is <symdef>BT</symdef>,
then <sym>VALS</sym> comprises the records of <sym>BT</sym> in the order determined by 
<sym>BT</sym> and <sym>NVALS</sym> is the cardinality of <sym>BT</sym>.

<note>See <specref ref="gql_conc_btt"/>.
</note>

</item>

<comment>WG3:W24-026R2</comment>
<comment>WG3:UTC-088</comment>
<comment>WG3:CMN-068</comment>
<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<item>Otherwise, <sym>FISR</sym> is the null value, <sym>VALS</sym> is the empty list values, and
<sym>NVALS</sym> is 0 (zero).
</item>

</olist>

</item>

<comment>WG3:UTC-088</comment>
<comment>WG3:CMN-019 P00-NLD-050</comment>
<comment>WG3:CMN-068</comment>
<item>For <symdef>j</symdef>, 1 (one) <leq/> <sym>j</sym> <leq/> <sym>NVALS</sym>:

<olist>

<comment>Editorial: Stefan Plantikow, 2020-10-07 Reworded</comment>
<comment>WG3:UTC-088</comment>
<comment>WG3:CMN-068</comment>
<item>Let <symdef>VR</symdef><sub><sym>j</sym></sub> be the record comprising a single field
whose name is <sym>ANAME</sym> and whose value is the <sym>j</sym>-th element of <sym>VALS</sym>.
</item>

<comment>WG3:W23-015</comment>
<comment>WG3:CMN-068</comment>
<item>Let <symdef>VRO</symdef><sub><sym>j</sym></sub> be defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:UTC-088</comment>
<item>If the <BNF name="for ordinality or offset"/> is specified, then:

<olist>

<comment>WG3:W23-015</comment>
<comment>WG3:UTC-088</comment>
<comment>WG3:W25-023</comment>
<comment>WG3:CMN-068</comment>
<item>If <sym>FOO</sym> immediately contains <kw>WITH</kw> <kw>ORDINALITY</kw>, then
<symdef>VRO</symdef><sub><sym>j</sym></sub> is the record obtained by adding a field to 
<sym>VR</sym><sub><sym>j</sym></sub> whose name is <sym>PNAME</sym> and whose value is 
<sym>j</sym>.
</item>

<comment>WG3:W23-015</comment>
<comment>WG3:UTC-088</comment>
<comment>WG3:W25-023</comment>
<comment>WG3:CMN-068</comment>
<item>If <sym>FOO</sym> immediately contains <kw>WITH</kw> <kw>OFFSET</kw>, then
<symdef>VRO</symdef><sub><sym>j</sym></sub> is the record obtained by adding a field to 
<sym>VR</sym><sub><sym>j</sym></sub> whose name is <sym>PNAME</sym> and whose value is 
<sym>j</sym>&minus;1.
</item>

</olist>

</item>

<comment>WG3:CMN-068</comment>
<item>Otherwise, <symdef>VRO</symdef><sub><sym>j</sym></sub> is 
<sym>VR</sym><sub><sym>j</sym></sub>.
</item>

</olist>

</item>

<comment>WG3:CMN-068</comment>
<item><sym>VRO</sym><sub><sym>j</sym></sub> is appended to the current working table.
</item>

</olist>

</item>

<comment>WG3:CMN-068</comment>
<item>The Cartesian product of <sym>R</sym> and the current working table is appended to
<sym>NEW_TABLE</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-351</comment>
<item>The current working table is set to <sym>NEW_TABLE</sym>.
</item>

<comment>WG3:UTC-088</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item>The current execution outcome is set to a successful outcome with an omitted result.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-088</comment>
<comment>WG3:CMN-068</comment>
<item>Without <feature code="GQ10"/>, conforming GQL language shall not contain
a <BNF name="for statement"/> that simply contains a <BNF name="list value expression"/>.
</item>

<comment>WG3:CMN-068</comment>
<item>Without <feature code="GQ23"/>, conforming GQL language shall not contain
a <BNF name="for statement"/> that simply contains 
a <BNF name="binding table reference value expression"/>.
</item>

<comment>WG3:CMN-049</comment>
<item>Without <feature code="GQ11"/>, conforming GQL language shall not contain
a <BNF name="for statement"/> that simply contains a <BNF name="for ordinality or offset"/>
that is <kw>WITH</kw> <kw>ORDINALITY</kw>. 
</item>

<comment>WG3:CMN-049</comment>
<item>Without <feature code="GQ24"/>, conforming GQL language shall not contain
a <BNF name="for statement"/> that simply contains a <BNF name="for ordinality or offset"/>
that is <kw>WITH</kw> <kw>OFFSET</kw>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>Editorial: Stefan Plantikow, 2020-02-07</comment>
<subClause id="gql_order_by_and_page" newpage="true">
<clauseHeading><BNF name="order by and page statement"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-05-15 order by and page statement added</comment>
<bodyMatter>

<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:W15-020</comment>
<comment>WG3:W23-009R1 P00-USA-356</comment>
<para>Specify, for the current working table, either: the ordering of the records, the number of 
records to be discarded from the beginning of the table, or the maximum number of records to be 
retained; or any combination of these.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:W15-020</comment>
<BNFdef name="order by and page statement">
<rhs>
<alt> 
<BNF name="order by clause"/> 
<opt> <BNF name="offset clause"/> </opt> 
<opt> <BNF name="limit clause"/> </opt> 
</alt> 
<alt> <BNF name="offset clause"/> <opt> <BNF name="limit clause"/> </opt> </alt> 
<alt> <BNF name="limit clause"/> </alt> 
</rhs>
</BNFdef>

<comment>WG3:W15-020</comment>
<comment>WG3:GYD-031</comment>
<ednote id="gql_PP163">Additional support for PARTITION BY, WITH TIES, WITH [ GROUP ] OFFSET, and 
WITH [ GROUP ] ORDINALITY should be considered.
See <PPref ref="PPgql163"/>.
</ednote>

</grammar>

</Format>


<SyntaxRules>

<comment>WG3:BER-019</comment>
<olist>

<item>Let <symdef>OPS</symdef> be the <BNF name="order by and page statement"/>.
</item>
<comment>WG3:UTC-022 Deleted 1 (one) SR</comment>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>IWRT</symdef> be the incoming working record type of <sym>OPS</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>Let <symdef>IWTT</symdef> be the incoming working table type of <sym>OPS</sym>.
</item>
<comment>WG3:UTC-022 Deleted 3 SRs</comment>

<comment>WG3:UTC-022</comment>
<comment>WG3:CMN-035</comment>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of any <BNF name="order by clause"/>,
<BNF name="offset clause"/>, and <BNF name="limit clause"/> immediately contained in <sym>OPS</sym>
is <sym>IWRT</sym>.
</item>

<comment>WG3:UTC-022</comment>
<comment>WG3:CMN-035</comment>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of any <BNF name="order by clause"/>,
<BNF name="offset clause"/>, and <BNF name="limit clause"/> immediately contained in <sym>OPS</sym>
is <sym>IWTT</sym>.
</item>
<endbar/>
<comment>WG3:CMN-019 P00-USA-075 Two SRs removed</comment>

<comment>WG3:W26-026R2</comment>
<item>The declared type of <sym>OPS</sym> is the empty type.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:BER-019 One rule deleted</comment>

<comment>WG3:W15-020</comment>
<item>Let <symdef>TABLE</symdef> be the current working table.
</item>

<comment>WG3:W15-020</comment>
<comment>WG3:W23-009R1 P00-USA-359</comment>
<item>Let <symdef>ORDERED</symdef> be the binding table defined as follows.

<para>Case:
</para>

<olist>

<comment>Editorial: WG3:RKE-010 P00-NLD-219 Simplify application of GRs</comment>
<comment>WG3:UTC-009 P00-USA-169</comment>
<item>If <sym>OPS</sym> immediately contains the <BNF name="order by clause"/> 
<symdef>OBC</symdef>, then let <symdef>ORDERED</symdef> be the result of <sym>OBC</sym>.
</item>

<item>Otherwise, let <symdef>ORDERED</symdef> be <sym>TABLE</sym>.
</item>

</olist>

</item>

<comment>WG3:W15-020</comment>
<item>Let <symdef>OFFSETED</symdef> be the binding table defined as follows.

<para>Case:
</para>

<olist>

<comment>Editorial: WG3:RKE-010 P00-NLD-219 Simplify application of GRs</comment>
<comment>WG3:UTC-009 P00-USA-169</comment>
<item>If <sym>OPS</sym> immediately contains the <BNF name="offset clause"/> <symdef>OC</symdef>, 
then let <symdef>OFFSETED</symdef> be the result of <sym>OC</sym>.
</item>

<item>Otherwise, let <symdef>OFFSETED</symdef> be <sym>ORDERED</sym>.
</item>

</olist>

</item>

<comment>WG3:W15-020</comment>
<item>Let <symdef>LIMITED</symdef> be the binding table defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:BER-019</comment>
<item>If <sym>OPS</sym> immediately contains the <BNF name="limit clause"/> <symdef>LC</symdef>, 
then let <symdef>LIMITED</symdef> be the result of <sym>LC</sym>.

</item>

<item>Otherwise, let <symdef>LIMITED</symdef> be <sym>OFFSETED</sym>.
</item>

</olist>

</item>

<comment>WG3:W15-020</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item>The current working table is set to <sym>LIMITED</sym>.
</item>

<comment>WG3:CMN-019 P00-USA-351</comment>
<item>The current execution outcome is set to a successful outcome with an omitted result.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-022</comment>
<comment>WG3:CMN-019 P00-USA-077</comment>
<item>Without <feature code="GQ12"/>, in conforming GQL language, 
an <BNF name="order by and page statement"/> shall not contain an <BNF name="offset clause"/>.
</item>

<comment>WG3:UTC-022</comment>
<comment>WG3:CMN-019 P00-USA-077</comment>
<item>Without <feature code="GQ13"/>, in conforming GQL language,
an <BNF name="order by and page statement"/> shall not contain a <BNF name="limit clause"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W22-055</comment>
<subClause id="gql_stm_result" newpage="true">
<clauseHeading><BNF name="primitive result statement"/></clauseHeading>

<bodyMatter>
<comment>WG3:W23-013 One editor's note removed</comment>

<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:BER-019</comment>
<para>Define what to include in a query result.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-04-25 Moved here for simplicity</comment>
<comment>WG3:W15-020</comment>
<comment>WG3:UTC-101</comment>
<comment>WG3:UTC-064</comment>
<BNFdef name="primitive result statement">
<rhs>
<alt> <BNF name="return statement"/> <opt> <BNF name="order by and page statement"/> </opt> </alt>
<alt> <kw>FINISH</kw> </alt>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<comment>WG3:BER-019</comment>
<olist>

<item>Let <symdef>PRS</symdef> be the <BNF name="primitive result statement"/>.
</item>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>IWRT</symdef> be the incoming working record type of <sym>PRS</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>Let <symdef>IWTT</symdef> be the incoming working table type of <sym>PRS</sym>.
</item>
<endbar/>

<comment>WG3:UTC-009 P00-USA-169</comment>
<item>If the <BNF name="return statement"/> <symdef>RS</symdef> is specified, then:

<olist>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>RS</sym> is <sym>IWRT</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>RS</sym> is <sym>IWTT</sym>.
</item>
<endbar/>

<item>Case:

<olist>

<item>If the <BNF name="order by and page statement"/> <symdef>OPS</symdef> is specified, then:

<olist>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>OPS</sym> is <sym>IWRT</sym>.
</item>
<endbar/>
<comment>WG3:UTC-022 Deleted 2 SRs</comment>

<comment>WG3:UTC-022</comment>
<item>Case:

<olist>

<item>If <sym>OPS</sym> immediately contains an <BNF name="order by clause"/> <symdef>OBC</symdef>,
then:

<olist>

<item>No <BNF name="sort key"/> shall contain a <BNF name="nested query specification"/>.
</item>

<item>Let <symdef>RETURN_IDENTIFIERS</symdef> be the set of all <BNF name="identifier"/>s
immediately contained in an explicit or implicit <BNF name="return item alias"/> contained in
<sym>RS</sym>.
</item>

<item>Let <symdef>ORDER_REFS</symdef> be the set of <BNF name="binding variable reference"/>s
defined as follows:

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>If <sym>RS</sym> does not contain a <BNF name="group by clause"/>,
a <BNF name="set quantifier"/> <kw>DISTINCT</kw>, or any <BNF name="return item"/> containing
an <BNF name="aggregate function"/>, then <sym>ORDER_REFS</sym> is the union of
<sym>RETURN_IDENTIFIERS</sym> and the set of <BNF name="identifier"/>s
representing all column names of <sym>IWTT</sym> and field type names of <sym>IWRT</sym>.
</item>

<item>If <sym>RS</sym> contains a <BNF name="group by clause"/> <symdef>GBC</symdef>, then
<sym>ORDER_REFS</sym> is the union of <sym>RETURN_IDENTIFIERS</sym> and
the set of all <BNF name="binding variable reference"/>s contained in <sym>GBC</sym>.
</item>

<item>If <sym>RS</sym> does not contain a <BNF name="group by clause"/>, but contains
a <BNF name="set quantifier"/> <kw>DISTINCT</kw> or a <BNF name="return item"/> containing
an <BNF name="aggregate function"/>, then <sym>ORDER_REFS</sym> is <sym>RETURN_IDENTIFIERS</sym>.
</item>

</olist>

</item>

<comment>Email from: Jeffrey Lovitz, 2023-03-02 WG3 UTC-022</comment>
<item>For every <BNF name="binding variable reference"/> <symdef>BVR</symdef> contained in
a <BNF name="sort key"/> <symdef>SK</symdef> contained in <sym>OBC</sym>,
if <sym>BVR</sym> is contained in <sym>SK</sym> without an intervening instance of
<BNF name="aggregate function"/>, then <sym>ORDER_REFS</sym> shall contain an identifier that is
equivalent to <sym>BVR</sym>.
</item>

<comment>WG3:GYD-035</comment>
<item>If <sym>RS</sym> does not simply contain a <BNF name="group by clause"/> and
does not directly contain a <BNF name="return item"/> containing 
an <BNF name="aggregate function"/>, then no <BNF name="sort key"/> contained in <sym>OBC</sym> 
shall contain an <BNF name="aggregate function"/>.
</item>

<item>Let <symdef>RIL</symdef> be the <BNF name="return item list"/> immediately contained
in <sym>RS</sym>, let <symdef>CRIL</symdef> be a copy of <sym>RIL</sym>, and
let <symdef>OB_COLS</symdef> be the empty set.
</item>

<item>For every <BNF name="sort key"/> <symdef>SK</symdef> contained in <sym>OBC</sym>
that contains an <BNF name="aggregate function"/>:

<olist>

<item>Let <symdef>AGG</symdef> be the <BNF name="value expression"/> immediately contained
in <sym>SK</sym>. 
</item>

<comment>WG3:W26-037R3</comment>
<item>Let <symdef>CN</symdef> be a new system-generated identifier.
</item>

<item>Append to <sym>CRIL</sym>:
<code>
, <sym>AGG</sym> <kw>AS</kw> <sym>CN</sym>
</code>
</item>

<item><sym>SK</sym> is replaced in <sym>OBC</sym> by:
<code>
<sym>CN</sym>
</code>
</item>

<item>Let <symdef>OB_COL</symdef> be a new column whose name is the canonical name form of
<sym>CN</sym> and whose type is the declared type of <sym>AGG</sym>.
</item>

<item><sym>OB_COL</sym> is added to <sym>OB_COLS</sym>.
</item>

</olist>

</item>

<item>For every <BNF name="binding variable reference"/> <symdef>REF</symdef> in
<sym>ORDER_REFS</sym> for which it holds that <sym>RETURN_IDENTIFIERS</sym> contains no element that
is equivalent to <sym>REF</sym>:

<olist>

<item>Append to <sym>CRIL</sym>:
<code>
, <sym>REF</sym> <kw>AS</kw> <sym>REF</sym>
</code>
</item>

<item>Let <symdef>OB_COL</symdef> be a new column whose name is the canonical name form of
<sym>REF</sym> and whose type is the declared type of <sym>REF</sym>.
</item>

<item><sym>OB_COL</sym> is added to <sym>OB_COLS</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-035</comment>
<item><sym>RIL</sym> is effectively replaced by <sym>CRIL</sym>.
Let <symdef>CRS</symdef> be <sym>RS</sym> after this replacement.
</item>

<comment>WG3:CMN-035</comment>
<comment>WG3:CMN-079</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>OPS</sym> is the outgoing working table type
of <sym>CRS</sym>.
</item>

<comment>WG3:CMN-068</comment>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>BTT</symdef> be the outgoing working table type of 
<sym>OPS</sym> without the columns identified by <sym>OB_COLS</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>The declared type of <sym>PRS</sym> and the outgoing working table type of <sym>PRS</sym> 
is <sym>BTT</sym>.
</item>
<endbar/>

</olist>

</item>

<item>Otherwise,

<olist>

<comment>WG3:CMN-079</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>OPS</sym> is
the outgoing working table type of <sym>RS</sym>.
</item>

<comment>Email from: Jeffrey Lovitz, 2023-03-02 WG3 UTC-022</comment>
<comment>WG3:XRH-036</comment>
<item>The declared type of <sym>PRS</sym> is the outgoing working table type of <sym>OPS</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>The outgoing working table type of <sym>PRS</sym> is the outgoing working table type
of <sym>OPS</sym>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:CMN-079</comment>
<comment>WG3:XRH-036</comment>
<item>Otherwise, the declared type of <sym>PRS</sym> is the outgoing working table type
of <sym>RS</sym>.
</item>
<endbar/>

</olist>

</item>

</olist>

</item>

<comment>WG3:UTC-064 Deleted 1 (one) SR</comment>

<comment>WG3:UTC-009 P00-USA-169</comment>
<comment>WG3:UTC-101</comment>
<comment>WG3:W26-026R2</comment>
<item>If <kw>FINISH</kw> is specified, then the declared type of <sym>PRS</sym> is the empty type.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2020-05-03 Added GRs</comment>
<olist>
<comment>Editorial: Stefan Plantikow, 2022-03-25 WG3:RKE-010 P00-NLD-219 Use default rule evaluation
order</comment>

<comment>WG3:UTC-022</comment>
<comment>Email from: Jeffrey Lovitz, 2023-03-02 WG3 UTC-022</comment>
<item>If the <BNF name="return statement"/> <sym>RS</sym> is specified, then:

<olist>

<comment>Email from: Jeffrey Lovitz, 2023-03-02 WG3 UTC-022</comment>
<item>The General Rules of <sym>RS</sym> are applied.

<comment>WG3:CMN-079 Removed 1 (one) Note</comment>

</item>

<comment>Email from: Jeffrey Lovitz, 2023-03-03 WG3 UTC-022</comment>
<comment>WG3:CMN-079</comment>
<item>If <sym>PRS</sym> specifies
the <BNF name="order by and page statement"/> <symdef>OPS</symdef>, then:

<olist>

<item>The General Rules of <sym>OPS</sym> are applied.
</item>

<comment>WG3:CMN-068</comment>
<item>If <sym>OPS</sym> immediately contains an <BNF name="order by clause"/>, then
the current working table is set to a copy of the current working table without any of the columns 
identified by <sym>OB_COLS</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-351</comment>
<comment>WG3:CMN-079</comment>
<item>The current execution outcome is set to a successful outcome with the current working table
as its result.
</item>

</olist>

</item>

<comment>WG3:W12-019</comment>
<comment>WG3:UTC-101</comment>
<comment>Editorial: Stefan Plantikow, 2023-03-03 Match GR order to Format</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item>If <kw>FINISH</kw> is specified, then the current execution outcome is set to
a successful outcome with an omitted result.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W25-029R1 Consequence</comment>
<comment>WG3:CMN-019 P00-USA-077</comment>
<comment>WG3:CMN-049</comment>
<item>Without <feature code="GA07"/>, in conforming GQL language, the <BNF name="order by clause"/> 
directly contained in a <BNF name="primitive result statement"/> shall not directly contain 
a <BNF name="sort key"/> that directly contains a <BNF name="binding variable reference"/> that is 
not equivalent to the <BNF name="identifier"/> immediately contained in 
a <BNF name="return item alias"/> that is directly contained in the <BNF name="return statement"/> 
unless the referenced binding variable of the <BNF name="binding variable reference"/> is defined by
an intervening BNF non-terminal instance simply contained in the <BNF name="sort key"/>.
</item>

<bar note="WG3:XRH-035"/>
<comment>WG3:XRH-035</comment>
<item>Without <feature code="GQ27"/>, conforming GQL language shall not contain 
a <BNF name="primitive result statement"/> that is <kw>FINISH</kw>.
</item>
<endbar/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W22-055</comment>
<subClause id="gql_stm_return" newpage="true">
<clauseHeading><BNF name="return statement"/></clauseHeading>

<bodyMatter>

<comment>WG3:UTC-081 Deleted 1 (one) editor's note in consequence</comment>

<Function>

<comment>Editorial: Stefan Plantikow, 2020-05-04 Adjusted</comment>
<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>Editorial: Stefan Plantikow, 2022-03-25 Wording</comment>
<comment>WG3:UTC-081</comment>
<comment>WG3:CMN-079</comment>
<para>Projection and aggregation of the current working table.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-02-07</comment>
<BNFdef name="return statement">
<rhs>
<kw>RETURN</kw> <BNF name="return statement body"/>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-05-04 Made grammar more general</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-15 Split projection clauses</comment>
<comment>WG3:W15-020</comment>
<comment>WG3:UTC-046</comment>
<BNFdef name="return statement body">
<rhs>
<alt> <opt> <BNF name="set quantifier"/> </opt>
<group>
<alt br="no"> <BNF name="asterisk"/> </alt> <alt br="no"> <BNF name="return item list"/> </alt>
</group>
<opt> <BNF name="group by clause"/> </opt>
</alt>
<alt> <kw>NO</kw> <kw>BINDINGS</kw> </alt>
</rhs>
</BNFdef>

<BNFdef name="return item list">
<rhs>
<BNF name="return item"/>
<opt> <group> <BNF name="comma"/> <BNF name="return item"/> </group><repeat/> </opt>
</rhs>
</BNFdef>

<comment>WG3:UTC-081</comment>
<BNFdef name="return item">
<rhs>
<BNF name="aggregating value expression"/> <opt> <BNF name="return item alias"/> </opt>
</rhs>
</BNFdef>

<BNFdef name="return item alias">
<rhs>
<kw>AS</kw> <BNF name="identifier"/>
</rhs>
</BNFdef>

<comment>WG3:W14-013: Stefan Plantikow, 2021-09-15 Add missing editor's note</comment>
<ednote id="gql_PP169_9">Consider allowing a single optional <BNF name="where clause"/>.
See <PPref ref="PPgql169"/>.
</ednote>

</grammar>

<comment>WG3:XRH-021R1 Removed 1 (one) editors note</comment>
<delbar note="WG3:XRH-021R1 Removed 1 (one) editors note"/>

</Format>


<SyntaxRules>

<ednote id="gql_PP017_return">Aggregation functionality should be improved for the needs of GQL.
See <PPref ref="PPgql017"/>.
</ednote>

<comment>WG3:UTC-022</comment>

<comment>Editorial: Stefan Plantikow, 2020-05-04 Added SRs</comment>
<olist>

<comment>Editorial: Stephen Cannan, 2020-05-08 Use correct language.</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-16 Split up for layout reasons</comment>
<item>Let <symdef>RS</symdef> be the <BNF name="return statement"/>.
</item>

<item>Let <symdef>RSB</symdef> be the <BNF name="return statement body"/> immediately contained
in <sym>RS</sym>.
</item>

<comment>Editorial: Stephen Cannan, 2020-05-08 Use correct language.</comment>
<item>If a <BNF name="set quantifier"/> is not immediately contained in <sym>RSB</sym>, then
<kw>ALL</kw> is the implicit <BNF name="set quantifier"/> of <sym>RSB</sym>.
</item>

<comment>WG3:W24-037</comment>
<item>If a <BNF name="set quantifier"/> <kw>DISTINCT</kw> is specified, then each 
<BNF name="return item"/> <symdef>RI</symdef> is an operand of a grouping operation. 
The Syntax Rules and Conformance Rules of <specref ref="gql_grouping_ops"/>, apply.
</item>

<item>Let <symdef>SQ</symdef> be the explicit or implicit <BNF name="set quantifier"/>
of <sym>RSB</sym>.
</item>

<comment>WG3:UTC-081 Deleted 1 (one) SR</comment>

<comment>Editorial: Stephen Cannan, 2020-05-08 Use correct language.</comment>
<item>If <sym>RSB</sym> immediately contains an <BNF name="asterisk"/>, then:

<olist>

<comment>WG3:W25-029R1</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>RS</sym> shall not be
the unit binding table type.
</item>
<endbar/>

<comment>Editorial: Stephen Cannan, 2020-05-08 Use correct language.</comment>
<item><sym>RSB</sym> shall not immediately contain a <BNF name="group by clause"/>.
</item>

<comment>Editorial: Stefan Plantikow, 2020-05-16 Corrected to use standard sort order</comment>
<comment>Editorial: Stephen Cannan, 2022-03-06 WG3:RKE-010 P00-USA-481</comment>
<comment>WG3:W24-037</comment>
<comment>WG3:UTC-081</comment>
<comment>WG3:CMN-019 P00-NLD-050</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>BVSEQ</symdef> be the sequence of all column names of
the incoming working table type of <sym>RS</sym> in ascending order.
Let <symdef>NBVSEQ</symdef> be the number of such binding variables.
For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NBVSEQ</sym>, 
let <symdef>BV</symdef><sub><sym>i</sym></sub> be the <sym>i</sym>-th such binding variable in
<sym>BVSEQ</sym>.
</item>
<endbar/>

<comment>Editorial: Stephen Cannan, 2022-03-06 WG3:RKE-010 P00-USA-478</comment>
<comment>WG3:UTC-046</comment>
<comment>WG3:CMN-019 P00-NLD-050</comment>
<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NBVSEQ</sym>, let the new
<BNF name="return item list"/> <symdef>NEWRIL</symdef> be a comma-separated list of
<BNF name="return item"/>s:
<code>
<sym>BV</sym><sub><sym>i</sym></sub> <kw>AS</kw> <sym>BV</sym><sub><sym>i</sym></sub>
</code>
</item>

<comment>Editorial: Stefan Plantikow, 2020-05-16 Add return tail statements</comment>
<comment>WG3:UTC-046</comment>
<item><sym>RS</sym> is effectively replaced by the <BNF name="return statement"/>:

<comment>WG3:W15-020</comment>
<comment>WG3:UTC-081</comment>
<code>
<kw>RETURN</kw> <sym>SQ</sym> <sym>NEWRIL</sym>
</code>

</item>

</olist>

</item>

<comment>Editorial: Stephen Cannan, 2022-03-06 WG3:RKE-010 P00-USA-481</comment>
<comment>WG3:UTC-081</comment>
<item>Let <symdef>RIL</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:UTC-081</comment>
<comment>Email from: Jeffrey Lovitz, 2023-03-06 1731</comment>
<item>If <sym>RSB</sym> is <kw>NO</kw> <kw>BINDINGS</kw>, then
<symdef>SQ</symdef> is <kw>ALL</kw> and <symdef>RIL</symdef> is the empty sequence.

<note>That is, <kw>RETURN</kw> <kw>NO</kw> <kw>BINDINGS</kw> is equivalent to
<kw>RETURN</kw> <kw>ALL</kw> with an empty <BNF name="return item list"/> and
no <BNF name="group by clause"/>.
The Format does not permit an empty <BNF name="return item list"/>, hence the need to define
these values artificially.
</note>
</item>

<comment>WG3:UTC-081</comment>
<item>Otherwise, <symdef>RIL</symdef> is the <BNF name="return item list"/>
immediately contained in <sym>RSB</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-081 Deleted 1 (one) SR</comment>

<comment>WG3:W15-020</comment>
<comment>Editorial: Stephen Cannan, 2022-03-06 WG3:RKE-010 P00-USA-481</comment>
<comment>WG3:UTC-081</comment>
<item>For each <BNF name="return item"/> <symdef>RI</symdef> in <sym>RIL</sym>:

<para>Case:
</para>

<olist>

<comment>WG3:W22-053R2</comment>
<item>If the <BNF name="aggregating value expression"/> immediately contained in
<sym>RI</sym> is a <BNF name="binding variable reference"/> <symdef>RIBV</symdef> and
<sym>RI</sym> does not immediately contain a <BNF name="return item alias"/>, then
<sym>RI</sym> is effectively replaced by:
<code>
<sym>RIBV</sym> <kw>AS</kw> <sym>RIBV</sym>
</code>
</item>

<item>Otherwise, <sym>RI</sym> shall immediately contain a <BNF name="return item alias"/>.
</item>

</olist>

</item>

<comment>WG3:UTC-081 Deleted 1 (one) SR</comment>

<comment>WG3:UTC-081</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>For a given <BNF name="return item"/> <symdef>RI</symdef>,
the <newterm>expression</newterm> of <sym>RI</sym> is
the <BNF name="aggregating value expression"/> immediately contained in <sym>RI</sym> and
the <newterm>alias name</newterm> of <sym>RI</sym> is the canonical name form of
the <BNF name="identifier"/> immediately contained in
the explicit or implicit <BNF name="return item alias"/> of <sym>RI</sym>.
</item>

<comment>Editorial: Stephen Cannan, 2020-05-08 Add implicit GROUP BY.</comment>
<comment>WG3:UTC-081</comment>
<item>Case:

<olist>
<comment>Editorial: Stephen Cannan, 2021-05-27 Standardize terms</comment>
<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10 Standardize terms</comment>
<comment>WG3:UTC-081 Deleted 1 (one) SR</comment>

<comment>WG3:UTC-081</comment>
<item>If <sym>RSB</sym> immediately contains a <BNF name="group by clause"/> <symdef>GBC</symdef>:

<olist>

<comment>WG3:W23-009R1 P00-USA-363</comment>
<item>Let <symdef>GRISET</symdef> be the set of grouping <BNF name="return item"/>s
contained in <sym>RIL</sym> whose alias name is simply contained in <sym>GBC</sym>
and let <symdef>NGRI</symdef> be the number of such <BNF name="return item"/>s in <sym>GRISET</sym>.
</item>

<comment>WG3:W23-009R1 P00-USA-363</comment>
<item>Let <symdef>ARISET</symdef> be the set of aggregating <BNF name="return item"/>s contained in
<sym>RIL</sym> whose alias name is not simply contained in <sym>GBC</sym> and 
let <symdef>NARI</symdef> be the number of such <BNF name="return item"/>s in <sym>ARISET</sym>.
</item>

<comment>WG3:W15-020</comment>
<comment>WG3:W24-014R2</comment>
<item>All <BNF name="return item"/>s shall be contained in <sym>GRISET</sym> or <sym>ARISET</sym>.
</item>

<comment>WG3:W24-014R2</comment>
<item>Let <symdef>INSET</symdef> be the set of all <BNF name="grouping element"/>s simply contained
in <sym>GBC</sym> that are not equal to an alias name in <sym>GRISET</sym>.
Let <symdef>NINSET</symdef> be the number of items in <sym>INSET</sym>.
</item>

<comment>WG3:W24-014R2</comment>
<comment>WG3:UTC-081</comment>
<item>Let <symdef>GROUP_COLS</symdef> be the set of columns constructed as follows:

<olist>

<comment>WG3:CMN-019 P00-NLD-016 Correct error in UTC-081</comment>
<item>For every grouping <BNF name="return item"/> <symdef>GRI</symdef> in <sym>GRISET</sym>:

<olist>

<item>Let <symdef>COL</symdef> be a new column whose name is the <BNF name="return item alias"/> 
of <sym>GRI</sym> and whose type is the declared type of
the <BNF name="aggregating value expression"/> immediately contained in <sym>GRI</sym>.
</item>

<comment>WG3:UTC-081</comment>
<item><sym>COL</sym> is included in <sym>GROUP_COLS</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-NLD-017 Correct error in UTC-081</comment>
<item>For every <BNF name="grouping element"/> <symdef>IN</symdef> in <sym>INSET</sym>:

<olist>

<item>Let <symdef>COL</symdef> be a new column whose name is the <BNF name="identifier"/> 
contained in <sym>IN</sym> and whose type is the declared type of the 
<BNF name="binding variable reference"/> contained in <sym>IN</sym>.
</item>

<comment>WG3:UTC-081</comment>
<item><sym>COL</sym> is included in <sym>GROUP_COLS</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:UTC-081</comment>
<comment>WG3:CMN-019 P00-USA-078</comment>
<item>Let <symdef>GR_TABLE_TYPE</symdef> be
the declared type of a binding table containing all columns of <sym>GROUP_COLS</sym>.
</item>

<comment>WG3:UTC-081</comment>
<comment>Email from: Jeffrey Lovitz, 2023-03-06 1731</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>ARI_TABLE_TYPE</symdef> be the incoming working table type of <sym>RS</sym> 
without the fields identified by <sym>GROUP_COLS</sym>.
</item>

<comment>WG3:UTC-081</comment>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of all <BNF name="return item"/>s
in <sym>ARISET</sym> is <sym>ARI_TABLE_TYPE</sym>.
</item>

<comment>WG3:UTC-081</comment>
<comment>Email from: Jeffrey Lovitz, 2023-03-06 1731</comment>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of all <BNF name="return item"/>s
in <sym>ARISET</sym> is the incoming working record type of <sym>RS</sym> amended
with the record type of <sym>GR_TABLE_TYPE</sym>.
</item>
<endbar/>

</olist>

</item>

<item>Otherwise:

<olist>

<comment>WG3:UTC-081</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of every <BNF name="return item"/> is
the incoming working table type of <sym>RS</sym>.
</item>

<comment>WG3:UTC-081</comment>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of every <BNF name="return item"/> is
the incoming working record type of <sym>RS</sym>.
</item>
<endbar/>

</olist>

</item>

</olist>

</item>

<comment>WG3:UTC-081</comment>
<item>Let <symdef>RETURN_TABLE_TYPE</symdef> be the declared type of a binding table defined
as follows.

<para>Case:
</para>

<olist>

<comment>WG3:UTC-081</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>If <sym>RSB</sym> immediately contains an <BNF name="asterisk"/>, then
<sym>RETURN_TABLE_TYPE</sym> is the incoming working table type of <sym>RS</sym>.
</item>
<endbar/>

<comment>WG3:UTC-081</comment>
<item>Otherwise:

<olist>

<comment>WG3:UTC-081</comment>
<item>Let <symdef>RETURN_COLS</symdef> be the sequence of columns constructed by,
for every element <sym>RI</sym> of <sym>RIL</sym>, creating a column whose name is 
the alias name of <sym>RI</sym> and whose declared type is the declared type of
the expression of <sym>RI</sym>.
</item>

<comment>WG3:UTC-081</comment>
<item><symdef>RETURN_TABLE_TYPE</symdef> is the declared type of a material binding table
whose set of columns is <sym>RETURN_COLS</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:UTC-081</comment>
<comment>WG3:CMN-079</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The outgoing working table type of <sym>RS</sym> is <sym>RETURN_TABLE_TYPE</sym>.
</item>

<comment>WG3:UTC-081</comment>
<comment>WG3:XRH-036</comment>
<item>The outgoing working record type of <sym>RS</sym> is
the incoming working record type of <sym>RS</sym>.
</item>
<endbar/>

<comment>WG3:UTC-081</comment>
<comment>WG3:CMN-079</comment>
<comment>WG3:W26-026R2</comment>
<item>The declared type of <sym>RS</sym> is the empty type.
</item>

<comment>WG3:UTC-081 Implicitly moved 1 (one) SR</comment>
<comment>WG3:UTC-081 Deleted 1 (one) SR</comment>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2020-05-04 Add GRs</comment>
<olist>

<comment>Editorial: Stefan Plantikow, 2020-05-17 Support aggregation</comment>
<comment>Editorial: Stephen Cannan, 2022-03-06 WG3:RKE-010 P00-USA-481</comment>
<comment>Editorial: Stefan Plantikow, 2023-06-02 Correct wording</comment>
<comment>WG3:CMN-019 P00-NLD-050</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>Let <symdef>TABLE</symdef> be the current working table.
Let <symdef>N</symdef> be the number of records of <sym>TABLE</sym>.
For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>, 
let <symdef>R</symdef><sub><sym>i</sym></sub>, be the <sym>i</sym>-th record of <sym>TABLE</sym> 
in the order determined by iterating over <sym>TABLE</sym>.
</item>

<item>Let <symdef>RETURN_TABLE</symdef> be a new empty binding table
of type <sym>RETURN_TABLE_TYPE</sym>.
</item>

<comment>WG3:UTC-046</comment>
<comment>WG3:UTC-081 Deleted 1 (one) GR</comment>

<comment>WG3:UTC-081</comment>
<item>Case:

<olist>
<comment>WG3:UTC-081 Deleted 1 (one) GR</comment>

<comment>WG3:UTC-081</comment>
<item>If <sym>RS</sym> immediately contains a <BNF name="group by clause"/> <sym>GBC</sym>:

<olist>

<comment>WG3:W12-019</comment>
<comment>Editorial: Stephen Cannan, 2022-03-06 WG3:RKE-010 P00-USA-481</comment>
<comment>WG3:W24-014R2</comment>
<comment>WG3:CMN-019 P00-NLD-050</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>, 
the <newterm>grouping record</newterm> <symdef>GR</symdef><sub><sym>i</sym></sub> of a record 
<symdef>R</symdef><sub><sym>i</sym></sub> of <sym>TABLE</sym> is a new record constructed as 
follows:

<olist>

<comment>WG3:CMN-019 P00-NLD-050</comment>
<comment>WG3:CMN-079</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>For <symdef>k</symdef>, 1 (one) <leq/> <sym>k</sym> <leq/> <sym>NGRI</sym>, 
<sym>GR</sym><sub><sym>i</sym></sub> includes a field <symdef>F</symdef><sub><sym>k</sym></sub>
such that the name of <sym>F</sym><sub><sym>k</sym></sub> is the alias name of 
<sym>GRISET</sym><sub><sym>k</sym></sub> 
and the value of <sym>F</sym><sub><sym>k</sym></sub> is the result of the 
expression of <sym>GRISET</sym><sub><sym>k</sym></sub> in a new child execution context amended with
<sym>R</sym><sub><sym>i</sym></sub>.
</item>

<comment>WG3:CMN-019 P00-NLD-050</comment>
<comment>WG3:CMN-079</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>For <symdef>j</symdef>, 1 (one) <leq/> <sym>j</sym> <leq/> <sym>NINSET</sym>,
<sym>GR</sym><sub><sym>i</sym></sub> includes a field <symdef>G</symdef><sub><sym>j</sym></sub>
such that the name of <sym>G</sym><sub><sym>j</sym></sub> is the name specified by
the <BNF name="identifier"/> contained in <sym>INSET</sym><sub><sym>j</sym></sub> and the value of 
<sym>G</sym><sub><sym>j</sym></sub> is the value in <sym>R</sym><sub><sym>i</sym></sub> of the 
<BNF name="binding variable reference"/> contained in <sym>INSET</sym>.
</item>

</olist>

</item>

<comment>Editorial: Stephen Cannan, 2022-03-06 WG3:RKE-010 P00-USA-481</comment>
<comment>WG3:W24-014R2</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>Let <symdef>GR_TABLE</symdef> be a new binding table of type <sym>GR_TABLE_TYPE</sym> 
of all grouping records
<symdef>GR</symdef><sub><sym>i</sym></sub>, 1 (one) <leq/> <symdef>i</symdef> <leq/> <sym>N</sym>,
of all records <sym>R</sym><sub><sym>i</sym></sub> of <sym>TABLE</sym>.
</item>

<comment>Editorial: 2022-03-25 WG3:RKE-010 P00-NLD-219 Simplify application of GRs</comment>
<item>Let <symdef>GROUP_BY</symdef> be the result of <sym>GBC</sym> in a new child
execution context with <sym>GR_TABLE</sym> as its working table.

<note>The result of <sym>GBC</sym> is obtained from the implicit invocation of the General Rules of
<specref ref="gql_group_by"/>.
</note>

</item>
<comment>WG3:UTC-081 Deleted 1 (one) GR</comment>

<comment>WG3:W15-020</comment>
<comment>WG3:UTC-081</comment>
<item>For each record <symdef>K</symdef> in <sym>GROUP_BY</sym>:

<olist>

<comment>Editorial: Stephen Cannan, 2022-03-06 WG3:RKE-010 P00-USA-481</comment>
<comment>WG3:UTC-081</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>Let <symdef>PART</symdef> be a new binding table of type <sym>ARI_TABLE_TYPE</sym>
comprising only the records <sym>R</sym><sub><sym>j</sym></sub>, 
1 (one) <leq/> <symdef>j</symdef> <leq/> <sym>N</sym>, from <sym>TABLE</sym>, 
for which the grouping record <sym>GR</sym><sub><sym>j</sym></sub> for 
<sym>R</sym><sub><sym>j</sym></sub> is not distinct from <sym>K</sym>,
without the columns identified by <symdef>GROUP_COLS</symdef>.
</item>
<comment>WG3:UTC-081 Deleted 2 GRs</comment>

<comment>WG3:UTC-081</comment>
<comment>WG3:CMN-068</comment>
<item>Let <symdef>IWR</symdef> be a copy of the current working record amended with 
<sym>GR</sym><sub><sym>j</sym></sub>.
</item>

<comment>WG3:UTC-081</comment>
<comment>WG3:CMN-068</comment>
<item>Let <symdef>NR</symdef> be a copy of <sym>K</sym> without the fields identified by 
<sym>INSET</sym>.
</item>

<comment>WG3:UTC-081</comment>
<item>For every <BNF name="return item"/> <symdef>ARI</symdef><sub><sym>j</sym></sub>
in <sym>ARISET</sym>, 1 (one) <leq/> <sym>j</sym> <leq/> <sym>NARI</sym>,
append a field to <sym>NR</sym> whose name is the alias name of
<sym>ARI</sym><sub><sym>j</sym></sub> and whose value is the result of evaluating
the <BNF name="aggregating value expression"/> of <sym>ARI</sym><sub><sym>j</sym></sub>
in a new child execution context with <sym>IWR</sym> as its working record and
with <sym>PART</sym> as its working table.

<comment>WG3:UTC-081</comment>
<note>This is used to determine the result of <BNF name="aggregate function"/>s.
</note>
</item>

<comment>WG3:UTC-081</comment>
<item>Append <sym>NR</sym> to <sym>RETURN_TABLE</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:UTC-081</comment>
<item>Otherwise, for each record <symdef>R</symdef> of <sym>TABLE</sym>
in a new child execution context amended with <sym>R</sym>:

<olist>

<comment>WG3:UTC-081</comment>
<item>Let <symdef>S</symdef> be a record defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:UTC-081</comment>
<item>If <sym>RIL</sym> is an empty sequence, then <sym>S</sym> is the unit record.
</item>

<comment>WG3:UTC-081</comment>
<item>Otherwise, <sym>S</sym> is the record comprising a field <symdef>F</symdef> for every
<BNF name="return item"/> <sym>RI</sym> in <sym>RIL</sym> such that the name of <sym>F</sym> is
the alias name of <sym>RI</sym> and the value of <sym>F</sym> is the result of the expression of
<sym>RI</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-081</comment>
<comment>Email from: Jeffrey Lovitz, 2023-03-06 1731</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item><sym>S</sym> is added to <sym>RETURN_TABLE</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>Editorial: Stefan Plantikow, 2020-05-16 Handle DISTINCT</comment>
<comment>WG3:UTC-081</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item>If <sym>SQ</sym> is <kw>DISTINCT</kw>, then the current working table is set to 
duplicate-free copy of <sym>RETURN_TABLE</sym> in which every record is distinct from
every other record of <sym>RETURN_TABLE</sym>;
otherwise, the current working table is set to <sym>RETURN_TABLE</sym>.
</item>

<comment>WG3:UTC-081 Deleted 1 (one) GR</comment>

<comment>WG3:W15-020</comment>
<comment>Editorial: Stephen Cannan, 2022-03-06 WG3:RKE-010 P00-USA-481</comment>
<comment>WG3:UTC-086R1</comment>
<comment>WG3:UTC-081</comment>
<comment>WG3:CMN-019 P00-NLD-018 Correct error in UTC-081</comment>
<item>Let <symdef>FINAL_TABLE</symdef> be a new binding table of type <sym>RETURN_TABLE_TYPE</sym>
obtained from the current working table by determining the preferred column name sequence to be
the sequence of alias names of all <BNF name="return item"/>s from <sym>RIL</sym> in the order of 
their occurrence in <sym>RIL</sym>.
</item>

<comment>WG3:UTC-081</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<comment>WG3:CMN-079</comment>
<item>The current working table is set to <sym>FINAL_TABLE</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2022-03-25 Wording</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<comment>WG3:CMN-079</comment>
<item>The current execution outcome is set to a successful outcome with an omitted result.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-046</comment>
<comment>Consequence of WG3:W25-024</comment>
<item>Conforming GQL language shall not contain a <BNF name="return statement body"/> that 
contains <kw>NO</kw> <kw>BINDINGS</kw>.

<comment>WG3:UTC-046</comment>
<note>A <BNF name="return statement body"/> that contains <kw>NO</kw> <kw>BINDINGS</kw> is 
a specification device for use by a syntactic transformation in <specref ref="gql_match"/> to 
specify the semantics of <BNF name="optional match statement"/> if the latter does not supply 
any new output bindings and is not syntax available to the user.
</note>

</item>

<comment>WG3:CMN-049 Removed 1 (one) Conformance Rule</comment>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W22-055</comment>
<subClause id="gql_select" newpage="true">
<clauseHeading><BNF name="select statement"/></clauseHeading>

<bodyMatter>
<comment>WG3:W23-028R2 One editor's note removed</comment>

<Function>

<comment>Editorial: Stefan Plantikow, 2020-05-12 Removed table references</comment>
<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>Editorial: Stefan Plantikow, 2022-11-14 Reword</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<para>Provide an <SQL/>-style query over graph data, which produces a binding table result.
</para>

</Function>


<Format>
<comment>WG3:W23-028R2 One editor's note removed</comment>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-02-07</comment>
<comment>Editorial: Stefan Plantikow, 2020-02-06</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-12 Adjusted grammar to be closer to GQL</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-18 Corrected order</comment>
<comment>WG3:RKE-015</comment>
<comment>Editorial: Stefan Plantikow, 2022-11-14 Adjusted for WG3:W23-028R2</comment>
<comment>WG3:W25-029R1</comment>
<BNFdef name="select statement">
<rhs>
<kw>SELECT</kw> <opt> <BNF name="set quantifier"/> </opt>
<group>
<alt br="no"> <BNF name="asterisk"/> </alt>
<alt br="no"> <BNF name="select item list"/> </alt>
</group>
<breakindent/>
<opt>
<BNF name="select statement body"/>
<breakindent/>
<opt> <BNF name="where clause"/> </opt>
<breakindent/>
<opt> <BNF name="group by clause"/> </opt>
<breakindent/>
<opt> <BNF name="having clause"/> </opt>
<breakindent/>
<opt> <BNF name="order by clause"/> </opt>
<breakindent/>
<opt> <BNF name="offset clause"/> </opt>
<opt> <BNF name="limit clause"/> </opt>
</opt> 
</rhs>
</BNFdef>

<BNFdef name="select item list">
<rhs>
<BNF name="select item"/>
<opt> <group> <BNF name="comma"/> <BNF name="select item"/> </group><repeat/> </opt>
</rhs>
</BNFdef>

<comment>WG3:UTC-081</comment>
<BNFdef name="select item">
<rhs>
<BNF name="aggregating value expression"/> <opt> <BNF name="select item alias"/> </opt>
</rhs>
</BNFdef>

<BNFdef name="select item alias">
<rhs>
<kw>AS</kw> <BNF name="identifier"/>
</rhs>
</BNFdef>

<BNFdef name="having clause">
<rhs>
<kw>HAVING</kw> <BNF name="search condition"/>
</rhs>
</BNFdef>

<comment>WG3:W15-017</comment>
<comment>WG3:W25-029R1</comment>
<BNFdef name="select statement body">
<rhs>
<kw>FROM</kw>
<group>
<alt br="no"> <BNF name="select graph match list"/> </alt>
<alt br="no"> <BNF name="select query specification"/> </alt>
</group>
</rhs>
</BNFdef>

<BNFdef name="select graph match list">
<rhs>
<BNF name="select graph match"/> 
<opt> <group> <BNF name="comma"/> <BNF name="select graph match"/> </group><repeat/> </opt>
</rhs>
</BNFdef>

<BNFdef name="select graph match">
<rhs>
<BNF name="graph expression"/> <BNF name="match statement"/>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-05-12 SQL FROM Removed</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-12 Aligned production rule names</comment>
<comment>WG3:W20-027R1</comment>
<comment>WG3:W25-029R1</comment>
<BNFdef name="select query specification">
<rhs>
<alt> <BNF name="nested query specification"/> </alt>
<alt> <BNF name="graph expression"/> <BNF name="nested query specification"/> </alt>
</rhs>
</BNFdef>

</grammar>

</Format>

<ednote id="gql_PP017_select">Aggregation functionality should be improved for the needs of GQL.
See <PPref ref="PPgql017"/>.
</ednote>


<SyntaxRules>
<comment>WG3:W23-028R2 One editor's note removed</comment>

<comment>WG3:W23-028R2</comment>
<olist>

<comment>WG3:W25-029R1</comment>
<item>The Syntax Rules of this Subclause are applied before all other Syntax Rules.
</item>

<comment>WG3:W23-028R2</comment>
<comment>WG3:W25-029R1</comment>
<item>Let <symdef>SELECTSTM</symdef> be the <BNF name="select statement"/>.
</item>

<comment>WG3:W23-028R2</comment>
<comment>WG3:W25-029R1</comment>
<item>If <sym>SELECTSTM</sym> does not immediately contain a <BNF name="set quantifier"/>, then
<kw>ALL</kw> is implicit.
</item>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>SETQ</symdef> be the explicit or implicit <BNF name="set quantifier"/> that is
immediately contained in <sym>SELECTSTM</sym>.
</item>

<comment>WG3:W24-037</comment>
<comment>WG3:W25-029R1 Consequence</comment>
<item>If <sym>SETQ</sym> is <kw>DISTINCT</kw>, then each <BNF name="select item"/> immediately
contained in the <BNF name="select item list"/> immediately contained in <sym>SELECTSTM</sym> is
an operand of a grouping operation. 
The Syntax Rules and Conformance Rules of <specref ref="gql_grouping_ops"/>, apply.
</item>
<comment>WG3:W25-029R1 Deleted 1 (one) SR</comment>

<comment>WG3:W23-028R2</comment>
<item>Let <symdef>SSB</symdef> be defined as follows. 
If <BNF name="select statement body"/> is specified, then <sym>SSB</sym> is the 
<BNF name="select statement body"/>; otherwise, <sym>SSB</sym> is the zero-length character string.
</item>

<comment>WG3:W25-029R1</comment>
<item>If <sym>SELECTSTM</sym> immediately contains an <BNF name="asterisk"/>, then:

<olist>

<comment>WG3:W25-029R1</comment>
<item><sym>SSB</sym> shall not be the zero-length character string.
</item>

<comment>WG3:W25-029R1</comment>
<item><sym>SELECTSTM</sym> shall not immediately contain a <BNF name="group by clause"/>.
</item>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>FROM_ITEMS</symdef> be the set of names defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W25-029R1 as minuted</comment>
<item>If the <BNF name="select statement body"/> of <sym>SELECTSTM</sym> immediately contains
a <BNF name="select graph match list"/> <symdef>SGML</symdef>, then <sym>FROM_ITEMS</sym> is
the set of names of binding variables referenced by all <BNF name="binding variable reference"/>s
that are declared in <BNF name="graph pattern"/>s directly contained in <sym>SGML</sym> without
an intervening instance of (another) <BNF name="graph pattern"/>.
</item>

<comment>WG3:W25-029R1</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>Otherwise, the <BNF name="select statement body"/> of <sym>SELECTSTM</sym> immediately
contains a <BNF name="select query specification"/> <symdef>SQS</symdef> and <sym>FROM_ITEMS</sym>
is the set of column names of the outgoing working table type of
the <BNF name="nested query specification"/> immediately contained in <sym>SQS</sym>.
</item>
<endbar/>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<comment>WG3:W26-030R1</comment>
<item>Let <symdef>FNSEQ</symdef> be a sequence of all names of <sym>FROM_ITEMS</sym> and 
let <symdef>NFNSEQ</symdef> be the number of such names.
</item>

<comment>WG3:W25-029R1</comment>
<comment>Editorial: Jim Melton 2024-09-30</comment>
<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NFNSEQ</sym>,
let <symdef>FROM_ITEM</symdef><sub><sym>i</sym></sub> be
the <sym>i</sym>-th name in <sym>FNSEQ</sym> and
let <symdef>BVR</symdef><sub><sym>i</sym></sub> be an <BNF name="identifier"/>
whose canonical name form is <sym>FROM_ITEM</sym><sub><sym>i</sym></sub>.
</item>

<comment>WG3:W25-029R1</comment>
<item>Let the <BNF name="select item list"/> <symdef>NEWSIL</symdef> be the comma-separated list
of <BNF name="select item"/>s defined as follows:
<code>
<sym>BVR</sym><sub>1</sub> <kw>AS</kw> <sym>BVR</sym><sub>1</sub>, <ellipsis/>, <sym>BVR</sym><sub><sym>NFNSEQ</sym></sub> <kw>AS</kw> <sym>BVR</sym><sub><sym>NFNSEQ</sym></sub>
</code>
</item>

<comment>WG3:W25-029R1</comment>
<item>The <BNF name="asterisk"/> immediately contained in <sym>SELECTSTM</sym> is effectively
replaced by the <BNF name="select item list"/>:
<code>
<sym>NEWSIL</sym>
</code>
</item>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<comment>Editorial: Stefan Plantikow 2023-03-17 Use immediate containment</comment>
<item>For each explicit <BNF name="select item"/> <symdef>SI</symdef> immediately contained in
the <BNF name="select item list"/> immediately contained in <sym>SELECTSTM</sym>,

<para>Case:
</para>

<olist>

<comment>WG3:W25-029R1</comment>
<item>If the <BNF name="aggregating value expression"/> immediately contained in <sym>SI</sym> is
a <BNF name="binding variable reference"/> <symdef>SIBVR</symdef> and <sym>SI</sym> does not
immediately contain a <BNF name="select item alias"/>, then <sym>SI</sym> is effectively replaced
by:
<code>
<sym>SIBVR</sym> <kw>AS</kw> <sym>SIBVR</sym>
</code>
</item>

<comment>WG3:W25-029R1</comment>
<item>Otherwise, <sym>SI</sym> shall immediately contain a <BNF name="select item alias"/>.
</item>

</olist>

</item>

<comment>WG3:W23-028R2</comment>
<item>Let <symdef>FILTERSTM</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W23-028R2</comment>
<item>If a <BNF name="where clause"/> <symdef>WHERECL</symdef> is specified, then
<sym>FILTERSTM</sym> is:
<code>
<kw>FILTER</kw> <sym>WHERECL</sym>
</code>
</item>

<comment>WG3:W23-028R2</comment>
<item>Otherwise,

<para>Case:
</para>

<olist>

<item>If <sym>SSB</sym> contains the <BNF name="select graph match list"/> <symdef>SGML</symdef>
and if the last <BNF name="select graph match"/> in <sym>SGML</sym> immediately contains
a <BNF name="match statement"/> that contains a <BNF name="graph pattern"/> <symdef>GP</symdef>
that contains a <BNF name="graph pattern where clause"/> <symdef>GPWC</symdef> that is not
followed by a <BNF name="yield clause"/>, then <sym>FILTERSTM</sym> is:
<code>
<kw>FILTER</kw> <sym>GPWC</sym>
</code>
<para>and <sym>GPWC</sym> is removed from <sym>GP</sym>.
</para>
</item>

<item>Otherwise, <sym>FILTERSTM</sym> is the zero-length character string.
</item>

</olist>

</item>

</olist>

</item>
<comment>WG3:W25-029R1 Deleted 3 SRs</comment>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>XOISIL</symdef> be the list of explicit or implicit <BNF name="select item"/>s
immediately contained in <sym>SELECTSTM</sym> in the order of their appearance,
let <symdef>XOISISET</symdef> be the set of <BNF name="select item"/>s in <sym>XOISIL</sym>,
let <symdef>XOISIASEQ</symdef> be the sequence of <BNF name="identifier"/>s immediately
contained in <BNF name="select item alias"/>es in <sym>XOISIL</sym>, and
let <symdef>NUM_SIS</symdef> be the number of elements of <sym>XOISIL</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>AGGREGATING_ITEMS</symdef> be the set of all <BNF name="select item"/>s in
<sym>XOISISET</sym> that directly contain an <BNF name="aggregate function"/> and
let <symdef>NUM_AGGREGATING</symdef> be the number of elements of <sym>AGGREGATING_ITEMS</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<item>Let the <BNF name="group by clause"/> <symdef>GROUP_BY</symdef> and 
the set of <BNF name="return item"/>s <symdef>GKRISET</symdef> be determined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W25-029R1</comment>
<item>If <sym>SELECTSTM</sym> immediately contains
a <BNF name="group by clause"/> <symdef>GBC</symdef> that does not simply contain
an <BNF name="empty grouping set"/>, then:

<olist>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>GEL</symdef> be the <BNF name="grouping element list"/> immediately contained
in <sym>GBC</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>NUM_GE</symdef> be the number of elements of <sym>GEL</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<item>For <symdef>j</symdef>, 1 (one) <leq/> <sym>j</sym> <leq/> <sym>NUM_GE</sym>:

<olist>

<comment>WG3:W25-029R1</comment>
<comment>WG3:CMN-019 P00-USA-080</comment>
<item>Let <symdef>GE</symdef><sub><sym>j</sym></sub> be
the <sym>j</sym>-th <BNF name="grouping element"/> contained in <sym>GEL</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<comment>WG3:CMN-019 P00-USA-080</comment>
<comment>WG3:W26-037R3</comment>
<item>Let <symdef>GEID</symdef><sub><sym>j</sym></sub> be a new system-generated regular identifier.
</item>

<comment>WG3:W25-029R1</comment>
<item>The following <BNF name="return item"/> is added to <sym>GKRISET</sym>:
<code>
<sym>GE</sym><sub><sym>j</sym></sub> <kw>AS</kw> <sym>GEID</sym><sub><sym>j</sym></sub>
</code>
</item>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<comment>WG3:CMN-019 P00-USA-081</comment>
<item><sym>GROUP_BY</sym> is:
<code>
<kw>GROUP</kw> <kw>BY</kw> <sym>GE</sym><sub>1</sub>, <ellipsis/>, <sym>GE</sym><sub><sym>NUM_GE</sym></sub>
</code>
</item>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<item>Otherwise, <sym>GROUP_BY</sym> is the zero-length character string and <sym>GKRISET</sym> is
the empty set.
</item>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>NONAGGREGATING_ITEMS</symdef> be the set of <BNF name="select item"/>s determined
as follows:

<olist>

<comment>WG3:W25-029R1</comment>
<item>Initially, <sym>NONAGGREGATING_ITEMS</sym> is the empty set.
</item>

<comment>WG3:W25-029R1</comment>
<item>For every <BNF name="select item"/> <symdef>SI</symdef> in <sym>XOISISET</sym> not included
in <sym>AGGREGATING_ITEMS</sym>,

<para>Case:
</para>

<olist>


<comment>WG3:W25-029R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-12 non-empty</comment>
<item>If <sym>GKRISET</sym> is non-empty, then:

<olist>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>COSI</symdef> be a copy of <sym>SI</sym> with every simply contained
<BNF name="binding variable reference"/> that is a <BNF name="value expression"/> of
a <BNF name="return item"/> <symdef>RI</symdef> in <sym>GKRISET</sym> replaced with
the <BNF name="identifier"/> immediately contained in the <BNF name="return item alias"/>
immediately contained in <sym>RI</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<item><sym>COSI</sym> is added to <sym>NONAGGREGATING_ITEMS</sym>
</item>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<item>Otherwise, <sym>SI</sym> is added to <sym>NONAGGREGATING_ITEMS</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<item>Let the set of <BNF name="return item"/>s <symdef>SARISET</symdef> be determined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W25-029R1</comment>
<item>If <sym>SELECTSTM</sym> immediately contains
an <BNF name="order by clause"/> <symdef>OBC</symdef>, then:

<olist>

<comment>WG3:W25-029R1</comment>
<item>Initially, <sym>SARISET</sym> is the empty set.
</item>

<comment>WG3:W25-029R1</comment>
<item>For every <BNF name="sort key"/> <symdef>SK</symdef> simply contained in <sym>OBC</sym>
that directly contains an <BNF name="aggregate function"/>:

<olist>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>OBVE</symdef> be the <BNF name="value expression"/> immediately contained in
<sym>SK</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<comment>WG3:W26-037R3</comment>
<item>Let <symdef>OBVEID</symdef> be a new system-generated regular identifier.
</item>

<comment>WG3:W25-029R1</comment>
<item>The following <BNF name="return item"/> is added to <sym>SARISET</sym>:
<code>
<sym>OBVE</sym> <kw>AS</kw> <sym>OBVEID</sym>
</code>
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<item>Otherwise, <sym>SARISET</sym> is the empty set.
</item>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<item>Let the sets of <BNF name="return item"/>s <symdef>ARISET</symdef> and
<symdef>PARISET</symdef> be determined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W25-029R1</comment>
<item>If <sym>AGGREGATING_ITEMS</sym> is not the empty set, then:

<olist>

<comment>WG3:W25-029R1</comment>
<item>Initially, both <sym>ARISET</sym> and <sym>PARISET</sym> are the empty set.
</item>

<comment>WG3:W25-029R1</comment>
<comment>WG3:W25-029R1</comment>
<item>For <symdef>k</symdef>, 1 (one) <leq/> <sym>k</sym> <leq/> <sym>NUM_AGGREGATING</sym>:

<olist>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>ITEM</symdef><sub><sym>k</sym></sub> be the <sym>k</sym>-th element of
<sym>AGGREGATING_ITEMS</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<item><sym>ITEM</sym><sub><sym>k</sym></sub> shall immediately contain
a <BNF name="select item alias"/>.
Let <symdef>ITEM_ALIAS</symdef><sub><sym>k</sym></sub> be the <BNF name="identifier"/> immediately
contained in that <BNF name="select item alias"/>.
</item>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>ITEM_EXPR</symdef><sub><sym>k</sym></sub> be the <BNF name="value expression"/>
immediately contained in <sym>ITEM</sym><sub><sym>k</sym></sub>.
</item>

<comment>WG3:W25-029R1</comment>
<comment>WG3:W26-037R3</comment>
<item>Let <symdef>ITEM_ID</symdef><sub><sym>k</sym></sub> be 
a new system-generated regular identifier.
</item>

<comment>WG3:W25-029R1</comment>
<item>The following <BNF name="return item"/> is added to <sym>ARISET</sym>:
<code>
<sym>ITEM_EXPR</sym><sub><sym>k</sym></sub> <kw>AS</kw> <sym>ITEM_ID</sym><sub><sym>k</sym></sub>
</code>
</item>

<comment>WG3:W25-029R1</comment>
<item>The following <BNF name="return item"/> is added to <sym>PARISET</sym>:
<code>
<symdef>ITEM_ID</symdef><sub><sym>k</sym></sub> <kw>AS</kw> <sym>ITEM_ALIAS</sym><sub><sym>k</sym></sub>
</code>
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<item>Otherwise, both <sym>ARISET</sym> and <sym>PARISET</sym> are the empty set.
</item>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<item>Let the set of <BNF name="return item"/>s <symdef>HARISET</symdef> and 
the <BNF name="filter statement"/> <symdef>HAVING_FILTER</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W25-029R1</comment>
<item>If <symdef>SELECTSTM</symdef> immediately contains
a <BNF name="having clause"/> <symdef>HC</symdef>, then:

<olist>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>HCCOND</symdef> be the <BNF name="search condition"/> immediately contained
in <sym>HC</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>HCBVE</symdef> be the <BNF name="boolean value expression"/> immediately contained
in <sym>HCCOND</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<comment>WG3:W26-037R3</comment>
<item>Let <symdef>HCID</symdef> be a new system-generated regular identifier.
</item>

<comment>WG3:W25-029R1</comment>
<item><sym>HARISET</sym> is the set comprising the <BNF name="return item"/>:
<code>
<sym>HCBVE</sym> <kw>AS</kw> <sym>HCID</sym>
</code>
</item>

<comment>WG3:W25-029R1</comment>
<item><sym>HAVING_FILTER</sym> is:
<code>
<kw>FILTER</kw> <kw>WHERE</kw> <sym>HCID</sym>
</code>
</item>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<item>Otherwise, <sym>HARISET</sym> is the empty set and <sym>HAVING_FILTER</sym> is
the zero-length character string.
</item>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>LET_ITEMS</symdef> be determined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W25-029R1</comment>
<item>If <sym>XOISISET</sym> does not directly contain an <BNF name="aggregate function"/> and
<sym>SELECTSTM</sym> immediately contains an <BNF name="order by clause"/> <symdef>LOBC</symdef>
that directly contains a <BNF name="sort key"/> that is not
a <BNF name="binding variable reference"/> and does not contain 
an <BNF name="aggregate function"/>:

<olist>

<comment>WG3:W25-029R1</comment>
<item>Initially, <sym>LET_ITEMS</sym> is the empty set.
</item>

<comment>WG3:W25-029R1</comment>
<item>For every <BNF name="sort key"/> <symdef>LSK</symdef> directly contained in <sym>LOBC</sym>
that is not a <BNF name="binding variable reference"/> and that does not contain
an <BNF name="aggregate function"/>:

<olist>

<comment>WG3:W25-029R1</comment>
<comment>WG3:W26-037R3</comment>
<item>Let <symdef>LET_IDENT</symdef> be a new system-generated regular identifier.
</item>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>LET_EXPR</symdef> be the <BNF name="value expression"/> immediately contained
in <sym>LSK</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<item>The following <BNF name="let variable definition"/> is added to <sym>LET_ITEMS</sym>:
<code>
<sym>LET_IDENT</sym> = <sym>LET_EXPR</sym> 
</code>
</item>

</olist>

</item>
</olist>

</item>

<comment>WG3:W25-029R1</comment>
<item>Otherwise, <sym>LET_ITEMS</sym> is the empty set.
</item>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>LETSTM</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W25-029R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-12 non-empty</comment>
<item>If <sym>LET_ITEMS</sym> is non-empty, then:

<olist>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>NUM_LET_ITEMS</symdef> be the number of elements in <sym>LET_ITEMS</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<comment>WG3:CMN-019 P00-NLD-050</comment>
<item>For <symdef>l</symdef>, 1 (one) <leq/> <sym>l</sym> <leq/> <sym>NUM_LET_ITEMS</sym>, 
let <symdef>LET_ITEM</symdef><sub><sym>l</sym></sub> be the <sym>l</sym>-th element of 
<sym>LET_ITEMS</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<item><symdef>LETSTM</symdef> is the <BNF name="let statement"/>:
<code>
<kw>LET</kw> <sym>LET_ITEM</sym><sub>1</sub>, <ellipsis/>, <sym>LET_ITEM</sym><sub><sym>NUM_LET_ITEMS</sym></sub>
</code>
</item>

</olist>
</item>

<item>Otherwise, <sym>LETSTM</sym> is the zero-length character string.
</item>

</olist>

</item>


<comment>WG3:W25-029R1</comment>
<item>If <sym>SELECTSTM</sym> immediately contains a <BNF name="select item list"/> that directly
contains an <BNF name="aggregate function"/> or if <sym>SELECTSTM</sym> immediately contains
a <BNF name="group by clause"/> that does not simply contain an <BNF name="empty grouping set"/>,
then for every <BNF name="sort key"/> <symdef>SESK</symdef> directly contained in
<sym>SELECTSTM</sym>,

<para>Case:
</para>

<olist>

<comment>WG3:W25-029R1</comment>
<item>If <sym>SESK</sym> is a <BNF name="binding variable reference"/> <symdef>SEBVR</symdef>, then
<sym>SEBVR</sym> shall be equivalent to an <BNF name="identifier"/> immediately contained in
a <BNF name="select item alias"/> directly contained in <sym>SELECTSTM</sym> or
a <BNF name="regular identifier"/> that is a <BNF name="grouping element"/> directly contained in
<sym>SELECTSTM</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<item>Otherwise, for every <BNF name="binding variable reference"/> <symdef>OSEBVR</symdef> that is
directly contained in <sym>SESK</sym>, <sym>OSEBVR</sym> shall be equivalent to
a <BNF name="grouping element"/> of a <BNF name="group by clause"/> immediately contained
in <sym>SELECTSTM</sym>.
</item>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>ORDER_BY</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W25-029R1</comment>
<item>If <sym>SELECTSTM</sym> immediately contains
an <BNF name="order by clause"/> <symdef>OIOBC</symdef>, then:

<olist>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>OISEQ</symdef> be the sequence determined as follows.

<olist>

<comment>WG3:W25-029R1</comment>
<item>Initially, <sym>OISEQ</sym> is the empty sequence.
</item>

<comment>WG3:W25-029R1</comment>
<item>For every <BNF name="sort key"/> <symdef>OISK</symdef> simply contained in <sym>OIOBC</sym>,

<para>Case:
</para>

<olist>

<comment>WG3:W25-029R1</comment>
<item>If <sym>SARISET</sym> is not the empty set and <sym>OISK</sym> directly contains
an <BNF name="aggregate function"/>, then the <BNF name="identifier"/> immediately contained in
the <BNF name="return item alias"/> immediately contained in a <BNF name="return item"/> in
<sym>ARISET</sym> whose <BNF name="value expression"/> is <sym>OISK</sym> is added to
<sym>OISEQ</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<item>If <sym>GKRISET</sym> is not the empty set and <sym>OISK</sym> is not
a <BNF name="binding variable reference"/>, then:

<olist>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>COOISK</symdef> be a copy of <sym>OISK</sym> in which all simply
contained <BNF name="binding variable reference"/>s that are the <BNF name="value expression"/> of 
a <BNF name="return item"/> <symdef>OIRI</symdef> in <sym>GKRISET</sym> are replaced with
the <BNF name="identifier"/> immediately contained in the <BNF name="return item alias"/>
immediately contained in <sym>OIRI</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<item><sym>COOISK</sym> is added to <sym>OISEQ</sym>.
</item>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<comment>WG3:W27-011</comment>
<item>If <sym>LET_ITEMS</sym> is not the empty set and <sym>OISK</sym> is
a <BNF name="value expression"/> immediately contained in
a <BNF name="let variable definition"/> <symdef>OILVD</symdef>, then
the <BNF name="binding variable"/> immediately contained in <sym>OILVD</sym> is added to
<sym>OISEQ</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<item>Otherwise, <sym>OISK</sym> is added to <sym>OISEQ</sym>.
</item>

</olist>

</item>

</olist>

</item>

<item>Let <symdef>NUM_OIS</symdef> be the number of elements of <sym>OISEQ</sym>.
</item>

<comment>WG3:CMN-019 P00-NLD-050</comment>
<item>For <symdef>m</symdef>, 1 (one) <leq/> <sym>m</sym> <leq/> <sym>NUM_OIS</sym>, 
let <symdef>OI</symdef><sub><sym>m</sym></sub> be the <sym>m</sym>-th element of <sym>OISEQ</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<item><sym>ORDER_BY</sym> is the comma-separated concatenation of the elements of <sym>OISEQ</sym>:
<code>
<sym>OI</sym><sub>1</sub>, <ellipsis/>, <sym>OI</sym><sub><sym>NUM_OIS</sym></sub>
</code>
</item>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<item>Otherwise, <sym>ORDER_BY</sym> is the zero-length character string.
</item>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>RETURN_FIRST</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W25-029R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-12 non-empty</comment>
<item>If <sym>AGGREGATING_ITEMS</sym> is non-empty, then:

<olist>

<comment>WG3:W25-029R1</comment>
<comment>WG3:W25-029R1</comment>
<item>Let <symdef>FIRST_ITEMS</symdef> be the union of <sym>GKRISET</sym>, <sym>SARISET</sym>,
<sym>ARISET</sym>, and <sym>HARISET</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>NUM_FIRST</symdef> be the number of elements of <sym>FIRST_ITEMS</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<comment>WG3:CMN-019 P00-NLD-050</comment>
<item>Let <symdef>FSTRIL</symdef> be a permutation of <sym>FIRST_ITEMS</sym>.
For <symdef>p</symdef>, 1 (one) <leq/> <sym>p</sym> <leq/> <sym>NUM_FIRST</sym>, 
let <symdef>FIRST_ITEM</symdef><sub><sym>p</sym></sub> be the <sym>p</sym>-th element of
<sym>FSTRIL</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<item><sym>RETURN_FIRST</sym> is the comma-separated concatenation of the elements of
<sym>FIRST_ITEMS</sym>:
<code>
<sym>FIRST_ITEM</sym><sub>1</sub>, <ellipsis/>, <sym>FIRST_ITEM</sym><sub><sym>NUM_FIRST</sym></sub>. 
</code>
</item>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<item>Otherwise, <sym>RETURN_FIRST</sym> is the zero-length character string.
</item>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>RETURN_LAST</symdef> be defined as follows.

<olist>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>LAST_ITEMS</symdef> be the union of <sym>NONAGGREGATING_ITEMS</sym> and
<sym>PARISET</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<item>For <symdef>q</symdef>, 1 (one) <leq/> <sym>q</sym> <leq/> <sym>NUM_SIS</sym>,
let <symdef>LAST_ITEM</symdef><sub><sym>q</sym></sub> be defined as follows:

<olist>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>ALIAS</symdef> be the <sym>q</sym>-th element of <sym>XOISIASEQ</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<item><sym>LAST_ITEM</sym><sub><sym>q</sym></sub> is the element of
<sym>LAST_ITEMS</sym> whose <BNF name="return item alias"/> immediately contains
an <BNF name="identifier"/> that is equivalent to <sym>ALIAS</sym>.
</item>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<item><sym>RETURN_LAST</sym> is the comma-separated concatenation of the elements of
<sym>LAST_ITEMS</sym>:
<code>
<sym>LAST_ITEM</sym><sub>1</sub>, <ellipsis/>, <sym>LAST_ITEM</sym><sub><sym>NUM_SIS</sym></sub>
</code>
</item>

</olist>

</item>

<comment>WG3:W23-028R2</comment>
<item>Let <symdef>OFFCL</symdef> be defined as follows. 
If <BNF name="offset clause"/> is specified, then <sym>OFFCL</sym> is the 
<BNF name="offset clause"/>; otherwise, <sym>OFFCL</sym> is the zero-length character string.
</item>

<comment>WG3:W23-028R2</comment>
<item>Let <symdef>LIMCL</symdef> be defined as follows. 
If <BNF name="limit clause"/> is specified, then <sym>LIMCL</sym> is the 
<BNF name="limit clause"/>; otherwise, <sym>LIMCL</sym> is the zero-length character string.
</item>

<comment>WG3:W26-030R1</comment>
<item>Let the <BNF name="variable scope clause"/> <symdef>VSC</symdef> and 
<BNF name="return item list"/> <symdef>SSBRIL</symdef> be defined as follows:

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>INCVARSEQ</symdef> be a sequence of all names of field types and columns of the 
incoming working record type and the incoming working table type and 
let <symdef>NINCVARSEQ</symdef> be the number of such names.
</item>
<endbar/>

<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NINCVARSEQ</sym>, 
let <symdef>INCVAR</symdef><sub><sym>i</sym></sub> be the <sym>i</sym>-th name in 
<sym>INCVARSEQ</sym> and let <symdef>INCBVR</symdef><sub><sym>i</sym></sub> be 
an <BNF name="identifier"/> whose canonical name form is <sym>INCVAR</sym><sub><sym>i</sym></sub>.
</item>

<item><sym>VSC</sym> is the comma-separated list of <BNF name="binding variable reference"/>s
defined as follows:

<code>
( <sym>INCBVR</sym><sub>1</sub>, <ellipsis/>, <sym>INCBVR</sym><sub><sym>NINCVARSEQ</sym></sub> )
</code>

</item>

<item>Let <symdef>SSBVARSEQ</symdef> be the defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>SSB</sym> immediately contains the <BNF name="select graph match list"/> 
<symdef>SGML</symdef>, then:

<olist>

<item>Let <symdef>SSBVARSET</symdef> be the set of all column names of the declared types of the
outgoing working tables of all <BNF name="match statement"/>s simply contained in <sym>SGML</sym>.
</item>

<item><sym>SSBVARSEQ</sym> is a sequence of all names in <sym>SSBVARSET</sym> without 
the names in <sym>INCVARSEQ</sym>.
</item>

</olist>

</item>

<item>Otherwise, <sym>SSB</sym> immediately contains the <BNF name="select query specification"/>
<symdef>SQS</symdef> and <symdef>SSBVARSEQ</symdef> is the sequence of all column names of the 
declared type of the <BNF name="nested query specification"/> immediately contained in 
<sym>SQS</sym>.
</item>

</olist>

</item>

<item>Let <symdef>NSSBVARSEQ</symdef> be the number of names in <sym>SSBVARSEQ</sym>.
</item>

<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NSSBVARSEQ</sym>, 
let <symdef>SSBVAR</symdef><sub><sym>i</sym></sub> be the <sym>i</sym>-th name in 
<sym>SSBVARSEQ</sym> and let <symdef>SSBBVR</symdef><sub><sym>i</sym></sub> be 
an <BNF name="identifier"/> whose canonical name form is <sym>SSBVAR</sym><sub><sym>i</sym></sub>.
</item>

<item><sym>SSBRIL</sym> is the comma-separated list of <BNF name="return item"/>s defined as 
follows:

<code>
<sym>SSBBVR</sym><sub>1</sub> AS SSBBVR<sub>1</sub>, <ellipsis/>, <sym>SSBBVR</sym><sub><sym>NSSBVARSEQ</sym></sub> AS <sym>SSBBVR</sym><sub><sym>NSSBVARSEQ</sym></sub>
</code>

</item>

</olist>

</item>

<comment>WG3:W23-028R2</comment>
<item>Let <symdef>BODY</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W23-028R2</comment>
<item>If <sym>SSB</sym> immediately contains the
<BNF name="select graph match list"/> <symdef>SGML</symdef>, then:

<olist>

<item>Let <symdef>NUM_SGMS</symdef> be the number of <BNF name="select graph match"/>es immediately
contained in <sym>SGML</sym>.
</item>

<item>For <symdef>r</symdef>, 1 (one) <leq/> <sym>r</sym> <leq/> <sym>NUM_SGMS</sym>:

<olist>

<item>Let <symdef>SGM</symdef><sub><sym>r</sym></sub> be the <sym>r</sym>-th
<BNF name="select graph match"/> in <sym>SGML</sym>.
</item>

<item>Let <symdef>GREXP</symdef><sub><sym>r</sym></sub> be the <BNF name="graph expression"/>
immediately contained in <sym>SGM</sym><sub><sym>r</sym></sub>.
</item>

<item>Let <symdef>MATCHSTM</symdef><sub><sym>r</sym></sub> be the <BNF name="match statement"/>
immediately contained in <sym>SGM</sym><sub><sym>r</sym></sub>.
</item>

</olist>

</item>

<item><symdef>BODY</symdef> is:

<comment>WG3:W26-030R1</comment>
<code>
CALL <sym>VSC</sym> {
  <kw>USE</kw> <sym>GREXP</sym><sub>1</sub> <sym>MATCHSTM</sym><sub>1</sub>
  <ellipsis/>
  <kw>USE</kw> <sym>GREXP</sym><sub><sym>NUM_SGMS</sym></sub> <sym>MATCHSTM</sym><sub><sym>NUM_SGMS</sym></sub>
  RETURN <sym>SSBRIL</sym>
}
</code>

</item>
<comment>WG3:W25-029R1 Deleted 1 (one) SR</comment>

</olist>

</item>

<comment>WG3:W23-028R2</comment>
<item>If <sym>SSB</sym> immediately contains the <BNF name="select query specification"/>
<symdef>SQS</symdef>, then:

<olist>

<item>Let <symdef>NQS</symdef> be the <BNF name="nested query specification"/> immediately contained
in <sym>SQS</sym>.
</item>

<comment>WG3:W25-029R1</comment>
<item>Case:

<olist>

<item>If <sym>SQS</sym> immediately contains a <BNF name="graph expression"/>, then <sym>NQS</sym>
shall simply contain an <BNF name="ambient linear query statement"/>.
</item>

<item>Otherwise, <sym>SQS</sym> does not immediately contain a <BNF name="graph expression"/> and
<sym>NQS</sym> shall simply contain a <BNF name="focused linear query statement"/>.
</item>

</olist>

</item>

<item>Let <symdef>USECL</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>SQS</sym> immediately contains a <BNF name="graph expression"/> 
<symdef>GREXP</symdef>, then <symdef>USECL</symdef> is:

<code>
 <kw>USE</kw> <sym>GREXP</sym>
 </code>
 
</item>

<item>Otherwise <sym>USECL</sym> is the zero-length character string.
</item>

</olist>

</item>

<comment>WG3:UTC-101</comment>
<comment>WG3:W25-029R1</comment>
<item><sym>BODY</sym> is:

<comment>WG3:W26-030R1</comment>
<code>
CALL <sym>VSC</sym> {
  <sym>USECL</sym>
  <kw>CALL</kw> <sym>NQS</sym>
  RETURN <sym>SSBRIL</sym>
}
</code>

</item>

</olist>

</item>

<comment>WG3:W23-028R2</comment>
<comment>WG3:W25-029R1</comment>
<item>Otherwise, <sym>BODY</sym> is the zero-length character string.
</item>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<comment>WG3:W25-029R1</comment>
<item>After the application of all preceding Syntax Rules,

<para>Case:
</para>

<olist>

<comment>WG3:W25-029R1</comment>
<item>If <sym>BODY</sym> is the zero-length character string, then <sym>SELECTSTM</sym> is
equivalent to:
<code>
<kw>RETURN</kw> <sym>SETQ</sym> <sym>XOISIL</sym>
</code>

<comment>WG3:W25-029R1</comment>
<para>and no further Syntax Rules of this Subclause are applied.
</para>

</item>

<item>Otherwise:

<olist>

<comment>WG3:W25-029R1</comment>
<item>Let <symdef>REPLACEMENT</symdef> be determined as follows.

<olist>

<comment>WG3:W25-029R1</comment>
<item>Initially, <sym>REPLACEMENT</sym> is:
<code>
<sym>BODY</sym>
<sym>FILTERSTM</sym>
</code>
</item>

<comment>WG3:W25-029R1</comment>
<item>If <sym>RETURN_FIRST</sym> is not the zero-length character string, then the following is
appended to <sym>REPLACEMENT</sym>:
<code>
<kw>RETURN</kw> <sym>SETQ</sym> <sym>RETURN_FIRST</sym>
<sym>GROUP_BY</sym>
<kw>NEXT</kw>
</code>
</item>

<comment>WG3:W25-029R1</comment>
<item>The following is appended to <sym>REPLACEMENT</sym>:
<code>
<sym>HAVING_FILTER</sym>
<sym>LETSTM</sym>
<kw>RETURN</kw> <sym>SETQ</sym> <sym>RETURN_LAST</sym>
<sym>ORDER_BY</sym> <sym>OFFCL</sym> <sym>LIMCL</sym>
</code>
</item>

</olist>

</item>

<comment>WG3:W25-029R1</comment>
<item><sym>SELECTSTM</sym> is effectively replaced by <sym>REPLACEMENT</sym>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W25-029R1 with adjustments</comment>
<comment>WG3:CMN-019 P00-USA-077</comment>
<comment>WG3:CMN-049</comment>
<item>Without <feature code="GA07"/>, in conforming GQL language, the <BNF name="order by clause"/> 
immediately contained in a <BNF name="select statement"/> shall not directly contain 
a <BNF name="sort key"/> that directly contains a <BNF name="binding variable reference"/> that is 
not equivalent to the <BNF name="identifier"/> immediately contained in 
a <BNF name="select item alias"/> that is directly contained in the <BNF name="select statement"/> 
unless the referenced binding variable of the <BNF name="binding variable reference"/> is defined by
an intervening BNF non-terminal instance simply contained in the <BNF name="sort key"/>.
</item>

<comment>WG3:CMN-019 P00-USA-083</comment>
<comment>WG3:CMN-019 P00-USA-077</comment>

<comment>WG3:CMN-019 P00-USA-083</comment>

<comment>WG3:CMN-019 P00-USA-083</comment>
<comment>WG3:CMN-019 P00-USA-077</comment>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>
<comment>WG3:UTC-064 Deleted 1 (one) Subclause</comment>

</clause>


<comment>WG3:UTC-122</comment>
<clause id="gql_stm">
<comment>WG3:GYD-030</comment>
<clauseHeading>Procedure calling and control flow</clauseHeading>

<subClause id="gql_stm_proc_call">
<clauseHeading><BNF name="call procedure statement"/> and 
<BNF name="procedure call"/></clauseHeading>

<bodyMatter>


<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:OHD-017</comment>
<para>Execute a procedure.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:W23-015</comment>
<BNFdef name="call procedure statement">
<rhs>
<opt> <kw>OPTIONAL</kw> </opt> <kw>CALL</kw> <BNF name="procedure call"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-086R1</comment>
<BNFdef name="procedure call">
<rhs>
<alt> <BNF name="inline procedure call"/> </alt>
<alt> <BNF name="named procedure call"/> </alt>
</rhs>
</BNFdef>

</grammar>

<ednote id="gql_PP169">Consider allowing <BNF name="where clause"/>.
See <PPref ref="PPgql169"/>.
</ednote>

<comment>Editorial: Stefan Plantikow, 2020-11-11 Suggest standalone calls</comment>
<ednote id="gql_PP168">Consider adding standalone calls.
A standalone call is a syntax shorthand for a <BNF name="call procedure statement"/> that
implies 
<code><kw>YIELD</kw> * <kw>RETURN</kw> *</code>
and that can only occur as valid singular (or perhaps last) top-level statement executed by 
a procedure.
<comment>WG3:UTC-064 Consequence</comment>
Standalone calls could be added by following existing syntactic precedence from Cypher or
by introducing completely new syntax.
See <PPref ref="PPgql168"/>.
</ednote>

</Format>


<comment>Editorial: Stefan Plantikow, 2020-05-10 Informal Semantics removed</comment>
<SyntaxRules>

<olist>

<comment>Editorial: Stephen Cannan, 2020-04-15</comment>
<item>Let <symdef>CPS</symdef> be the <BNF name="call procedure statement"/>.
</item>

<item>Let <symdef>PC</symdef> be the <BNF name="procedure call"/> immediately contained in
<sym>CPS</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2020-05-13 One GR extracted</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-12 Adjust</comment>
<comment>Editorial: Stephen Cannan, 2022-03-07 WG3:RKE-010 P00-USA-479</comment>
<comment>WG3:W23-015 One SR removed</comment>

<comment>WG3:OHD-017</comment>
<comment>WG3:UTC-086R1</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>Let the record type <symdef>IWRT</symdef> be the incoming working record type
of <sym>CPS</sym>.
</item>

<comment>WG3:OHD-017</comment>
<comment>WG3:UTC-086R1</comment>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>IWTTRT</symdef> be the record type of the incoming working table type
of <sym>CPS</sym>.
</item>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-019 P00-USA-084</comment>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>IREDTPC</symdef> be <sym>IWRT</sym> amended by <sym>IWTTRT</sym>.
</item>

<comment>WG3:OHD-017</comment>
<comment>WG3:UTC-086R1</comment>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>PC</sym> is <sym>IREDTPC</sym>.
</item>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>PC</sym> is the material unit 
binding table type.
</item>
<endbar/>

<comment>WG3:OHD-017</comment>
<comment>WG3:UTC-086R1</comment>
<item>Let <symdef>OTARTPC</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<item id="gql_gql_stm_proc_call_SR_NPC">If <sym>PC</sym> is the <BNF name="named procedure call"/> 
<symdef>NPC</symdef> and <sym>NPC</sym> has a declared type, then <sym>OTARTPC</sym> is 
the record type of the declared type of <sym>NPC</sym>.

<ednote id="gql_PP423">A <BNF name="named procedure call"/> can in principle return a result of 
any possible result type, not just binding tables. 
This needs to be protected against here as the calling context is not yet ready to handle 
non-tabular returns. 
</ednote>
</item>

<comment>WG3:CMN-019 P00-USA-085</comment>
<comment>WG3:GYD-011</comment>
<item id="gql_gql_stm_proc_call_SR_IPC">If <sym>PC</sym> is the <BNF name="inline procedure call"/>
<symdef>IPC</symdef> and <sym>IPC</sym> has a declared type that is a binding table type, then 
<sym>OTARTPC</sym> is the record type of the declared type of <sym>IPC</sym>.
</item>

<item id="gql_gql_stm_proc_call_SR_Other">Otherwise, <sym>OTARTPC</sym> is 
the material unit record type.
</item>

</olist>

</item>

<comment>WG3:OHD-017</comment>
<comment>WG3:UTC-086R1</comment>
<comment>WG3:GYD-011</comment>
<item id="gql_stm_proc_call_SR_disjoint"><sym>IREDTPC</sym> and <sym>OTARTPC</sym> shall be 
field name-disjoint.
</item>

<comment>WG3:OHD-017</comment>
<comment>WG3:UTC-086R1</comment>
<item>Let <symdef>OTART</symdef> be <sym>IWTTRT</sym> amended with <sym>OTARTPC</sym>.
</item>

<comment>WG3:OHD-017</comment>
<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-019 P00-NLD-019</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The outgoing working record type of <sym>CPS</sym> is <sym>IWRT</sym>.
</item>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:XRH-036</comment>
<item>The outgoing working table type of <sym>CPS</sym> is the binding table type 
whose record type is <sym>OTART</sym>.
</item>
<endbar/>

<comment>WG3:OHD-017</comment>
<comment>WG3:W26-026R2</comment>
<item>The declared type of <sym>CPS</sym> is the empty type.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2020-05-11 Sketched GRs for CALL</comment>
<comment>Editorial: Stefan Plantikow, 2020-05-13 GRs extracted to procedure call yield</comment>
<olist>

<item>Let <symdef>TABLE</symdef> be the current working table.
</item>

<comment>WG3:OHD-017</comment>
<comment>WG3:CMN-057R1</comment>
<item>Let <symdef>NEW_TABLE</symdef> be a new empty binding table whose columns are the 
field types of <sym>OTART</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2020-10-16 Create fresh context</comment>
<comment>WG3:W12-019</comment>
<item>For each record <symdef>R</symdef> of <sym>TABLE</sym> in a new child execution context
amended with <sym>R</sym>:

<olist>

<comment>Editorial: Stefan Plantikow, 2022-03-25 WG3:RKE-010 P00-NLD-219 Wording</comment>
<comment>WG3:OHD-024</comment>
<comment>WG3:CMN-047R1</comment>
<item>Case:

<olist>

<comment>WG3:CMN-047R1</comment>
<item>If <sym>PC</sym> is an <BNF name="inline procedure call"/>, then the General Rules of
<specref ref="gql_inline_procedure_call"/> are applied.
</item>

<comment>WG3:CMN-047R1</comment>
<item>Otherwise, <sym>PC</sym> is a <BNF name="named procedure call"/> and the General Rules of
<specref ref="gql_named_procedure_call"/> are applied.
</item>

</olist>

</item>

<comment>WG3:OHD-024</comment>
<item>Let <symdef>RESULT</symdef> be a new binding table defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:CMN-057R1</comment>
<item>If the current execution result is a binding table <symdef>RESULT_TABLE</symdef>, then 
<sym>RESULT</sym> is <sym>RESULT_TABLE</sym> and the columns of <sym>RESULT</sym> are the
field types of <sym>OTARTPC</sym>.
</item>

<comment>WG3:W23-015</comment>
<item>Otherwise, the current execution result is omitted and <sym>RESULT</sym> is a unit binding
table.
</item>

</olist>

</item>

<comment>WG3:W23-015</comment>
<comment>WG3:CMN-047R1</comment>
<item>Let <symdef>OPTIONAL_RESULT</symdef> be a new binding table defined as follows.

<para>Case:
</para>

<olist>
<comment>WG3:CMN-047R1 2 deleted one Subrule</comment>

<comment>WG3:CMN-047R1</comment>
<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<item>If <sym>CPS</sym> immediately contains <kw>OPTIONAL</kw> and <sym>RESULT</sym> is
an empty binding table result, then <sym>OPTIONAL_RESULT</sym> comprises a new record of type
<sym>OTARTPC</sym> in which every field value is the null value.
</item>

<comment>WG3:CMN-047R1</comment>
<item>Otherwise, <sym>OPTIONAL_RESULT</sym> is <sym>RESULT</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-047R1</comment>
<item>The Cartesian product of <sym>R</sym> and <sym>OPTIONAL_RESULT</sym> is appended to
<sym>NEW_TABLE</sym>.
</item>

</olist>

</item>

<comment>WG3:W23-015</comment>

<comment>WG3:CMN-019 P00-USA-351</comment>
<item>The current working table is set to <sym>NEW_TABLE</sym>.
</item>

<comment>WG3:CMN-019 P00-USA-351</comment>
<item>The current execution outcome is set to a successful outcome with an omitted result.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_inline_procedure_call" newpage="true">
<clauseHeading><BNF name="inline procedure call"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-05-12 Added inline procedure calls</comment>
<bodyMatter>

<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:OHD-017</comment>
<para>Execute a procedure that is specified inline.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:OHD-017</comment>
<BNFdef name="inline procedure call">
<rhs>
<opt> <BNF name="variable scope clause"/> </opt> <BNF name="nested procedure specification"/>
</rhs>
</BNFdef>

<comment>WG3:OHD-017</comment>
<BNFdef name="variable scope clause">
<rhs>
<BNF name="left paren"/> 
<opt> <BNF name="binding variable reference list"/> </opt> 
<BNF name="right paren"/>
</rhs>
</BNFdef>

<comment>WG3:OHD-017</comment>
<BNFdef name="binding variable reference list">
<rhs>
<BNF name="binding variable reference"/> 
<opt> <group> <BNF name="comma"/> <BNF name="binding variable reference"/> </group><repeat/> </opt>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>Editorial: Stephen Cannan, 2023-10-10, Defined missing symbol</comment>
<item>Let <symdef>IPC</symdef> be the <BNF name="inline procedure call"/>.
</item>

<comment>WG3:OHD-017</comment>
<item>Let <symdef>PROC</symdef> be the <BNF name="nested procedure specification"/>
immediately contained in <sym>IPC</sym>.
</item>

<comment>WG3:OHD-017</comment>
<item>If <BNF name="variable scope clause"/> is not specified, then:

<olist>

<comment>Editorial: Stefan Plantikow, 2022-10-06 Add WR site</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>FNL</symdef> be a comma-separated list of all the field type names of
the incoming working record type of <sym>IPC</sym>.
</item>
<endbar/>

<item><sym>IPC</sym> is effectively replaced by:
<code>
(<sym>FNL</sym>) <sym>PROC</sym>
</code>
</item>

</olist>

</item>

<comment>WG3:OHD-017</comment>
<comment>WG3:CMN-082</comment>
<item>Let <symdef>VSC</symdef> be the implicit or explicit <BNF name="variable scope clause"/>
immediately contained in <sym>IPC</sym>.
</item>

<comment>WG3:CMN-082</comment>
<item>For every <BNF name="binding variable reference"/> <symdef>BVR</symdef> simply contained in
<sym>VSC</sym>:

<olist>

<comment>WG3:CMN-082</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>BVR</sym> is the incoming working record type
of <sym>IPC</sym>.
</item>

<comment>WG3:CMN-082</comment>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>BVR</sym> is the incoming working table type
of <sym>IPC</sym>.
</item>
<endbar/>

</olist>

</item>

<comment>WG3:OHD-017</comment>
<item>Let <symdef>BVRLN</symdef> be defined as follows:

<olist>

<item>If <sym>VSC</sym> immediately contains a <BNF name="binding variable reference list"/> 
<symdef>BVRL</symdef>, then:

<olist>

<item><sym>BVRLN</sym> is the sequence of names of the binding variables referenced by the
<BNF name="binding variable reference"/>s immediately contained in <sym>BVRL</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-01-05 Correct to use equal</comment>
<item><sym>BVRLN</sym> shall not contain two equal names at different positions.
</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-NLD-060</comment>
<item>Otherwise, <sym>BVRLN</sym> is the empty sequence.
</item>

</olist>

</item>

<comment>WG3:OHD-017</comment>
<comment>WG3:CMN-082</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>PROC</sym> is the incoming working record type
of <sym>IPC</sym> comprising the field types identified by <sym>BVRLN</sym>.
</item>

<comment>WG3:OHD-017</comment>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>PROC</sym> is the incoming working table type
of <sym>IPC</sym>.
</item>

<comment>WG3:OHD-017</comment>
<comment>WG3:XRH-036</comment>
<item>The outgoing working record type of <sym>IPC</sym> is the outgoing working record type
of <sym>PROC</sym>.
</item>

<comment>WG3:OHD-017</comment>
<comment>WG3:XRH-036</comment>
<item>The outgoing working table type of <sym>IPC</sym> is the outgoing working table type
of <sym>PROC</sym>.
</item>
<endbar/>

<comment>WG3:OHD-017</comment>
<item>The declared type of <sym>IPC</sym> is the declared type of <sym>PROC</sym>.
</item>
</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:OHD-017</comment>
<comment>WG3:CMN-082</comment>
<item>Let <symdef>R</symdef> be the current working record comprising the fields identified by 
<sym>BVRLN</sym>.
</item>

<comment>WG3:OHD-017</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item>The current working record is set to <sym>R</sym>.
</item>

<comment>WG3:OHD-017</comment>
<item>The General Rules of <sym>PROC</sym> are applied.
</item>

<comment>WG3:OHD-017</comment>
<item>The outcome of <sym>IPC</sym> is the outcome of <sym>PROC</sym>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:OHD-017</comment>
<item>Without <feature code="GP01"/>, conforming GQL language shall not contain
an <BNF name="inline procedure call"/>.
</item>

<comment>WG3:OHD-017</comment>
<item>Without <feature code="GP02"/>, in conforming GQL language, 
an <BNF name="inline procedure call"/> shall contain a <BNF name="variable scope clause"/>.
</item>

<comment>WG3:OHD-017</comment>
<item>Without <feature code="GP03"/>, in conforming GQL language, 
an <BNF name="inline procedure call"/> shall not contain a <BNF name="variable scope clause"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_named_procedure_call" newpage="true">
<clauseHeading><BNF name="named procedure call"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-05-13 Extracted named procedure call</comment>
<bodyMatter>

<ednote id="gql_PP003_call">Bindings for host languages should eventually be defined.
See <PPref ref="PPgql003"/>.
</ednote>

<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:UTC-096R1</comment>
<para>Execute a named procedure.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-10-06 Changed to procedure reference</comment>
<BNFdef name="named procedure call">
<rhs>
<BNF name="procedure reference"/>
<BNF name="left paren"/> 
<opt> <BNF name="procedure argument list"/> </opt>
<BNF name="right paren"/>
<breakindent/>
<opt> <BNF name="yield clause"/> </opt>
</rhs>
</BNFdef>

<BNFdef name="procedure argument list">
<rhs>
<BNF name="procedure argument"/>
<opt> <group> <BNF name="comma"/> <BNF name="procedure argument"/> </group><repeat/> </opt>
</rhs>
</BNFdef>

<BNFdef name="procedure argument">
<rhs>
<BNF name="value expression"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>Editorial: Stephen Cannan, 2020-04-15</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-06 Changed to procedure reference</comment>
<comment>WG3:W22-054</comment>
<item>Let <symdef>NPC</symdef> be the <BNF name="named procedure call"/> and 
let <symdef>PROC</symdef> be the procedure identified by the <BNF name="procedure reference"/>
immediately contained in <sym>NPC</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2020-05-11 Added procedure signature</comment>
<comment>Editorial: Stephen Cannan, 2020-05-21 GQL- prefix reduction</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-06 One editorial note removed</comment>
<comment>WG3:UTC-077</comment>
<item>Let <symdef>PROCDESC</symdef> be the named procedure descriptor of <sym>PROC</sym>.
</item>

<comment>WG3:W22-054</comment>
<comment>WG3:UTC-077</comment>
<item>Let <symdef>PARAMS</symdef> be the list of procedure parameters of 
<sym>PROCDESC</sym>, let <symdef>PARAMSMIN</symdef> be the number of procedure parameters required 
by <sym>PROCDESC</sym> and let <symdef>PARAMSMAX</symdef> be the maximum number of procedure 
parameters allowed by <sym>PROCDESC</sym>.
</item>

<item>Let <symdef>ARGEXPS</symdef> be the sequence of all <BNF name="value expression"/>s that are
simply contained in <sym>NPC</sym> in the order of their occurrence in <sym>NPC</sym> from left to
right and let <symdef>NUMARGS</symdef> be the number of such elements in <sym>ARGEXPS</sym>.
</item>

<comment>Editorial: Stephen Cannan, 2020-05-24 Add missing exceptions</comment>
<comment>WG3:W22-054</comment>
<item><sym>NUMARGS</sym> shall be greater than or equal to <sym>PARAMSMIN</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2020-10-16 Considered optional arguments</comment>
<comment>WG3:W22-054</comment>
<item><sym>NUMARGS</sym> shall be less than or equal to <sym>PARAMSMAX</sym>.
</item>

<comment>WG3:W25-022R1</comment>
<comment>WG3:CMN-019 P00-NLD-050</comment>
<comment>WG3:CMN-019 P00-USA-087</comment>
<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NUMARGS</sym>:

<olist>

<item>Let <symdef>ARGEXP</symdef><sub><sym>i</sym></sub> be the <sym>i</sym>-th element of 
<sym>ARGEXPS</sym>.
</item>

<item>Let <symdef>PT</symdef><sub><sym>i</sym></sub> be the declared type of the <sym>i</sym>-th 
element of <sym>PARAMS</sym>.
</item>

<item>The <applySC ref="gql_store" rules="SR">
<symarg param="TARGET">a transient site of type <sym>PT</sym><sub><sym>i</sym></sub></symarg>
<symarg param="VALUE"><sym>ARGEXP</sym><sub><sym>i</sym></sub></symarg>
</applySC>.
</item>

</olist>

</item>

<comment>Editorial: Stephen Cannan, 2020-05-24 Add missing exceptions</comment>
<comment>WG3:W22-054</comment>
<comment>WG3:UTC-077</comment>
<item>If <sym>NPC</sym> immediately contains a <BNF name="yield clause"/>, then the procedure
result type of <sym>PROCDESC</sym> shall be a binding table type.
</item>

<comment>WG3:W22-054</comment>
<comment>WG3:UTC-077</comment>
<comment>WG3:CMN-047R1</comment>
<item>Let the declared type of <sym>NPC</sym> be defined as follows.

<comment>WG3:CMN-047R1</comment>
<para>Case:
</para>

<olist>

<comment>WG3:CMN-047R1</comment>
<item>If <sym>NPC</sym> immediately contains a <BNF name="yield clause"/> <symdef>YC</symdef>, then
the declared type of <sym>NPC</sym> is the declared type of <sym>YC</sym>.
</item>

<comment>WG3:CMN-047R1</comment>
<item>Otherwise, the declared type of <sym>NPC</sym> is the procedure result type of
<sym>PROCDESC</sym>.
</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2020-05-14 Reworked GRs</comment>
<olist>

<comment>WG3:W22-054</comment>
<comment>WG3:CMN-019 P00-NLD-050</comment>
<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>PARAMSMAX</sym>, 
let <symdef>ARGVAL</symdef><sub><sym>i</sym></sub> be defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>i</sym> <leq/> <sym>NUMARGS</sym>, then <sym>ARGVAL</sym><sub><sym>i</sym></sub> is 
the result of <sym>ARGEXP</sym><sub><sym>i</sym></sub>.
</item>

<item>Otherwise, <sym>ARGVAL</sym><sub><sym>i</sym></sub> is the default value of the 
<sym>i</sym>-th element of <sym>PARAMS</sym>.
</item>

</olist>

</item>

<comment>WG3:W12-019</comment>
<comment>Editorial: Stephen Cannan, 2022-03-06 WG3:RKE-010 P00-USA-481</comment>
<comment>WG3:W22-054</comment>
<comment>WG3:UTC-077</comment>
<comment>WG3:W25-022R1</comment>
<comment>WG3:CMN-019 P00-NLD-050</comment>
<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>PARAMSMAX</sym>, 
let <symdef>R</symdef> be a new record comprising fields <symdef>F</symdef><sub><sym>i</sym></sub>
defined as follows:

<olist>

<item>Let <symdef>T</symdef><sub><sym>i</sym></sub> be the declared type of the <sym>i</sym>-th 
element of <sym>PARAMS</sym>.
</item>

<item>Let <symdef>TS</symdef> be a transient site of type <sym>T</sym><sub><sym>i</sym></sub>.
The <applySC ref="gql_store" rules="GR">
<symarg param="TARGET"><sym>TS</sym></symarg>
<symarg param="VALUE"><sym>ARGVAL</sym><sub><sym>i</sym></sub></symarg>
</applySC>.
Let <symdef>TSV</symdef><sub><sym>i</sym></sub> be the value of <sym>TS</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>The name of <sym>F</sym><sub><sym>i</sym></sub> is the procedure parameter name of 
the <sym>i</sym>-th element of <sym>PARAMS</sym> and the value of 
<sym>F</sym><sub><sym>i</sym></sub> is <sym>TSV</sym><sub><sym>i</sym></sub>.
</item>

</olist>

</item>

<comment>WG3:W12-019</comment>
<item>The following steps are performed in a new child execution context with <sym>R</sym> as its 
working record:

<olist>

<item>Execute <sym>PROC</sym>.
</item>

<comment>WG3:W22-054</comment>
<item>Let <symdef>RESULT</symdef> be the result returned from the successful execution of 
<sym>PROC</sym>.
</item>

<comment>WG3:W22-054</comment>
<item>The current execution outcome is set as follows.

<para>Case:
</para>

<olist>

<item>If a <BNF name="yield clause"/> <symdef>YC</symdef> is specified, then:

<olist>

<comment>Editorial: Stefan Plantikow, 2022-03-25 WG3:RKE-010 P00-NLD-219 Wording</comment>
<comment>Email from: Nathalie Charbel, 2022-08-25</comment>
<item>The General Rules of <sym>YC</sym> are applied; let <symdef>YIELD</symdef> be the 
result returned from the application of these General Rules.
</item>

<comment>Editorial: Stefan Plantikow, 2022-03-25 WG3:RKE-010 P00-NLD-219 Wording</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<item>The current execution outcome is set to a successful outcome with <sym>YIELD</sym> as its
result.
</item>

</olist>

</item>

<comment>WG3:W22-054</comment>
<comment>WG3:CMN-019 P00-USA-089</comment>
<item>Otherwise, set the current execution outcome to a successful outcome with
<sym>RESULT</sym> as its result.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W22-054</comment>
<item>Without <feature code="GP04"/>, conforming GQL Language shall not contain 
a <BNF name="named procedure call"/>.
</item>

<comment>WG3:UTC-039R1</comment>
<comment>WG3:CMN-057R1</comment>
<item>Without <feature code="GP15"/>, in conforming GQL language,
the declared type of a <BNF name="value expression"/> immediately contained in
a <BNF name="procedure argument"/> shall not be a supertype of a graph reference value type.
</item>

<comment>WG3:UTC-039R1</comment>
<comment>WG3:CMN-057R1</comment>
<item>Without <feature code="GP14"/>, in conforming GQL language,
the declared type of a <BNF name="value expression"/> immediately contained in
a <BNF name="procedure argument"/> shall not be a supertype of 
a binding table reference value type.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:GYD-030</comment>
<subClause id="gql_conditional_stm" newpage="true">
<clauseHeading><BNF name="conditional statement"/></clauseHeading>

<bodyMatter>

<Function>

<para>Define a <BNF name="conditional statement"/>
</para>

</Function>


<Format>

<grammar>

<BNFdef name="conditional statement">
<rhs>
<BNF name="searched conditional statement"/>
</rhs>
</BNFdef>

<BNFdef name="searched conditional statement">
<rhs>
<BNF name="conditional statement when clause"/><repeat/>
<opt> <BNF name="conditional statement else clause"/> </opt>
</rhs>
</BNFdef>

<BNFdef name="conditional statement when clause">
<rhs>
<kw>WHEN</kw> <BNF name="search condition"/> <kw>THEN</kw> 
<BNF name="conditional statement result"/>
</rhs>
</BNFdef>

<BNFdef name="conditional statement else clause">
<rhs>
<kw>ELSE</kw> <BNF name="conditional statement result"/>
</rhs>
</BNFdef>

<BNFdef name="conditional statement result">
<rhs>
<alt> <BNF name="nested procedure specification"/> </alt>
<alt> <BNF name="linear data-modifying statement"/> </alt>
<alt> <BNF name="linear query statement"/> </alt>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<item>A <newterm>branch</newterm> of a <BNF name="conditional statement"/> is 
a <BNF name="conditional statement when clause"/> or 
a <BNF name="conditional statement else clause"/> simply contained in that 
<BNF name="conditional statement"/>. 
A branch result of a branch is the <BNF name="conditional statement result"/> immediately 
contained in that branch.
</item>

<item>Let <symdef>SBR</symdef> be the set of all branches of the specified 
<BNF name="conditional statement"/> that are not a <BNF name="nested procedure specification"/>.

<olist>

<item>One of the following shall hold:

<olist>

<item>Every branch result of a branch of <sym>SBR</sym> is 
a <BNF name="focused linear query statement"/> or 
a <BNF name="focused linear data-modifying statement"/>.
</item>

<item>Every branch result of a branch of <sym>SBR</sym> is 
an <BNF name="ambient linear query statement"/> or 
an <BNF name="ambient linear data-modifying statement"/>.
</item>

<item>Every branch result of a branch of <sym>SBR</sym> is a <BNF name="select statement"/>.
</item>

</olist>

</item>

<item id="gql_gql_conditional_stm_SR_restiction">If a branch result of a branch of <sym>SBR</sym> 
is a <BNF name="linear data-modifying statement"/>, then the specified 
<BNF name="conditional statement"/> shall be the left-most <BNF name="statement"/> immediately
contained in the <BNF name="statement block"/> that is immediately contained in 
a <BNF name="procedure specification"/> that is either immediately contained in 
a <BNF name="transaction activity"/> or is immediately contained in the 
<BNF name="nested procedure specification"/> of an <BNF name="inline procedure call"/>.

<note>This restricts data-modifying <BNF name="conditional statement"/>s to situations
where the incoming working table of the current execution context is statically known
to always contain at most one row during the application of General Rules (in
particular: child execution contexts created for iterating over the incoming working table).
</note>

<ednote id="gsl_PPgql416">Placing a <BNF name="conditional statement"/> immediately after 
<kw>NEXT</kw> when one of its branches is potentially data-modifying should be permitted.
See <PPref ref="PPgql416"/>.
</ednote>
</item>

</olist>

</item>

<item>If a <BNF name="conditional statement result"/> <symdef>CSR</symdef> is specified that is 
not a <BNF name="nested procedure specification"/>, then <sym>CSR</sym> is effectively replaced by:
<code>
{ <sym>CSR</sym> }
</code>
</item>

<item>Let <symdef>CS</symdef> be the specified <BNF name="conditional statement"/> after the 
preceding syntactic transformations and let <symdef>NB</symdef> be the number of branches of 
<sym>CS</sym>.

<note><sym>CS</sym> necessarily is a <BNF name="searched conditional statement"/> with at least 
<sym>NB</sym> &gt; 1 (one) branches and every branch result of <sym>CS</sym> is 
a <BNF name="nested procedure specification"/>.
</note>
</item>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>IWRT</symdef> be the incoming working record type of <sym>CS</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>Let <symdef>IWTTRT</symdef> be the record type of the incoming working table type
of <sym>CS</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>Let <symdef>IRT</symdef> be <sym>IWRT</sym> amended with <sym>IWTTRT</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>The incoming working record type of every branch of <sym>CS</sym> is <sym>IRT</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>The incoming working table type of every branch of <sym>CS</sym> is the 
material unit binding table type.
</item>
<endbar/>

<item>Let <symdef>TYPES</symdef> be the set of the declared types of all branch results of 
<sym>CS</sym>. 
<sym>TYPES</sym> shall only contain binding table types whose respective sets of columns are 
pairwise column name-equal and column-combinable.
</item>

<item>Let <symdef>COLS</symdef> be the combined columns of <sym>TYPES</sym> and 
let <symdef>DTCS</symdef> be the material binding table type whose columns are <sym>COLS</sym>.
</item>

<item>The record type of <sym>DTCS</sym> and <sym>IRT</sym> shall be field name-disjoint.
</item>

<item>The declared type of <sym>CS</sym> is <sym>DTCS</sym>.
</item>

</olist>

</SyntaxRules>


<GeneralRules>

<olist>

<item>Let <symdef>TABLE</symdef> be the current working table.
</item>

<item>Let <symdef>RESULT_TABLE</symdef> be a new empty binding table whose columns are
<sym>COLS</sym>.
</item>

<item>For each record <symdef>R</symdef> of <sym>TABLE</sym> in a new child execution context 
amended with <sym>R</sym>:
</item>

<item>Let <symdef>PART</symdef> be defined as follows

<para>Case:
</para>

<olist>

<item>If the result of the <BNF name="search condition"/> of some 
<BNF name="conditional statement when clause"/> in <sym>CS</sym> is <bool>True</bool>, then 
<sym>PART</sym> is the result of the evaluation of the branch result of the first (left-most) 
<BNF name="conditional statement when clause"/> whose <BNF name="search condition"/> evaluates 
to <bool>True</bool>, cast to <sym>DTCS</sym>.
</item>

<item>Otherwise, no <BNF name="search condition"/> of some 
<BNF name="conditional statement when clause"/> in <sym>CS</sym> evaluates to <bool>True</bool> and

<para>Case:
</para>

<olist>

<item>If the <BNF name="conditional statement else clause"/> <symdef>CSEC</symdef> is specified, 
then <sym>PART</sym> is the result of the evaluation of the branch result of <sym>CSEC</sym>, 
cast to <sym>DTCS</sym>.
</item>

<item>Otherwise, no <BNF name="conditional statement else clause"/> is specified and
<sym>PART</sym> is a new empty binding table whose columns are <sym>COLS</sym>, cast to 
<sym>DTCS</sym>.
</item>

</olist>

</item>

</olist>

</item>

<item><sym>PART</sym> is appended to <sym>RESULT_TABLE</sym>.
</item>

<item>The result of <sym>CS</sym> is <sym>RESULT_TABLE</sym>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<item>Without <feature code="GQ25"/>, conforming GQL language shall not contain 
a <BNF name="conditional statement"/>.
</item>

<item>Without <feature code="GQ26"/>, conforming GQL language shall not contain 
a <BNF name="conditional statement"/> that has at least one branch whose branch result is 
a <BNF name="data-modifying procedure specification"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>

</clause>


<!-- Uncomment when Access Control is defined.
<clause id="gql_access">
<clauseHeading>Access control</clauseHeading>

<bodyMatter>

<ednote>See <PPref ref="PPgql005"/>.
</ednote>

</bodyMatter>

</clause>
-->


<clause id="gql_common">
<clauseHeading>Common elements</clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-02-05</comment>
<subClause id="gql_at">
<clauseHeading><BNF name="at schema clause"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-07-12 WG3:MMX-055</comment>
<bodyMatter>

<comment>WG3:W19-017 One editor's note removed</comment>

<Function>

<comment>WG3:W19-017</comment>
<comment>Editorial: Stephen Cannan, 2022-03-11</comment>
<para>Declare a working schema and its scope.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-02-06</comment>
<comment>Editorial: Stefan Plantikow, 2020-09-25 Allow schema reference</comment>
<BNFdef name="at schema clause">
<rhs>
<kw>AT</kw> <BNF name="schema reference"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:W19-017</comment>
<item>Let <symdef>ASC</symdef> be the <BNF name="at schema clause"/>.
</item>

<comment>WG3:W13-024: Stefan Plantikow, 2021-07-21</comment>
<comment>WG3:BER-088R1</comment>
<comment>Editorial: Stefan Plantikow, 2022-08-18 Correct to use GQL-schema</comment>
<comment>WG3:CMN-042</comment>
<item>Let <symdef>ACSR</symdef> be an <BNF name="absolute catalog schema reference"/>
that identifies the GQL-schema identified by the <BNF name="schema reference"/>
immediately contained in <sym>ASC</sym>.

<comment>WG3:CMN-042</comment>
<comment>WG3:CMN-061R1</comment>
<note>If the <BNF name="schema reference"/> <symdef>SR</symdef> that is
immediately contained in <sym>ASC</sym> is a <BNF name="relative catalog schema reference"/> or
a <BNF name="reference parameter specification"/>, then the Syntax Rules of 
<specref ref="gql_schema_refs"/> are applied to determine the GQL-schema identified by 
<sym>SR</sym>.
</note>

</item>

<item>Let <symdef>PB</symdef> be the <BNF name="procedure body"/> immediately containing
<sym>ASC</sym>.
</item>

<item>The scope clause of <sym>ASC</sym> is <sym>PB</sym>.
</item>

<comment>WG3:CMN-042</comment>
<item>The scope of <sym>ACSR</sym> comprises <sym>PB</sym>.
</item>

<comment>WG3:CMN-042</comment>
<item><sym>ASC</sym> identifies <sym>ACSR</sym> as a working schema reference.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2020-04-27 Basic GRs added</comment>
<olist>

<comment>Editorial: Stefan Plantikow, 2020-09-16 Made rule non-conditional</comment>
<comment>WG3:W13-024: Stefan Plantikow, 2021-07-21 2 (Two) SRs removed</comment>

<comment>WG3:W13-024: Stefan Plantikow, 2021-07-21</comment>
<comment>WG3:W19-017 One General Rule removed</comment>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_use" newpage="true">
<clauseHeading><BNF name="use graph clause"/></clauseHeading>

<bodyMatter>

<Function>

<comment>Editorial: Stefan Plantikow, 2020-04-27 Reworded</comment>
<comment>WG3:W20-027R1</comment>
<para>Declare a working graph and its scope.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-02-21</comment>
<comment>Editorial: Stefan Plantikow, 2020-09-25 Allow graph expression</comment>
<BNFdef name="use graph clause">
<rhs>
<kw>USE</kw> <BNF name="graph expression"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<comment>WG3:W20-027R1</comment>
<olist>

<item>Let <symdef>UGC</symdef> be the <BNF name="use graph clause"/>.
</item>

<comment>WG3:BER-088R1</comment>
<comment>WG3:UTC-039R1</comment>
<item>Let <symdef>GE</symdef> be
the <BNF name="graph expression"/> simply contained in <sym>UGC</sym>.
</item>

<comment>WG3:CMN-035</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>GE</sym> is the incoming working record type
of <sym>UGC</sym>.
</item>

<comment>WG3:CMN-035</comment>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>GE</sym> is the material unit binding table type.
</item>
<endbar/>

<comment>WG3:W23-009R1 P00-USA-371</comment>
<item>Let <symdef>PART</symdef> be the instance of the BNF non-terminal that immediately contains 
<sym>UGC</sym>.
</item>

<comment>WG3:CMN-042</comment>
<item>The scope clause of <sym>UGC</sym> is defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>PART</sym> is simply contained in a <BNF name="focused linear query statement"/> 
<symdef>FLQS</symdef>, then the scope clause of <sym>UGC</sym> is <sym>FLQS</sym>.
</item>

<item>Otherwise, <sym>PART</sym> is simply contained in 
a <BNF name="focused linear data-modifying statement"/> <symdef>FLDMS</symdef>, and 
the scope clause of <sym>UGC</sym> is <sym>FLDMS</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-042</comment>
<item>The scope of <sym>GE</sym> is defined as follows.

<comment>WG3:CMN-042</comment>
<para>Case:
</para>

<olist>

<comment>WG3:CMN-042</comment>
<item>If <sym>PART</sym> is a <BNF name="focused linear query statement part"/>, then
the scope of <sym>GE</sym> comprises the <BNF name="simple linear query statement"/>
immediately contained in <sym>PART</sym>.
</item>

<comment>WG3:CMN-042</comment>
<item>If <sym>PART</sym> is 
a <BNF name="focused linear query and primitive result statement part"/>, then 
the scope of <sym>GE</sym> comprises the <BNF name="simple linear query statement"/> and
the <BNF name="primitive result statement"/> immediately contained in <sym>PART</sym>.
</item>

<comment>WG3:CMN-042</comment>
<item>If <sym>PART</sym> is a <BNF name="focused primitive result statement"/>, then
the scope of <sym>GE</sym> comprises the <BNF name="primitive result statement"/>
immediately contained in <sym>PART</sym>.
</item>

<comment>WG3:CMN-042</comment>
<item>If <sym>PART</sym> is a <BNF name="focused nested query specification"/>, then 
the scope of <sym>GE</sym> comprises the <BNF name="nested query specification"/>
immediately contained in <sym>PART</sym>.
</item>

<comment>WG3:CMN-042</comment>
<item>If <sym>PART</sym> is a <BNF name="focused linear data-modifying statement body"/>, then
the scope of <sym>GE</sym> comprises the <BNF name="simple linear query statement"/>,
the <BNF name="simple data-modifying statement"/>,
the <BNF name="simple linear data-accessing statement"/>, and
the <BNF name="primitive result statement"/> immediately contained in <sym>PART</sym>.
</item>

<comment>WG3:CMN-042</comment>
<item>Otherwise, <sym>PART</sym> is
a <BNF name="focused nested data-modifying procedure specification"/> and
the scope of <sym>GE</sym> comprises the <BNF name="nested data-modifying procedure specification"/>
immediately contained in <sym>PART</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-042</comment>
<item><sym>UGC</sym> identifies <sym>GE</sym> as a working graph site.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:W20-027R1</comment>

<comment>WG3:CMN-035</comment>
<item>The working graph site that is <sym>GE</sym> is set to the result of evaluating <sym>GE</sym>
in a new child execution context.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-047</comment>
<item>Without <feature code="GQ01"/>, conforming GQL language shall not contain 
a <BNF name="use graph clause"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_gpbt" newpage="true">
<clauseHeading><BNF name="graph pattern binding table"/></clauseHeading>

<bodyMatter>


<Function>

<para>Evaluate a <BNF name="graph pattern"/> to a binding table.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="graph pattern binding table">
<rhs>
<BNF name="graph pattern"/> <opt> <BNF name="graph pattern yield clause"/> </opt>
</rhs>
</BNFdef>

<BNFdef name="graph pattern yield clause">
<rhs>
<kw>YIELD</kw> <BNF name="graph pattern yield item list"/>
</rhs>
</BNFdef>

<comment>WG3:W25-024</comment>
<BNFdef name="graph pattern yield item list">
<rhs>
<alt>
<BNF name="graph pattern yield item"/> 
<opt> <group> <BNF name="comma"/> <BNF name="graph pattern yield item"/> </group><repeat/> </opt>
</alt>
<alt> <kw>NO</kw> <kw>BINDINGS</kw> </alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-087R2</comment>
<BNFdef name="graph pattern yield item">
<rhs>
<alt> <BNF name="element variable reference"/> </alt>
<alt> <BNF name="path variable reference"/> </alt>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<item>Let <symdef>GPBT</symdef> be the <BNF name="graph pattern binding table"/> and 
let <symdef>GP</symdef> be the <BNF name="graph pattern"/> simply contained in <sym>GPBT</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2022-10-10 Corrected to not use global scope</comment>
<item>Every variable in the scope of <sym>GP</sym> is also in the scope of the 
<BNF name="graph pattern yield clause"/> simply contained in <sym>GPBT</sym>.
</item>

<comment>WG3:OHD-039</comment>
<comment>WG3:UTC-087R2</comment>
<item>Let <symdef>EVSET</symdef> be the set of names of element variable declared by <sym>GP</sym>,
let <symdef>PVSET</symdef> be the set of names of path variables declared by <sym>GP</sym>, and
let <symdef>GPVARS</symdef> be a permutation of <sym>EVSET</sym> <setunion/> <sym>PVSET</sym> in
the order of their first occurrence as an <BNF name="element variable declaration"/> or 
a <BNF name="path variable declaration"/>, respectively, that is simply contained in <sym>GP</sym>.
Let <symdef>SPVSET</symdef> be the set of names of subpath variables declared by <sym>GP</sym>.

<ednote id="gql_w22053_1">Handling of subpath variables to be decided.
See <PPref ref="PPgql194"/>.
</ednote>
</item>

<item>Each graph pattern variable name in <sym>GPVARS</sym> shall identify exactly one graph 
pattern variable in <sym>GP</sym> at the same depth of graph pattern matching.
</item>

<comment>WG3:OHD-039</comment>
<comment>Editorial: Stefan Plantikow, 2022-10-10 Corrected to not use global scope</comment>
<comment>WG3:UTC-087R2</comment>
<item>Let <symdef>GLOBALS</symdef> be <sym>GPVARS</sym> restricted to the names of graph pattern 
variables in the scope of <sym>GP</sym>.
</item>

<comment>WG3:UTC-087R2</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>IWRT</symdef> be the incoming working record type of <sym>GPBT</sym>.
</item>

<comment>WG3:UTC-087R2</comment>
<comment>WG3:XRH-036</comment>
<item><sym>IWRT</sym> shall not contain a field whose name is in <sym>SPVSET</sym>.
</item>

<comment>WG3:UTC-087R2</comment>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>IWTTRT</symdef> be the record type of the declared type of the incoming working 
table of <sym>GPBT</sym>.
</item>

<comment>WG3:UTC-087R2</comment>
<comment>WG3:XRH-036</comment>
<item><sym>IWTTRT</sym> shall not contain a field whose name is in <sym>SPVSET</sym>.
</item>

<comment>WG3:OHD-039</comment>
<comment>Editorial: Stefan Plantikow, 2022-10-05 Added WR sites</comment>
<comment>WG3:W24-029</comment>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>RECORD_OVERLAP</symdef> be <sym>GLOBALS</sym> restricted to the names of fields
of <sym>IWRT</sym>,
let <symdef>TABLE_OVERLAP</symdef> be <sym>GLOBALS</sym> restricted to the names of fields of
<sym>IWTTRT</sym>, and let <symdef>OVERLAP</symdef> be the concatenation of 
<sym>RECORD_OVERLAP</sym> with <sym>TABLE_OVERLAP</sym>.
</item>
<endbar/>

<comment>WG3:OHD-039</comment>
<item>The sequence of variable names <symdef>XGPYCVARS</symdef> is defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:UTC-087R2</comment>
<item>If an explicit <BNF name="graph pattern yield clause"/> <symdef>XGPYC</symdef> is specified,
then <sym>XGPYCVARS</sym> is the sequence of names of variables identified by instances of 
<BNF name="binding variable reference"/>s simply contained in <sym>XGPYC</sym>.
</item>

<comment>WG3:CMN-019 P00-NLD-060</comment>
<item>Otherwise, <sym>XGPYCVARS</sym> is the empty sequence.
</item>

</olist>

</item>

<comment>WG3:OHD-039</comment>
<item id="gql_gpbt_SR_yield">Case:

<olist>

<comment>WG3:UTC-087R2</comment>
<item>If the length of <symdef>XGPYCVARS</symdef> is at least 1 (one), then:

<olist>

<comment>Editorial: Stefan Plantikow, 2023-01-05 Correct to use equal</comment>
<item><sym>XGPYCVARS</sym> shall not contain two equal names at different positions.
</item>

<item>Every name in <sym>XGPYCVARS</sym> shall be contained in <sym>GLOBALS</sym>.
</item>

<item>Let <symdef>OGPYCVARS</symdef> be <sym>OVERLAP</sym> without the names contained in 
<sym>XGPYCVARS</sym>.
</item>

<item>Let <symdef>GPYIL</symdef> be the comma-separated list of the elements of the concatenation
of <sym>OGPYCVARS</sym> with <sym>XGPYCVARS</sym>.
</item>

<comment>WG3:UTC-087R2</comment>
<item><sym>XGPYC</sym> is equivalent to:

<code>
YIELD <sym>GPYIL</sym>
</code>
</item>

</olist>

</item>

<comment>WG3:UTC-087R2</comment>
<comment>WG3:W25-024</comment>
<comment>WG3:CMN-019 P00-NLD-060</comment>
<item>Otherwise, <sym>XGPYCVARS</sym> is the empty sequence.

<para>Case:
</para>

<olist>

<item>If <sym>GLOBALS</sym> is empty, then the implicit <BNF name="graph pattern yield clause"/> 
of <sym>GPBT</sym> is:

<code>
<kw>YIELD</kw> <kw>NO</kw> <kw>BINDINGS</kw>
</code>

</item>

<comment>Editorial: Stefan Plantikow, 2023-11-12 non-empty</comment>
<item>Otherwise, <sym>GLOBALS</sym> is non-empty.
Let <symdef>GPYIL</symdef> be the comma-separated list of the elements of <sym>GLOBALS</sym>.
The implicit <BNF name="graph pattern yield clause"/> of <sym>GPBT</sym> is:

<code>
<kw>YIELD</kw> <sym>GPYIL</sym>
</code>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:OHD-039</comment>
<comment>WG3:UTC-087R2</comment>
<item>Let <symdef>GPYC</symdef> be the explicit or implicit 
<BNF name="graph pattern yield clause"/> after the application of 
<itemref ref="gql_gpbt_SR_yield" type="SR"/>.
</item>

<comment>WG3:UTC-087R2</comment>
<comment>WG3:CMN-019 P00-USA-091</comment>
<item>Let <symdef>GPYCREFS</symdef> be defined as follows.

<comment>WG3:CMN-019 P00-USA-091</comment>
<para>Case:
</para>

<olist>

<comment>WG3:CMN-019 P00-USA-091</comment>
<comment>WG3:CMN-019 P00-NLD-060</comment>
<item>If <symdef>GPYC</symdef> is <kw>YIELD</kw> <kw>NO</kw> <kw>BINDINGS</kw>, then
<symdef>GPYCREFS</symdef> is the empty sequence.
</item>

<comment>WG3:CMN-019 P00-USA-091</comment>
<item>Otherwise, <sym>GPYCREFS</sym> is the sequence of <BNF name="binding variable reference"/>s 
simply contained in <sym>GPYC</sym>.
</item>

</olist>

<comment>Editorial: Stefan Plantikow, 2023-02-24 Resolve GQL-352</comment>
<note>This is restricted to variable names from <sym>GLOBALS</sym>, <ie/> in particular contains no
names of subpath variables declared by <sym>GP</sym>.
</note>
</item>

<comment>WG3:UTC-087R2</comment>
<item>The binding graph pattern of each <BNF name="binding variable reference"/> in 
<sym>GPYCREFS</sym> shall be <sym>GP</sym>.

<comment>WG3:UTC-087R2</comment>
<note>See <itemref type="SR" ref="gql_var_refs_SR_bgp"/> of <specref ref="gql_var_refs"/>,
for the definition of binding graph pattern.
</note>
</item>

<comment>WG3:UTC-087R2</comment>
<comment>WG3:W26-025R1</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>For every <BNF name="binding variable reference"/> <symdef>BVR</symdef> with 
name <symdef>NAME</symdef> in <sym>GPYCREFS</sym> for which it holds that <sym>NAME</sym> is the 
name of a field in <sym>IWRT</sym> or <sym>IWTTRT</sym>:

<olist>

<comment>WG3:W26-025R1</comment>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>IVT</symdef> be the value type of the field type in <sym>IWRT</sym> or 
<sym>IWTTRT</sym> with name equal to <sym>NAME</sym>.
<endbar/>

<para>Case:
</para>

<olist>

<item>If the declared type of <sym>BVR</sym> has group degree of reference, then <sym>IVT</sym> 
shall have group degree of reference.
</item>

<item>Otherwise, the declared type of <sym>BVR</sym> does not have group degree of reference and 
<sym>IVT</sym> shall not have group degree of reference.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:UTC-087R2</comment>
<item>Let <symdef>GPYCFTSET</symdef> be the set of the projected field types of 
all elements of <sym>GPYCREFS</sym>.

<comment>Editorial: Stefan Plantikow 2023-03-09 Clarify reference</comment>
<note>See <itemref type="SR" ref="gql_var_refs_SR_pft"/> of <specref ref="gql_var_refs"/>,
for the definition of projected field type.
</note>

</item>

<comment>WG3:UTC-086R1</comment>
<item id="gql_gpbt_SR_GPYCRT">Let <symdef>GPYCRT</symdef> be
the closed record type whose field type set is <sym>GPYCFTSET</sym>.
</item>

<comment>WG3:W26-024 Removed 2 Syntax Rules</comment>

<comment>WG3:W26-024</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item id="gql_gpbt_SR_IBRT">Let <symdef>IBRT</symdef> be <sym>IWRT</sym> amended with
<sym>IWTTRT</sym>.
</item>
<endbar/>

<comment>WG3:W26-024</comment>
<item>The records bound to <symdef>COMBINED</symdef> by applications of
<itemref ref="gql_gpbt_GR_COMBINED" type="GR"/> whose declared type is <sym>IBRT</sym> and
the binding tables bound to <symdef>INNER_TABLE</symdef> by applications of
<itemref ref="gql_gpbt_GR_INNER_TABLE" type="GR"/> whose declared type is <sym>GPYCRT</sym> are
the operands of an equality operation (the natural join performed by the application of
<itemref ref="gql_gpbt_GR_nat_join" type="GR"/>).
The Syntax Rules and Conformance Rules of <specref ref="gql_equality_ops"/>, apply.
</item>

<comment>W6-013</comment>
<comment>Email from: Keith Hare, 2021-08-26 1200</comment>
<item>For each <BNF name="element property specification"/> <symdef>EPS</symdef> simply contained 
in <sym>GP</sym>:

<olist>

<item>Let <symdef>EPP</symdef> be the <BNF name="element pattern predicate"/> that simply contains 
<sym>EPS</sym>.
</item>

<item>Let <symdef>EPF</symdef> be the <BNF name="element pattern filler"/> that simply contains 
<sym>EPP</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2022-05-03 Introduce proper Case</comment>
<comment>WG3:W24-022</comment>
<item>Let <symdef>EVARDECL</symdef> and <symdef>EVAR</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W24-022</comment>
<item>If <sym>EPF</sym> simply contains an <BNF name="element variable declaration"/> 
<sym>EVARDECL</sym>, then <sym>EVAR</sym> is the <BNF name="identifier"/> contained in the 
<BNF name="element variable declaration"/> simply contained in <sym>EPF</sym>.
</item>

<comment>WG3:W24-022</comment>
<comment>WG3:W26-037R3</comment>
<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<item>Otherwise, <sym>EVAR</sym> is a new system-generated regular identifier
distinct from every element variable, subpath variable, and path variable contained in
<sym>GP</sym> and <sym>EVARDECL</sym> is <kw>TEMP</kw> <sym>EVAR</sym>.

<comment>WG3:W24-022</comment>
<comment>Editorial; Jim Melton, 2023-09-04; fix which/that problems</comment>
<note>In this case, <sym>EVAR</sym> specifies a temporary element variable that is never 
contained in <sym>GPYC</sym>.
</note>

</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-095</comment>
<item>Let <symdef>EPILE</symdef> be defined as follows. 
If <sym>EPF</sym> simply contains the <BNF name="is label expression"/> 
<symdef>EPILE_CAND</symdef>, then <sym>EPILE</sym> is <sym>EPILE_CAND</sym>; 
otherwise, <sym>EPILE</sym> is the zero-length character string.
</item>


<item>Let <symdef>PECL</symdef> be the <BNF name="property key value pair list"/> simply contained 
in <sym>EPS</sym>.
</item>

<item>Let <symdef>NOPEC</symdef> be the number of <BNF name="property key value pair"/>s simply
contained in <sym>PECL</sym>.
</item>

<item>Let <symdef>PEC</symdef><sub>1</sub>, <ellipsis/>, 
<symdef>PEC</symdef><sub><sym>NOPEC</sym></sub> be 
the <BNF name="property key value pair"/>s simply contained in <sym>PECL</sym>.
</item>

<comment>WG3:CMN-019 P00-NLD-050</comment>
<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NOPEC</sym>:

<olist>

<item>Let <symdef>PROP</symdef><sub><sym>i</sym></sub> be the <BNF name="property name"/> 
simply contained in <sym>PEC</sym><sub><sym>i</sym></sub>.
</item>

<item>Let <symdef>VAL</symdef><sub><sym>i</sym></sub> be the <BNF name="value expression"/> 
simply contained in <sym>PEC</sym><sub><sym>i</sym></sub>.
</item>

<item>Let <symdef>RPEC</symdef><sub><sym>i</sym></sub> be a <BNF name="comparison predicate"/> 
formed as:
<code>
<sym>EVAR</sym>.<sym>PROP</sym><sub><sym>i</sym></sub> = <sym>VAL</sym><sub><sym>i</sym></sub>
</code>
</item>

</olist>

</item>

<item>Let <symdef>EPSC</symdef> be a <BNF name="boolean value expression"/> formed through the
concatenation of <BNF name="boolean factor"/>s:
<sym>RPEC</sym><sub>1</sub> <kw>AND</kw> <ellipsis/> <kw>AND</kw> <ellipsis/> 
<sym>RPEC</sym><sub><sym>NOPEC</sym></sub>.
</item>

<comment>WG3:W24-022</comment>
<item><sym>EPF</sym> is effectively replaced by:
<code>
<sym>EVARDECL</sym> <sym>EPILE</sym> <kw>WHERE</kw> <sym>EPSC</sym>
</code>
</item>

</olist>

<comment>WG3:W26-025R1</comment>
<ednote>This rule is related to <itemref ref="gql_path_pattern_expr_norm" type="GR"/> of 
<specref ref="gql_path_pattern_expr"/>.
However, in order to maintain the maximum correspondence in the specification of the 
<specref ref="gql_path_pattern_expr"/>, which is shared with <SQL/>/PGQ, and because
<BNF name="element property specification"/> is not part of <SQL/>/PGQ, the rule is included here.
</ednote>

</item>

<item>Let <symdef>GPT</symdef> be the <BNF name="graph pattern"/> simply contained in 
<sym>GPBT</sym> after the preceding transformations and let <symdef>PPLT</symdef> be the 
<BNF name="path pattern list"/> simply contained in <sym>GPT</sym>.
</item>

<comment>WG3:CMN-042</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use of omitted</comment>
<item>The current working graph site of <sym>GPBT</sym> shall not be <quote>omitted</quote>.
</item>

<comment>Editorial: Stefan Plantikow, 2022-08-17 Adjusted to align with WG3:W22-051</comment>
<comment>WG3:CMN-042</comment>
<item>Let <symdef>CWGS</symdef> be the current working graph site of <sym>GPBT</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2022-10-10 Aligned use of scope with matching GRs</comment>
<comment>WG3:UTC-087R2</comment>
<comment>Editorial: Stephen Cannan, 2023-10-13</comment>
<item id="gql_gql_gpbt_SR_wrt">For every <BNF name="value expression"/> 
or <BNF name="search condition"/> <symdef>EXP</symdef> simply contained in <sym>GP</sym>, 
if <sym>EXP</sym> is evaluated in a new child execution context during the application of 
the <specref ref="gql_app_bind_eval_expr"/>, then:

<olist>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>EXP</sym> is the record type whose
field types are given by the union between:
<endbar/>

<olist>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item><sym>IWRT</sym> without the fields identified by <sym>RECORD_OVERLAP</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item><sym>IWTTRT</sym> without the fields identified by <sym>TABLE_OVERLAP</sym>.
</item>
<endbar/>

<item>The projected field types of all graph pattern variable references simply contained in 
<sym>EXP</sym> whose variables are declared by <sym>GP</sym> and that are exposed in 
<sym>EXP</sym>.

<comment>Editorial: Stefan Plantikow 2023-03-09 Clarify reference</comment>
<note>See <itemref type="SR" ref="gql_var_refs_SR_pft"/> of <specref ref="gql_var_refs"/>,
for the definition of projected field type.
</note>

</item>

</olist>

</item>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>EXP</sym> is the unit binding table type.
</item>
<endbar/>

</olist>

</item>

<comment>WG3:OHD-039</comment>
<comment>WG3:UTC-087R2</comment>
<item>Let <symdef>GPBTRT</symdef> be the closed record type whose field types are given by 
the union between:

<olist>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item><sym>IWRT</sym> without the fields identified by <sym>RECORD_OVERLAP</sym>.
</item>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:XRH-036</comment>
<item><sym>IWTTRT</sym> without the fields identified by <sym>TABLE_OVERLAP</sym>.
</item>
<endbar/>

<item><sym>GPYCFTSET</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-087R2</comment>
<item>The declared type of <sym>GPBT</sym> is the binding table type whose record type is 
<sym>GPBTRT</sym>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:CMN-042</comment>
<item>Let <symdef>PG</symdef> be the graph referenced by <sym>CWGS</sym>.
</item>

<item>The <applySC ref="gql_machinery_graph_pattern_matching" rules="GR">
<symarg param="PROPERTY GRAPH"><sym>PG</sym></symarg>
<symarg param="PATH PATTERN LIST"><sym>PPLT</sym></symarg>
<symresult param="MACHINERY"><symdef>MACH</symdef></symresult>
</applySC>.
</item>

<item>Let <symdef>MATCH_TABLE</symdef> be a new empty binding table whose columns are the columns 
of the declared type of <sym>GPBT</sym>.
</item>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:UTC-087R2</comment>
<comment>WG3:W25-024</comment>
<item>The preferred column name sequence <symdef>PCNS</symdef> of <sym>MATCH_TABLE</sym> is the 
concatenation of the following sequences of names in the order given.

<para>Case:
</para>
<olist>

<comment>WG3:UTC-086R1</comment>
<item>If the current working table has a preferred column name sequence <symdef>PCS</symdef>, then 
<sym>PCNS</sym> is the concatenation of:

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The field type names of <sym>IWRT</sym> not included in <sym>XGPYCVARS</sym>,
in ascending order.
</item>
<endbar/>

<item><sym>PCS</sym> without the names included in <sym>XGPYCVARS</sym>.
</item>

<item><sym>XGPYCVARS</sym>.
</item>


</olist>
 
</item>

<comment>WG3:W25-024</comment>
<item>Otherwise, <sym>PCNS</sym> is the concatenation of:

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The field type names of <sym>IWRT</sym> and <sym>IWTTRT</sym> not included in 
<sym>XGPYCVARS</sym>, in ascending order.
</item>
<endbar/>

<item><sym>XGPYCVARS</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:OHD-039</comment>
<item>Let <symdef>CWR</symdef> be the current working record.
</item>

<item>For each record <symdef>OUTER</symdef> in the current working table:

<olist>

<!-- Original INNER_TABLE symdef is in forward-referencing SR -->
<item id="gql_gpbt_GR_INNER_TABLE">Let <symdef>INNER_TABLE</symdef> be a new empty binding table
whose columns are the field types in <sym>GPYCFTSET</sym>.
</item>

<comment>WG3:OHD-039</comment>
<comment>WG3:CMN-057R1</comment>
<!-- Original COMBINED symdef is in forward-referencing SR -->
<item id="gql_gpbt_GR_COMBINED">Let <symdef>COMBINED</symdef> be <sym>CWR</sym> amended
with <sym>OUTER</sym>.
The field types of <sym>COMBINED</sym> are the field types of <sym>IWRT</sym> amended with 
<sym>IWTTRT</sym>.
</item>

<comment>WG3:OHD-039</comment>
<item>Let <symdef>SANITIZED</symdef> be <sym>COMBINED</sym> without the fields identified by
<sym>OVERLAP</sym>.
</item>

<item>In a new child execution context whose working record is <sym>SANITIZED</sym>, the 
<applySC ref="gql_graph_pattern" rules="GR">
<symarg param="PROPERTY GRAPH"><sym>PG</sym></symarg>
<symarg param="GRAPH PATTERN"><sym>GPT</sym></symarg>
<symarg param="PATH PATTERN LIST"><sym>PPLT</sym></symarg>
<symarg param="MACHINERY"><sym>MACH</sym></symarg>
<symresult param="SET OF REDUCED MATCHES"><symdef>MATCHES</symdef></symresult>
</applySC>.
</item>

<item>For each reduced match <symdef>RM</symdef> in <sym>MATCHES</sym>:

<olist>

<item>The <applySC ref="gql_app_bind_gen_rec" rules="GR">
<symarg param="GRAPH PATTERN"><sym>GPT</sym></symarg>
<symarg param="YIELD CLAUSE"><sym>GPYC</sym></symarg>
<symarg param="MULTI-PATH BINDING"><sym>RM</sym></symarg>
<symarg param="MACHINERY"><sym>MACH</sym></symarg>
<symresult param="RECORD"><symdef>INNER</symdef></symresult>
</applySC>.
</item>

<item><sym>INNER</sym> is appended to <sym>INNER_TABLE</sym>.
</item>

</olist>

</item>

<comment>WG3:W26-024</comment>
<item>If there is a record <symdef>R1</symdef> of <sym>INNER_TABLE</sym> such that
<sym>R1</sym> and <sym>COMBINED</sym> are not comparable values, then
an exception condition is raised: <raise class="22" subclass="G04"/>.
</item>

<comment>WG3:OHD-039</comment>
<item id="gql_gpbt_GR_nat_join">The binding table constructed as the natural join between 
<sym>COMBINED</sym> and <sym>INNER_TABLE</sym> is appended to <sym>MATCH_TABLE</sym>.
</item>

</olist>

</item>

<item>The result of <sym>GPBT</sym> is <sym>MATCH_TABLE</sym>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W25-024</comment>
<item>Conforming GQL language shall not contain a <BNF name="graph pattern yield item list"/>
that contains <kw>NO</kw> <kw>BINDINGS</kw>.

<note>A <BNF name="graph pattern yield item list"/> that contains <kw>NO</kw> <kw>BINDINGS</kw> is
a specification device and is not syntax available to the user.
</note>

</item>

<comment>WG3:UTC-060</comment>
<item>Without <feature code="GQ19"/>, conforming GQL language shall not contain 
a <BNF name="graph pattern binding table"/> that immediately contains 
a <BNF name="graph pattern yield clause"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_graph_pattern" newpage="true">
<clauseHeading><BNF name="graph pattern"/></clauseHeading>

<bodyMatter>


<Function>

<para>Specify a pattern to be matched in a graph.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Move MATCH to match statement, Stefan Plantikow, 2019-10-10</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-27 Connect with GQL</comment>
<comment>WG3:W04-009R1</comment>
<comment>WG3:BER-032R3</comment>
<comment>WG3:W23-028R2 Opt. yield clause removed</comment>
<BNFdef name="graph pattern">
<rhs>
<opt> <BNF name="match mode"/> </opt>
<BNF name="path pattern list"/>
<breakindent/>
<opt> <BNF name="keep clause"/> </opt>
<breakindent/>
<opt> <BNF name="graph pattern where clause"/> </opt>
</rhs>
</BNFdef>

<BNFdef name="match mode">
<rhs>
<alt> <BNF name="repeatable elements match mode"/> </alt>
<alt> <BNF name="different edges match mode"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="repeatable elements match mode">
<rhs>
<kw>REPEATABLE</kw> <BNF name="element bindings or elements"/>
</rhs>
</BNFdef>

<BNFdef name="different edges match mode">
<rhs>
<kw>DIFFERENT</kw> <BNF name="edge bindings or edges"/>
</rhs>
</BNFdef>

<BNFdef name="element bindings or elements">
<rhs>
<alt> <kw>ELEMENT</kw> <opt> <kw>BINDINGS</kw> </opt> </alt> 
<alt> <kw>ELEMENTS</kw> </alt>
</rhs>
</BNFdef>

<BNFdef name="edge bindings or edges">
<rhs>
<alt> <BNF name="edge synonym"/> <opt> <kw>BINDINGS</kw> </opt> </alt>
<alt> <BNF name="edges synonym"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="path pattern list">
<rhs>
<BNF name="path pattern"/>
<opt> <group> <BNF name="comma"/> <BNF name="path pattern"/> </group><repeat/> </opt>
</rhs>
</BNFdef>

<comment>WG3:SXM-052</comment>
<comment>WG3:W04-009R1</comment>
<comment>WG3:BER-031</comment>
<BNFdef name="path pattern">
<rhs>
<opt> <BNF name="path variable declaration"/> </opt>
<opt> <BNF name="path pattern prefix"/> </opt>
<BNF name="path pattern expression"/>
</rhs>
</BNFdef>

<comment>WG3:BER-031</comment>
<BNFdef name="path variable declaration">
<rhs>
<BNF name="path variable"/> <BNF name="equals operator"/>
</rhs>
</BNFdef>

<comment>WG3:W04-009R1</comment>
<BNFdef name="keep clause">
<rhs>
<kw>KEEP</kw> <BNF name="path pattern prefix"/>
</rhs>
</BNFdef>

<BNFdef name="graph pattern where clause">
<rhs>
<kw>WHERE</kw> <BNF name="search condition"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>Rule added for GQL to replace the followed commented out rule.</comment>
<item>Let <symdef>GP</symdef> be the <BNF name="graph pattern"/>.

</item>

<item>If <symdef>BNF1</symdef> and <symdef>BNF2</symdef> are instances of two BNF non-terminals, 
both contained in <sym>GP</sym> without an intervening <BNF name="graph pattern"/>,
then <sym>BNF1</sym> and <sym>BNF2</sym> are said to be 
<newterm>at the same depth of graph pattern matching</newterm>.

<comment>Editorial: Stephen Cannan 2023-01-20 Align with Directives Part 2</comment>
<note><sym>BNF1</sym> can contain <sym>BNF2</sym> while being at the same depth of graph pattern
matching.
</note>

</item>

<comment>WG3:W01-014</comment>
<item>In a <BNF name="path pattern list"/>, if two <BNF name="path pattern"/>s expose an element 
variable <symdef>EV</symdef>, then both shall expose <sym>EV</sym> as an unconditional singleton 
variable.

<note>This case expresses an implicit join on <sym>EV</sym>.
Implicit joins between conditional singleton variables or group variables are forbidden.
</note>
</item>

<comment>WG3:BER-031</comment>
<item>Two <BNF name="path pattern"/>s shall not expose the same subpath variable.

<note>Implicit equijoins on subpath variables are not supported.
</note>
</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:BER-031</comment>
<item>The name of a node variable shall not be equivalent to the name of an edge variable 
declared at the same depth of graph pattern matching.
</item>

<comment>WG3:SXM-052</comment>
<comment>Editorial: WG3:SXM-052 Email Fred Zemke, 2020-07-21</comment>
<comment>WG3:W01-014 Deleted two items</comment>
<comment>WG3:W04-009R1</comment>
<comment>WG3:W09-031 deleted one rule.</comment>

<comment>WG3:W04-009R1</comment>
<comment>WG3:W09-031</comment>
<item>If <BNF name="keep clause"/> <symdef>KP</symdef> is specified, then:

<olist>

<item>Let <symdef>PSP</symdef> be the <BNF name="path pattern prefix"/> simply contained in 
<sym>KP</sym>.
</item>

<item>For each <BNF name="path pattern"/> <symdef>PP</symdef> simply contained in <sym>GP</sym>:

<olist>

<comment>WG3:W09-031</comment>
<item><sym>PP</sym> shall not contain a <BNF name="path search prefix"/>.
</item>

<item>Case:

<olist>

<comment>WG3:BER-031</comment>
<item>If <sym>PP</sym> specifies a <BNF name="path variable declaration"/>, then
let <symdef>PVDECL</symdef> be that <BNF name="path variable declaration"/>.
</item>

<comment>Editorial: Stephen Cannan, 2021-05-27 Standardize terms</comment>
<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10 Standardize terms</comment>
<item>Otherwise, let <symdef>PVDECL</symdef> be the zero-length character string.
</item>

</olist>

</item>

<item>Case:

<olist>

<comment>WG3:W09-031</comment>
<comment>WG3:UTC-009 P00-USA-169</comment>
<item>If <sym>PP</sym> specifies a <BNF name="path mode prefix"/>, then let <symdef>PMP</symdef>
be that <BNF name="path mode prefix"/>.
</item>

<comment>Editorial: Stephen Cannan, 2021-05-27 Standardize terms</comment>
<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10 Standardize terms</comment>
<item>Otherwise, let <symdef>PMP</symdef> be the zero-length character string.
</item>

</olist>

</item>

<item>Let <symdef>PPE</symdef> be the <BNF name="path pattern expression"/> simply contained in 
<sym>PP</sym>.
</item>

<comment>WG3:W09-031</comment>
<item><sym>PP</sym> is effectively replaced by:

<comment>WG3:W21-024R1</comment>
<code>
<sym>PVDECL</sym> <sym>PSP</sym> ( <sym>PMP</sym> <sym>PPE</sym> )
</code>

</item>

</olist>

</item>

<item>The <BNF name="keep clause"/> is removed from the <BNF name="graph pattern"/>.

<ednote id="gql_w04009_12">It has been suggested that it might be possible to treat the 
<BNF name="path pattern prefix"/> specified in <BNF name="keep clause"/> as merely providing 
a default <BNF name="path pattern prefix"/> rather than a mandatory one for each 
<BNF name="path pattern"/>.
Whereas nested <BNF name="path pattern prefix"/> is prohibited, this may be 
a feasible avenue of growth.
On the other hand, perhaps a less definitive verb than <kw>KEEP</kw> may be appropriate when 
specifying a default <BNF name="path pattern prefix"/>.
See <PPref ref="PPgql057"/>.
</ednote>

</item>

</olist>

</item>

<comment>WG3:W09-031</comment>
<item>After the preceding transformations, for every <BNF name="path pattern"/> <symdef>PP</symdef>,
if <sym>PP</sym> contains a <BNF name="path pattern prefix"/> <symdef>PPP</symdef> that specifies 
a <BNF name="path mode"/> <symdef>PM</symdef>, then:

<olist>

<item>Case:

<olist>

<comment>WG3:BER-031</comment>
<item>If <sym>PP</sym> specifies a <BNF name="path variable declaration"/>, then
let <symdef>PVDECL</symdef> be that <BNF name="path variable declaration"/>.
</item>

<comment>Editorial: Stephen Cannan, 2021-05-27 Standardize terms</comment>
<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10 Standardize terms</comment>
<item>Otherwise, let <symdef>PVDECL</symdef> be the zero-length character string.
</item>

</olist>

</item>

<item>Let <symdef>PPE</symdef> be the <BNF name="path pattern expression"/> simply contained in 
<sym>PP</sym>.
</item>

<item><sym>PP</sym> is effectively replaced by:

<comment>WG3:W21-024R1</comment>
<code>
<sym>PVDECL</sym> <sym>PPP</sym> ( <sym>PM</sym> <sym>PPE</sym> )
</code>

<note>One effect of the preceding transforms is that every <BNF name="path mode"/>
expressed outside a <BNF name="parenthesized path pattern expression"/> is also expressed
within a <BNF name="parenthesized path pattern expression"/>.
For example,

<code>
<kw>ALL</kw> <kw>SHORTEST</kw> <kw>TRAIL</kw> <kw>GROUP</kw> <BNF name="path pattern expression"/>
</code>
is rewritten as

<comment>Email from: Fred Zemke, 2022-05-22 2231</comment>
<code>
<kw>ALL</kw> <kw>SHORTEST</kw> <kw>TRAIL</kw> <kw>GROUP</kw> ( <kw>TRAIL</kw> <BNF name="path pattern expression"/> )
</code>

<comment>Editorial: Stefan Plantikow, 2022-02-24 WG3:W20-010 P00-USA-374</comment>
<para>The <kw>TRAIL</kw> specified outside the parentheses is now redundant.
The benefit is that the definition of a consistent path binding in 
<specref ref="gql_machinery_graph_pattern_matching"/>, only has to consider 
<BNF name="path mode"/>s declared in <BNF name="parenthesized path pattern expression"/>s.
</para>
</note>

</item>

</olist>

</item>

<comment>WG3:BER-032R3</comment>
<item>Let <symdef>GPT</symdef> be the <BNF name="graph pattern"/> after the preceding 
syntactic transformations.
</item>

<comment>WG3:BER-032R3</comment>
<item>Let <symdef>PPL</symdef> be the <BNF name="path pattern list"/> simply contained in 
<sym>GPT</sym>.
</item>

<comment>WG3:BER-032R3</comment>
<item>If <sym>GPT</sym> does not specify a <BNF name="match mode"/>, then 
an <impDef code="ID086"/> <BNF name="match mode"/> is implicit.
</item>

<comment>WG3:BER-032R3</comment>
<item>Let <symdef>MM</symdef> be the <BNF name="match mode"/> implicitly or explicitly specified 
by <sym>GPT</sym>.
</item>

<comment>WG3:BER-032R3</comment>
<comment>WG3:UTC-024</comment>
<item>If <sym>MM</sym> is <BNF name="different edges match mode"/> and <sym>PPL</sym> simply 
contains a <BNF name="path pattern"/> that is selective, then <sym>PPL</sym> shall not simply 
contain any other <BNF name="path pattern"/>.

<note>If <sym>MM</sym> is <BNF name="different edges match mode"/> and there is a selective
<BNF name="path pattern"/> <symdef>SPP</symdef>, then <sym>PPL</sym> must only contain 
<sym>SPP</sym>. 
If there is no selective <BNF name="path pattern"/> in <sym>GPT</sym>, then there are no 
restrictions on how many non-selective <BNF name="path pattern"/>s are contained in <sym>PPL</sym>. 
If <sym>MM</sym> is <BNF name="repeatable elements match mode"/>, then there is no restriction on 
how many (selective and non-selective) <BNF name="path pattern"/>s are contained in <sym>PPL</sym>.
</note>

</item>

<comment>WG3:BER-032R3</comment>
<item>Let <symdef>E</symdef> be an element variable declared by <sym>GPT</sym>.

<para>Case:
</para>

<olist>

<item>If <sym>E</sym> is exposed by <sym>GPT</sym> as an unconditional singleton, then 
<sym>E</sym> is a <newterm>global unconditional singleton</newterm> of <sym>GPT</sym>.
</item>

<comment>WG3:BER-080</comment>
<item>Otherwise, let <symdef>PPPE</symdef> be the outermost 
<BNF name="parenthesized path pattern expression"/> that exposes <sym>E</sym> as 
an unconditional singleton; the <newterm>unconditional singleton scope index</newterm> of 
<sym>E</sym> in <sym>GPT</sym> is the bracket index of <sym>PPPE</sym>.

<note>Bracket index is defined in <specref ref="gql_machinery_graph_pattern_matching"/>. 
The unconditional singleton scope index is well-defined because implicit equijoins between 
conditional singleton variables or group variables are forbidden.
Hence there cannot be two <BNF name="parenthesized path pattern expression"/>s that expose 
<sym>E</sym> as a conditional singleton or group variable unless one is contained in the other. 
For example,

<code>
( ( ( -[E]-> ) -[E]-> )* -[F]-> )*
</code>

<para>The unconditional singleton scope of E is the middle 
<BNF name="parenthesized path pattern expression"/> in the nest of three.
</para>

</note>

</item>

</olist>

</item>

<comment>WG3:BER-032R3</comment>
<item>After the preceding transformations, for every <BNF name="quantified path primary"/> 
<symdef>QPP</symdef> contained in <sym>GPT</sym>, at least one of the following shall be true:

<olist>

<item>The <BNF name="graph pattern quantifier"/> of <sym>QPP</sym> is bounded.
</item>

<item><sym>QPP</sym> is contained in a restrictive 
<BNF name="parenthesized path pattern expression"/>.
</item>

<comment>WG3:W09-031</comment>
<item><sym>QPP</sym> is contained in a selective <BNF name="path pattern"/>.
</item>

<comment>WG3:BER-032R3</comment>
<item><sym>MM</sym> is <BNF name="different edges match mode"/>.

<comment>WG3:W22-043 as amended</comment>
<comment>Editorial: Stephen Cannan, 2023-07-11, Standardize the spelling of keyword</comment>
<note>Unless an explicit <BNF name="path mode"/> other than <kw>WALK</kw> is specified, 
an explicit or implicit specification of a <BNF name="different edges match mode"/> effectively 
imparts the <BNF name="path mode"/> <kw>TRAIL</kw> without the presence of the 
keyword <kw>TRAIL</kw>.
</note>

</item>

</olist>

</item>

<comment>WG3:RKE-031</comment>
<comment>WG3:BER-031</comment>
<comment>WG3:BER-032R3</comment>
<comment>WG3:UTC-075</comment>
<comment>WG3:CMN-019 P00-USA-007</comment>
<item>Each <BNF name="path variable"/> <symdef>PV</symdef> contained in <sym>GPT</sym> is
the name of a path variable. 
The <newterm>degree of exposure</newterm> of the path variable that <sym>PV</sym> identifies is 
unconditional singleton.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>Editorial: Stefan Plantikow, 2020-02-21</comment>
<comment>WG3:W22-053R2</comment>
<comment>Editorial: Stephen Cannan, 2023-01-03 Add documentation</comment>
<item><SCsignature>
<symparam name="PROPERTY GRAPH"><symdef>PG</symdef></symparam>
<symparam name="GRAPH PATTERN"><symdef>GPT</symdef></symparam>
<symparam name="PATH PATTERN LIST"><symdef>PPL</symdef></symparam>
<symparam name="MACHINERY"><symdef>MACH</symdef></symparam>
<symreturn name="SET OF REDUCED MATCHES"/>
<documentation>
<slist>
<item>PROPERTY GRAPH &mdash; a property graph
</item>
<item>GRAPH PATTERN &mdash; a <BNF name="graph pattern"/>.
</item>
<item>PATH PATTERN LIST &mdash; a <BNF name="path pattern list"/>.
</item>
<item>MACHINERY &mdash; the machinery for graph pattern matching.
</item>
<item>SET OF REDUCED MATCHES &mdash; the resulting set of reduced matches.
</item>
</slist>
</documentation>
</SCsignature>

<comment>WG3:CMN-042</comment>
<note>In this document, <sym>PG</sym> is always the graph referenced by
the current working graph site of <sym>GPT</sym>.
</note>

</item>

<comment>WG3:W04-009R1</comment>
<item>The following components of <sym>MACH</sym> are identified:

<olist>

<item><symdef>ABC</symdef>, the alphabet, formed as the disjoint union of the following:

<olist>

<comment>WG3:BER-031</comment>
<item><symdef>SVV</symdef>, the set of names of node variables.
</item>

<comment>WG3:BER-031</comment>
<item><symdef>SEV</symdef>, the set of names of edge variables.
</item>

<item><symdef>SPS</symdef>, the set of subpath symbols.
</item>

<item><symdef>SAS</symdef>, the set of anonymous symbols.
</item>

<item><symdef>SBS</symdef>, the set of bracket symbols.
</item>

</olist>

</item>

<item><symdef>REDUCE</symdef>, the function mapping path bindings to path bindings, and multi-path
bindings to multi-path bindings.
</item>

</olist>

</item>

<comment>WG3:W04-009R1</comment>
<comment>Editorial: Stephen Cannan 2021-11-28</comment>
<item>Let <symdef>NP</symdef> be the number of <BNF name="path pattern"/>s simply contained in
<sym>PPL</sym>.
Let <symdef>PP</symdef><sub>1</sub>, <ellipsis/>, 
<symdef>PP</symdef><sub><sym>NP</sym></sub> be
the <BNF name="path pattern"/>s simply contained in <sym>PPL</sym> after the transformations in
the Syntax Rules.
</item>

<comment>WG3:BER-032R3</comment>
<comment>WG3:UTC-024</comment>
<item>A multi-path binding <symdef>MPBINDING</symdef> is 
<newterm>different-edges-matched</newterm> if, for every edge binding 
<symdef>EB1</symdef> = (<symdef>EV1</symdef>, <symdef>E</symdef>) contained in 
<sym>MPBINDING</sym>, there is no edge binding <symdef>EB2</symdef> = (<symdef>EV2</symdef>, 
<sym>E</sym>) contained in <sym>MPBINDING</sym> at a different position than <sym>EB1</sym>
that binds the edge <sym>E</sym>.
</item>

<comment>WG3:W04-009R1</comment>
<item>For every <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NP</sym>:

<olist>

<comment>WG3:W26-025R1</comment>
<item>Let <symdef>PPE</symdef> be the <BNF name="path pattern expression"/> simply  contained in 
<sym>PP</sym><sub><sym>i</sym></sub>.
</item>

<comment>WG3:W09-031</comment>
<comment>WG3:RKE-038 P16-USA-781</comment>
<comment>WG3:W21-048</comment>
<comment>WG3:BER-084R1</comment>
<comment>WG3:W22-053R2</comment>
<item>The <applySC ref="gql_eval_path_pattern_expr" rules="GR">
<symarg param="PROPERTY GRAPH"><sym>PG</sym></symarg>
<symarg param="PATH PATTERN LIST"><sym>PPL</sym></symarg>
<symarg param="MACHINERY"><sym>MACH</sym></symarg>
<symarg param="SPECIFIC BNF INSTANCE"><sym>PPE</sym></symarg>
<symresult param="SET OF MATCHES"><symdef>SMPPE</symdef><sub><sym>i</sym></sub></symresult>
</applySC>.

<comment>WG3:W22-043</comment>
<comment>WG3:W24-039R1</comment>
<note>If an elementary variable has been multiply declared within 
a restrictive <BNF name="parenthesized path pattern expression"/> <symdef>PP</symdef>, then 
no matches are returned for <sym>PP</sym>.
For example:

<code>
<kw>MATCH</kw> <kw>ACYCLIC</kw> (X) -> (X)
</code>

<para>does not find any results, even if there are nodes with self-edges.
</para>

</note>

</item>

<comment>WG3:W09-031</comment>
<item>Case:

<olist>

<comment>WG3:W20-022</comment>
<comment>WG3:RKE-038 P16-USA-781</comment>
<comment>WG3:W21-048</comment>
<comment>WG3:BER-032R3</comment>
<item>If <sym>PP</sym><sub><sym>i</sym></sub> is a selective <BNF name="path pattern"/>, then:

<olist>

<item>Case:

<olist>

<comment>WG3:UTC-024</comment>
<item>If <sym>MM</sym> is <BNF name="different edges match mode"/>, then 
let <symdef>SMUP</symdef><sub><sym>i</sym></sub> be the set of different-edges-matched
multi-path bindings in <sym>SMPPE</sym><sub><sym>i</sym></sub>.

<note>If an edge variable has been multiply declared within a <BNF name="path pattern"/> 
<symdef>PP</symdef>, then no matches are returned for <sym>PP</sym>.
For example, the following produces no results:
<code>
<kw>MATCH</kw> <kw>DIFFERENT</kw> <kw>EDGES</kw>
      <kw>ANY</kw> <kw>SHORTEST</kw> () -[E]-> () -[E]-> ()
</code>
</note>

</item>

<comment>WG3:W24-039R1</comment>
<item>Otherwise, let <symdef>SMUP</symdef><sub><sym>i</sym></sub> be
<sym>SMPPE</sym><sub><sym>i</sym></sub>.
</item>

</olist>

</item>

<comment>WG3:W22-053R2</comment>
<item>The 
<applySC ref="gql_eval_sel_paren_path_pattern_expr" rules="GR">
<symarg param="PROPERTY GRAPH"><sym>PG</sym></symarg>
<symarg param="PATH PATTERN LIST"><sym>PPL</sym></symarg>
<symarg param="MACHINERY"><sym>MACH</sym></symarg>
<symarg param="SELECTIVE PATH PATTERN"><sym>PP</sym><sub><sym>i</sym></sub></symarg>
<symarg param="INPUT SET OF LOCAL MATCHES"><sym>SMUP</sym><sub><sym>i</sym></sub></symarg>
<symresult param="OUTPUT SET OF LOCAL MATCHES"><symdef>SM</symdef><sub><sym>i</sym></sub>
</symresult>
</applySC>.
</item>

</olist>

</item>

<comment>WG3:W24-039R1</comment>
<item>Otherwise, let <symdef>SM</symdef><sub><sym>i</sym></sub> be 
<sym>SMPPE</sym><sub><sym>i</sym></sub>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W04-009R1</comment>
<item>Let <symdef>CROSS</symdef> be the cross product 
<sym>SM</sym><sub>1</sub> <crossProd/> <ellipsis/> <crossProd/> 
<sym>SM</sym><sub><sym>NP</sym></sub>.
</item>

<comment>WG3:W04-009R1</comment>
<comment>WG3:BER-031</comment>
<item>Let <symdef>INNER</symdef> be the set of multi-path bindings <symdef>MPB</symdef> in 
<sym>CROSS</sym> such that, for every unconditional singleton <BNF name="element variable"/>
<symdef>USV</symdef> exposed by <sym>PPL</sym>, <sym>USV</sym> is bound to a unique graph element 
by the elementary bindings of <sym>USV</sym> contained in <sym>MPB</sym>.

<note>Anonymous symbols are not <BNF name="element variable"/>s; there is no requirement that two 
anonymous symbols bind to the same graph element.
</note>

</item>

<comment>WG3:BER-032R3</comment>
<item>Case:

<olist>

<comment>WG3:UTC-024</comment>
<item>If <sym>MM</sym> is <BNF name="different edges match mode"/>, then 
let <symdef>BINDINGS</symdef> be the set of different-edges-matched multi-path
bindings in <sym>INNER</sym>.

<note>If an edge variable has been multiply declared within a <BNF name="graph pattern"/> 
<symdef>GP</symdef>, then no matches are returned for <sym>GP</sym>.
For example, the following produces no results:
<code>
<kw>MATCH</kw> <kw>DIFFERENT</kw> <kw>EDGES</kw> () -[E]-> (), () -[E]-> ()
</code>
<para>and neither does the following:
</para>
<code>
<kw>MATCH</kw> <kw>DIFFERENT</kw> <kw>EDGES</kw> () -[E]-> () -[E]-> ()
</code>

</note>

</item>

<item>Otherwise, let <symdef>BINDINGS</symdef> be <sym>INNER</sym>.
</item>

</olist>

</item>

<comment>WG3:W04-009R1</comment>
<comment>WG3:W08-018</comment>
<comment>Email from: Tobias Lindaaker, 2021-03-22</comment>
<comment>Editorial: Stephen Cannan 2021-11-28</comment>
<comment>WG3:BER-031</comment>
<comment>Email from: Jim Melton 2022-12-08 0219</comment>
<item>A <newterm>match</newterm> of <sym>GPT</sym> is a multi-path binding <symdef>M</symdef> =
( <symdef>PB</symdef><sub>1</sub>, <ellipsis/>, <symdef>PB</symdef><sub><sym>NP</sym></sub> ) of
<sym>NP</sym> path bindings in <sym>BINDINGS</sym>, such that all of the following are true:

<olist>

<comment>Email from: Fred Zemke, 2019-02-28 2154</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W04-009R1</comment>
<item>For every <symdef>j</symdef>, 1 (one) <leq/> <sym>j</sym> <leq/> <sym>NP</sym>,
and for every <BNF name="parenthesized path pattern expression"/> <symdef>PPPE</symdef> 
contained in <sym>PP</sym><sub><sym>j</sym></sub>, let <symdef>i</symdef> be the bracket index 
of <sym>PPPE</sym>, and let <symdef><delimId>[<sub><sym>i</sym></sub></delimId></symdef> and 
<symdef><delimId>]<sub><sym>i</sym></sub></delimId></symdef> be the bracket symbols associated with 
<sym>PPPE</sym>.
A <newterm>binding</newterm> of <sym>PPPE</sym> is a substring of 
<sym>PB</sym><sub><sym>j</sym></sub> that begins with the bracket binding 
(<delimId>[<sub><sym>i</sym></sub></delimId>,
<delimId>[<sub><sym>i</sym></sub></delimId>) and ends with the next bracket binding
(<delimId>]<sub><sym>i</sym></sub></delimId>, <delimId>]<sub><sym>i</sym></sub></delimId>).

<comment>WG3:RKE-039 P16-USA-771</comment>
<note><quote>Bracket index</quote> is defined in 
<specref ref="gql_machinery_graph_pattern_matching"/>.
</note>

<comment>Email from: Jim Melton 2022-12-08 0219</comment>
<para>For every binding <symdef>BPPPE</symdef> of <sym>PPPE</sym> contained in
<sym>PB</sym><sub><sym>j</sym></sub>, all of the following are true:
</para>

<olist>

<comment>WG3:SXM-052</comment>
<comment>WG3:W02-015</comment>
<comment>WG3:BER-031</comment>
<item>For every <BNF name="element variable"/> <symdef>EV</symdef> that is exposed as 
an unconditional singleton by <sym>PPPE</sym>, <sym>EV</sym> is bound to a unique graph element by 
the element variable bindings contained in <sym>BPPPE</sym>.

<note>Anonymous symbols are not <BNF name="element variable"/>s; there is no requirement that 
two anonymous symbols bind to the same graph element.
</note>

</item>

<comment>WG3:SXM-052</comment>
<comment>WG3:W13-018</comment>
<comment>WG3:BER-032R3</comment>
<comment>Editorial: Stephen Cannan 2021-09-28 Use new applySC asTest option</comment>
<item>If <sym>PPPE</sym> contains a <BNF name="parenthesized path pattern where clause"/>
<symdef>PPPWC</symdef>, then <bool>True</bool> 
<applySC ref="gql_app_bind_eval_expr" rules="GR" type="asTest">
<symarg param="GRAPH PATTERN"><sym>GPT</sym></symarg>
<symarg param="EXPRESSION">the <BNF name="search condition"/> simply contained 
in <sym>PPPWC</sym></symarg>
<symarg param="MACHINERY"><sym>MACH</sym></symarg>
<symarg param="MULTI-PATH BINDING"><sym>M</sym></symarg>
<symarg param="REFERENCE TO LOCAL CONTEXT">a reference to <sym>BPPPE</sym></symarg>
<symresult param="VALUE"><symdef>V1</symdef></symresult>
</applySC>.

</item>

</olist>

</item>

<comment>WG3:W13-018</comment>
<comment>WG3:BER-032R3</comment>
<comment>Editorial: Stephen Cannan 2021-09-28 Use new applySC asTest option</comment>
<item>If <sym>GPT</sym> contains a <BNF name="graph pattern where clause"/> <symdef>GPWC</symdef>,
then <bool>True</bool>
<applySC ref="gql_app_bind_eval_expr" rules="GR" type="asTest">
<symarg param="GRAPH PATTERN"><sym>GPT</sym></symarg>
<symarg param="EXPRESSION"><sym>GPWC</sym></symarg>
<symarg param="MACHINERY"><sym>MACH</sym></symarg>
<symarg param="MULTI-PATH BINDING"><sym>M</sym></symarg>
<symarg param="REFERENCE TO LOCAL CONTEXT">a reference to <sym>M</sym></symarg>
<symresult param="VALUE"><symdef>V2</symdef></symresult>
</applySC>.
</item>

</olist>

</item>

<comment>WG3:SXM-052</comment>
<comment>WG3:W04-009R1</comment>
<comment>Editorial: Stephen Cannan 2021-11-28</comment>
<item id="gql_graph_pattern_GR_red_match">A <newterm>reduced match</newterm> <symdef>RM</symdef> =
( <symdef>RPB</symdef><sub>1</sub>, <ellipsis/>, <sym>RPB</sym><sub><sym>NP</sym></sub> ) is 
obtained from a match <symdef>M</symdef> = ( <sym>PB</sym><sub>1</sub>, <ellipsis/>, 
<sym>PB</sym><sub><sym>NP</sym></sub> ) as 
<sym>RM</sym> = <sym>REDUCE</sym>(<sym>M</sym>).

<comment>Editorial: Stephen Cannan 2023-01-20 Align with Directives Part 2</comment>
<note>Set-theoretic deduplication will occur here.
That is, two or more matches can reduce to the same reduced match; this scenario is regarded as
contributing only a single reduced match to the result set.
</note>

</item>

<comment>WG3:W22-053R2</comment>
<comment>Editorial: Stephen Cannan 2022-09-27 Align with SQL/PGQ</comment>
<item>Let <symdef>SRM</symdef> be the set of reduced matches.
</item>

<comment>Insert explicit SCreturn</comment>
<item><SCreturn>
 <SCretval name="SET OF REDUCED MATCHES"><sym>SRM</sym></SCretval>
</SCreturn>
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<item>Without <feature code="G002"/>, conforming GQL language shall not contain 
a <BNF name="different edges match mode"/>.
</item>

<item>Without <feature code="G003"/>, conforming GQL language shall not contain 
a <BNF name="match mode"/> that specifies <kw>REPEATABLE</kw> <kw>ELEMENTS</kw> or 
<kw>REPEATABLE</kw> <kw>ELEMENT</kw> <kw>BINDINGS</kw>.
</item>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G004"/>, conforming GQL language shall not contain 
a <BNF name="path pattern"/> that simply contains a <BNF name="path variable declaration"/>.
</item>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G005"/>, conforming GQL language shall not contain 
a <BNF name="path pattern"/> that simply contains a <BNF name="path pattern prefix"/> that is 
a <BNF name="path search prefix"/>.
</item>

<comment>WG3:W13-022R1</comment>
<comment>WG3:BER-030</comment>
<item>Without <feature code="G006"/>, conforming GQL language shall not contain 
a <BNF name="keep clause"/> that simply contains a <BNF name="path mode prefix"/>.
</item>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G007"/>, conforming GQL language shall not contain 
a <BNF name="keep clause"/> that simply contains a <BNF name="path search prefix"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_insert_graph_pattern" newpage="true">
<clauseHeading><BNF name="insert graph pattern"/></clauseHeading>

<bodyMatter>


<Function>

<comment>WG3:OHD-012</comment>
<para>Define an <BNF name="insert graph pattern"/>.
</para>

</Function>


<Format>

<comment>WG3:OHD-012</comment>
<grammar>

<BNFdef name="insert graph pattern">
<rhs>
<BNF name="insert path pattern list"/>
</rhs>
</BNFdef>

<comment>Editorial: Stephen Cannan, 2023-06-22, Correct application of OHD-012</comment>
<comment>WG3:CMN-019 P00-USA-101</comment>
<BNFdef name="insert path pattern list">
<rhs>
<BNF name="insert path pattern"/>
<opt> <group> <BNF name="comma"/> <BNF name="insert path pattern"/> </group><repeat/> </opt>
</rhs>
</BNFdef>

<BNFdef name="insert path pattern">
<rhs>
<BNF name="insert node pattern"/>
<opt>
<group> <BNF name="insert edge pattern"/> <BNF name="insert node pattern"/> </group><repeat/>
</opt>
</rhs>
</BNFdef>

<BNFdef name="insert node pattern">
<rhs>
<BNF name="left paren"/> 
<opt> <BNF name="insert element pattern filler"/> </opt> 
<BNF name="right paren"/>
</rhs>
</BNFdef>

<BNFdef name="insert edge pattern">
<rhs>
<alt> <BNF name="insert edge pointing left"/> </alt>
<alt> <BNF name="insert edge pointing right"/> </alt>
<alt> <BNF name="insert edge undirected"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="insert edge pointing left">
<rhs>
<BNF name="left arrow bracket"/>
<opt> <BNF name="insert element pattern filler"/> </opt> 
<BNF name="right bracket minus"/>
</rhs>
</BNFdef>

<BNFdef name="insert edge pointing right">
<rhs>
<BNF name="minus left bracket"/>
<opt> <BNF name="insert element pattern filler"/> </opt> 
<BNF name="bracket right arrow"/>
</rhs>
</BNFdef>

<BNFdef name="insert edge undirected">
<rhs>
<BNF name="tilde left bracket"/>
<opt> <BNF name="insert element pattern filler"/> </opt> 
<BNF name="right bracket tilde"/>
</rhs>
</BNFdef>

<BNFdef name="insert element pattern filler">
<rhs>
<alt>
<BNF name="element variable declaration"/>
<opt> <BNF name="label and property set specification"/> </opt>
</alt>
<alt>
<opt> <BNF name="element variable declaration"/> </opt>
<BNF name="label and property set specification"/>
</alt>
</rhs>
</BNFdef>

<comment>WG3:CMN-044</comment>
<BNFdef name="label and property set specification">
<rhs>
<alt>
<BNF name="is or colon"/> <BNF name="label set specification"/>
<opt> <BNF name="element property specification"/> </opt>
</alt>
<alt>
<opt> <BNF name="is or colon"/> <BNF name="label set specification"/> </opt>
<BNF name="element property specification"/>
</alt>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2 Removed 1 (one) production</comment>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:UTC-094</comment>
<item>Let <symdef>IGP</symdef> be the <BNF name="insert graph pattern"/>.
</item>

<comment>WG3:UTC-094</comment>
<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<item>For every <BNF name="insert element pattern filler"/> <symdef>IEPF</symdef> simply contained
in <sym>IGP</sym> that does not immediately contain an <BNF name="element variable declaration"/>:

<olist>

<comment>WG3:W26-037R3</comment>
<item>Let <symdef>IDN</symdef> be the name of a new system-generated regular identifier.
</item>

<item><sym>IEPF</sym> is effectively replaced by:
<code>
<sym>IDN</sym> <sym>IEPF</sym>
</code>

</item>

</olist>

</item>

<comment>WG3:UTC-094</comment>
<comment>WG3:W26-037R3</comment>
<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<item>The system-generated variable names of <sym>IGP</sym> are the names of all 
<BNF name="element variable declaration"/>s that are system-generated regular identifiers
immediately contained in an <BNF name="insert element pattern filler"/> simply contained in 
<sym>IGP</sym>.
</item>

<comment>WG3:UTC-094</comment>
<item>Let <symdef>IS</symdef> be the <BNF name="insert statement"/> that immediately contains
<sym>IGP</sym>.
</item>

<comment>WG3:OHD-012</comment>
<comment>WG3:UTC-094</comment>
<item>An <BNF name="element variable"/> <symdef>EV</symdef> contained in
an <BNF name="element variable declaration"/> <symdef>EVD</symdef> is said to be declared by
<sym>EVD</sym>, and by the <BNF name="insert node pattern"/> or <BNF name="insert edge pattern"/> 
<symdef>EP</symdef> that simply contains <sym>EVD</sym>.
The <BNF name="element variable"/> specifies the name of an element variable, which is also 
declared by <sym>EVD</sym> and <sym>EP</sym>.
</item>

<comment>WG3:OHD-012</comment>
<comment>Editorial: Stephen Cannan, 2023-10-13</comment>
<item>For every <BNF name="value expression"/> <symdef>VE</symdef> immediately contained
in a <BNF name="property key value pair"/> immediately contained in
an <BNF name="element property specification"/> simply contained in <sym>IGP</sym>:

<olist>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>VE</sym> is incoming working record type
of <sym>IS</sym> amended with the record type of incoming working table type
of <sym>IS</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>VE</sym> is the material unit binding
table type.
</item>
<endbar/>

<item>The declared type of <sym>VE</sym> shall be a supported property value type.
</item>

</olist>

</item>

<comment>WG3:OHD-012</comment>
<comment>WG3:UTC-094</comment>
<item id="gql_insert_SR_element_pattern">An <newterm>insert element pattern</newterm> is either
an <BNF name="insert node pattern"/> or an <BNF name="insert edge pattern"/> that is simply
contained in <sym>IGP</sym>.
</item>

<comment>WG3:UTC-094</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item id="gql_insert_SR_bound_element_pattern">A <newterm>bound insert element pattern</newterm>
is an insert element pattern <symdef>IEP</symdef> that declares 
an <BNF name="element variable"/> <symdef>EV</symdef> whose name is either the name of 
a column <symdef>COL</symdef> of the incoming working table type of <sym>IS</sym> or
is the name of a field type <symdef>FT</symdef> of the incoming working record type
of <sym>IS</sym>. 
The declared type of <sym>IEP</sym> is the column type of <sym>COL</sym> or the value type of 
<sym>FT</sym>.
</item>
<endbar/>

<comment>WG3:UTC-094</comment>
<item>No <BNF name="property key value pair list"/> simply contained in a bound insert element
pattern shall simply contain two equivalent <BNF name="property name"/>s that are each
immediately contained in a different <BNF name="property key value pair"/>.
</item>

<comment>WG3:OHD-012</comment>
<comment>WG3:UTC-094</comment>
<item>For every <BNF name="element variable"/> <symdef>EV</symdef> simply contained in 
<symdef>IGP</symdef>:

<olist>

<comment>Editorial: Stefan Plantikow, 2022-10-05 Added WT site</comment>
<comment>WG3:UTC-009 P00-USA-169</comment>
<item>For every bound insert element pattern <symdef>EP</symdef> that declares <sym>EV</sym>:

<olist>

<comment>WG3:CMN-019 P00-USA-102</comment>
<item><symdef>EP</symdef> shall be an <BNF name="insert node pattern"/>.
</item>

<item>The declared type of <sym>EP</sym> shall be a node reference value type.
</item>

<item><sym>EP</sym> shall not simply contain a <BNF name="label and property set specification"/>.
</item>

</olist>

</item>

<item id="gql_insert_gp_SR_def_ins_patt">The <newterm>defining insert element pattern</newterm> of
<sym>EV</sym> is the first insert element pattern that declares <sym>EV</sym>.
Every insert element pattern that declares <sym>EV</sym> and is not the 
defining insert element pattern of <sym>EV</sym> shall not simply contain 
a <BNF name="label and property set specification"/>.
</item>

</olist>

</item>

<comment>WG3:OHD-012</comment>
<comment>Email from: Jim Melton 2022-12-08 0219</comment>
<comment>Editorial: Stefan Plantikow, 2023-01-05 Correct use of equivalent</comment>
<item>If an <BNF name="insert edge pattern"/> <symdef>EP1</symdef> declares
an <BNF name="element variable"/> <symdef>EV1</symdef>, then there shall not be
an <BNF name="insert node pattern"/> or <BNF name="insert edge pattern"/> <symdef>EP2</symdef> 
that declares an <BNF name="element variable"/> <symdef>EV2</symdef> equivalent to <sym>EV1</sym>.

<note>This rule has two consequences.

<ulist>

<item>If an <BNF name="insert node pattern"/> declares 
an <BNF name="element variable"/> <symdef>EV</symdef>, then there is not 
an <BNF name="insert edge pattern"/> that declares an <BNF name="element variable"/> with 
the same name as <sym>EV</sym>.
</item>

<item>Every <BNF name="insert edge pattern"/> is the defining insert element pattern of the 
element variable it declares.
</item>

</ulist>

</note>

</item>

</olist>

</SyntaxRules>


<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W12-025</comment>
<comment>WG3:OHD-015</comment>
<comment>WG3:CMN-026</comment>
<comment>WG3:W26-022R2 Consequence</comment>
<item>Without <feature code="GH02"/>, conforming GQL language shall not contain
an <BNF name="insert edge pattern"/> that is an <BNF name="insert edge undirected"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:BER-030</comment>
<subClause id="gql_path_pattern_prefix" newpage="true">
<clauseHeading><BNF name="path pattern prefix"/></clauseHeading>

<bodyMatter>

<Function>

<para>Specify a path-finding operation and a path mode.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:W09-031</comment>
<BNFdef name="path pattern prefix">
<rhs>
<alt> <BNF name="path mode prefix"/> </alt>
<alt> <BNF name="path search prefix"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W09-031</comment>
<BNFdef name="path mode prefix">
<rhs>
<BNF name="path mode"/> <opt> <BNF name="path or paths"/> </opt>
</rhs>
</BNFdef>

<BNFdef name="path mode">
<rhs>
<alt> <kw>WALK</kw> </alt>
<alt> <kw>TRAIL</kw> </alt>
<alt> <kw>SIMPLE</kw> </alt>
<alt> <kw>ACYCLIC</kw> </alt>
</rhs>
</BNFdef>

<BNFdef name="path search prefix">
<rhs>
<alt> <BNF name="all path search"/> </alt>
<alt> <BNF name="any path search"/> </alt>
<alt> <BNF name="shortest path search"/> </alt>
</rhs>
</BNFdef>

<ednote id="gql_w04009_15">The ability to specify <quote>cheapest</quote> queries (analogous to 
<kw>SHORTEST</kw>, but minimizing the sum of costs along a path) is desirable.
See <PPref ref="PPgql052"/>.
</ednote>

<BNFdef name="all path search">
<rhs>
<kw>ALL</kw> <opt> <BNF name="path mode"/> </opt> <opt> <BNF name="path or paths"/> </opt>
</rhs>
</BNFdef>

<BNFdef name="path or paths">
<rhs>
<alt br="no"> <kw>PATH</kw> </alt>
<alt br="no"> <kw>PATHS</kw> </alt>
</rhs>
</BNFdef>

<BNFdef name="any path search">
<rhs>
<kw>ANY</kw> <opt> <BNF name="number of paths"/> </opt> 
<opt> <BNF name="path mode"/> </opt> 
<opt> <BNF name="path or paths"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:W15-020</comment>
<comment>WG3:CMN-061R1</comment>
<BNFdef name="number of paths">
<rhs>
<BNF name="non-negative integer specification"/>
</rhs>
</BNFdef>

<ednote>This differs from the SQL/PGQ definition of <BNF name="number of paths"/>.
</ednote>

<BNFdef name="shortest path search">
<rhs>
<alt> <BNF name="all shortest path search"/> </alt>
<alt> <BNF name="any shortest path search"/> </alt>
<alt> <BNF name="counted shortest path search"/> </alt>
<alt> <BNF name="counted shortest group search"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="all shortest path search">
<rhs>
<kw>ALL</kw> <kw>SHORTEST</kw> 
<opt> <BNF name="path mode"/> </opt> <opt> <BNF name="path or paths"/> </opt>
</rhs>
</BNFdef>

<BNFdef name="any shortest path search">
<rhs>
<kw>ANY</kw> <kw>SHORTEST</kw> 
<opt> <BNF name="path mode"/> </opt> <opt> <BNF name="path or paths"/> </opt>
</rhs>
</BNFdef>

<BNFdef name="counted shortest path search">
<rhs>
<kw>SHORTEST</kw> <BNF name="number of paths"/>
<opt> <BNF name="path mode"/> </opt> <opt> <BNF name="path or paths"/> </opt>
</rhs>
</BNFdef>

<BNFdef name="counted shortest group search">
<rhs>
<kw>SHORTEST</kw> <opt> <BNF name="number of groups"/> </opt>
<opt> <BNF name="path mode"/> </opt> <opt> <BNF name="path or paths"/> </opt>
<group> <alt br="no"> <kw>GROUP</kw> </alt> <alt br="no"> <kw>GROUPS</kw> </alt> </group>
</rhs>
</BNFdef>

<comment>WG3:W15-020</comment>
<comment>WG3:CMN-061R1</comment>
<BNFdef name="number of groups">
<rhs>
<BNF name="non-negative integer specification"/>
</rhs>
</BNFdef>

<ednote>This differs from the SQL/PGQ definition of <BNF name="number of groups"/>.
</ednote>

<ednote id="gql_w04009_16">In addition to <kw>SHORTEST</kw> <kw>GROUP</kw>, it has been proposed to 
support <kw>SHORTEST</kw> [ <symdef>k</symdef> ] WITH TIES, with the semantics to 
return the first <sym>k</sym> matches (where <sym>k</sym> defaults to 1) when sorting matches in 
ascending order on number of edges, and also return every match that has the same number of edges 
as the last of the <sym>k</sym> matches.
This is the semantics of WITH TIES in <extref standard="9075" part="02" ref="fnd_qexp"/> in 
SQL/Foundation.
See <PPref ref="PPgql053"/>.
</ednote>

</grammar>


</Format>


<SyntaxRules>

<olist>

<comment>WG3:W09-031</comment>
<item>If a <BNF name="parenthesized path pattern expression"/> does not specify 
a <BNF name="path mode prefix"/>, then <kw>WALK</kw> <kw>PATHS</kw> is implicit.
</item>

<comment>WG3:W09-031</comment>
<item>If a <BNF name="path pattern prefix"/> <symdef>PPP</symdef> does not specify 
<BNF name="all path search"/>, then:

<olist>

<item>Case:

<olist>

<item>If <sym>PPP</sym> does not simply contain a <BNF name="path mode"/>, then 
let <symdef>PM</symdef> be <kw>WALK</kw>.
</item>

<item>Otherwise, let <symdef>PM</symdef> be the <BNF name="path mode"/> simply contained in 
<sym>PPP</sym>.
</item>

</olist>

</item>

<item>Case:

<olist>

<item>If <sym>PPP</sym> does not simply contain a <BNF name="number of paths"/> or 
<BNF name="number of groups"/>, then let <symdef>N</symdef> be 
an <BNF name="unsigned integer"/> whose value is 1 (one).
</item>

<item>Otherwise, let <symdef>N</symdef> be the <BNF name="number of paths"/> or 
<BNF name="number of groups"/> simply contained in <sym>PPP</sym>.
The declared type of <sym>N</sym> shall be exact numeric with scale 0 (zero).
If <sym>N</sym> is a <BNF name="literal"/>, then the value of <sym>N</sym> shall be 
positive.
</item>

</olist>

</item>

<item>Case:

<olist>

<item>If <sym>PPP</sym> is an <BNF name="any path search"/>, then <sym>PPP</sym> is equivalent to:

<code>
<kw>ANY</kw> <sym>N</sym> <sym>PM</sym> <kw>PATHS</kw>
</code>
</item>

<item>If <sym>PPP</sym> is a <BNF name="shortest path search"/>, then

<para>Case:
</para>

<olist>

<item>If <sym>PPP</sym> is <BNF name="all shortest path search"/>, then <sym>PPP</sym> is 
equivalent to:

<code>
<kw>SHORTEST</kw> 1 <sym>PM</sym> <kw>GROUP</kw>
</code>
</item>

<item>If <sym>PPP</sym> is <BNF name="any shortest path search"/>, then <sym>PPP</sym> is
equivalent to:

<code>
<kw>SHORTEST</kw> 1 <sym>PM</sym> <kw>PATH</kw>
</code>
</item>

<item>If <sym>PPP</sym> is <BNF name="counted shortest path search"/>, then <sym>PPP</sym> is 
equivalent to:

<code>
<kw>SHORTEST</kw> <sym>N</sym> <sym>PM</sym> <kw>PATHS</kw>
</code>
</item>

<item>If <sym>PPP</sym> is <BNF name="counted shortest group search"/>, then <sym>PPP</sym> is 
equivalent to:

<code>
<kw>SHORTEST</kw> <sym>N</sym> <sym>PM</sym> <kw>GROUPS</kw>
</code>
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W09-031</comment>
<item>A <BNF name="path pattern prefix"/> that specifies a <BNF name="path mode"/> other than 
<kw>WALK</kw> is <newterm>restrictive</newterm>.
A <BNF name="parenthesized path pattern expression"/> that immediately contains
a restrictive <BNF name="path mode prefix"/> is <newterm>restrictive</newterm>.
</item>

<comment>WG3:W09-031</comment>
<item>A <BNF name="path search prefix"/> other than <BNF name="all path search"/> is 
<newterm>selective</newterm>.
A <BNF name="path pattern"/> that simply contains a selective <BNF name="path search prefix"/> 
is <newterm>selective</newterm>.
</item>

<comment>WG3:W08-018</comment>
<comment>WG3:W09-031</comment>

<comment>WG3:W09-031</comment>
<comment>WG3:BER-080</comment>
<item>Let <symdef>PPPE</symdef> be a selective <BNF name="path pattern"/>.

<olist>

<item>An element variable exposed by <sym>PPPE</sym> is an <newterm>interior variable</newterm> of 
<sym>PPPE</sym>.
</item>

<comment>Email from: Jim Melton 2022-12-08 0219</comment>
<item>A node variable <symdef>LVV</symdef> is the <newterm>left boundary variable</newterm> of 
<sym>PPPE</sym> if all of the following conditions are true:

<olist>

<comment>WG3:W08-009 P16-SWE-024</comment>
<item><sym>PPPE</sym> exposes <sym>LVV</sym> as an unconditional singleton variable.
</item>

<item><sym>LVV</sym> is declared in the first explicit or implicit <BNF name="node pattern"/> 
<symdef>LVP</symdef> contained in <sym>PPPE</sym>.
</item>

<item><sym>LVP</sym> is not contained in a <BNF name="path pattern union"/> or 
<BNF name="path multiset alternation"/> that is contained in <sym>PPPE</sym>.
</item>

</olist>

</item>

<comment>Email from: Jim Melton 2022-12-08 0219</comment>
<item>A node variable <symdef>RVV</symdef> is the <newterm>right boundary variable</newterm> of 
<sym>PPPE</sym> if all of the following conditions are true:

<olist>

<item><sym>PPPE</sym> exposes <sym>RVV</sym> as an unconditional singleton variable.
</item>

<item><sym>RVV</sym> is declared in the last explicit or implicit <BNF name="node pattern"/> 
<symdef>RVP</symdef> contained in <sym>PPPE</sym>.
</item>

<item><sym>RVP</sym> is not contained in a <BNF name="path pattern union"/> or 
<BNF name="path multiset alternation"/> that is contained in <sym>PPPE</sym>.

<ednote id="gql_w04009_19">With more work, it is possible to recognize when a node variable is 
declared uniformly in the first or the last position in every operand of 
a <BNF name="path pattern union"/>.
However, WG3:W04-009R1 declined to make the effort because it is easy for the user to factor out 
such a node pattern.
For example, instead of
<code>
(X) -> (Y) | (X) -> (Z)
</code>

<para>the user can write
</para>

<comment>WG3:W21-024R1</comment>
<code>
(X) ( -> (Y) | -> (Z))
</code>

<para>Thus a more general definition of right or left boundary variable is possible.
See <PPref ref="PPgql056"/>.
</para>

</ednote>

</item>

</olist>

</item>

<item>An element variable that is exposed by <sym>PPPE</sym> that is neither a left boundary
variable of <sym>PPPE</sym> nor a right boundary variable of <sym>PPPE</sym> is 
a <newterm>strict interior variable</newterm> of <sym>PPPE</sym>.
</item>

</olist>

</item>

<comment>WG3:W09-031</comment>
<item>An element variable that is not declared in a selective <BNF name="path pattern"/> is 
an <newterm>exterior variable</newterm>.
</item>

<comment>Editorial: Stephen Cannan, 2023-08-10</comment>
<item>A strict interior variable of one selective <BNF name="path pattern"/> shall not be 
equivalent to an exterior variable, or to an interior variable of another selective 
<BNF name="path pattern"/>.

<comment>WG3:W20-022</comment>
<comment>WG3:CMN-019 P00-ISO-031</comment>
<note id="gql_selector_use_6">This does not prohibit implicit joins of boundary variables of 
selective <BNF name="path pattern"/>s with exterior variables or boundary variables of other 
selective <BNF name="path pattern"/>s.
</note>

</item>

<comment>WG3:W21-062</comment>
<item>A selective <BNF name="path pattern"/> <symdef>SPP</symdef> shall not contain a reference to 
a graph pattern variable that is not declared by <sym>SPP</sym>.

<comment>Editorial: Stephen Cannan 2023-01-20 Align with Directives Part 2</comment>
<note>This rule, and the prohibition of implicit joins to exterior variables and interior 
variables of other selective <BNF name="path pattern"/>s, insure that each selective 
<BNF name="path pattern"/> can be evaluated in isolation from any other <BNF name="path pattern"/>.
</note>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<None/>

</olist>

<comment>WG3:W20-022</comment>
<note>Restrictive <BNF name="path mode"/>s are enforced as part of the check for
consistent path bindings in the generation of the set of local matches in 
<specref ref="gql_path_pattern_expr"/>.
Selective <BNF name="path pattern"/>s are evaluated by 
<specref ref="gql_eval_sel_paren_path_pattern_expr"/>.
</note>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G010"/>, conforming GQL language shall not contain 
a <BNF name="path mode"/> that specifies <kw>WALK</kw>.
</item>

<comment>WG3:W13-022R1</comment>
<item>Without <feature code="G011"/>, conforming GQL language shall not contain 
a <BNF name="path mode"/> that specifies <kw>TRAIL</kw>.
</item>

<comment>WG3:W13-022R1</comment>
<item>Without <feature code="G012"/>, conforming GQL language shall not contain 
a <BNF name="path mode"/> that specifies <kw>SIMPLE</kw>.
</item>

<comment>WG3:W13-022R1</comment>
<item>Without <feature code="G013"/>, conforming GQL language shall not contain 
a <BNF name="path mode"/> that specifies <kw>ACYCLIC</kw>.
</item>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G014"/>, conforming GQL language shall not contain 
a <BNF name="path or paths"/>.
</item>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G015"/>, conforming GQL language shall not contain 
an <BNF name="all path search"/>.
</item>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G016"/>, conforming GQL language shall not contain 
an <BNF name="any path search"/>.
</item>

<comment>WG3:W13-022R1</comment>
<item>Without <feature code="G017"/>, conforming GQL language shall not contain 
an <BNF name="all shortest path search"/>.
</item>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G018"/>, conforming GQL language shall not contain 
an <BNF name="any shortest path search"/>.
</item>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G019"/>, conforming GQL language shall not contain 
a <BNF name="counted shortest path search"/>.
</item>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G020"/>, conforming GQL language shall not contain 
a <BNF name="counted shortest group search"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W04-009R1</comment>
<subClause id="gql_path_pattern_expr" newpage="true">
<clauseHeading><BNF name="path pattern expression"/></clauseHeading>

<bodyMatter>

<Function>

<para>Specify a pattern to match a single path in a property graph.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:ERF-035</comment>
<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<BNFdef name="path pattern expression">
<rhs>
<alt> <BNF name="path term"/> </alt>
<alt> <BNF name="path multiset alternation"/> </alt>
<alt> <BNF name="path pattern union"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:BNE-034</comment>
<comment>Email from: Fred Zemke, 2019-02-28 2154</comment>
<BNFdef name="path multiset alternation">
<rhs>
<BNF name="path term"/> <BNF name="multiset alternation operator"/> <BNF name="path term"/>
<breakindent/>
<opt>
<group> <BNF name="multiset alternation operator"/> <BNF name="path term"/> </group><repeat/>
</opt>
</rhs>
</BNFdef>

<comment>WG3:BNE-034</comment>
<comment>Email from: Fred Zemke, 2019-02-28 2154</comment>
<comment>WG3:SXM-052</comment>
<BNFdef name="path pattern union">
<rhs>
<BNF name="path term"/> <BNF name="vertical bar"/> <BNF name="path term"/>
<opt>
<group> <BNF name="vertical bar"/> <BNF name="path term"/> </group><repeat/>
</opt>
</rhs>
</BNFdef>

<comment>WG3:BNE-034</comment>
<BNFdef name="path term">
<rhs>
<alt> <BNF name="path factor"/> </alt>
<alt> <BNF name="path concatenation"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:BNE-034</comment>
<BNFdef name="path concatenation">
<rhs>
<BNF name="path term"/> <BNF name="path factor"/>
</rhs>
</BNFdef>

<comment>WG3:W01-014</comment>
<BNFdef name="path factor">
<rhs>
<alt> <BNF name="path primary"/> </alt>
<alt> <BNF name="quantified path primary"/> </alt>
<alt> <BNF name="questioned path primary"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:BNE-034</comment>
<BNFdef name="quantified path primary">
<rhs>
<BNF name="path primary"/> <BNF name="graph pattern quantifier"/>
</rhs>
</BNFdef>

<comment>WG3:W01-014</comment>
<comment>WG3:W08-009 P16-USA-340</comment>
<BNFdef name="questioned path primary">
<rhs>
<BNF name="path primary"/> <BNF name="question mark"/>
</rhs>
</BNFdef>
<note>Unlike most regular expression languages, <BNF name="question mark"/> is not
equivalent to the quantifier {0,1}: the quantifier {0,1} exposes variables as group, whereas 
<BNF name="question mark"/> does not change the singleton variables that it exposes to 
group.
However, <BNF name="question mark"/> does expose any singleton variables as conditional 
singletons.
</note>

<comment>WG3:ERF-035</comment>
<comment>WG3:BNE-034</comment>
<comment>WG3:MMX-060</comment>
<BNFdef name="path primary">
<rhs>
<alt> <BNF name="element pattern"/> </alt>
<alt> <BNF name="parenthesized path pattern expression"/> </alt>
<alt> <BNF name="simplified path pattern expression"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:ERF-035</comment>
<BNFdef name="element pattern">
<rhs>
<alt> <BNF name="node pattern"/> </alt>
<alt> <BNF name="edge pattern"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:ERF-035</comment>
<comment>WG3:W04-009R1</comment>
<BNFdef name="node pattern">
<rhs>
<BNF name="left paren"/> <BNF name="element pattern filler"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<comment>WG3:ERF-035</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W04-009R1</comment>
<comment>WG3:W06-013</comment>
<comment>WG3:W21-049</comment>
<BNFdef name="element pattern filler">
<rhs>
<opt> <BNF name="element variable declaration"/> </opt><linebreak/>
<opt> <BNF name="is label expression"/> </opt><linebreak/>
<opt> <BNF name="element pattern predicate"/> </opt><linebreak/>
</rhs>
</BNFdef>

<comment>WG3:ERF-035</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W24-022</comment>
<BNFdef name="element variable declaration">
<rhs>
<opt> <kw>TEMP</kw> </opt> <BNF name="element variable"/>
</rhs>
</BNFdef>

<comment>WG3:ERF-035</comment>
<BNFdef name="is label expression">
<rhs>
<BNF name="is or colon"/> <BNF name="label expression"/>
</rhs>
</BNFdef>

<comment>WG3:ERF-035</comment>
<BNFdef name="is or colon">
<rhs>
<alt> <kw>IS</kw> </alt>
<alt> <BNF name="colon"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W06-013</comment>
<BNFdef name="element pattern predicate">
<rhs>
<alt> <BNF name="element pattern where clause"/> </alt>
<alt> <BNF name="element property specification"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:ERF-035</comment>
<BNFdef name="element pattern where clause">
<rhs>
<kw>WHERE</kw> <BNF name="search condition"/>
</rhs>
</BNFdef>

<comment>WG3:W06-013</comment>
<BNFdef name="element property specification">
<rhs>
<BNF name="left brace"/> <BNF name="property key value pair list"/> <BNF name="right brace"/>
</rhs>
</BNFdef>

<comment>WG3:W06-013</comment>
<BNFdef name="property key value pair list">
<rhs>
<BNF name="property key value pair"/>
<opt> <group> <BNF name="comma"/> <BNF name="property key value pair"/> </group><repeat/> </opt>
</rhs>
</BNFdef>

<comment>WG3:W06-013</comment>
<BNFdef name="property key value pair">
<rhs>
<BNF name="property name"/> <BNF name="colon"/> <BNF name="value expression"/>
</rhs>
</BNFdef>

<comment>WG3:ERF-035</comment>
<BNFdef name="edge pattern">
<rhs>
<alt> <BNF name="full edge pattern"/> </alt>
<alt> <BNF name="abbreviated edge pattern"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:ERF-035</comment>
<comment>WG3:MMX-060</comment>
<BNFdef name="full edge pattern">
<rhs>
<alt> <BNF name="full edge pointing left"/> </alt>
<alt> <BNF name="full edge undirected"/> </alt>
<alt> <BNF name="full edge pointing right"/> </alt>
<alt> <BNF name="full edge left or undirected"/> </alt>
<alt> <BNF name="full edge undirected or right"/> </alt>
<alt> <BNF name="full edge left or right"/> </alt>
<alt> <BNF name="full edge any direction"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:ERF-035</comment>
<comment>WG3:MMX-060</comment>
<comment>WG3:W04-009R1</comment>
<BNFdef name="full edge pointing left">
<rhs>
<BNF name="left arrow bracket"/> <BNF name="element pattern filler"/>
<BNF name="right bracket minus"/>
</rhs>
</BNFdef>

<comment>WG3:MMX-060</comment>
<comment>WG3:W04-009R1</comment>
<BNFdef name="full edge undirected">
<rhs>
<BNF name="tilde left bracket"/> <BNF name="element pattern filler"/>
<BNF name="right bracket tilde"/>
</rhs>
</BNFdef>

<comment>WG3:ERF-035</comment>
<comment>WG3:MMX-060</comment>
<comment>WG3:W04-009R1</comment>
<BNFdef name="full edge pointing right">
<rhs>
<BNF name="minus left bracket"/> <BNF name="element pattern filler"/>
<BNF name="bracket right arrow"/>
</rhs>
</BNFdef>

<comment>WG3:MMX-060</comment>
<comment>WG3:W04-009R1</comment>
<comment>WG3:W22-051</comment>
<BNFdef name="full edge left or undirected">
<rhs>
<BNF name="left arrow tilde bracket"/> <BNF name="element pattern filler"/>
<BNF name="right bracket tilde"/>
</rhs>
</BNFdef>

<comment>WG3:MMX-060</comment>
<comment>WG3:W04-009R1</comment>
<BNFdef name="full edge undirected or right">
<rhs>
<BNF name="tilde left bracket"/> <BNF name="element pattern filler"/>
<BNF name="bracket tilde right arrow"/>
</rhs>
</BNFdef>

<comment>WG3:MMX-060</comment>
<BNFdef name="full edge left or right">
<rhs>
<BNF name="left arrow bracket"/> <BNF name="element pattern filler"/>
<BNF name="bracket right arrow"/>
</rhs>
</BNFdef>

<comment>WG3:ERF-035</comment>
<comment>WG3:MMX-060</comment>
<comment>WG3:W04-009R1</comment>
<BNFdef name="full edge any direction">
<rhs>
<BNF name="minus left bracket"/> <BNF name="element pattern filler"/>
<BNF name="right bracket minus"/>
</rhs>
</BNFdef>

<comment>WG3:W09-017</comment>
<comment>WG3:W12-025</comment>
<ednote id="gql_w09017">In the BNF for <BNF name="full edge any direction"/>, the delimiter 
tokens &lt;~[ ]~&gt; have been suggested as a synonym for -[ ]- as part of <feature code="GH02"/>.
The synonym for the <BNF name="abbreviated edge pattern"/> - (<BNF name="minus sign"/>) 
would then be &lt;~&gt;, the synonym for <BNF name="simplified defaulting any direction"/> would 
use the delimiter tokens &lt;~/ /~&gt; and the synonym for 
<BNF name="simplified override any direction"/> would use the tokens &lt;~ and &gt; surrounding 
a label as originally proposed in WG3:MMX-060.
These synonyms might be considered to make the table of edge patterns more harmonious and 
internally consistent.
See <PPref ref="PPgql212"/>.
</ednote>

<comment>WG3:MMX-060</comment>
<comment>Editorial: WG3:MMX-060 Email Fred Zemke, 2020-07-21</comment>
<BNFdef name="abbreviated edge pattern">
<rhs>
<alt> <BNF name="left arrow"/> </alt>
<alt> <BNF name="tilde"/> </alt>
<alt> <BNF name="right arrow"/> </alt>
<alt> <BNF name="left arrow tilde"/> </alt>
<alt> <BNF name="tilde right arrow"/> </alt>
<alt> <BNF name="left minus right"/> </alt>
<alt> <BNF name="minus sign"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W04-009R1</comment>
<comment>WG3:W09-031</comment>
<comment>WG3:W21-024R1</comment>
<comment>WG3:W21-049</comment>
<BNFdef name="parenthesized path pattern expression">
<rhs>
<BNF name="left paren"/>
<breakindent/>
<opt> <BNF name="subpath variable declaration"/> </opt>
<breakindent/>
<opt> <BNF name="path mode prefix"/> </opt>
<breakindent/>
<BNF name="path pattern expression"/>
<breakindent/>
<opt> <BNF name="parenthesized path pattern where clause"/> </opt>
<linebreak/>
<BNF name="right paren"/>
</rhs>
</BNFdef>

<comment>WG3:SXM-052</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-27 Corrected infinite grammar recursion</comment>
<BNFdef name="subpath variable declaration">
<rhs>
<BNF name="subpath variable"/> <BNF name="equals operator"/>
</rhs>
</BNFdef>

<comment>WG3:BNE-034</comment>
<BNFdef name="parenthesized path pattern where clause">
<rhs>
<kw>WHERE</kw> <BNF name="search condition"/>
</rhs>
</BNFdef>

<comment>WG3:SXM-052</comment>
<comment>WG3:W21-049</comment>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>Email from: Fred Zemke, 2023-08-29 2028</comment>
<item>Let <symdef>GP</symdef> be the outermost <BNF name="graph pattern"/> that contains the 
<BNF name="path pattern expression"/>.
</item>

<comment>WG3:BER-025</comment>
<item>Let <symdef>RIGHTMINUS</symdef> be the following collection of <BNF name="token"/>s: 
<BNF name="right bracket minus"/>, <BNF name="left arrow"/>, <BNF name="slash minus"/>, and 
<BNF name="minus sign"/>.

<comment>Editorial; Jim Melton, 2023-09-04; fix which/that problems</comment>
<note>These are the tokens (<quote>]-</quote>, <quote>&lt;-</quote>, <quote>/-</quote>,
and <quote>-</quote>) that expose a minus sign on the right.
</note>

</item>

<comment>WG3:BER-025</comment>
<item>Let <symdef>LEFTMINUS</symdef> be the following collection of <BNF name="token"/>s: 
<BNF name="minus left bracket"/>, <BNF name="right arrow"/>, <BNF name="minus slash"/>, and 
<BNF name="minus sign"/>.

<comment>Editorial; Jim Melton, 2023-09-04; fix which/that problems</comment>
<note>These are the tokens (<quote>-[</quote>, <quote>-&gt;</quote>, <quote>-/</quote>,
and <quote>-</quote>) that expose a minus sign on the left. 
<BNF name="minus sign"/> itself is in both <sym>RIGHTMINUS</sym> and <sym>LEFTMINUS</sym>.
</note>

</item>

<comment>WG3:BER-025</comment>
<item>A <BNF name="path pattern expression"/> shall not juxtapose a <BNF name="token"/> 
from <sym>RIGHTMINUS</sym> followed by a <BNF name="token"/> from <sym>LEFTMINUS</sym> without 
a <BNF name="separator"/> between them.

<note>Otherwise, the concatenation of the two tokens would include the
sequence of two <BNF name="minus sign"/>s, which is a <BNF name="simple comment introducer"/>.
</note>
</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W01-014</comment>
<item>A <BNF name="path pattern expression"/> that contains at the same depth of graph pattern
matching a variable quantifier, a <BNF name="questioned path primary"/>, 
a <BNF name="path multiset alternation"/>, or 
a <BNF name="path pattern union"/> is a <newterm>possibly variable length path pattern</newterm>.
</item>

<comment>WG3:BNE-034</comment>
<item>A <BNF name="path pattern expression"/> that is not a possibly variable length path pattern
is a <newterm>fixed length path pattern</newterm>.
</item>

<comment>WG3:W01-014</comment>
<item>The <newterm>minimum path length</newterm> of certain BNF non-terminal instances defined in
this Subclause is defined recursively as follows:

<olist>

<item>The minimum path length of a <BNF name="node pattern"/> is 0 (zero).
</item>

<item>The minimum path length of an <BNF name="edge pattern"/> is 1 (one).
</item>

<item>The minimum path length of a <BNF name="path concatenation"/> is the sum of the
minimum path lengths of its operands.
</item>

<item>The minimum path length of a <BNF name="path pattern union"/> or 
<BNF name="path multiset alternation"/> is the minimum of the minimum path length of its operands.
</item>

<item>The minimum path length of a <BNF name="quantified path primary"/> is the product of the
minimum path length of the simply contained <BNF name="path primary"/> and the value of the 
<BNF name="lower bound"/>.
</item>

<item>The minimum path length of a <BNF name="questioned path primary"/> is 0 (zero).
</item>

<item>The minimum path length of a <BNF name="parenthesized path pattern expression"/> is the
minimum path length of the simply contained <BNF name="path pattern expression"/>.
</item>

<item>If <symdef>BNT1</symdef> and <symdef>BNT2</symdef> are two BNF non-terminal instances such
that <sym>BNT1</sym> ::= <sym>BNT2</sym> and the minimum path length of <sym>BNT2</sym> is defined, 
then the minimum path length of <sym>BNT1</sym> is also defined and is the same as the minimum path 
length of <sym>BNT2</sym>.
</item>

</olist>

</item>

<comment>WG3:BNE-034</comment>
<comment>Remark Karl Schendel regarding simply contains (see SXM001 item 13.2)</comment>
<comment>WG3:W01-014</comment>
<item>The <BNF name="path primary"/> immediately contained in 
a <BNF name="quantified path primary"/> or <BNF name="questioned path primary"/>
shall have minimum path length that is greater than 0 (zero).
</item>

<comment>WG3:W01-014</comment>
<comment>WG3:W07-009</comment>
<item id="gql_path_primary_SR">The <BNF name="path primary"/> simply contained in 
a <BNF name="quantified path primary"/> shall not contain a <BNF name="quantified path primary"/> 
at the same depth of graph pattern matching.

<ednote id="gql_PP036">It may be possible to permit nested quantifiers.
WG3:W01-014 contained a discussion of a way to support aggregates at different depths of 
aggregation if there are nested quantifiers.
See <PPref ref="PPgql036"/>.
</ednote>

</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<item>Let <symdef>PMA</symdef> be a <BNF name="path multiset alternation"/>.

<olist>

<comment>WG3:SXM-052</comment>
<comment>Email from: Fred Zemke, 2020-07-21</comment>
<item>A <BNF name="path term"/> simply contained in <symdef>PMA</symdef> is 
a <newterm>multiset alternation operand</newterm> of <sym>PMA</sym>.
</item>

<comment>WG3:SXM-052</comment>
<comment>Editorial: Stephen Cannan 2021-11-28</comment>
<comment>WG3:W21-061</comment>
<item>Let <symdef>NOPMA</symdef> be the number of multiset alternation operands of <sym>PMA</sym>.
Let <symdef>OPMA</symdef><sub>1</sub>, <ellipsis/>, 
<symdef>OPMA</symdef><sub><sym>NOPMA</sym></sub> be an enumeration of the operands of 
<sym>PMA</sym>.
</item>

<comment>WG3:W21-061</comment>
<item>Any <BNF name="subpath variable"/>s declared by <BNF name="subpath variable declaration"/>s
simply contained in the multiset alternation operands of <sym>PMA</sym> shall be mutually distinct.
</item>

<comment>WG3:W21-061</comment>
<comment>WG3:W26-037R3</comment>
<item>Let <symdef>SOPMA</symdef><sub>1</sub>, <ellipsis/>, 
<symdef>SOPMA</symdef><sub><sym>NOPMA</sym></sub> be new system-generated regular identifiers.
</item>

<comment>WG3:SXM-052</comment>
<comment>WG3:RKE-039 P16-USA-787</comment>
<comment>WG3:CMN-019 P00-NLD-050</comment>
<comment>Editorial: Stefan Plantikow, 2025-03-24</comment>
<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NOPMA</sym>,
let <symdef>OPMAX</symdef><sub><sym>i</sym></sub> be defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:SXM-052</comment>
<item>If <sym>OPMA</sym><sub><sym>i</sym></sub> is 
a <BNF name="parenthesized path pattern expression"/>
that simply contains a <BNF name="subpath variable declaration"/>,
then <symdef>OPMAX</symdef><sub><sym>i</sym></sub> is <sym>OPMA</sym><sub><sym>i</sym></sub>.
</item>

<comment>WG3:SXM-052</comment>
<item>Otherwise, <symdef>OPMAX</symdef><sub><sym>i</sym></sub> is the
<BNF name="parenthesized path pattern expression"/>:
<code>
(<sym>SOPMA</sym><sub><sym>i</sym></sub> = <sym>OPMA</sym><sub><sym>i</sym></sub>)
</code>
</item>

</olist>

</item>

<comment>WG3:SXM-052</comment>
<item><sym>PMA</sym> is equivalent to:

<code>
<sym>OPMAX</sym><sub>1</sub> | <ellipsis/> | <sym>OPMAX</sym><sub><sym>NOPMA</sym></sub>
</code>
</item>

</olist>

</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:BER-031</comment>
<item>A <BNF name="path term"/> <symdef>PPUOP</symdef> simply contained in 
a <BNF name="path pattern union"/> <symdef>PSD</symdef> is 
a <newterm>path pattern union operand</newterm> of <symdef>PSD</symdef>.

<comment>WG3:SXM-052</comment>
<ednote id="gql_bne034_3">Path pattern union is not defined using left recursion.
WG3:SXM-052 believed that it should be possible to support left recursion but declined to do so for
expediency.
It is a Language Opportunity to support left recursion.
See <PPref ref="PPgql025"/>.
</ednote>

<comment>Editorial: WG3:SXM-052 Email Fred Zemke, 2020-07-21</comment>
<comment>WG3:BER-031</comment>
<para><sym>PPUOP</sym> shall not contain a reference to an element variable that is not declared 
in <sym>PPUOP</sym> or outside of <sym>PSD</sym>.
</para>
</item>

<comment>WG3:W13-018</comment>
<item id="gql_path_pattern_expr_norm">An <BNF name="element pattern"/> <symdef>EP</symdef> that 
contains an <BNF name="element pattern where clause"/> <symdef>EPWC</symdef> is transformed as 
follows:

<olist>

<item>Let <symdef>EPF</symdef> be the <BNF name="element pattern filler"/> simply contained 
in <sym>EP</sym>.
</item>

<item>Let <symdef>PREFIX</symdef> be the <BNF name="delimiter token"/> contained in <sym>EP</sym> 
before <sym>EPF</sym> and let <symdef>SUFFIX</symdef> be the <BNF name="delimiter token"/> 
contained in <sym>EP</sym> after <sym>EPF</sym>.
</item>

<comment>WG3:W21-049</comment>
<comment>WG3:CMN-019 P00-USA-097</comment>
<item>Let <symdef>EV</symdef> be the <BNF name="element variable"/> simply contained in 
<sym>EPF</sym>.
</item>

<comment>WG3:CMN-019 P00-USA-097</comment>
<item>Let <symdef>ILE</symdef> be defined as follows. 
If <sym>EPF</sym> simply contains the <BNF name="is label expression"/> <symdef>ILE_CAND</symdef>, 
then <sym>ILE</sym> is <sym>ILE_CAND</sym>; 
otherwise, <sym>ILE</sym> is the zero-length character string.
</item>

<item><sym>EP</sym> is effectively replaced by

<comment>WG3:W21-024R1</comment>
<comment>WG3:W21-049</comment>
<code>
( <sym>PREFIX</sym> <sym>EV</sym> <sym>ILE</sym> <sym>SUFFIX</sym> <sym>EPWC</sym> )
</code>

</item>

</olist>

</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W06-013</comment>
<comment>Editorial: Stephen Cannan, 2021-04-06</comment>
<item>An <BNF name="element pattern"/> that does not contain 
an <BNF name="element variable declaration"/>, an <BNF name="is label expression"/>,
or an <BNF name="element pattern predicate"/> is said to be <newterm>empty</newterm>.
</item>

<comment>WG3:W04-009R1</comment>
<item>Each <BNF name="path pattern expression"/> is transformed in the following steps:

<olist>

<comment>WG3:BNE-034</comment>
<comment>Remark Karl Schendel regarding simply contains (see SXM001 item 13.2)</comment>
<comment>WG3:W01-014</comment>
<comment>Email from: Tobias, 2020-12-07 2045</comment>
<item>If the <BNF name="path primary"/> immediately contained in 
a <BNF name="quantified path primary"/> or <BNF name="questioned path primary"/> is 
an <BNF name="edge pattern"/> <symdef>EP</symdef>, then <sym>EP</sym> is effectively replaced by:

<code>
( <sym>EP</sym> )
</code>

<note>For example,

<code>
-&gt;*
</code>

<para>becomes:
</para>

<comment>Email from: Fred Zemke, 2019-02-28 2154</comment>
<code>
(-&gt;) {0,}
</code>

<para>which in later transformations becomes:
</para>

<code>
(() -&gt; ()) {0,}
</code>

</note>

</item>

<comment>WG3:BNE-034</comment>
<item>If two successive <BNF name="element pattern"/>s contained in 
a <BNF name="path concatenation"/> at the same depth of graph pattern matching are
<BNF name="edge pattern"/>s, then an implicit empty
<BNF name="node pattern"/> is inserted between them.
</item>

<comment>WG3:BNE-034</comment>
<comment>Editorial: Stephen Cannan, 2023-10-13</comment>
<item>If an edge pattern <sym>EP</sym> contained in a <BNF name="path term"/> <symdef>PST</symdef>
at the same depth of graph pattern matching is not preceded by a <BNF name="node pattern"/>
contained in <sym>PST</sym> at the same depth of graph pattern matching, then an implicit empty
<BNF name="node pattern"/> is inserted in <sym>PST</sym> immediately prior to <sym>EP</sym>.
</item>

<comment>WG3:BNE-034</comment>
<comment>Editorial: Stephen Cannan, 2023-10-13</comment>
<item>If an edge pattern <symdef>EP</symdef> contained in a <BNF name="path term"/>
<symdef>PST</symdef> at the same depth of graph pattern matching is not followed by 
a <BNF name="node pattern"/> contained in <sym>PST</sym> at the same depth of 
graph pattern matching, than an implicit empty <BNF name="node pattern"/> is inserted 
in <sym>PST</sym> immediately after <sym>EP</sym>.

<note>As a result of the preceding transformations, a fixed length path pattern has an odd number
of <BNF name="element pattern"/>s, beginning and ending with <BNF name="node pattern"/>s,
and alternating between <BNF name="node pattern"/>s and <BNF name="edge pattern"/>s.
</note>

</item>

<comment>WG3:BNE-034</comment>
<item id="gql_abr_edge_patt_to_full">Every <BNF name="abbreviated edge pattern"/> 
<symdef>AEP</symdef> is effectively replaced with an empty <BNF name="full edge pattern"/> 
as follows.

<para>Case:
</para>

<comment>Editorial: WG3:MMX-060 Email Fred Zemke, 2020-07-21</comment>
<comment>WG3:UTC-055R1</comment>
<olist>

<item>If <sym>AEP</sym> is <BNF name="left arrow"/>, then <sym>AEP</sym> is effectively replaced by 
the  <BNF name="full edge pointing left"/>:
<code>
&lt;-[ ]-
</code>
</item>

<item>If <sym>AEP</sym> is <BNF name="tilde"/>, then <sym>AEP</sym> is effectively replaced by the 
<BNF name="full edge undirected"/>:
<code>
~[ ]~
</code>
</item>

<item>If <sym>AEP</sym> is <BNF name="right arrow"/>, then <sym>AEP</sym> is effectively replaced 
by the <BNF name="full edge pointing right"/>:
<code>
-[ ]-&gt;
</code>
</item>

<item>If <sym>AEP</sym> is <BNF name="left arrow tilde"/>, then <sym>AEP</sym> is effectively 
replaced by the <BNF name="full edge left or undirected"/>:
<code>
&lt;~[ ]~
</code>
</item>

<item>If <sym>AEP</sym> is <BNF name="tilde right arrow"/>, then <sym>AEP</sym> is effectively
replaced by the <BNF name="full edge undirected or right"/>:
<code>
~[ ]~>
</code>
</item>

<item>If <sym>AEP</sym> is <BNF name="left minus right"/>, then <sym>AEP</sym> is effectively 
replaced by the <BNF name="full edge left or right"/>:
<code>
&lt;-[ ]->
</code>
</item>

<item>If <sym>AEP</sym> is <BNF name="minus sign"/>, then <sym>AEP</sym> is effectively replaced 
by the <BNF name="full edge any direction"/>:
<code>
-[ ]-
</code>
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W01-014</comment>
<item>The <newterm>minimum node count</newterm> of certain BNF non-terminal instances defined in
this Subclause is defined recursively as follows:

<olist>

<item>The minimum node count of a <BNF name="node pattern"/> is 1 (one).
</item>

<item>The minimum node count of an <BNF name="edge pattern"/> is 0 (zero).
</item>

<comment>WG3:BER-071</comment>
<item>The minimum node count of a <BNF name="path concatenation"/> <symdef>PC</symdef> is:

<para>Case:
</para>

<olist>

<item>If two successive <BNF name="element pattern"/>s contained in <sym>PC</sym> at the same
depth of graph pattern matching are <BNF name="node pattern"/>s, then 1 (one) less than the
sum of the minimum node counts of its operands.
</item>

<item>Otherwise, the sum of the minimum node counts of its operands.
</item>

</olist>

</item>

<item>The minimum node count of a <BNF name="path pattern union"/> or 
<BNF name="path multiset alternation"/> is the minimum of the minimum node count of its operands.
</item>

<comment>Email from: Fred Zemke, 2020-08-26 1002</comment>
<item>The minimum node count of a <BNF name="quantified path primary"/> is the product of
the minimum node count of the simply contained <BNF name="path primary"/> and the value of the
<BNF name="lower bound"/> of the simply contained <BNF name="graph pattern quantifier"/>.
</item>

<item>The minimum node count of a <BNF name="questioned path primary"/> is 0 (zero).
</item>

<item>The minimum node count of a <BNF name="parenthesized path pattern expression"/> is the
minimum node count of the simply contained <BNF name="path pattern expression"/>.
</item>

<comment>WG3:BER-071</comment>
<item>If <symdef>BNF1</symdef> and <symdef>BNF2</symdef> are two BNF non-terminal instances such
that <sym>BNF1</sym> ::= <sym>BNF2</sym> and the minimum node count of <sym>BNF2</sym> is defined, 
then the minimum node count of <sym>BNF1</sym> is also defined and is the same as the minimum 
node count of <sym>BNF2</sym>.
</item>

</olist>

</item>

<comment>WG3:W01-014</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<item>The <BNF name="path pattern expression"/> simply contained in a <BNF name="path pattern"/> 
shall have a minimum node count that is greater than 0 (zero).
<note>The minimum node count is computed after the syntactic transform that adds implicit 
node patterns.
Thus a single <BNF name="edge pattern"/> is a permitted <BNF name="path pattern"/> because it 
implies two <BNF name="node pattern"/>s.
</note>

<comment>WG3:UTC-080</comment>
<note>A later Syntax Rule makes the same requirement of 
a <BNF name="parenthesized path pattern expression"/> that simply contains 
a <BNF name="subpath variable declaration"/>.
</note>
</item>

<comment>WG3:SXM-052</comment>
<comment>WG3:BER-031</comment>
<comment>WG3:W24-022</comment>
<comment>WG3:UTC-087R2</comment>
<item id="gql_ele_var_1">An <BNF name="element variable"/> <symdef>EV</symdef> contained in 
an <BNF name="element variable declaration"/> <symdef>GPVD</symdef>
is said to be <newterm>declared</newterm> by <sym>GPVD</sym>, and by the
<BNF name="element pattern"/> <symdef>EP</symdef> that simply contains <sym>GPVD</sym>.
The <BNF name="element variable"/> is the name of an element variable, which is also declared by
<sym>GPVD</sym> and <sym>EP</sym>.
If <sym>GPVD</sym> simply contains <kw>TEMP</kw>, then <sym>EV</sym> is a temporary element 
variable.

<comment>WG3:W24-022</comment>
<note>Element bindings to temporary element variables are removed prior to set-theoretic 
deduplication of matches. 
See <itemref type="GR" ref="gql_graph_pattern_GR_red_match"/> of <specref ref="gql_graph_pattern"/>
and <itemref type="GR" ref="gql_machinery_graph_pattern_matching_GR_reduce"/> of 
<specref ref="gql_machinery_graph_pattern_matching"/>.
</note>
</item>

<comment>WG3:SXM-052</comment>
<comment>WG3:CMN-019 P00-USA-007</comment>
<item>An element variable that is declared by a <BNF name="node pattern"/> is a node variable.
An element variable that is declared by an <BNF name="edge pattern"/> is an edge variable.
</item>

<comment>WG3:SXM-052</comment>
<comment>WG3:W22-053R2</comment>
<comment>WG3:W24-022</comment>
<item>The scope of an <BNF name="element variable"/> <symdef>EV</symdef> that is declared by 
an <BNF name="element pattern"/> <symdef>EP</symdef> is defined as follows. 
If <sym>EV</sym> is a temporary element variable, then the scope of <sym>EV</sym> is the innermost 
<BNF name="path term"/> containing <sym>EP</sym>; otherwise, the scope of <sym>EV</sym> is the 
innermost <BNF name="graph pattern binding table"/> containing <sym>EP</sym>.
</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:BER-031</comment>
<comment>WG3:UTC-080</comment>
<comment>WG3:CMN-019 P00-USA-098</comment>
<comment>Editorial: Stefan Plantikow, 2023-08-30 Correct resolution of WG3:CMN-019 P00-USA-098
</comment>
<item>If a <BNF name="parenthesized path pattern expression"/> <sym>PPPE</sym> simply contains
a <BNF name="subpath variable declaration"/>, then the minimum node count of <sym>PPPE</sym>
shall be greater than 0 (zero).
</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:BER-031</comment>
<comment>WG3:CMN-019 P00-USA-099</comment>
<item>If an <BNF name="element pattern"/> <symdef>EP</symdef> that contains 
an <BNF name="element pattern where clause"/> <symdef>EPWC</symdef>, then <sym>EP</sym> shall 
simply contain an <BNF name="element variable declaration"/> <symdef>GPVD</symdef>.
</item>

<comment>WG3:W01-014</comment>
<comment>WG3:W04-009R1</comment>
<comment>WG3:W13-018</comment>
<comment>WG3:RKE-031</comment>
<item>If <sym>EV</sym> is an element variable or subpath variable, and <symdef>BNT</symdef> is 
an instance of a BNF non-terminal, then the terminology 
<quote><sym>BNT</sym> exposes <sym>EV</sym></quote> is defined as follows.
The full terminology is one of the following: 
<quote><sym>BNT</sym> exposes <sym>EV</sym> as an unconditional singleton variable</quote>, 
<quote><sym>BNT</sym> exposes <sym>EV</sym> as a conditional singleton variable</quote>, 
<quote><sym>BNT</sym> exposes <sym>EV</sym> as an effectively bounded group variable</quote> or
<quote><sym>BNT</sym> exposes <sym>EV</sym> as an effectively unbounded group variable</quote>.
The terms <quote>unconditional singleton variable</quote>, 
<quote>conditional singleton variable</quote>, <quote>effectively bounded group variable</quote>, 
and <quote>effectively unbounded group variable</quote> are called the 
<newterm>degree of exposure</newterm>.

<olist>

<item>An <BNF name="element pattern"/> <symdef>EP</symdef> that declares an element variable 
<sym>EV</sym> exposes <sym>EV</sym> as an unconditional singleton.
</item>

<comment>WG3:RKE-031</comment>
<comment>WG3:BER-031</comment>
<item>A <BNF name="parenthesized path pattern expression"/> <symdef>PPPE</symdef> that 
simply contains a <BNF name="subpath variable declaration"/> that declares <sym>EV</sym> exposes 
<sym>EV</sym> as an unconditional singleton variable.
<sym>PPPE</sym> shall not contain another <BNF name="parenthesized path pattern expression"/> that 
declares <sym>EV</sym>.
</item>

<item>If a <BNF name="path concatenation"/> <symdef>PPC</symdef> declares <sym>EV</sym> 
then let <symdef>PT</symdef> be the <BNF name="path term"/> and let <symdef>PF</symdef> be the 
<BNF name="path factor"/> simply contained in <sym>PPC</sym>.

<para>Case:
</para>

<olist>

<comment>WG3:BER-031</comment>
<item>If <sym>EV</sym> is exposed as an unconditional singleton by both <sym>PT</sym> and 
<sym>PF</sym>, then <sym>EV</sym> is exposed as an unconditional singleton by <sym>PPC</sym>.
<sym>EV</sym> shall not be a subpath variable.

<note>This case expresses an implicit join on <sym>EV</sym> within <sym>PPC</sym>.
Implicit joins between conditional singleton variables, group variables, or subpath variables 
are forbidden.
</note>
</item>

<item>Otherwise, <sym>EV</sym> shall only be exposed by one of <sym>PT</sym> or <sym>PF</sym>.
In this case <sym>EV</sym> is exposed by <sym>PPC</sym> in the same degree that it is exposed by 
<sym>PT</sym> or <sym>PF</sym>.
</item>

</olist>

</item>

<item>If a <BNF name="path pattern union"/> or <BNF name="path multiset alternation"/> 
<symdef>PA</symdef> declares <sym>EV</sym>, then

<para>Case:
</para>

<olist>

<item>If every operand of <sym>PA</sym> exposes <sym>EV</sym> as an unconditional singleton 
variable, then <sym>PA</sym> exposes <sym>EV</sym> as an unconditional singleton variable.
</item>

<comment>WG3:W04-009R1</comment>
<item>If at least one operand of <sym>PA</sym> exposes <sym>EV</sym> as an effectively unbounded
group variable, then <sym>PA</sym> exposes <sym>EV</sym> as an effectively unbounded group variable.
</item>

<comment>WG3:W04-009R1</comment>
<item>If at least one operand of <sym>PA</sym> exposes <sym>EV</sym> as an effectively bounded
group variable, then <sym>PA</sym> exposes <sym>EV</sym> as an effectively bounded group variable.
</item>

<item>Otherwise, <sym>PA</sym> exposes <sym>EV</sym> as a conditional singleton variable.
</item>

</olist>

</item>

<comment>WG3:W04-009R1</comment>
<comment>WG3:RKE-033</comment>
<item>If a <BNF name="quantified path primary"/> <symdef>QPP</symdef> declares <sym>EV</sym>, then 
let <symdef>PP</symdef> be the <BNF name="path primary"/> simply contained in <sym>QPP</sym>.

<para>Case:
</para>

<olist>

<comment>WG3:W04-009R1</comment>
<comment>WG3:RKE-033</comment>
<item>If <sym>QPP</sym> contains a <BNF name="graph pattern quantifier"/> that is 
a <BNF name="fixed quantifier"/> or a <BNF name="general quantifier"/> that contains 
an <BNF name="upper bound"/> and <sym>PP</sym> does not expose <sym>EV</sym> as 
an effectively unbounded group variable, then <sym>QPP</sym> exposes <sym>EV</sym> as 
an effectively bounded group variable.
</item>

<comment>WG3:W04-009R1</comment>
<item>If <sym>QPP</sym> is contained at the same depth of graph pattern matching in 
a restrictive <BNF name="parenthesized path pattern expression"/>, then <sym>QPP</sym> exposes 
<sym>EV</sym> as an effectively bounded group variable.

<comment>WG3:W09-031</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<note>The preceding definition is applied after the syntactic transformation to insure that 
every <BNF name="path mode prefix"/> is at the head of 
a <BNF name="parenthesized path pattern expression"/>.
</note>

</item>

<comment>WG3:W04-009R1</comment>
<item>Otherwise, <sym>QPP</sym> exposes <sym>EV</sym> as an effectively unbounded group variable.
</item>

</olist>

</item>

<item>If a <BNF name="questioned path primary"/> <symdef>QUPP</symdef> declares <sym>EV</sym>, then 
let <symdef>PP</symdef> be the <BNF name="path primary"/> simply contained in <sym>QUPP</sym>.

<para>Case:
</para>

<olist>

<comment>WG3:W04-009R1</comment>
<item>If <sym>PP</sym> exposes <sym>EV</sym> as a group variable, then <sym>QUPP</sym> exposes 
<sym>EV</sym> as a group variable with the same degree of exposure.
</item>

<item>Otherwise, <sym>QUPP</sym> exposes <sym>EV</sym> as a conditional singleton variable.
</item>

</olist>

</item>

<comment>WG3:W04-009R1</comment>
<comment>WG3:W09-031</comment>
<comment>WG3:BER-031</comment>
<item>A <BNF name="parenthesized path pattern expression"/> exposes the same variables as the
simply contained <BNF name="path pattern expression"/>, in the same degree of exposure.

<comment>WG3:W09-031</comment>
<note>A restrictive <BNF name="path mode"/> declared by 
a <BNF name="parenthesized path pattern expression"/> makes variables effectively bounded, 
but it does so even for proper subexpressions within the scope of the <BNF name="path mode"/> and 
has already been handled by the rules for <BNF name="quantified path primary"/>.
</note>

</item>

<comment>WG3:W09-031</comment>
<item>If a <BNF name="path pattern"/> <symdef>PP</symdef> declares <symdef>EV</symdef>, 
then let <symdef>PPE</symdef> be the simply contained <BNF name="path pattern expression"/>.

<para>Case:
</para>

<olist>

<item>If <sym>PPE</sym> exposes <sym>EV</sym> as an unconditional singleton, 
a conditional singleton, or an effectively bounded group variable, 
then <sym>PP</sym> exposes <sym>EV</sym> with the same degree of exposure.
</item>

<item>Otherwise, <sym>PP</sym> exposes <sym>EV</sym> as an effectively bounded group variable.

<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>WG3:W26-025R1</comment>
<note>That is, even if <sym>PPE</sym> exposes <sym>EV</sym> as an effectively unbounded
group variable, <sym>PP</sym> still exposes <sym>EV</sym> as effectively bounded, because in this
case <sym>PP</sym> is either required to be a selective <BNF name="path pattern"/> or to be in 
the scope of the <BNF name="different edges match mode"/>.
</note>

</item>

</olist>

</item>

<item>If <symdef>BNT1</symdef> and <symdef>BNT2</symdef> are two BNF non-terminal instances such
that <sym>BNT1</sym> ::= <sym>BNT2</sym> and <sym>BNT2</sym> exposes <sym>EV</sym>, then 
<sym>BNT1</sym> exposes <sym>EV</sym> to the same degree of exposure as <sym>BNT2</sym>.
</item>

</olist>

</item>

<comment>WG3:W04-009R1</comment>
<comment>WG3:W13-018</comment>
<comment>WG3:BER-031</comment>
<item>If <sym>BNT</sym> is a BNF non-terminal instance that exposes a graph pattern variable 
<symdef>GPV</symdef> with a degree of exposure <symdef>DEGREE</symdef>, then <sym>BNT</sym> is 
also said to expose the name of <sym>GPV</sym> with degree of exposure <sym>DEGREE</sym>.
</item>

<comment>WG3:W04-009R1</comment>
<comment>WG3:W13-018</comment>
<comment>WG3:BER-031</comment>
<comment>Editorial: Stephen Cannan, 2023-10-13</comment>
<item>A <BNF name="parenthesized path pattern where clause"/> simply contained in 
a <BNF name="parenthesized path pattern expression"/> <symdef>PPPE</symdef> shall not
reference a path variable.

<comment>Editorial: Stephen Cannan, 2023-10-13</comment>
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<None/>

</olist>

<note>The evaluation of a <BNF name="path pattern expression"/> is performed by the
General Rules of <specref ref="gql_eval_path_pattern_expr"/>.
</note>

</GeneralRules>


<ConformanceRules>

<olist>
<comment>WG3:W09-017</comment>
<comment>WG3:W12-025</comment>

<comment>WG3:W24-022</comment>
<comment>Consequence of WG3:W25-024</comment>
<item>Conforming GQL language shall not contain an <BNF name="element variable declaration"/> that 
immediately contains <kw>TEMP</kw>.

<note>An <BNF name="element variable declaration"/> containing <kw>TEMP</kw> is a specification 
device and is not syntax available to the user.
</note>

</item>

<comment>WG3:W13-022R1</comment>
<item>Without <feature code="G030"/>, conforming GQL language shall not contain 
a <BNF name="path multiset alternation"/>.
</item>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G031"/>, in conforming GQL language, an operand of 
a <BNF name="path multiset alternation"/> shall be a fixed length path pattern.
</item>

<comment>WG3:W13-022R1</comment>
<item>Without <feature code="G032"/>, conforming GQL language shall not contain 
a <BNF name="path pattern union"/>.
</item>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G033"/>, in conforming GQL language, an operand of 
a <BNF name="path pattern union"/> shall be a fixed length path pattern.
</item>

<comment>WG3:W13-022R1</comment>
<comment>WG3:W21-047</comment>
<item>Without <feature code="G035"/>, conforming GQL language shall not contain 
a <BNF name="quantified path primary"/> that does not immediately contain 
a <BNF name="path primary"/> that is an <BNF name="edge pattern"/>.
</item>

<comment>WG3:W13-022R1</comment>
<item>Without <feature code="G036"/>, conforming GQL language shall not contain 
a <BNF name="quantified path primary"/> that immediately contains a <BNF name="path primary"/> 
that is an <BNF name="edge pattern"/>.
</item>

<comment>WG3:W13-022R1</comment>
<item>Without <feature code="G037"/>, conforming GQL language shall not contain 
a <BNF name="questioned path primary"/>.
</item>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G038"/>, conforming GQL language shall not contain 
a <BNF name="parenthesized path pattern expression"/>.
</item>

<comment>WG3:W13-018</comment>
<item>Without <feature code="G041"/>, in conforming GQL language, the 
<BNF name="element pattern where clause"/> of an <BNF name="element pattern"/> <symdef>EP</symdef> 
shall only reference the <BNF name="element variable"/> declared in <sym>EP</sym>.
</item>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G043"/>, conforming GQL language shall not contain 
a <BNF name="full edge pattern"/> that is not a <BNF name="full edge any direction"/>, 
a <BNF name="full edge pointing left"/>, or a <BNF name="full edge pointing right"/>.
</item>

<comment>WG3:W13-022R1</comment>
<comment>WG3:BER-030</comment>
<item>Without <feature code="G044"/>, conforming GQL language shall not contain 
an <BNF name="abbreviated edge pattern"/> that is a <BNF name="minus sign"/>, 
a <BNF name="left arrow"/>, or a <BNF name="right arrow"/>.
</item>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G045"/>, conforming GQL language shall not contain 
an <BNF name="abbreviated edge pattern"/> that is not a <BNF name="minus sign"/>, 
a <BNF name="left arrow"/>, or a <BNF name="right arrow"/>.
</item>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G046"/>, in conforming GQL language, between any two 
<BNF name="node pattern"/>s contained in a <BNF name="path pattern expression"/> there shall be 
at least one <BNF name="edge pattern"/>, <BNF name="left paren"/>, or 
<BNF name="right paren"/>.
</item>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G047"/>, in conforming GQL language, an <BNF name="edge pattern"/>
shall be immediately preceded and followed by a <BNF name="node pattern"/>.
</item>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G048"/>, conforming GQL language shall not contain 
a <BNF name="parenthesized path pattern expression"/> that simply contains 
a <BNF name="subpath variable declaration"/>.
</item>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G049"/>, conforming GQL language shall not contain 
a <BNF name="parenthesized path pattern expression"/> that immediately contains 
a <BNF name="path mode prefix"/>.
</item>

<comment>WG3:W13-022R1</comment>
<item>Without <feature code="G050"/>, conforming GQL language shall not contain 
a <BNF name="parenthesized path pattern where clause"/>.
</item>

<comment>WG3:W13-018</comment>
<item>Without <feature code="G051"/>, in conforming GQL language, 
a <BNF name="parenthesized path pattern where clause"/> simply contained in 
a <BNF name="parenthesized path pattern expression"/> <symdef>PPPE</symdef> shall not reference 
an <BNF name="element variable"/> that is not declared in <sym>PPPE</sym>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>
<comment>WG3:OHD-012 One Subclause deleted</comment>


<subClause id="gql_label_expr" newpage="true">
<clauseHeading><BNF name="label expression"/></clauseHeading>

<bodyMatter>


<Function>

<para>Specify an expression that matches one or more labels of a graph.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="label expression">
<rhs>
<alt> <BNF name="label term"/> </alt>
<alt> <BNF name="label disjunction"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="label disjunction">
<rhs>
<BNF name="label expression"/> <BNF name="vertical bar"/> <BNF name="label term"/>
</rhs>
</BNFdef>

<BNFdef name="label term">
<rhs>
<alt> <BNF name="label factor"/> </alt>
<alt> <BNF name="label conjunction"/>
</alt>
</rhs>
</BNFdef>

<BNFdef name="label conjunction">
<rhs>
<BNF name="label term"/> <BNF name="ampersand"/> <BNF name="label factor"/>
</rhs>
</BNFdef>

<BNFdef name="label factor">
<rhs>
<alt> <BNF name="label primary"/> </alt>
<alt> <BNF name="label negation"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="label negation">
<rhs>
<BNF name="exclamation mark"/> <BNF name="label primary"/>
</rhs>
</BNFdef>

<comment>WG3:MMX-060</comment>
<comment>WG3:RKE-027 P16-USA-747</comment>
<BNFdef name="label primary">
<rhs>
<alt> <BNF name="label name"/> </alt>
<alt> <BNF name="wildcard label"/> </alt>
<alt> <BNF name="parenthesized label expression"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:MMX-060</comment>
<BNFdef name="wildcard label">
<rhs>
<BNF name="percent"/>
</rhs>
</BNFdef>

<comment>WG3:W21-024R1</comment>
<BNFdef name="parenthesized label expression">
<rhs>
<BNF name="left paren"/> <BNF name="label expression"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:UTC-096R1</comment>
<comment>WG3:CMN-075R1</comment>
<item>Let <symdef>LE</symdef> be the <BNF name="label expression"/>.
</item>

<comment>WG3:CMN-042</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use of omitted</comment>
<item>The current working graph site of <sym>LE</sym> shall not be <quote>omitted</quote>.
</item>

<comment>WG3:W20-027R1</comment>
<comment>WG3:UTC-096R1</comment>
<comment>WG3:CMN-042</comment>
<item>Let <symdef>CWGS</symdef> be the current working graph site of <sym>LE</sym>.
</item>

<comment>WG3:CMN-075R1 Removed 1 (one) Syntax Rule</comment>

<item>Case:

<olist>

<comment>WG3:CMN-075R1</comment>
<item>If <sym>LE</sym> is simply contained in an <BNF name="is label expression"/>, then:

<olist>

<comment>WG3:CMN-042</comment>
<comment>WG3:CMN-075R1</comment>
<item>Let <symdef>GRVT</symdef> be the graph reference value type that is the declared type of
<sym>CWGS</sym>.
</item>

<comment>WG3:CMN-075R1</comment>
<item>If <sym>GRVT</sym> is a closed graph reference value type with constraining GQL-object type
<symdef>COT</symdef> then:

<comment>WG3:CMN-042</comment>
<olist>

<comment>WG3:RKE-027 P16-USA-747</comment>
<comment>WG3:CMN-042</comment>
<comment>WG3:CMN-075R1</comment>
<comment>Editorial: Stephen Cannan, 2024-04-10 Move unwanted content out of newterm</comment>
<item>If <sym>LE</sym> is simply contained in a <BNF name="node pattern"/>, then <sym>LE</sym> is
a <newterm>node label expression</newterm>.
Every <BNF name="label name"/> contained in <sym>LE</sym> shall identify a node label of 
<sym>COT</sym>.
</item>

<comment>WG3:RKE-027 P16-USA-747</comment>
<comment>WG3:CMN-042</comment>
<comment>WG3:CMN-075R1</comment>
<comment>Editorial: Stephen Cannan, 2024-04-10 Move unwanted content out of newterm</comment>
<item>Otherwise, <sym>LE</sym> is an <newterm>edge label expression</newterm>.
Every <BNF name="label name"/> contained in <sym>LE</sym> shall identify an edge label of 
<sym>COT</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:CMN-075R1</comment>
<item id="gql_label_expr_SR_in_lbl_pred">Otherwise, <sym>LE</sym> is simply contained in
a <BNF name="labeled predicate"/> <symdef>LP</symdef> and then:

<olist>

<comment>WG3:CMN-075R1</comment>
<item>Let <symdef>EVR</symdef> be the <BNF name="element variable reference"/> in <sym>LP</sym>.
</item>

<comment>WG3:CMN-075R1</comment>
<comment>WG3:GYD-014</comment>
<item>If the declared type of <sym>EVR</sym> is a closed graph element reference value type with
constraining GQL-object type <symdef>COT</symdef>, then every <BNF name="label name"/> contained
in <sym>LE</sym> shall identify a label in the label set of <sym>COT</sym>.

<comment>WG3:CMN-075R1</comment>
<note><sym>COT</sym> is either a node type or an edge type. 
<specref ref="gql_labeled_pred"/>, <itemref ref="gql_labeled_pred_SR_singleton" type="SR"/>,
requires that <sym>EVR</sym> has singleton degree of reference and in this case,
<specref ref="gql_ele_ref"/>, <itemref ref="gql_ele_ref_SR_greltreftype" type="SR"/> requires that
<sym>EVR</sym> is a node reference value or an edge reference value type,
whose constraining GQL-object type is a node type or an edge type, respectively.
</note>

</item>

</olist>

</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:W13-018</comment>
<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G074"/>, conforming GQL language shall not contain 
a <BNF name="wildcard label"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W22-053R2</comment>
<subClause id="gql_path_var_ref" newpage="true">
<clauseHeading><BNF name="path variable reference"/></clauseHeading>

<bodyMatter>

<Function>

<para>Specify path variable references.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:UTC-087R2</comment>
<BNFdef name="path variable reference">
<rhs>
<BNF name="binding variable reference"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<item>Let <symdef>PVR</symdef> be the <BNF name="path variable reference"/>.
</item>

<comment>WG3:UTC-087R2</comment>
<item>The degree of reference of <sym>PVR</sym> shall be unconditional singleton.
</item>

<comment>WG3:UTC-087R2</comment>
<item>The declared type of <sym>PVR</sym> shall be a path value type.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<None/>

</olist>

<note>Every <BNF name="path variable reference"/> is evaluated in the General Rules of 
<specref ref="gql_var_refs"/> by looking it up in the current working table. 
However the actual path value is originally constructed and bound in the General Rules of 
<specref ref="gql_app_bind_eval_expr"/>.
</note>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W13-018</comment>
<comment>WG3:W22-053R2</comment>
<subClause id="gql_ele_ref" newpage="true">
<clauseHeading><BNF name="element variable reference"/></clauseHeading>

<bodyMatter>

<Function>

<para>Specify element variable references.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:UTC-087R2</comment>
<BNFdef name="element variable reference">
<rhs>
<BNF name="binding variable reference"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:BER-031</comment>
<item>Let <symdef>EVR</symdef> be the <BNF name="element variable reference"/>.
</item>

<comment>WG3:UTC-087R2</comment>
<item>Let <symdef>EVRDT</symdef> be the declared type of <sym>EVR</sym>.
</item>

<comment>WG3:UTC-087R2</comment>
<item>Case:

<olist>

<item id="gql_ele_ref_SR_greltreftype">If the degree of reference of <sym>EVR</sym> is singleton,
then <sym>EVRDT</sym> shall be a node reference value type or an edge reference value type.
</item>

<comment>WG3:UTC-087R2 consequence</comment>
<item>Otherwise, the degree of reference of <sym>EVR</sym> is group and <sym>EVRDT</sym> shall be 
a group list value type whose list element type only includes node reference values, 
edge reference values, or the null value.
</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<None/>

</olist>

<comment>WG3:CMN-042</comment>
<note>Every <BNF name="element variable reference"/> is evaluated in the General Rules of
<specref ref="gql_var_refs"/> by looking it up in the current working record. 
However the actual element variable reference value is originally constructed and bound in the 
General Rules of <specref ref="gql_app_bind_eval_expr"/>.
</note>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:BER-030</comment>
<subClause id="gql_graph_pattern_quantifier" newpage="true">
<clauseHeading><BNF name="graph pattern quantifier"/></clauseHeading>

<bodyMatter>

<Function>

<para>Specify a graph pattern quantifier.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:BNE-034</comment>
<comment>WG3:W01-014</comment>
<BNFdef name="graph pattern quantifier">
<rhs>
<alt> <BNF name="asterisk"/> </alt>
<alt> <BNF name="plus sign"/> </alt>
<alt> <BNF name="fixed quantifier"/> </alt>
<alt> <BNF name="general quantifier"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:BNE-034</comment>
<BNFdef name="fixed quantifier">
<rhs>
<BNF name="left brace"/> <BNF name="unsigned integer"/>
<BNF name="right brace"/>
</rhs>
</BNFdef>

<comment>WG3:BNE-034</comment>
<BNFdef name="general quantifier">
<rhs>
<BNF name="left brace"/>
<opt>
<BNF name="lower bound"/> </opt> <BNF name="comma"/> <opt> <BNF name="upper bound"/>
</opt>
<BNF name="right brace"/>
</rhs>
</BNFdef>

<comment>WG3:BNE-034</comment>
<BNFdef name="lower bound">
<rhs>
<BNF name="unsigned integer"/>
</rhs>
</BNFdef>

<comment>WG3:BNE-034</comment>
<BNFdef name="upper bound">
<rhs>
<BNF name="unsigned integer"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<item>The maximum value of <BNF name="upper bound"/> is <impDef code="IL018"/>.
<BNF name="upper bound"/>, if specified, shall not be greater than this value.
</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:W01-014</comment>
<item>Every <BNF name="graph pattern quantifier"/> is normalized, as follows:

<olist>

<item><BNF name="asterisk"/> is equivalent to:
<code>
{0,}
</code>
</item>

<item><BNF name="plus sign"/> is equivalent to:
<code>
{1,}
</code>
</item>

<item>If <BNF name="fixed quantifier"/> <symdef>FQ</symdef> is specified,
then let <symdef>UI</symdef> be the
<BNF name="unsigned integer"/> contained in <sym>FQ</sym>.
<sym>FQ</sym> is equivalent to:
<code>
{<sym>UI</sym>,<sym>UI</sym>}
</code>
</item>

<item>If <BNF name="general quantifier"/> <symdef>GQ</symdef> is specified, and if
<BNF name="lower bound"/> is not specified,
then the <BNF name="unsigned integer"/> 0 (zero) is supplied as the
<BNF name="lower bound"/>.
</item>

</olist>

</item>

<comment>WG3:BNE-034</comment>
<item>If <BNF name="general quantifier"/> <symdef>GQ</symdef> is specified or implied by the
preceding normalizations, then

<para>Case:
</para>

<olist>

<comment>WG3:BNE-034</comment>
<item>If <BNF name="upper bound"/> is specified, then:

<olist>

<comment>WG3:BNE-034</comment>
<comment>WG3:W08-009: CD1 2021 P16-USA-350</comment>
<item>The value of <BNF name="upper bound"/> <symdef>VUP</symdef> shall be greater than 0 (zero).
</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:W08-009: CD1 2021 P16-USA-350</comment>
<item>The value of <BNF name="lower bound"/> <symdef>LUP</symdef> shall be less than or equal to
<sym>VUP</sym>.
</item>

<comment>WG3:BNE-034</comment>
<item>If <sym>LUP</sym> equals <sym>VUP</sym>, then <sym>GQ</sym> is 
a <newterm>fixed quantifier</newterm>.
</item>

<comment>WG3:BNE-034</comment>
<item><sym>GQ</sym> is a <newterm>bounded quantifier</newterm>.
</item>

</olist>

</item>

<comment>WG3:BNE-034</comment>
<comment>Email from: Fred Zemke 2019-02-28 21:54</comment>
<item>Otherwise, <sym>GQ</sym> is an <newterm>unbounded quantifier</newterm>.
</item>

</olist>

</item>

<comment>WG3:BNE-034</comment>
<item>A <BNF name="graph pattern quantifier"/> that is not a fixed quantifier is 
a <newterm>variable quantifier</newterm>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G060"/>, conforming GQL language shall not contain 
a <BNF name="fixed quantifier"/> or a <BNF name="general quantifier"/> that immediately contains 
an <BNF name="upper bound"/>.
</item>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G061"/>, conforming GQL language shall not contain 
a <BNF name="graph pattern quantifier"/> that immediately contains 
an <BNF name="asterisk"/>, a <BNF name="plus sign"/>, or 
a <BNF name="general quantifier"/> that does not immediately contain an <BNF name="upper bound"/>.
</item>

</olist>


</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:MMX-060</comment>
<subClause id="gql_simpl_path_patt_expr" newpage="true">
<clauseHeading><BNF name="simplified path pattern expression"/></clauseHeading>

<bodyMatter>

<Function>

<para>Express a path pattern as a regular expression of edge labels.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="simplified path pattern expression">
<rhs>
<alt> <BNF name="simplified defaulting left"/> </alt>
<alt> <BNF name="simplified defaulting undirected"/> </alt>
<alt> <BNF name="simplified defaulting right"/> </alt>
<alt> <BNF name="simplified defaulting left or undirected"/> </alt>
<alt> <BNF name="simplified defaulting undirected or right"/> </alt>
<alt> <BNF name="simplified defaulting left or right"/> </alt>
<alt> <BNF name="simplified defaulting any direction"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="simplified defaulting left">
<rhs>
<BNF name="left minus slash"/> <BNF name="simplified contents"/> <BNF name="slash minus"/>
</rhs>
</BNFdef>

<BNFdef name="simplified defaulting undirected">
<rhs>
<BNF name="tilde slash"/> <BNF name="simplified contents"/> <BNF name="slash tilde"/>
</rhs>
</BNFdef>

<BNFdef name="simplified defaulting right">
<rhs>
<BNF name="minus slash"/> <BNF name="simplified contents"/> <BNF name="slash minus right"/>
</rhs>
</BNFdef>

<BNFdef name="simplified defaulting left or undirected">
<rhs>
<BNF name="left tilde slash"/> <BNF name="simplified contents"/> <BNF name="slash tilde"/>
</rhs>
</BNFdef>

<BNFdef name="simplified defaulting undirected or right">
<rhs>
<BNF name="tilde slash"/> <BNF name="simplified contents"/> <BNF name="slash tilde right"/>
</rhs>
</BNFdef>

<BNFdef name="simplified defaulting left or right">
<rhs>
<BNF name="left minus slash"/> <BNF name="simplified contents"/>
<BNF name="slash minus right"/>
</rhs>
</BNFdef>

<BNFdef name="simplified defaulting any direction">
<rhs>
<BNF name="minus slash"/> <BNF name="simplified contents"/> <BNF name="slash minus"/>
</rhs>
</BNFdef>

<BNFdef name="simplified contents">
<rhs>
<alt> <BNF name="simplified term"/> </alt>
<alt> <BNF name="simplified path union"/> </alt>
<alt> <BNF name="simplified multiset alternation"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W08-009 P16-USA-390</comment>
<BNFdef name="simplified path union">
<rhs>
<BNF name="simplified term"/> <BNF name="vertical bar"/> <BNF name="simplified term"/>
<breakindent/>
<opt> <group> <BNF name="vertical bar"/> <BNF name="simplified term"/> </group><repeat/> </opt>
</rhs>
</BNFdef>

<BNFdef name="simplified multiset alternation">
<rhs>
<BNF name="simplified term"/> <BNF name="multiset alternation operator"/>
<BNF name="simplified term"/>
<breakindent/>
<opt> 
<group> 
<BNF name="multiset alternation operator"/> <BNF name="simplified term"/> 
</group><repeat/> 
</opt>
</rhs>
</BNFdef>

<BNFdef name="simplified term">
<rhs>
<alt> <BNF name="simplified factor low"/> </alt>
<alt> <BNF name="simplified concatenation"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="simplified concatenation">
<rhs>
<BNF name="simplified term"/> <BNF name="simplified factor low"/>
</rhs>
</BNFdef>

<BNFdef name="simplified factor low">
<rhs>
<alt> <BNF name="simplified factor high"/> </alt>
<alt> <BNF name="simplified conjunction"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="simplified conjunction">
<rhs>
<BNF name="simplified factor low"/> <BNF name="ampersand"/> <BNF name="simplified factor high"/>
</rhs>
</BNFdef>

<comment>WG3:W01-014</comment>
<BNFdef name="simplified factor high">
<rhs>
<alt> <BNF name="simplified tertiary"/> </alt>
<alt> <BNF name="simplified quantified"/> </alt>
<alt> <BNF name="simplified questioned"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="simplified quantified">
<rhs>
<BNF name="simplified tertiary"/> <BNF name="graph pattern quantifier"/>
</rhs>
</BNFdef>

<comment>WG3:W01-014</comment>
<BNFdef name="simplified questioned">
<rhs>
<BNF name="simplified tertiary"/> <BNF name="question mark"/>
</rhs>
</BNFdef>

<BNFdef name="simplified tertiary">
<rhs>
<alt> <BNF name="simplified direction override"/> </alt>
<alt> <BNF name="simplified secondary"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="simplified direction override">
<rhs>
<alt> <BNF name="simplified override left"/> </alt>
<alt> <BNF name="simplified override undirected"/> </alt>
<alt> <BNF name="simplified override right"/> </alt>
<alt> <BNF name="simplified override left or undirected"/> </alt>
<alt> <BNF name="simplified override undirected or right"/> </alt>
<alt> <BNF name="simplified override left or right"/> </alt>
<alt> <BNF name="simplified override any direction"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="simplified override left">
<rhs>
<BNF name="left angle bracket"/> <BNF name="simplified secondary"/>
</rhs>
</BNFdef>

<BNFdef name="simplified override undirected">
<rhs>
<BNF name="tilde"/> <BNF name="simplified secondary"/>
</rhs>
</BNFdef>

<BNFdef name="simplified override right">
<rhs>
<BNF name="simplified secondary"/> <BNF name="right angle bracket"/>
</rhs>
</BNFdef>

<BNFdef name="simplified override left or undirected">
<rhs>
<BNF name="left arrow tilde"/> <BNF name="simplified secondary"/>
</rhs>
</BNFdef>

<BNFdef name="simplified override undirected or right">
<rhs>
<BNF name="tilde"/> <BNF name="simplified secondary"/> <BNF name="right angle bracket"/>
</rhs>
</BNFdef>

<BNFdef name="simplified override left or right">
<rhs>
<BNF name="left angle bracket"/> <BNF name="simplified secondary"/> 
<BNF name="right angle bracket"/>
</rhs>
</BNFdef>

<comment>WG3:W09-036</comment>
<BNFdef name="simplified override any direction">
<rhs>
<BNF name="minus sign"/> <BNF name="simplified secondary"/>
</rhs>
</BNFdef>

<BNFdef name="simplified secondary">
<rhs>
<alt> <BNF name="simplified primary"/> </alt>
<alt> <BNF name="simplified negation"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="simplified negation">
<rhs>
<BNF name="exclamation mark"/> <BNF name="simplified primary"/>
</rhs>
</BNFdef>

<comment>WG3:RKE-027 P16-USA-747</comment>
<comment>WG3:W21-024R1</comment>
<BNFdef name="simplified primary">
<rhs>
<alt> <BNF name="label name"/> </alt>
<alt> <BNF name="left paren"/> <BNF name="simplified contents"/> <BNF name="right paren"/> </alt>
</rhs>
</BNFdef>

<ednote id="gql_mmx060_2">It has been proposed that a macro name may be 
a <BNF name="simplified primary"/> in a <BNF name="simplified path pattern expression"/>.
See <PPref ref="PPgql034"/>.
</ednote>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:W01-014</comment>
<item>A <BNF name="simplified negation"/> shall not contain 
a <BNF name="simplified concatenation"/>, <BNF name="simplified quantified"/>, 
<BNF name="simplified questioned"/>, or <BNF name="simplified multiset alternation"/>.
</item>

<item>A <BNF name="simplified direction override"/> shall not contain another 
<BNF name="simplified direction override"/>.
</item>

<comment>WG3:W01-014</comment>
<item>A <BNF name="simplified direction override"/> shall not contain 
<BNF name="simplified concatenation"/>, <BNF name="simplified quantified"/>,
<BNF name="simplified questioned"/>, or <BNF name="simplified multiset alternation"/>.
</item>

<comment>WG3:W01-014</comment>
<item>A <BNF name="simplified conjunction"/> shall not contain 
a <BNF name="simplified concatenation"/>, <BNF name="simplified quantified"/>, 
<BNF name="simplified questioned"/>, or <BNF name="simplified multiset alternation"/>.
</item>

<item>A <BNF name="simplified path pattern expression"/> <symdef>SPPE</symdef> is effectively 
replaced by:
<code>
( <sym>SPPE</sym> )
</code>
<note>This is done once for each <BNF name="simplified path pattern expression"/> prior to the 
following recursive transformation and not with each iteration of the transformation.
</note>
</item>

<item>The following rules are recursively applied until no 
<BNF name="simplified path pattern expression"/>s remain.

<comment>Editorial: Stephen Cannan 2023-01-20 Align with Directives Part 2</comment>
<note>The rules work from the root of the parse tree of 
a <BNF name="simplified path pattern expression"/>.
At each step, the coarsest analysis of a <BNF name="simplified path pattern expression"/> is 
replaced, eliminating at least one level of the parse tree, measured from the root.
Note that each replacement can create more <BNF name="simplified path pattern expression"/>s than 
before, but these replacements have less depth.
Eventually the recursion replaces <BNF name="simplified path pattern expression"/> with 
<BNF name="edge pattern"/>.
</note>

<olist>

<item>Let <symdef>SPPE</symdef> be a <BNF name="simplified path pattern expression"/>.

<olist>

<item>Let <symdef>SC</symdef> be the <BNF name="simplified contents"/> contained in <sym>SPPE</sym>.
</item>

<item>Let <symdef>PREFIX</symdef> be the <BNF name="minus slash"/>, <BNF name="left minus slash"/>, 
<BNF name="tilde slash"/>, <BNF name="left tilde slash"/>, or <BNF name="left minus slash"/> 
contained in <sym>SPPE</sym>.
</item>

<item>Let <symdef>SUFFIX</symdef> be the <BNF name="slash minus right"/>, 
<BNF name="slash minus"/>, <BNF name="slash tilde"/>, or <BNF name="slash tilde right"/> 
contained in <sym>SPPE</sym>.
</item>

<item>Let <symdef>EDGEPRE</symdef> and <symdef>EDGESUF</symdef> be determined by 
<specref ref="gql_simpl_delim_conv"/>, from the row containing the values of 
<sym>PREFIX</sym> and <sym>SUFFIX</sym>.

<comment>WG3:UTC-013 P16-DEU-019</comment>
<table id="gql_simpl_delim_conv">
<tableTitle>Conversion of simplified syntax delimiters to default edge delimiters</tableTitle>

<table-common>

<table-setup numcols="4">
<table-coldef colnum="1" colwidth="1.0in"></table-coldef>
<table-coldef colnum="2" colwidth="1.0in"></table-coldef>
<table-coldef colnum="3" colwidth="1.0in"></table-coldef>
<table-coldef colnum="4" colwidth="1.0in"></table-coldef>
</table-setup>

<table-heads>
<table-head align="center"> <sym>PREFIX</sym> </table-head>
<table-head align="center"> <sym>SUFFIX</sym> </table-head>
<table-head align="center"> <sym>EDGEPRE</sym> </table-head>
<table-head align="center"> <sym>EDGESUF</sym> </table-head>
</table-heads>

</table-common>

<table-body>

<table-row>
<table-cell align="center"><mono>-/</mono></table-cell>
<table-cell align="center"><mono>/-></mono></table-cell>
<table-cell align="center"><mono>-[</mono></table-cell>
<table-cell align="center"><mono>]-></mono></table-cell>
</table-row>

<table-row>
<table-cell align="center"><mono>&lt;-/</mono></table-cell>
<table-cell align="center"><mono>/-</mono></table-cell>
<table-cell align="center"><mono>&lt;-[</mono></table-cell>
<table-cell align="center"><mono>]-</mono></table-cell>
</table-row>

<table-row>
<table-cell align="center"><mono>~/</mono></table-cell>
<table-cell align="center"><mono>/~</mono></table-cell>
<table-cell align="center"><mono>~[</mono></table-cell>
<table-cell align="center"><mono>]~</mono></table-cell>
</table-row>

<table-row>
<table-cell align="center"><mono>~/</mono></table-cell>
<table-cell align="center"><mono>/~></mono></table-cell>
<table-cell align="center"><mono>~[</mono></table-cell>
<table-cell align="center"><mono>]~></mono></table-cell>
</table-row>

<table-row>
<table-cell align="center"><mono>&lt;~/</mono></table-cell>
<table-cell align="center"><mono>/~</mono></table-cell>
<table-cell align="center"><mono>&lt;~[</mono></table-cell>
<table-cell align="center"><mono>]~</mono></table-cell>
</table-row>

<table-row>
<table-cell align="center"><mono>&lt;-/</mono></table-cell>
<table-cell align="center"><mono>/-></mono></table-cell>
<table-cell align="center"><mono>&lt;-[</mono></table-cell>
<table-cell align="center"><mono>]-></mono></table-cell>
</table-row>

<table-row>
<table-cell align="center"><mono>-/</mono></table-cell>
<table-cell align="center"><mono>/-</mono></table-cell>
<table-cell align="center"><mono>-[</mono></table-cell>
<table-cell align="center"><mono>]-</mono></table-cell>
</table-row>

</table-body>

</table>

</item>

</olist>

</item>

<item>Case:

<olist>

<comment>Editorial: Stephen Cannan 2021-11-28</comment>
<comment>WG3:BER-080</comment>
<item>If <sym>SC</sym> is a <BNF name="simplified path union"/> <symdef>SPU</symdef>, then
let <symdef>N</symdef> be the number of <BNF name="simplified term"/>s simply contained in 
<sym>SPU</sym>, and let <symdef>ST</symdef><sub>1</sub>, <ellipsis/>, 
<symdef>ST</symdef><sub><sym>N</sym></sub> be those <BNF name="simplified term"/>s;
<sym>SPPE</sym> is effectively replaced by:

<comment>WG3:W08-009 P16-USA-400</comment>
<code>
<sym>PREFIX</sym> <sym>ST</sym><sub>1</sub> <sym>SUFFIX</sym> | <sym>PREFIX</sym> <sym>ST</sym><sub>2</sub> <sym>SUFFIX</sym> | <ellipsis/> | <sym>PREFIX</sym> <sym>ST</sym><sub><sym>N</sym></sub> <sym>SUFFIX</sym>
</code>
</item>

<comment>Editorial: Stephen Cannan 2021-11-28</comment>
<comment>WG3:BER-080</comment>
<item>If <sym>SC</sym> is a <BNF name="simplified multiset alternation"/> <symdef>SMA</symdef>, then
let <symdef>N</symdef> be the number of <BNF name="simplified term"/>s simply contained in 
<sym>SMA</sym>, and let <symdef>ST</symdef><sub>1</sub>, <ellipsis/>, 
<symdef>ST</symdef><sub><sym>N</sym></sub> be those <BNF name="simplified term"/>s;
<sym>SPPE</sym> is effectively replaced by:

<comment>WG3:W08-009 P16-USA-400</comment>
<code>
<sym>PREFIX</sym> <sym>ST</sym><sub>1</sub> <sym>SUFFIX</sym> |+| <sym>PREFIX</sym> <sym>ST</sym><sub>2</sub> <sym>SUFFIX</sym> |+| <ellipsis/> |+| <sym>PREFIX</sym> <sym>ST</sym><sub><sym>N</sym></sub> <sym>SUFFIX</sym>
</code>
</item>

<comment>WG3:BER-080</comment>
<item>If <sym>SC</sym> is a <BNF name="simplified concatenation"/> <symdef>SCAT</symdef>, then
let <symdef>ST</symdef> be the <BNF name="simplified term"/> and let <symdef>SFL</symdef> be the 
<BNF name="simplified factor low"/> simply contained in <sym>SCAT</sym>;
<sym>SPPE</sym> is effectively replaced by:

<code>
<sym>PREFIX</sym> <sym>ST</sym> <sym>SUFFIX</sym> <sym>PREFIX</sym> <sym>SFL</sym> <sym>SUFFIX</sym>
</code>
</item>

<item>If <sym>SC</sym> is a <BNF name="simplified conjunction"/> <symdef>SAND</symdef>, then 
<sym>SPPE</sym> is effectively replaced by:

<code>
<sym>EDGEPRE</sym> <kw>IS</kw> <sym>SAND</sym> <sym>EDGESUF</sym>
</code>

<note>As a result, <sym>SAND</sym> is now interpreted as a <BNF name="label expression"/>
within an <BNF name="edge pattern"/>.
By earlier Syntax Rules, there are no operators allowed in <sym>SAND</sym> that cannot be 
interpreted as operators of a <BNF name="label expression"/>.
</note>
</item>

<comment>WG3:BER-080</comment>
<item>If <sym>SC</sym> is a <BNF name="simplified quantified"/> <symdef>SQ</symdef>, then
let <symdef>ST</symdef> be the <BNF name="simplified tertiary"/> simply contained in <sym>SC</sym> 
and let <symdef>GPQ</symdef> be the <BNF name="graph pattern quantifier"/> simply contained in 
<sym>SQ</sym>; <sym>SPPE</sym> is effectively replaced by:

<code>
( <sym>PREFIX</sym> <sym>ST</sym> <sym>SUFFIX</sym> ) <sym>GPQ</sym>
</code>
</item>

<comment>WG3:W01-014</comment>
<comment>WG3:BER-080</comment>
<comment>Editorial: Stephen Cannan, 2023-10-13</comment>
<item>If <sym>SC</sym> is a <BNF name="simplified questioned"/>, then
let <symdef>ST</symdef> be the <BNF name="simplified tertiary"/> simply contained in <sym>SC</sym>;
<sym>SPPE</sym> is effectively replaced by:

<code>
( <sym>PREFIX</sym> <sym>ST</sym> <sym>SUFFIX</sym> ) ?
</code>
</item>

<comment>WG3:RKE-039 P16-USA-380</comment>
<item>If <sym>SC</sym> is a <BNF name="simplified direction override"/> <symdef>SDO</symdef>, then
let <symdef>SS</symdef> be the <BNF name="simplified secondary"/> simply contained in 
<sym>SDO</sym>.

<para>Case:
</para>

<comment>WG3:RKE-039 P16-USA-???</comment>
<note>As a result of the following replacements, <sym>SDO</sym> is now interpreted as 
a <BNF name="label expression"/> within an <BNF name="edge pattern"/>. 
By earlier Syntax Rules, there are no operators allowed in <sym>SDO</sym> that cannot be 
interpreted as operators of a <BNF name="label expression"/>.
</note>

<olist>

<item>If <sym>SDO</sym> is <BNF name="simplified override left"/>, then <sym>SPPE</sym> is replaced 
by:

<code>
&lt;-[ <kw>IS</kw> <sym>SS</sym> ]-
</code>
</item>

<item>If <sym>SDO</sym> is <BNF name="simplified override undirected"/>, then <sym>SPPE</sym> is 
effectively replaced by:
<code>
~[ <kw>IS</kw> <sym>SS</sym> ]~
</code>
</item>

<item>If <sym>SDO</sym> is <BNF name="simplified override left or undirected"/>, then 
<sym>SPPE</sym> is effectively replaced by:
<code>
&lt;~[ <kw>IS</kw> <sym>SS</sym> ]~
</code>
</item>

<item>If <sym>SDO</sym> is <BNF name="simplified override undirected or right"/>, then 
<sym>SPPE</sym> is effectively replaced by:
<code>
~[ <kw>IS</kw> <sym>SS</sym> ]~>
</code>
</item>

<item>If <sym>SDO</sym> is <BNF name="simplified override left or right"/>, then <sym>SPPE</sym> 
is effectively replaced by:
<code>
&lt;-[ <kw>IS</kw> <sym>SS</sym> ]->
</code>
</item>

<item>If <sym>SDO</sym> is <BNF name="simplified override any direction"/>, then <sym>SPPE</sym> is 
effectively replaced by:
<code>
-[ <kw>IS</kw> <sym>SS</sym> ]-
</code>
</item>

</olist>

</item>

<item>If <sym>SC</sym> is a <BNF name="simplified negation"/> <symdef>SN</symdef>, then 
<sym>SPPE</sym> is effectively replaced by:
<code>
<sym>EDGEPRE</sym> <kw>IS</kw> <sym>SN</sym> <sym>EDGESUF</sym>
</code>
<note>As a result, <sym>SN</sym> is now interpreted as a <BNF name="label expression"/> within 
an <BNF name="edge pattern"/>.
By earlier Syntax Rules, there are no operators allowed in <sym>SN</sym> that cannot be 
interpreted as operators of a <BNF name="label expression"/>.
</note>
</item>

<item>If <sym>SC</sym> is a <BNF name="simplified primary"/> <symdef>SP</symdef>, then

<para>Case:
</para>

<olist>

<comment>WG3:RKE-027 P16-USA-747</comment>
<item>If <sym>SP</sym> is a <BNF name="label name"/>, then <sym>SPPE</sym> is effectively replaced 
by:
<code>
<sym>EDGEPRE</sym> <kw>IS</kw> <sym>SP</sym> <sym>EDGESUF</sym>
</code>
</item>

<comment>WG3:BER-080</comment>
<item>Otherwise, let <symdef>INNER</symdef> be the <BNF name="simplified contents"/> simply 
contained in <sym>SC</sym>; <sym>SPPE</sym> is effectively replaced by:

<code>
( <sym>PREFIX</sym> <sym>INNER</sym> <sym>SUFFIX</sym> )
</code>
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:BER-030</comment>
<item>The Conformance Rules of <specref ref="gql_path_pattern_expr"/> are applied to the result of 
the previous syntactic transformation.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W13-022R1</comment>
<comment>WG3:BER-030</comment>
<item>Without <feature code="G039"/>, conforming GQL language shall not contain 
a <BNF name="simplified path pattern expression"/> that is not 
a <BNF name="simplified defaulting left"/>, a <BNF name="simplified defaulting right"/>, or 
a <BNF name="simplified defaulting any direction"/>.
</item>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G080"/>, conforming GQL language shall not contain 
a <BNF name="simplified defaulting left"/>, a <BNF name="simplified defaulting right"/>, or
a <BNF name="simplified defaulting any direction"/>.
</item>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G081"/>, conforming GQL language shall not contain 
a <BNF name="simplified direction override"/> that is not 
a <BNF name="simplified override left"/>, a <BNF name="simplified override right"/>, or
a <BNF name="simplified override any direction"/>.
</item>

<comment>WG3:BER-030</comment>
<item>Without <feature code="G082"/>, conforming GQL language shall not contain 
a <BNF name="simplified override left"/>, a <BNF name="simplified override right"/>, or
a <BNF name="simplified override any direction"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_where" newpage="true">
<clauseHeading><BNF name="where clause"/></clauseHeading>

<bodyMatter>

<Function>

<comment>Editorial: 2020-03-25 Reduce scope of function as a graph pattern has own where</comment>
<comment>Editorial: 2020-04-26 Adjust in line with other changes</comment>
<para>Compute a new binding table by selecting records from the current working table
fulfilling the specified <BNF name="search condition"/>.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="where clause">
<rhs>
<kw>WHERE</kw> <BNF name="search condition"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<comment>WG3:BER-019</comment>
<olist>

<item>Let <symdef>WC</symdef> be the <BNF name="where clause"/> and let <symdef>SC</symdef> 
be the <BNF name="search condition"/> immediately contained in <sym>WC</sym>.
</item>

<comment>WG3:OHD-028</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>SC</sym> is the incoming working record type
of <sym>WC</sym> amended with the record type of the incoming working table type
of <sym>WC</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>SC</sym> is the material unit binding
table type.
</item>

<comment>WG3:XRH-036</comment>
<item>The declared type of <sym>WC</sym> is incoming working table type of <sym>WC</sym>.
</item>
<endbar/>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2020-04-20 Reformulated GRs</comment>
<olist>

<comment>Editorial: Stefan Plantikow, 2020-05-15 Joined GRs</comment>
<comment>WG3:BER-019 One rule deleted</comment>

<comment>Editorial: 2020-03-25 Initial specification</comment>
<item>Let <symdef>WHERE</symdef> be a new empty binding table.
</item>

<item>For each record <symdef>R</symdef> of the current working table:

<olist>

<comment>WG3:W12-019</comment>
<item>Let <symdef>INCLUDE</symdef> be the result of <sym>SC</sym> in a new child execution context
amended with <sym>R</sym>.
</item>

<comment>WG3:CMN-019 P00-USA-351</comment>
<item>If <sym>INCLUDE</sym> is <bool>True</bool>, then <sym>R</sym> is added to <sym>WHERE</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-096R1</comment>
<item>The result of <sym>WC</sym> is <sym>WHERE</sym>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>Editorial: Stephen Cannan, 2020-04-06</comment>
<subClause id="gql_yield" newpage="true">
<clauseHeading><BNF name="yield clause"/></clauseHeading>

<bodyMatter>


<Function>

<comment>WG3:UTC-108</comment>
<para>Select and rename columns of a binding table.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-04-20 Added missing keyword</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-20 Removed slicing from YIELD</comment>
<BNFdef name="yield clause">
<rhs>
<kw>YIELD</kw>
<BNF name="yield item list"/>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-04-02</comment>
<BNFdef name="yield item list">
<rhs>
<BNF name="yield item"/>
<opt> 
<group> <BNF name="comma"/> <BNF name="yield item"/> </group><repeat/> 
</opt>
</rhs>
</BNFdef>

<BNFdef name="yield item">
<rhs>
<group>
<BNF name="yield item name"/> 
<opt> <BNF name="yield item alias"/> </opt>
</group>
</rhs>
</BNFdef>

<comment>WG3:W22-053R2</comment>
<BNFdef name="yield item name">
<rhs>
<BNF name="field name"/> 
</rhs>
</BNFdef>

<comment>WG3:W17-027</comment>
<comment>WG3:W22-053R2</comment>
<BNFdef name="yield item alias">
<rhs>
<kw>AS</kw> <BNF name="binding variable"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<comment>Editorial: Stefan Plantikow, 2020-04-28 Reworked</comment>
<olist>

<item>Let <symdef>YC</symdef> be the <BNF name="yield clause"/>.
</item>

<comment>WG3:W22-053R2</comment>
<item>Let <symdef>COYI</symdef> be the collection of <BNF name="yield item"/>s
simply contained in <sym>YC</sym>.
</item>

<comment>WG3:W22-053R2</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>Let <symdef>N</symdef> be the number of <BNF name="yield item"/>s in <symdef>COYI</symdef>.
</item>

<comment>Editorial: Stephen Cannan, 2022-03-06 WG3:RKE-010 P00-USA-481</comment>
<comment>WG3:W22-053R2</comment>
<comment>WG3:UTC-108</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>For each <BNF name="yield item"/> <symdef>YI</symdef><sub><sym>i</sym></sub>, 
1 (one) <leq/> <symdef>i</symdef> <leq/> <sym>N</sym>, in <sym>COYI</sym>:

<olist>

<comment>WG3:W22-053R2</comment>
<item>Let <symdef>YIN</symdef><sub><sym>i</sym></sub> be the <BNF name="yield item name"/> 
specified by <sym>YI</sym><sub><sym>i</sym></sub>.
</item>

<comment>WG3:RKE-015</comment>
<item>If <sym>YI</sym><sub><sym>i</sym></sub> does not immediately contain 
a <BNF name="yield item alias"/>, then:

<olist>

<comment>WG3:W22-053R2</comment>
<item><sym>YIN</sym><sub><sym>i</sym></sub> shall be a <BNF name="binding variable"/>.
</item>

<item><sym>YI</sym><sub><sym>i</sym></sub> is effectively replaced by:

<code>
<sym>YIN</sym><sub><sym>i</sym></sub> <kw>AS</kw> <sym>YIN</sym><sub><sym>i</sym></sub>
</code>
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W22-053R2</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>Let <symdef>YCT</symdef> be the <BNF name="yield clause"/> after the preceding 
transformation and let <symdef>COYIT</symdef> be the collection of 
<sym>N</sym> <BNF name="yield item"/>s simply contained in <sym>YCT</sym>.
</item>

<item>If <sym>COYIT</sym> simply contains a <BNF name="yield item alias"/> that simply contains 
a <BNF name="binding variable"/> <symdef>YIABV1</symdef>, then <sym>COYIT</sym> shall not simply 
contain another <BNF name="yield item alias"/> that simply contains 
a <BNF name="binding variable"/> <symdef>YIABV2</symdef> such that <sym>YIABV1</sym> and 
<sym>YIABV2</sym> are equivalent.
</item>

<comment>WG3:BER-019</comment>
<comment>WG3:W22-053R2</comment>
<item>The declared type of <sym>YCT</sym> is a binding table type <symdef>BTT</symdef> 
defined as follows:

<olist>

<comment>WG3:CMN-019 P00-USA-207</comment>
<item><sym>BTT</sym> has <symdef>N</symdef> columns.
</item>

<comment>WG3:W22-053R2</comment>
<comment>WG3:UTC-108</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>For each <BNF name="yield item"/> <symdef>YI</symdef><sub><sym>i</sym></sub>, 
1 (one) <leq/> <symdef>i</symdef> <leq/> <sym>N</sym> in <sym>COYIT</sym>:

<olist>

<comment>WG3:W22-053R2</comment>
<comment>WG3:OHD-026</comment>
<item>Let <symdef>YIN</symdef><sub><sym>i</sym></sub> be the <BNF name="yield item name"/> 
specified by <sym>YI</sym><sub><sym>i</sym></sub>.
</item>

<comment>WG3:W22-053R2</comment>
<item>Let <symdef>YIA</symdef><sub><sym>i</sym></sub> be the <BNF name="binding variable"/> simply
contained in the <BNF name="yield item alias"/> specified by <sym>YI</sym><sub><sym>i</sym></sub>.
</item>

<comment>WG3:OHD-026</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>YC</sym> shall have 
a column <symdef>SC</symdef> with column name <sym>YIN</sym><sub><sym>i</sym></sub>.
</item>
<endbar/>

<item><sym>BTT</sym> has a column <symdef>TC</symdef>.
</item>

<comment>WG3:W22-053R2</comment>
<item>The column type of <sym>TC</sym> is the column type of <sym>SC</sym>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2020-04-28 Added GRs</comment>
<olist>

<item>Let <symdef>YIELD</symdef> be a new empty binding table.
</item>

<comment>WG3:W12-019</comment>
<item>For each record <symdef>R</symdef> of the current working table in a new child execution 
context amended with <sym>R</sym>:

<olist>

<item>Let <symdef>T</symdef> be a new empty record.
</item>

<comment>Editorial: Stephen Cannan, 2020-04-05</comment>
<comment>Editorial: Stephen Cannan, 2022-03-06 WG3:RKE-010 P00-USA-481</comment>
<comment>WG3:W22-053R2</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>For each <BNF name="yield item"/> <symdef>YI</symdef><sub><sym>i</sym></sub>, 
1 (one) <leq/> <symdef>i</symdef> <leq/> <sym>N</sym>, from <sym>COYIT</sym>:

<olist>

<item>Let <symdef>YIN</symdef><sub><sym>i</sym></sub> be the <BNF name="yield item name"/>
specified by <sym>YI</sym><sub><sym>i</sym></sub>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>Let <symdef>F</symdef><sub><sym>i</sym></sub> be the field of the current working record
whose name is <sym>YIN</sym><sub><sym>i</sym></sub>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>Let <symdef>YIV</symdef><sub><sym>i</sym></sub> be the value of 
<sym>F</sym><sub><sym>i</sym></sub>.

<comment>WG3:W22-053R2</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<note>As opposed to the General Rules for <BNF name="binding variable"/>,
<BNF name="yield item"/>s only consider the current working record and ignore
the working records of any parent execution contexts that precede the current execution context
in the current execution stack.
</note>

</item>

<comment>WG3:W17-027</comment>
<comment>WG3:W22-053R2</comment>
<item>Let <symdef>YIA</symdef><sub><sym>i</sym></sub> be the <BNF name="binding variable"/> 
simply contained in the <BNF name="yield item alias"/> specified by 
<sym>YI</sym><sub><sym>i</sym></sub>.
</item>

<comment>WG3:CMN-019 P00-USA-351</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>A new field with name <sym>YIA</sym><sub><sym>i</sym></sub> and
with value <sym>YIV</sym><sub><sym>i</sym></sub> is added to <sym>T</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-351</comment>
<item><sym>T</sym> is added to <sym>YIELD</sym>.
</item>

</olist>

</item>

<comment>WG3:W22-053R2</comment>
<item>The result of <sym>YCT</sym> is <sym>YIELD</sym>.
</item>

</olist>

</GeneralRules>


<comment>WG3:UTC-108</comment>
<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_group_by" newpage="true">
<clauseHeading><BNF name="group by clause"/></clauseHeading>

<bodyMatter>
<comment>WG3:W23-013 One editor's note removed</comment>

<Function>

<comment>Editorial: Stephen Cannan, 2020-05-08 Initial GQL version.</comment>
<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<para>Define a <BNF name="group by clause"/> for specifying the set of grouping keys to be used
during grouping.
</para>

</Function>

<ednote id="gql_PP017_group_by">Aggregation functionality should be improved for the needs of GQL.
See <PPref ref="PPgql017"/>.
</ednote>

<Format>

<grammar>

<BNFdef name="group by clause">
<rhs>
<kw>GROUP</kw> <kw>BY</kw> <BNF name="grouping element list"/>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-10-17 Adjusted to match rules</comment>
<comment>WG3:CMN-019 P00-USA-104</comment>
<BNFdef name="grouping element list">
<rhs>
<alt>
<BNF name="grouping element"/>
<opt> <group> <BNF name="comma"/> <BNF name="grouping element"/> </group><repeat/> </opt>
</alt>
<alt> <BNF name="empty grouping set"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W22-053R2</comment>
<BNFdef name="grouping element">
<rhs>
<BNF name="binding variable reference"/> 
</rhs>
</BNFdef>

<BNFdef name="empty grouping set">
<rhs>
<BNF name="left paren"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-10-16 binding variable reference</comment>
</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:OHD-028</comment>
<item>Let <symdef>GBC</symdef> be the <BNF name="group by clause"/> and let <symdef>GEL</symdef>
be the <BNF name="grouping element list"/>.
</item>

<comment>WG3:OHD-028</comment>
<item>Let <symdef>COLS</symdef> be the sequence of columns defined as follows.

<para>Case:
</para>

<olist>

<comment>Editorial: Stefan Plantikow, 2022-10-07 Corrected to use sequence</comment>
<comment>WG3:CMN-019 P00-NLD-060</comment>
<item>If <sym>GEL</sym> is the <BNF name="empty grouping set"/>, then <sym>COLS</sym> is
the empty sequence.
</item>

<item>Otherwise:

<olist>

<item>Let <symdef>GESEQ</symdef> be the sequence of <BNF name="grouping element"/>s immediately
contained in <sym>GEL</sym> and let <symdef>NGESEQ</symdef> be the number of such 
<BNF name="grouping element"/>s in <sym>GESEQ</sym>.
</item>

<item>For every <sym>i</sym>-th element <symdef>GE</symdef><sub><sym>i</sym></sub> of 
<sym>GESEQ</sym>, 1 (one) <leq/> <symdef>i</symdef> <leq/> <sym>NGESEQ</sym>:

<olist>

<item>Let <symdef>BVR</symdef><sub><sym>i</sym></sub> be the 
<BNF name="binding variable reference"/> immediately contained in 
<sym>GE</sym><sub><sym>i</sym></sub>.
</item>

<comment>WG3:UTC-081</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <symdef>BVR</symdef><sub><sym>i</sym></sub> is 
the incoming working record type of <sym>GBC</sym> amended with
the record type of the incoming working table type of <sym>GBC</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <symdef>BVR</symdef><sub><sym>i</sym></sub>
is the unit binding table type.
</item>
<endbar/>

<comment>Editorial: Stefan Plantikow, 2022-12-22 Correct application</comment>
<comment>WG3:W24-037</comment>
<comment>Email from: Nathalie Charbel, 2022-12-20 1738</comment>
<item><sym>BVR</sym><sub><sym>i</sym></sub> is an operand of a grouping operation. 
The Syntax Rules and Conformance Rules of <specref ref="gql_grouping_ops"/>, apply.
</item>

<item>Let <symdef>GEBV</symdef><sub><sym>i</sym></sub> be the name of the binding variable 
referenced by <sym>BVR</sym><sub><sym>i</sym></sub>.
</item>

<comment>Editorial: Stefan Plantikow, 2022-10-07 Adjusted to defined sequence</comment>
<item>Let <symdef>COL</symdef><sub>i</sub> be the column whose name is
<sym>GEBV</sym><sub><sym>i</sym></sub> and whose type is the declared type of
<sym>BVR</sym><sub><sym>i</sym></sub>.
</item>

<comment>WG3:W24-014R2</comment>
<item>Append <sym>COL</sym> to <sym>COLS</sym>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:OHD-028</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The outgoing working table type of <sym>GBC</sym> is a material binding table
whose set of columns is <sym>COLS</sym>.
</item>

<comment>WG3:OHD-028</comment>
<comment>WG3:XRH-036</comment>
<item>The outgoing working record type of <sym>GBC</sym> is the incoming working record type
of <sym>GBC</sym>.
</item>

<comment>WG3:OHD-028</comment>
<comment>WG3:XRH-036</comment>
<item>The declared type of <sym>GBC</sym> is the outgoing working table type of <sym>GBC</sym>.
</item>
<endbar/>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2020-05-16 Sketch GROUP BY</comment>
<olist>

<item>Case:

<olist>

<comment>WG3:BER-019 - email from Hannes Voigt 2022-06-22</comment>
<item>If <sym>GEL</sym> is the <BNF name="empty grouping set"/>, then 
let <symdef>GROUP_BY</symdef> be a unit binding table.
</item>

<item>Otherwise:

<olist>

<comment>Editorial: Stephen Cannan, 2022-03-06 WG3:RKE-010 P00-USA-481</comment>
<comment>WG3:W22-053R2</comment>
<comment>WG3:W24-014R2</comment>
<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NGESEQ</sym>, 
let <symdef>GE</symdef><sub><sym>i</sym></sub> be the <sym>i</sym>-th element of <sym>GESEQ</sym> 
and let <symdef>GEBV</symdef><sub><sym>i</sym></sub> be the <BNF name="binding variable reference"/>
simply contained in <sym>GEBV</sym><sub><sym>i</sym></sub>.
</item>

<comment>WG3:OHD-028</comment><comment>WG3:W24-014R2</comment>
<item>Let <symdef>GROUP_BY</symdef> be a new empty binding table with the column set 
<sym>COLS</sym>.
</item>

<comment>WG3:W12-019</comment>
<item>For each record <symdef>R</symdef> of the current working table
in a new child execution context amended with <sym>R</sym>:

<olist>

<comment>Editorial: Stephen Cannan, 2022-03-06 WG3:RKE-010 P00-USA-481</comment>
<comment>WG3:W24-014R2</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>Let <symdef>T</symdef> be a new record comprising fields 
<symdef>F</symdef><sub><sym>i</sym></sub>, 1 (one) <leq/> <symdef>i</symdef> <leq/> 
<sym>NGESEQ</sym>, such that the name of <sym>F</sym><sub><sym>i</sym></sub> is
the name of <sym>COLS</sym><sub><sym>i</sym></sub> and the value of 
<sym>F</sym><sub><sym>i</sym></sub> is the value of <sym>GEBV</sym><sub><sym>i</sym></sub> in 
<sym>R</sym>.
</item>

<comment>WG3:W24-014R2</comment>
<comment>WG3:UTC-081</comment>
<item>If <sym>T</sym> is distinct from every record in <sym>GROUP_BY</sym>, then
<sym>T</sym> is added to <sym>GROUP_BY</sym>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<comment>Editorial: Stefan Plantikow, 2022-03-25 WG3:RKE-010 P00-NLD-219 Wording</comment>
<comment>WG3:UTC-081</comment>
<item>The result of <sym>GBC</sym> is <sym>GROUP_BY</sym>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-081</comment>
<item>Without <feature code="GQ15"/>, conforming GQL language shall not contain
<BNF name="group by clause"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_order_by" newpage="true">
<clauseHeading><BNF name="order by clause"/></clauseHeading>

<bodyMatter>

<Function>

<comment>Editorial: Stefan Plantikow, 2020-05-15 Reworded</comment>
<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:UTC-096R1</comment>
<para>Apply a <BNF name="sort specification list"/> to the current working table.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:W15-020</comment>
<BNFdef name="order by clause">
<rhs>
<kw>ORDER</kw> <kw>BY</kw> <BNF name="sort specification list"/>
</rhs>
</BNFdef>
</grammar>

</Format>


<SyntaxRules>

<comment>WG3:W15-020</comment>
<olist>


<comment>WG3:UTC-096R1</comment>
<item>Let <symdef>OBC</symdef> be the <BNF name="order by clause"/>.
</item>

<comment>WG3:UTC-096R1</comment>
<item>Let <symdef>SSL</symdef> be the <BNF name="sort specification list"/> immediately contained 
in <sym>OBC</sym>.
</item>

<comment>WG3:UTC-096R1</comment>
<item>The declared type of <sym>OBC</sym> is the declared type of
the incoming working table of <sym>OBC</sym>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:UTC-096R1 Deleted 2 GRs</comment>

<comment>Editorial: Stefan Plantikow, 2022-03-25 WG3:RKE-010 P00-NLD-219 Wording</comment>
<comment>WG3:UTC-096R1</comment>
<item>The result of <sym>OBC</sym> is the result of <sym>SSL</sym>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_sort_spec_list" newpage="true">
<clauseHeading><BNF name="sort specification list"/></clauseHeading>

<bodyMatter>

<Function>

<comment>WG3:UTC-096R1</comment>
<para>Obtaining an ordered binding table from the current working table.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="sort specification list">
<rhs>
<BNF name="sort specification"/>
<opt> <group> <BNF name="comma"/> <BNF name="sort specification"/> </group><repeat/> </opt>
</rhs>
</BNFdef>

<comment>WG3:W15-020</comment>
<BNFdef name="sort specification">
<rhs>
<BNF name="sort key"/> 
<opt> <BNF name="ordering specification"/> </opt> <opt> <BNF name="null ordering"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:UTC-081</comment>
<BNFdef name="sort key">
<rhs>
<BNF name="aggregating value expression"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-050</comment>
<BNFdef name="ordering specification">
<rhs>
<alt> <kw>ASC</kw> </alt>
<alt> <kw>ASCENDING</kw> </alt>
<alt> <kw>DESC</kw> </alt>
<alt> <kw>DESCENDING</kw> </alt>
</rhs>
</BNFdef>

<comment>WG3:W15-020</comment>
<BNFdef name="null ordering">
<rhs>
<alt> <kw>NULLS</kw> <kw>FIRST</kw> </alt>
<alt> <kw>NULLS</kw> <kw>LAST</kw> </alt>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>Remark Karl Schendel regarding simply contains (see SXM001 item 13.2)</comment>
<item>Each <BNF name="value expression"/> immediately contained in the <BNF name="sort key"/>
contained in a <BNF name="sort specification"/> is an operand of an ordering operation.
The Syntax Rules and Conformance Rules of <specref ref="gql_ordering_ops"/>, apply.
</item>

<comment>WG3:W15-020</comment>
<item>Let <symdef>SSL</symdef> be the <BNF name="sort specification list"/>
</item>

<comment>WG3:W15-020</comment>
<item>Let <symdef>NSS</symdef> be the number of <BNF name="sort specification"/>s immediately 
contained in <sym>SSL</sym>.
</item>

<comment>WG3:W15-020</comment>
<comment>WG3:CMN-019 P00-NLD-050</comment>
<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NSS</sym>, 
let <symdef>SS</symdef><sub><sym>i</sym></sub> be the 
<sym>i</sym>-th <BNF name="sort specification"/> immediately contained in <sym>SSL</sym>.
</item>

<comment>WG3:W15-020</comment>
<item>For each <sym>SS</sym><sub><sym>i</sym></sub>, 1 (one) <leq/> <symdef>i</symdef> <leq/> 
<sym>NSS</sym>:

<olist>

<item>Let <symdef>SK</symdef><sub><sym>i</sym></sub> be the <BNF name="sort key"/> 
immediately contained in <sym>SS</sym><sub><sym>i</sym></sub>.
</item>

<item>If <sym>SS</sym><sub><sym>i</sym></sub> does not immediately contain 
an <BNF name="ordering specification"/>, then <sym>SS</sym><sub><sym>i</sym></sub> is 
effectively replaced by:

<code>
<sym>SK</sym><sub><sym>i</sym></sub> <kw>ASC</kw>
</code>

</item>

<comment>WG3:OHD-028</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>SK</sym><sub><sym>i</sym></sub> is 
the incoming working record type of <sym>SSL</sym> amended with the record type of
the incoming working table type of <sym>SSL</sym>.
</item>

<comment>WG3:OHD-028</comment>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>SK</sym><sub><sym>i</sym></sub> is 
the material unit binding table type.
</item>
<endbar/>

<comment>WG3:OHD-028</comment>
<comment>WG3:UTC-081 Consequence</comment>
<item>The declared type of <sym>SK</sym><sub><sym>i</sym></sub> is the declared type of the 
<BNF name="aggregating value expression"/> immediately contained in
<sym>SK</sym><sub><sym>i</sym></sub>.
</item>

</olist>

</item>

<comment>WG3:W15-020</comment>
<item>If <BNF name="null ordering"/> is not specified, then an <impDef code="IS001"/> 
<BNF name="null ordering"/> is implicit. 
The <impDef annex="no" code="None"/> default for <BNF name="null ordering"/> shall not depend on
the context outside of <BNF name="sort specification list"/>.
</item>

<comment>WG3:UTC-096R1</comment>
<item>The declared type of <sym>SSL</sym> is the declared type of
the incoming working table of <sym>SSL</sym>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:W23-009R1 P00-USA-391</comment>
<comment>WG3:UTC-096R1</comment>
<item>Let <symdef>SORTED</symdef> be a new ordered binding table created from the collection of
records of the current working table by ordering the records, as follows:

<olist>

<item>Let <symdef>N</symdef> be the number of <BNF name="sort specification"/>s.
</item>

<comment>WG3:CMN-019 P00-NLD-050</comment>
<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>, 
let <symdef>K</symdef><sub><sym>i</sym></sub> be the <BNF name="sort key"/> contained in the 
<sym>i</sym>-th <BNF name="sort specification"/>.
</item>

<comment>WG3:UTC-050</comment>
<item>Each <BNF name="sort specification"/> specifies the <newterm>sort direction</newterm>
for the corresponding sort key <sym>K</sym><sub><sym>i</sym></sub>.
If neither <kw>DESC</kw> nor <kw>DESCENDING</kw> is specified in the <sym>i</sym>-th 
<BNF name="sort specification"/>, then the sort direction for
<sym>K</sym><sub><sym>i</sym></sub> is ascending and the applicable <BNF name="comp op"/> is the
<BNF name="less than operator"/>;
otherwise, the sort direction for <sym>K</sym><sub><sym>i</sym></sub> is descending and the
applicable <BNF name="comp op"/> is the <BNF name="greater than operator"/>.
</item>

<comment>WG3:W23-009R1 P00-USA-391</comment>
<item>Let <symdef>P</symdef> be any record of the collection of records to be ordered,
and let <symdef>Q</symdef> be any other record of the same collection of records.
</item>

<comment>WG3:OHD-028</comment>
<item>Let <symdef>PV</symdef><sub><sym>i</sym></sub> be the result of 
<sym>K</sym><sub><sym>i</sym></sub> in a new child execution context amended with <sym>P</sym>.
</item>

<comment>WG3:OHD-028</comment>
<item>Let <symdef>QV</symdef><sub><sym>i</sym></sub> be the result of 
<sym>K</sym><sub><sym>i</sym></sub> in a new child execution context amended with <sym>Q</sym>.
</item>

<comment>WG3:OHD-028</comment>
<comment>WG3:W23-009R1 P00-USA-391</comment>
<item>The relative position of records <sym>P</sym> and <sym>Q</sym> in the result is
determined by comparing <sym>PV</sym><sub><sym>i</sym></sub> and 
<sym>QV</sym><sub><sym>i</sym></sub> as follows:

<olist>

<comment>WG3:UTC-050</comment>
<item>The comparison is performed according to the General Rules of <specref ref="gql_comp"/>, 
where the <BNF name="comp op"/> is the applicable <BNF name="comp op"/> for 
<sym>K</sym><sub><sym>i</sym></sub>.
</item>

<item>The comparison is performed with the following special treatment of null values.

<para>Case:
</para>

<olist>

<item>If <sym>PV</sym><sub><sym>i</sym></sub> and <sym>QV</sym><sub><sym>i</sym></sub> are both
the null value, then they are considered equal to each other.
</item>

<item>If <sym>PV</sym><sub><sym>i</sym></sub> is the null value and
<sym>QV</sym><sub><sym>i</sym></sub> is not the null value, then

<para>Case:
</para>

<olist>

<comment>WG3:W15-020</comment>
<item>If <kw>NULLS</kw> <kw>FIRST</kw> is specified or implied, then 
<sym>PV</sym><sub><sym>i</sym></sub> <BNF name="comp op"/> <sym>QV</sym><sub><sym>i</sym></sub> is 
considered to be <bool>True</bool>.
</item>

<comment>WG3:W15-020</comment>
<item>If <kw>NULLS</kw> <kw>LAST</kw> is specified or implied, then 
<sym>PV</sym><sub><sym>i</sym></sub> <BNF name="comp op"/> <sym>QV</sym><sub><sym>i</sym></sub> is 
considered to be <bool>False</bool>.
</item>

</olist>

</item>

<item>If <sym>PV</sym><sub><sym>i</sym></sub> is not the null value and
<sym>QV</sym><sub><sym>i</sym></sub> is the null value, then

<para>Case:
</para>

<olist>

<comment>WG3:W15-020</comment>
<item>If <kw>NULLS</kw> <kw>FIRST</kw> is specified or implied, then 
<sym>PV</sym><sub><sym>i</sym></sub> <BNF name="comp op"/> <sym>QV</sym><sub><sym>i</sym></sub> is
considered to be <bool>False</bool>.
</item>

<comment>WG3:W15-020</comment>
<item>If <kw>NULLS</kw> <kw>LAST</kw> is specified or implied, then 
<sym>PV</sym><sub><sym>i</sym></sub> <BNF name="comp op"/> <sym>QV</sym><sub><sym>i</sym></sub> is 
considered to be <bool>True</bool>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<item><sym>PV</sym><sub><sym>i</sym></sub> is said to <newterm>precede</newterm>
<sym>QV</sym><sub><sym>i</sym></sub> if the result of the <BNF name="comparison predicate"/>

<quote><mono><sym>PV</sym><sub><sym>i</sym></sub> <BNF name="comp op"/>
<sym>QV</sym><sub><sym>i</sym></sub></mono></quote> is
<bool>True</bool> for the applicable <BNF name="comp op"/>.
</item>

<item>If <sym>PV</sym><sub><sym>i</sym></sub> and <sym>QV</sym><sub><sym>i</sym></sub> are not the
null value and the result of <quote><sym>PV</sym><sub><sym>i</sym></sub> <BNF name="comp op"/>
<sym>QV</sym><sub><sym>i</sym></sub></quote> is <bool>Unknown</bool>, then the relative ordering of
<sym>PV</sym><sub><sym>i</sym></sub> and <sym>QV</sym><sub><sym>i</sym></sub> is
<unDef code="US007"/>.
</item>

<comment>WG3:CMN-019 P00-NLD-050</comment>
<item>The relative position of record <sym>P</sym> is before record <sym>Q</sym>
if for some <symdef>n</symdef>, 1 (one) <leq/> <sym>n</sym> <leq/> <sym>N</sym>,
<sym>PV</sym><sub><sym>n</sym></sub> precedes <sym>QV</sym><sub><sym>n</sym></sub> and
<sym>PV</sym><sub><sym>i</sym></sub> is not distinct from <sym>QV</sym><sub><sym>i</sym></sub> for
all <symdef>i</symdef> &lt; <sym>n</sym>.
</item>

<comment>WG3:W23-009R1 P00-USA-391</comment>
<item>Two records that are not distinct with respect to the <BNF name="sort specification"/>s are
said to be <newterm>peers</newterm> of each other.
The relative ordering of peers is <unDef code="US006"/>.
</item>

<comment>WG3:UTC-096R1</comment>
<item>The result of <sym>SSL</sym> is <sym>SORTED</sym>.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W22-052R1</comment>
<item>Without <feature code="GA03"/>, conforming GQL language shall not contain 
a <BNF name="null ordering"/>.
</item>

<comment>WG3:UTC-022</comment>
<comment>WG3:CMN-019 P00-USA-077</comment>
<comment>WG3:POS-022</comment>
<item>Without <feature code="GQ14"/>, in conforming GQL language, the <BNF name="value expression"/>
immediately contained in a <BNF name="sort key"/> shall be
a <BNF name="binding variable reference"/>.
</item>

<comment>WG3:UTC-022</comment>
<comment>WG3:CMN-019 P00-USA-077</comment>
<comment>WG3:POS-022</comment>
<item>Without <feature code="GQ16"/>, in conforming GQL language, the <BNF name="value expression"/>
immediately contained in a <BNF name="sort key"/> shall not simply contain
any <BNF name="binding variable reference"/> that is not a <BNF name="return item alias"/> in
the preceding <BNF name="return statement"/>.
</item>

<comment>WG3:UTC-022</comment>
<comment>WG3:CMN-019 P00-USA-077</comment>
<comment>WG3:POS-022</comment>
<item>Without <feature code="GF20"/>, in conforming GQL language, the <BNF name="value expression"/>
immediately contained in a <BNF name="sort key"/> shall not simply contain
an <BNF name="aggregate function"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_limit" newpage="true">
<clauseHeading><BNF name="limit clause"/></clauseHeading>

<bodyMatter>

<Function>

<comment>Editorial: Stefan Plantikow, 2020-05-15 Reworded</comment>
<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:UTC-096R1</comment>
<para>Obtain a new binding table that retains only a limited number of records of
the current working table.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:W15-020</comment>
<comment>WG3:CMN-061R1</comment>
<bar note="WG3:XRH-021R1"/>
<comment>WG3:XRH-021R1</comment>
<BNFdef name="limit clause">
<rhs>
<kw>LIMIT</kw> 
<opt><BNF name="limit approximation"/></opt>
<BNF name="non-negative integer specification"/>
</rhs>
</BNFdef>

<comment>WG3:XRH-021R1</comment>
<BNFdef name="limit approximation">
<rhs>
<alt><BNF name="approximation synonym"/></alt>
<alt><kw>EXACT</kw></alt>
</rhs>
</BNFdef>

<comment>WG3:XRH-021R1</comment>
<BNFdef name="approximation synonym">
<rhs>
<alt><kw>APPROX</kw></alt>
<alt><kw>APPROXIMATE</kw></alt>
</rhs>
</BNFdef>
<endbar/>

</grammar>

</Format>

<ednote id="gql_PP161">WITH TIES, ONLY, RECORDS, and GROUPS to be added.
See <PPref ref="PPgql161"/>
</ednote>


<SyntaxRules>

<comment>WG3:W15-020</comment>
<olist>

<comment>WG3:UTC-096R1</comment>
<item>Let <symdef>LC</symdef> be the <BNF name="limit clause"/>.
</item>

<comment>WG3:UTC-096R1</comment>
<item>The declared type of <sym>LC</sym> is the declared type of
the incoming working table of <sym>LC</sym>.
</item>

<bar note="WG3:XRH-021R1"/>
<comment>WG3:XRH-021R1</comment>
<item>Case:

<comment>WG3:XRH-021R1</comment>
<olist>

<comment>WG3:XRH-021R1</comment>
<item>If a <BNF name="limit approximation"/> is not specified, and
a <BNF name="linear query statement"/>, which directly contains <symdef>LC</symdef>,
directly contains a <BNF name="value expression"/> whose declared type is a vector type, then
it is <impDef code="ID100"/> whether <kw>EXACT</kw> or
an <BNF name="approximation synonym"/> is implicit.
</item>

<comment>WG3:XRH-021R1</comment>
<item>Otherwise, <kw>EXACT</kw> is implicit.
</item>

</olist>

</item>
<endbar/>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>Editorial: Stefan Plantikow, 2020-05-15 Reworded to not modify the context</comment>
<item>Let <symdef>TABLE</symdef> be the current working table.
</item>

<comment>WG3:JCJ-010R1</comment>
<item>If <sym>TABLE</sym> is not ordered, then let <symdef>ORDERED_TABLE</symdef> be a new ordered
binding table created from the result of sorting the collection of all records of <sym>TABLE</sym>
according to an <unDef code="US001"/> order;
otherwise, let <symdef>ORDERED_TABLE</symdef> be <sym>TABLE</sym>.
</item>

<comment>WG3:W23-035</comment>
<comment>WG3:CMN-061R1</comment>
<bar note="WG3:XRH-021R1"/>
<comment>WG3:XRH-021R1</comment>
<item>Let <symdef>VLIM</symdef> be the result of
the <BNF name="non-negative integer specification"/>.
</item>

<comment>WG3:XRH-021R1</comment>
<item>Let <symdef>V</symdef> be defined as follows.

<comment>WG3:XRH-021R1</comment>
<para>Case:
</para>

<olist>

<comment>WG3:XRH-021R1</comment>
<item>If <kw>EXACT</kw> is specified or implied, then <sym>V</sym> is <sym>VLIM</sym>.
</item>

<comment>WG3:XRH-021R1</comment>
<item>Otherwise, <BNF name="approximation synonym"/> is specified and <sym>V</sym> is
an <unDef code="UV015"/> exact numeric value with scale 0 (zero) less than or equal to
<sym>VLIM</sym>.
</item>

</olist>

<comment>Editorial: XRH-021R1 Consequence. Stefan Pantikow, 2025-06-16</comment>
<note>It follows that <sym>V</sym> necessarily is an element of
the <impDef code="ID062"/> exact numeric type with scale 0 (zero) of 
non-negative integer specifications.
</note>

</item>

<comment>Editorial: Stephen Cannan, 2020-03-30</comment>
<comment>WG3:XRH-021R1</comment>
<item>Let <symdef>LIMIT</symdef> be an ordered binding table determined as follows.

<comment>WG3:XRH-021R1</comment>
<para>Case:
</para>

<olist>

<comment>WG3:XRH-021R1</comment>
<item>If <kw>EXACT</kw> is specified or implied, <sym>LIMIT</sym> is a new ordered binding table
obtained by selecting only the first <sym>V</sym> records of <sym>ORDERED_TABLE</sym> and 
discarding all subsequent records.
</item>

<comment>WG3:XRH-021R1</comment>
<item>Otherwise, <BNF name="approximation synonym"/> is specified and <sym>LIMIT</sym> is
a new ordered binding table obtained by selecting <sym>V</sym> records from <sym>ORDERED_TABLE</sym>
in an <unDef code="UW002"/> manner while retaining the order given by <sym>ORDERED_TABLE</sym>.

<comment>WG3:XRH-021R1</comment>
<note>In this case, these are not necessarily the first <sym>V</sym> records.
</note>
</item>

</olist>

<comment>WG3:UTC-096R1</comment>
<note>If the order of the result of <sym>LC</sym> has no effect on the outcome of
a <BNF name="GQL-program"/>, there is no need for <sym>LIMIT</sym> to be indicated as ordered.
</note>

</item>
<endbar/>

<comment>Editorial: Stefan Plantikow, 2022-03-25 WG3:RKE-010 P00-NLD-219 Wording</comment>
<item>The result of <sym>LC</sym> is <sym>LIMIT</sym>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<bar note="WG3:XRH-021R1"/>
<comment>WG3:XRH-021R1</comment>
<olist>

<comment>WG3:XRH-021R1</comment>
<item>Without <feature code="GQ28"/>, conforming GQL language shall not contain
a <BNF name="limit approximation"/>.
</item>

</olist>
<endbar/>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:JCJ-010R1</comment>
<subClause id="gql_offset" newpage="true">
<clauseHeading><BNF name="offset clause"/></clauseHeading>

<bodyMatter>

<Function>

<comment>Editorial: Stefan Plantikow, 2020-05-15 Reworded</comment>
<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:UTC-096R1</comment>
<para>Obtaining a new binding table that retains all records of the current working table except
for some discarded initial records.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:JCJ-010R1</comment>
<comment>WG3:W15-020</comment>
<comment>WG3:CMN-061R1</comment>
<BNFdef name="offset clause">
<rhs>
<BNF name="offset synonym"/> <BNF name="non-negative integer specification"/>
</rhs>
</BNFdef>

<comment>WG3:W15-020</comment>
<BNFdef name="offset synonym">
<rhs>
<alt br="no"> <kw>OFFSET</kw> </alt> 
<alt br="no"> <kw>SKIP</kw> </alt>
</rhs>
</BNFdef>

</grammar>

</Format>

<ednote id="gql_PP162">WITH TIES, ONLY, RECORDS, and GROUPS to be added.
See <PPref ref="PPgql162"/>.
</ednote>

<SyntaxRules>

<comment>WG3:W15-020</comment>
<olist>

<comment>WG3:UTC-096R1</comment>
<item>Let <symdef>OC</symdef> be the <BNF name="offset clause"/>.
</item>

<comment>WG3:UTC-096R1</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The declared type of <sym>OC</sym> is the incoming working table type of <sym>OC</sym>.
</item>
<endbar/>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>Editorial: Stefan Plantikow, 2020-05-15 Reworded to not modify the context</comment>
<item>Let <symdef>TABLE</symdef> be the current working table.
</item>

<comment>WG3:JCJ-010R1</comment>
<item>If <sym>TABLE</sym> is not ordered, then let <symdef>ORDERED_TABLE</symdef> be a new ordered
binding table created from the result of sorting the collection of all records of <sym>TABLE</sym>
according to an <unDef code="US001"/> order;
otherwise, let <symdef>ORDERED_TABLE</symdef> be <sym>TABLE</sym>.

<comment>WG3:UTC-096R1</comment>
<note>If the order of the result of <sym>OC</sym> has no effect on the outcome of
a <BNF name="GQL-program"/>, there is no need for <sym>OFFSET</sym> to be indicated as ordered.
</note>
</item>

<comment>WG3:W23-035</comment>
<comment>WG3:CMN-061R1</comment>
<item>Let <symdef>V</symdef> be the result of the <BNF name="non-negative integer specification"/>.
</item>

<comment>Editorial: Stephen Cannan, 2020-03-30</comment>
<item>Let <symdef>OFFSET</symdef> be a new ordered binding table obtained from all but the first
<sym>V</sym> records of <sym>ORDERED_TABLE</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2022-03-25 WG3:RKE-010 P00-NLD-219 Wording</comment>
<comment>WG3:UTC-096R1</comment>
<item>The result of <sym>OC</sym> is <sym>OFFSET</sym>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>

</clause>


<comment>Editorial: Stefan Plantikow, 2020-09-19 Adjusted for WG3:MMX-055</comment>
<comment>Editorial: Stefan Plantikow, 2020-02-06</comment>
<comment>WG3:W22-053R2</comment>
<clause id="gql_obj_refs">
<clauseHeading>Object references</clauseHeading>

<subClause id="gql_schema_refs">
<clauseHeading><BNF name="schema reference"/>
and <BNF name="catalog schema parent and name"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-07-26 WG3:MMX-055</comment>
<bodyMatter>


<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:W22-051</comment>
<para>Identify a GQL-schema in the GQL-catalog.
</para>

</Function>


<Format>

<comment>WG3:W13-024: Stefan Plantikow, 2021-07-21 Remove previous format</comment>
<grammar>

<comment>WG3:W13-024: Stefan Plantikow, 2021-07-21</comment>
<comment>WG3:W22-051</comment>
<comment>WG3:CMN-061R1</comment>
<BNFdef name="schema reference">
<rhs>
<alt> <BNF name="absolute catalog schema reference"/> </alt>
<alt> <BNF name="relative catalog schema reference"/> </alt>
<alt> <BNF name="reference parameter specification"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W22-051</comment>
<comment>WG3:OHD-032R1</comment>
<BNFdef name="absolute catalog schema reference">
<rhs>
<alt br="no"> <BNF name="solidus"/> </alt>
<alt br="no"> <BNF name="absolute directory path"/> <BNF name="schema name"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W22-051</comment>
<BNFdef name="catalog schema parent and name">
<rhs>
<BNF name="absolute directory path"/> <BNF name="schema name"/>
</rhs>
</BNFdef>

<comment>WG3:W22-051</comment>
<BNFdef name="relative catalog schema reference">
<rhs>
<alt> <BNF name="predefined schema reference"/> </alt>
<alt> <BNF name="relative directory path"/> <BNF name="schema name"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W22-051</comment>
<BNFdef name="predefined schema reference">
<rhs>
<alt br="no"> <kw>HOME_SCHEMA</kw> </alt>
<alt br="no"> <kw>CURRENT_SCHEMA</kw> </alt>
<alt br="no"> <BNF name="period"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W22-051</comment>
<BNFdef name="absolute directory path">
<rhs>
<BNF name="solidus"/> <opt> <BNF name="simple directory path"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:W22-051</comment>
<comment>Email from: Hannes Voigt, 2022-08-22 1723 W22</comment>
<comment>WG3:W23-009R1 P00-USA-397</comment>
<comment>Editorial: Stefan Plantikow, 2024-06-18 Correct application of WG3:W22-051</comment>
<BNFdef name="relative directory path">
<rhs>
<BNF name="double period"/>
<breakindent/>
<opt> <group> <BNF name="solidus"/> <BNF name="double period"/> </group><repeat/> </opt>
<BNF name="solidus"/>
<opt> <BNF name="simple directory path"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:W22-051</comment>
<BNFdef name="simple directory path">
<rhs>
<group> <BNF name="directory name"/> <BNF name="solidus"/> </group><repeat/> 
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>
<comment>WG3:W13-024: Stefan Plantikow, 2021-07-21 One SR removed</comment>
<comment>WG3:W22-051 deleted (all) two rules</comment>

<comment>WG3:W22-051</comment>
<item>If the <BNF name="schema reference"/> <symdef>SR</symdef> is specified, then the GQL-schema
identified by <sym>SR</sym> is the GQL-schema identified by the immediately contained
<BNF name="absolute catalog schema reference"/> or <BNF name="relative catalog schema reference"/>.
</item>

<comment>WG3:W22-051</comment>
<comment>WG3:OHD-032R1</comment>
<item>If the <BNF name="absolute catalog schema reference"/> <symdef>ACSR</symdef> is specified,
then

<para>Case:
</para>

<olist>

<item>If <sym>ACSR</sym> is a <BNF name="solidus"/>, then:

<olist>

<comment>WG3:CMN-019 P00-USA-125</comment>
<item>The GQL-catalog root shall be a GQL-schema.
</item>

<comment>WG3:CMN-019 P00-USA-125</comment>
<item>The GQL-schema identified by <sym>ACSR</sym> is the GQL-catalog root.
</item>

</olist>

</item>

<comment>WG3:OHD-032R1</comment>
<item>Otherwise:

<olist>

<item>Let <symdef>PARENT</symdef> be the GQL-directory identified by the immediately
contained <BNF name="absolute directory path"/>.
</item>

<item>Let <symdef>SN</symdef> be the immediately contained <BNF name="schema name"/>.
</item>

<item><sym>PARENT</sym> shall contain a GQL-schema <symdef>S</symdef> with name <symdef>SN</symdef>.
</item>

<comment>WG3:W23-014</comment>
<item>For every GQL-directory or GQL-schema <symdef>DOS</symdef> contained in <sym>PARENT</sym>,
if the name by which <sym>DOS</sym> is identified in <sym>PARENT</sym> and <sym>SN</sym> are 
visually confusable with each other, then the following exception condition is raised:
<raise class="42" subclass="004"/>.
</item>

<item>The GQL-schema identified by <sym>ACSR</sym> is <sym>S</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W22-051</comment>
<item>If the <BNF name="relative catalog schema reference"/> <symdef>RCSR</symdef> is specified,
then the GQL-schema identified by <sym>RCSR</sym> is defined as follows. 

<para>Case:
</para>

<olist>

<item>If <sym>RCSR</sym> is the <BNF name="predefined schema reference"/> <symdef>PSR</symdef>, then
the GQL-schema identified by <sym>RCSR</sym> is the GQL-schema identified by <sym>PSR</sym>.

</item>

<item>If <sym>RCSR</sym> immediately contains
the <BNF name="relative directory path"/> <symdef>RDP</symdef> and
the <BNF name="schema name"/> <symdef>SN</symdef>, then:

<olist>

<item>Let <symdef>PARENT</symdef> be the GQL-directory identified by <sym>RDP</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2022-08-18 Correct to use GQL-schema</comment>
<item><sym>SN</sym> shall identify an existing GQL-schema descriptor in <sym>PARENT</sym>.
</item>

<item>The schema identified by <sym>RCSR</sym> is the GQL-schema identified by <sym>SN</sym> in
<sym>PARENT</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W22-051</comment>
<item>If the <BNF name="predefined schema reference"/> <symdef>PSR</symdef> is specified, then
the GQL-schema identified by <sym>PSR</sym> is defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:UTC-045R1</comment>
<item>If <sym>PSR</sym> is <kw>HOME_SCHEMA</kw>, then:

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-13 Use of omitted</comment>
<item>The current home schema shall not be <quote>omitted</quote>.
</item>

<item><sym>PSR</sym> identifies the current home schema.
</item>

</olist>

</item>

<comment>WG3:CMN-042</comment>
<item>If <sym>PSR</sym> is <kw>CURRENT_SCHEMA</kw> or <BNF name="period"/>, then:

<comment>WG3:CMN-042</comment>
<olist>

<comment>WG3:CMN-042</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use of omitted</comment>
<item>The current working schema of <sym>PSR</sym> shall not be <quote>omitted</quote>.
</item>

<comment>WG3:CMN-042</comment>
<item><sym>PSR</sym> identifies the current working schema of <sym>PSR</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W22-051</comment>
<item>If the <BNF name="absolute directory path"/> <symdef>ADP</symdef> is specified, then:

<olist>

<comment>WG3:CMN-019 P00-USA-125</comment>
<item>The GQL-catalog root shall be a GQL-directory.
</item>

<item>The GQL-directory identified by <sym>ADP</sym> is defined as follows. 

<para>Case:
</para>

<olist>

<comment>WG3:CMN-019 P00-USA-125</comment>
<item>If <sym>ADP</sym> does not immediately contain the <BNF name="simple directory path"/>,
then the GQL-directory identified by <sym>ADP</sym> is the GQL-catalog root.
</item>

<comment>WG3:W23-014</comment>
<item>Otherwise:

<olist>

<item>Let <symdef>SDP</symdef> be the <BNF name="simple directory path"/> immediately contained 
in <sym>ADP</sym>. 
The <applySC ref="gql_res_simple_directory_path" rules="SR">
<symarg param="SIMPLE DIRECTORY PATH"><sym>SDP</sym></symarg>
<symarg param="START DIRECTORY">the GQL-catalog root</symarg>
<symresult param="RESOLVED DIRECTORY"><symdef>RD</symdef></symresult>
</applySC>.
</item>

<item>The GQL-directory identified by <sym>ADP</sym> is <sym>RD</sym>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W22-051</comment>
<item>If the <BNF name="relative directory path"/> <symdef>RDP</symdef> is specified, then:

<olist>

<comment>WG3:CMN-019 P00-USA-207</comment>
<item>Let <symdef>N</symdef> be the number of all <BNF name="double period"/>s that are immediately
contained in <sym>RDP</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-11-13 Use of omitted</comment>
<item>The current working schema of <sym>RDP</sym> shall not be <quote>omitted</quote>.
</item>

<comment>WG3:CMN-019 P00-USA-207</comment>
<comment>WG3:CMN-042</comment>
<item>Let <symdef>PD</symdef><sub><sym>N</sym>+1</sub> be
the current working schema of <sym>RDP</sym>.
</item>

<comment>WG3:CMN-019 P00-NLD-050</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>For <symdef>j</symdef>, <sym>N</sym> <geq/> <sym>j</sym> <geq/> 1 (one),
the GQL-directory <sym>PD</sym><sub><sym>j</sym></sub> is defined as follows:

<olist>

<comment>WG3:CMN-019 P00-USA-125</comment>
<item>GQL-directory <sym>PD</sym><sub><sym>j</sym>+1</sub> shall not be the GQL-catalog root. 
</item>

<comment>Editorial: Stefan Plantikow, 2022-12-19 WG3:W24-009 831. P00-USA-396</comment>
<item><sym>PD</sym><sub><sym>j</sym></sub> is the parent directory of the GQL-directory or
GQL-schema <sym>PD</sym><sub><sym>j</sym>+1</sub>.
</item>

</olist>

</item>

<item>The GQL-directory identified by <sym>RDP</sym> is defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>RDP</sym> does not immediately contain the <BNF name="simple directory path"/>, then
the GQL-directory identified by <sym>RDP</sym> is the GQL-directory <sym>PD</sym><sub>1</sub>. 
</item>

<comment>WG3:W23-014</comment>
<item>Otherwise:

<olist>

<item>Let <symdef>SDP</symdef> be the <BNF name="simple directory path"/> immediately contained 
in <sym>RDP</sym>. 
The <applySC ref="gql_res_simple_directory_path" rules="SR">
<symarg param="SIMPLE DIRECTORY PATH"><sym>RDP</sym></symarg>
<symarg param="START DIRECTORY"><sym>PD</sym><sub>1</sub></symarg>
<symresult param="RESOLVED DIRECTORY"><symdef>RD</symdef></symresult>
</applySC>.
</item>

<item>The GQL-directory identified by <sym>RDP</sym> is <sym>RD</sym>.
</item>

</olist>

</item>

</olist>


</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:W13-024: Stefan Plantikow, 2021-07-21</comment>
<None/>

</olist>

</GeneralRules>

<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_g_refs" newpage="true">
<clauseHeading><BNF name="graph reference"/> and
<BNF name="catalog graph parent and name"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-07-26 WG3:MMX-055</comment>
<bodyMatter>


<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:W22-051</comment>
<para>Identify a graph in the GQL-catalog.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:W22-051</comment>
<comment>WG3:UTC-039R1</comment>
<comment>WG3:CMN-061R1</comment>
<BNFdef name="graph reference">
<rhs>
<alt> <BNF name="catalog object parent reference"/> <BNF name="graph name"/> </alt>
<alt> <BNF name="delimited graph name"/> </alt>
<alt> <BNF name="home graph"/> </alt>
<alt> <BNF name="reference parameter specification"/> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-10-09 Add URL path parameter without trailing solidus
</comment>
<comment>WG3:W22-051</comment>
<BNFdef name="catalog graph parent and name">
<rhs>
<opt> <BNF name="catalog object parent reference"/> </opt> <BNF name="graph name"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-039R1 Deleted 1 (one) production</comment>

<comment>WG3:W22-051</comment>
<BNFdef name="home graph">
<rhs>
<alt br="no"> <kw>HOME_PROPERTY_GRAPH</kw> </alt>
<alt br="no"> <kw>HOME_GRAPH</kw> </alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-039R1 Deleted 1 (one) production</comment>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:OHD-032R1</comment>
<comment>WG3:UTC-039R1</comment>
<item>If <BNF name="graph reference"/> <symdef>GR</symdef> is specified, then

<para>Case:
</para>

<olist>

<comment>WG3:UTC-039R1</comment>
<comment>WG3:UTC-045R1</comment>
<item>If <sym>GR</sym> is a <BNF name="home graph"/>, then:

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-13 Use of omitted</comment>
<item>The current home graph shall not be <quote>omitted</quote>.
</item>

<comment>WG3:CMN-019 P00-NLD-027</comment>
<item><sym>GR</sym> identifies the current home graph.
</item>

</olist>

</item>
<comment>WG3:UTC-039R1 Deleted 1 (one) SR</comment>

<comment>WG3:UTC-039R1</comment>
<item>If <sym>GR</sym> is a <BNF name="delimited graph name"/> <symdef>DGN</symdef>, then
the graph identified by <sym>GR</sym> is the graph identified by
the <BNF name="catalog graph parent and name"/>:
<code>
./<sym>DGN</sym>
</code>
</item>

<comment>WG3:UTC-039R1</comment>
<item>Otherwise, <sym>GR</sym> simply contains a <BNF name="catalog object parent reference"/>
<symdef>COPR</symdef> and a <BNF name="graph name"/> <symdef>GN</symdef> and
the graph identified by <sym>GR</sym> is the graph identified by
the <BNF name="catalog graph parent and name"/>:
<code>
<sym>COPR</sym> <sym>GN</sym>
</code>
</item>

</olist>

</item>

<comment>WG3:OHD-032R1</comment>
<item>If <BNF name="catalog graph parent and name"/> <symdef>CGPN</symdef> is specified, then:

<olist>

<item>If <sym>CGPN</sym> does not immediately contain 
a <BNF name="catalog object parent reference"/>, then the following 
<BNF name="catalog object parent reference"/> is implicit:
<code>
./
</code>

</item>

<item>Let <symdef>PARENT</symdef> be the GQL-schema or the catalog object identified
by the explicit or implicit <BNF name="catalog object parent reference"/> immediately contained 
in <sym>CGPN</sym>.
</item>

<item>Let <symdef>GN</symdef> be the <BNF name="graph name"/> immediately contained in 
<sym>CGPN</sym>.
</item>

<item>Case:

<olist>

<comment>WG3:W23-014</comment>
<item>If <sym>PARENT</sym> contains an object <symdef>O</symdef> with name <sym>GN</sym>, then:

<olist>

<item><sym>O</sym> shall be a graph.
</item>

<item>For every primary object <symdef>PO</symdef> contained in <sym>PARENT</sym>, if the name by
which <sym>PO</sym> is identified in <sym>PARENT</sym> and <sym>GN</sym> are visually confusable 
with each other, then the following exception condition is raised:
<raise class="42" subclass="004"/>.
</item>

<item>The graph identified by <sym>CGPN</sym> is <sym>O</sym>.
</item>

</olist>

</item>

<item>Otherwise, <sym>CGPN</sym> does not identify any object.
</item>

</olist>

</item>

</olist>

</item>
<comment>WG3:UTC-039R1 Deleted 1 (one) SR</comment>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->

<GeneralRules>

<olist>

<comment>WG3:W22-051 deleted all general rules</comment>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_gt_refs" newpage="true">
<clauseHeading><BNF name="graph type reference"/> and
<BNF name="catalog graph type parent and name"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-07-26 WG3:MMX-055</comment>
<bodyMatter>


<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:W22-051</comment>
<para>Identify a graph type in the GQL-catalog.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:W22-051</comment>
<comment>WG3:CMN-061R1</comment>
<BNFdef name="graph type reference">
<rhs>
<alt> <BNF name="catalog graph type parent and name"/> </alt>
<alt> <BNF name="reference parameter specification"/> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-10-09 Add URL path parameter without trailing solidus
</comment>
<comment>WG3:W22-051</comment>
<BNFdef name="catalog graph type parent and name">
<rhs>
<opt> <BNF name="catalog object parent reference"/> </opt> <BNF name="graph type name"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>
<comment>WG3:W22-051 deleted one rule</comment>

<comment>WG3:OHD-032R1</comment>
<item>If <BNF name="graph type reference"/> <symdef>GTR</symdef> is specified, then 
the immediately contained <BNF name="catalog graph type parent and name"/> <symdef>CGTPN</symdef> 
shall identify a graph type <symdef>GT</symdef>. 
The graph type identified by <sym>GTR</sym> is <sym>GT</sym>.
</item>

<comment>WG3:OHD-032R1</comment>
<item>If the <BNF name="catalog graph type parent and name"/> <symdef>CGTPN</symdef> is specified, 
then:

<olist>

<item>If <sym>CGTPN</sym> does not immediately contain 
a <BNF name="catalog object parent reference"/>, then the following 
<BNF name="catalog object parent reference"/> is implicit:
<code>
./
</code> 
</item>

<item>Let <symdef>PARENT</symdef> be the GQL-schema or the catalog object identified
by the explicit or implicit <BNF name="catalog object parent reference"/> immediately contained 
in <sym>CGTPN</sym>.
</item>

<item>Let <symdef>GTN</symdef> be the <BNF name="graph type name"/> immediately contained in
<sym>CGTPN</sym>.
</item>

<item>Case:

<olist>

<comment>WG3:W23-014</comment>
<item>If <sym>PARENT</sym> contains an object <symdef>O</symdef> with name <sym>GTN</sym>, then:

<olist>

<item><sym>O</sym> shall be a graph type.
</item>

<item>For every primary object <symdef>PO</symdef> contained in <sym>PARENT</sym>, if the name by
which <sym>PO</sym> is identified in <sym>PARENT</sym> and <sym>GTN</sym> are visually confusable 
with each other, then the following exception condition is raised:
<raise class="42" subclass="004"/>.
</item>

<item>The graph type identified by <sym>CGTPN</sym> is <sym>O</sym>.
</item>

</olist>

</item>


<item>Otherwise, <sym>CGTPN</sym> does not identify any object.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:W22-051 deleted all general rules</comment>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_bt_refs" newpage="true">
<clauseHeading><BNF name="binding table reference"/> and
<BNF name="catalog binding table parent and name"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-07-26 WG3:MMX-055</comment>
<bodyMatter>


<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:W22-051</comment>
<para>Identify a binding table in the GQL-catalog.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:W22-051</comment>
<comment>WG3:UTC-039R1</comment>
<comment>WG3:CMN-061R1</comment>
<BNFdef name="binding table reference">
<rhs>
<alt> <BNF name="catalog object parent reference"/> <BNF name="binding table name"/> </alt>
<alt> <BNF name="delimited binding table name"/> </alt>
<alt> <BNF name="reference parameter specification"/> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-10-09 Add URL path parameter without trailing solidus
</comment>
<BNFdef name="catalog binding table parent and name">
<rhs>
<opt> <BNF name="catalog object parent reference"/> </opt> <BNF name="binding table name"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>
<comment>WG3:W22-051 deleted one rule</comment>

<comment>WG3:UTC-039R1 Deleted 1 (one) SR</comment>

<comment>WG3:W22-051</comment>
<comment>WG3:UTC-039R1</comment>
<item>If the <BNF name="binding table reference"/> <symdef>BTR</symdef> is specified, then

<para>Case:
</para>

<olist>

<comment>WG3:UTC-039R1</comment>
<item>If <sym>BTR</sym> is a <BNF name="delimited binding table name"/> <symdef>DBTN</symdef>, then
the binding table identified by <sym>BTR</sym> is the binding table identified by
the <BNF name="catalog binding table parent and name"/>:
<code>
./<sym>DBTN</sym>
</code>
</item>

<comment>WG3:UTC-039R1</comment>
<item>Otherwise, <sym>BTR</sym> simply contains
a <BNF name="catalog object parent reference"/> <symdef>COPR</symdef> and
a <BNF name="binding table name"/> <symdef>BTN</symdef> and
the binding table identified by <sym>BTR</sym> is the binding table identified by
the <BNF name="catalog binding table parent and name"/>: 
<code>
<sym>COPR</sym> <sym>BTN</sym>
</code>
</item>

</olist>

</item>

<comment>WG3:W22-051</comment>
<item>If the <BNF name="catalog binding table parent and name"/> <symdef>CBTPN</symdef>
is specified, then:

<olist>

<item>If the <BNF name="catalog binding table parent and name"/> does not immediately contain
a <BNF name="catalog object parent reference"/>, then
the following <BNF name="catalog object parent reference"/> is implicit:
<code>
./
</code>
</item>

<item>Let <symdef>PARENT</symdef> be the GQL-schema or the catalog object identified by the
<BNF name="catalog object parent reference"/> immediately contained in <sym>CBTPN</sym>.
</item>

<comment>WG3:UTC-039R1 Deleted 1 (one) GR</comment>

<comment>WG3:UTC-039R1</comment>
<item>Let <symdef>BTN</symdef> be the <BNF name="binding table name"/> immediately contained
in <sym>CBTPN</sym>.
</item>

<comment>WG3:UTC-039R1</comment>
<item>Case:

<olist>

<comment>WG3:UTC-039R1</comment>
<item>If <sym>PARENT</sym> contains an object <symdef>O</symdef> with name <sym>BTN</sym>, then:

<olist>

<item><sym>O</sym> shall be a binding table.
</item>

<item>For every primary object <symdef>PO</symdef> contained in <sym>PARENT</sym>, if the name
by which <sym>PO</sym> is identified in <sym>PARENT</sym> and <sym>BTN</sym> are visually confusable
with each other, then the following exception condition is raised: 
<raise class="42" subclass="004"/>.
</item>

<item>The binding table identified by <sym>CBTPN</sym> is <sym>O</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-039R1</comment>
<item>Otherwise, <sym>CBTPN</sym> does not identify any object.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:W22-051 deleted all general rules</comment>

<None/>

</olist>

</GeneralRules>

<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_proc_refs" newpage="true">
<clauseHeading><BNF name="procedure reference"/> and
<BNF name="catalog procedure parent and name"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-07-26 WG3:MMX-055</comment>
<bodyMatter>


<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:W22-051</comment>
<para>Identify a procedure in the GQL-catalog.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:W22-051</comment>
<comment>WG3:CMN-061R1</comment>
<BNFdef name="procedure reference">
<rhs>
<alt> <BNF name="catalog procedure parent and name"/> </alt>
<alt> <BNF name="reference parameter specification"/> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-10-09 Add URL path parameter without trailing solidus
</comment>
<comment>WG3:W22-051</comment>
<BNFdef name="catalog procedure parent and name">
<rhs>
<opt> <BNF name="catalog object parent reference"/> </opt> <BNF name="procedure name"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>
<comment>WG3:W22-051 deleted one rule</comment>

<comment>WG3:W22-051</comment>
<item>If the <BNF name="catalog procedure parent and name"/> does not immediately contain
a <BNF name="catalog object parent reference"/>, then
the following <BNF name="catalog object parent reference"/> is implicit:
<code>
./
</code>
</item>

<comment>WG3:W22-051</comment>
<item>If the <BNF name="procedure reference"/> <symdef>PR</symdef> is specified, then
the procedure identified by <sym>PR</sym> is the procedure identified by the immediately contained
<BNF name="catalog procedure parent and name"/>.
</item>

<comment>WG3:W22-051</comment>
<item>If the <BNF name="catalog procedure parent and name"/> <symdef>CPPN</symdef> is specified,
then:

<olist>

<item>Let <symdef>PARENT</symdef> be the GQL-schema or the catalog object identified by
the <BNF name="catalog object parent reference"/> immediately contained in <sym>CPPN</sym>.
</item>

<item>The procedure identified by <sym>CPPN</sym> is defined as follows:

<olist>

<item>Let <symdef>PN</symdef> be the <BNF name="procedure name"/> immediately contained in
<sym>CPPN</sym>. 
</item>

<item><sym>PARENT</sym> shall contain a procedure <symdef>P</symdef> with name <sym>PN</sym>.
</item>

<comment>WG3:W23-014</comment>
<item>For every primary object <symdef>PO</symdef> contained in <sym>PARENT</sym>, if the name by
which <sym>PO</sym> is identified in <sym>PARENT</sym> and <sym>PN</sym> are visually confusable 
with each other, then the following exception condition is raised:
<raise class="42" subclass="004"/>.
</item>

<item>The procedure identified by <sym>CPPN</sym> is <sym>P</sym>.
</item>

</olist>

</item>

</olist>

</item>


</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:W22-051 deleted all general rules</comment>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>
<comment>WG3:W22-051 deleted one Subclause</comment>


<comment>Editorial: Stefan Plantikow, 2020-02-06</comment>
<subClause id="gql_cat_obj_refs" newpage="true">
<clauseHeading><BNF name="catalog object parent reference"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-07-26 WG3:MMX-055</comment>
<bodyMatter>


<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:W22-051</comment>
<para>Identify the parent GQL-schema or parent catalog object in a reference to a catalog object.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:W22-051</comment>
<BNFdef name="catalog object parent reference">
<rhs>
<alt>
<BNF name="schema reference"/> <opt> <BNF name="solidus"/> </opt>
<opt> <group> <BNF name="object name"/> <BNF name="period"/> </group><repeat/> </opt> 
</alt>
<alt> <group> <BNF name="object name"/> <BNF name="period"/> </group><repeat/> </alt>
</rhs>
</BNFdef>
<comment>Result of discussion on WG3:GYD-013</comment>
<note>While the repetition of <BNF name="object name"/>s is not currently used in this document,
it standardizes how to refer to nested named secondary catalog objects, such as named subgraphs 
of graphs, procedures in library objects, named node types in graph type, <etc/>
These facilities are likely to be provided by implementations and are also candidates for future 
revisions of this document.
</note>
<comment>WG3:UTC-023 Deleted 1 (one) production</comment>

</grammar>

</Format>


<SyntaxRules>

<olist>
<comment>WG3:W22-051 deleted two rules</comment>

<comment>WG3:W22-051</comment>
<item>Let <symdef>COPR</symdef> be the <BNF name="catalog object parent reference"/>.

<para>Case:
</para>

<olist>

<comment>Editorial: Stefan Plantikow, 2023-01-05 Correct use of equivalent</comment>
<comment>WG3:UTC-009 P00-USA-169</comment>
<item>If <sym>COPR</sym> simply contains a <BNF name="schema reference"/> that is
a <BNF name="solidus"/>, then <sym>COPR</sym> shall not immediately contain a <BNF name="solidus"/>.
</item>

<item>Otherwise, <sym>COPR</sym> shall immediately contain a <BNF name="solidus"/>.
</item>

</olist>

<note><mono>//</mono> is not a valid <BNF name="catalog object parent reference"/>.
</note>

</item>

<comment>WG3:W22-051</comment>
<item>Let the GQL-schema <symdef>SCHEMA</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>COPR</sym> immediately contains a <BNF name="schema reference"/> <symdef>CSR</symdef>,
then <sym>SCHEMA</sym> is the GQL-schema identified by <sym>CSR</sym>.
</item>

<item>Otherwise:

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-13 Use of omitted</comment>
<item>The current working schema of <sym>COPR</sym> shall not be <quote>omitted</quote>.
</item>

<item><sym>SCHEMA</sym> is the current working schema of <sym>COPR</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W22-051</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>Let <symdef>ONSEQ</symdef> be the sequence of all <BNF name="object name"/>s that are
immediately contained in <sym>COPR</sym>.
Let <symdef>N</symdef> be the number of elements of <sym>ONSEQ</sym>.
</item>

<comment>WG3:CMN-019 P00-NLD-050</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>, 
let <symdef>ON</symdef><sub><sym>i</sym></sub> be the <sym>i</sym>-th element of <sym>ONSEQ</sym>.
</item>

<comment>WG3:W22-051</comment>
<item>The GQL-schema or catalog object identified by <sym>COPR</sym> is defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:CMN-019 P00-USA-207</comment>
<item>If <sym>N</sym> is 0 (zero), then <sym>COPR</sym> identifies the GQL-schema <sym>SCHEMA</sym>.
</item>

<item>Otherwise,

<olist>

<item>The GQL-schema <sym>SCHEMA</sym> shall contain a catalog object with name
<sym>ON</sym><sub>1</sub>.
</item>

<item>Let <symdef>CO</symdef><sub>1</sub> be the catalog object with name <sym>ON</sym><sub>1</sub>
contained in <sym>SCHEMA</sym>. 
</item>

<comment>WG3:CMN-019 P00-NLD-050</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>For <symdef>j</symdef>, 2 (two) <leq/> <sym>j</sym> <leq/> <sym>N</sym>, 
the catalog object <sym>CO</sym><sub><sym>j</sym></sub> is defined as follows:

<olist>

<item>The catalog object <sym>CO</sym><sub><sym>j</sym>-1</sub> shall contain
a catalog object with name <sym>ON</sym><sub><sym>j</sym></sub>.
</item>

<item><sym>CO</sym><sub><sym>j</sym></sub> is the catalog object with name
<sym>ON</sym><sub><sym>j</sym></sub> contained in <sym>CO</sym><sub><sym>j</sym>-1</sub>. 
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W22-051</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item><sym>COPR</sym> identifies the catalog object <sym>CO</sym><sub><sym>N</sym></sub>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>
<comment>WG3:W22-051 deleted all general rules</comment>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>
<comment>WG3:W22-051 deleted one Subclause.</comment>


<comment>WG3:CMN-061R1</comment>
<subClause id="gql_ref_param" newpage="true">
<clauseHeading><BNF name="reference parameter specification"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-10-09 Extracted URL path parameter</comment>
<bodyMatter>


<comment>WG3:W22-051</comment>
<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>Email from: Hannes Voigt, 2022-08-22 1723 W22</comment>
<comment>WG3:CMN-061R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-09 Fix wording</comment>
<para>Specify a reference parameter for a catalog reference.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:W22-051</comment>
<comment>WG3:CMN-061R1</comment>
<BNFdef name="reference parameter specification">
<rhs>
<BNF name="substituted parameter reference"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:W22-051</comment>
<comment>WG3:CMN-061R1</comment>
<item>Let <symdef>RPS</symdef> be the <BNF name="reference parameter specification"/>.
</item>

<comment>WG3:W22-051</comment>
<comment>Editorial: Stefan Plantikow, 2020-11-11 Clarified parameter availability</comment>
<comment>WG3:CMN-061R1</comment>
<item>Let <symdef>SPR</symdef> be the <BNF name="substituted parameter reference"/> simply 
contained in <sym>RPS</sym>.
</item>

<comment>WG3:CMN-061R1</comment>
<item>Let <symdef>ROP</symdef> be the parameter substitution of <sym>SPR</sym>.

<note>The parameter substitution of a <BNF name="substituted parameter reference"/> is
determined by the provisions of <specref ref="gql_annot_gql_program"/>.
</note>

</item>

<comment>WG3:W21-044</comment>
<comment>WG3:W22-051</comment>
<comment>WG3:UTC-039R1</comment>
<comment>WG3:CMN-061R1</comment>
<item>Let <symdef>ROP1</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:UTC-039R1</comment>
<item>If <sym>RPS</sym> is immediately contained in a <BNF name="schema reference"/>, then:

<olist>

<item>One of the following shall hold:

<olist>

<item><sym>ROP</sym> conforms to the Format and Syntax Rules of
<BNF name="absolute catalog schema reference"/>.
</item>

<item><sym>ROP</sym> conforms to the Format and Syntax Rules of
<BNF name="relative catalog schema reference"/>.
</item>

</olist>

</item>

<item><sym>ROP1</sym> is <sym>ROP</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-039R1</comment>
<item>If <sym>RPS</sym> is immediately contained in a <BNF name="graph reference"/>, then:

<olist>

<item>One of the following shall hold:

<olist>

<item><sym>ROP</sym> conform to the Format and Syntax Rules of
<BNF name="catalog graph parent and name"/>.
</item>

<item><sym>ROP</sym> conforms to the Format and Syntax Rules of <BNF name="home graph"/>.
</item>

</olist>

</item>

<item>The Syntax Rules of Subclause <specref ref="gql_g_refs"/> are applied to <sym>ROP</sym>;
<sym>ROP1</sym> is <sym>ROP</sym> after the application of those Syntax Rules.
</item>

</olist>

</item>

<comment>WG3:UTC-039R1</comment>
<item>If <sym>RPS</sym> is immediately contained in a <BNF name="graph type reference"/>, 
then <sym>ROP</sym> shall conform to the Format and Syntax Rules of
<BNF name="catalog graph type parent and name"/> and <sym>ROP1</sym> is <sym>ROP</sym>.
</item>

<comment>WG3:UTC-039R1</comment>
<item>If <sym>RPS</sym> is immediately contained in a <BNF name="binding table reference"/>,
then:

<olist>

<item><sym>ROP</sym> shall conform to the Format and Syntax Rules of
<BNF name="catalog binding table parent and name"/>.
</item>

<item>The Syntax Rules of Subclause <specref ref="gql_bt_refs"/> are applied to <sym>ROP</sym>;
<sym>ROP1</sym> is <sym>ROP</sym> after the application of those Syntax Rules.
</item>

</olist>

</item>

<comment>WG3:UTC-039R1</comment>
<item>If <sym>RPS</sym> is immediately contained in a <BNF name="procedure reference"/>,
then <sym>ROP</sym> shall conform to the Format and Syntax Rules of
<BNF name="catalog procedure parent and name"/> and <sym>ROP1</sym> is <sym>ROP</sym>.
</item>

</olist>

</item>

<comment>WG3:W21-044</comment>
<comment>WG3:UTC-039R1</comment>
<item><sym>RPS</sym> is effectively replaced by <sym>ROP1</sym>.
</item>
<comment>WG3:W21-044 Two GRs removed</comment>

</olist>

</SyntaxRules>


<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:CMN-047R1</comment>
<item>Without <feature code="GE08"/>, conforming GQL language shall not contain
a <BNF name="reference parameter specification"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>Editorial: Stefan Plantikow, 2020-02-06</comment>
<subClause id="gql_ext_obj_ref" newpage="true">
<clauseHeading><BNF name="external object reference"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-07-26 WG3:MMX-055</comment>
<bodyMatter>


<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>WG3:W22-051</comment>
<para>Identify a GQL-object with a URI.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:W22-051</comment>
<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<bar note="Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references"/>
<BNFdef name="external object reference">
<rhs>
<seeTheRules><itemref ref="gql_ext_obj_ref_format" type="SR"/></seeTheRules>
</rhs>
</BNFdef>
<endbar/>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>Editorial: Stefan Plantikow, 2020-09-16 Made more precise</comment>
<item>Let <symdef>EOR</symdef> be the <BNF name="external object reference"/>.
</item>

<comment>WG3:W22-051 deleted one rule</comment>

<comment>Editorial: Stefan Plantikow, 2021-06-19 consistent use of "character string"</comment>
<comment>Editorial: Stefan Plantikow 2022-04-07 Correct word order: "shall be either"</comment>
<comment>WG3:W22-051</comment>
<comment>Editorial: Stefan Plantikow, 2022-08-17 Flipped order of options</comment>
<comment>WG3:UTC-023</comment>
<item id="gql_ext_obj_ref_format"><sym>EOR</sym> shall be a URI with a mandatory scheme as 
specified by <docref ref="RFC3986"/> or alternatively shall be 
an <mono>absolute-URL-with-fragment</mono> character string as specified by 
<docref ref="WHATWG-URL"/>.
</item>

<comment>WG3:UTC-023</comment>
<item><sym>EOR</sym> shall contain a <BNF name="colon"/>.

<comment>WG3:UTC-023</comment>
<note>This condition is true for any URI with a mandatory scheme as specified by
<docref ref="RFC3986"/> and, when this document was last edited, was true for any
<mono>absolute-URL-with-fragment</mono> character string as specified by <docref ref="WHATWG-URL"/>.
</note>
</item>

<comment>WG3:W22-051</comment>
<item>It is <impDef code="IE001"/> what <sym>EOR</sym> identifies.
</item>

<comment>WG3:W22-051</comment>
<item><sym>EOR</sym> shall identify a GQL-object.
</item>

<comment>Editorial: Stefan Plantikow, 2020-09-16 IPv6 host number</comment>
</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:W22-051 deleted two rules</comment>


<!-- Obsoleted by application of WG3:W22-051

<item>The result of <sym>EOR</sym> is the result of resolving <sym>EOU</sym> as specified by the
<itemref type="GR" ref="gql_GR_resolve_exturl"/>.
</item>

<comment>Editorial: Stefan Plantikow 2022-04-07 Change word order: "either shall"</comment>
<comment>Editorial: Stephen Cannan 2022-08-16 W22-010 P00-USA-285</comment>
<item id="gql_GR_resolve_exturl">The result of resolving <sym>EOU</sym> is <impDef code="IA010"/>.
If the result of resolving <sym>EOU</sym> is not a GQL-object, then an <impDef code="ID061"/> 
exception is raised.
</item>

-->

<comment>Editorial: Stefan Plantikow, 2020-09-16 remote object URL</comment>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W22-052R1</comment>
<comment>WG3:W26-022R2 Consequence</comment>
<item>Without <feature code="GH01"/>, conforming GQL language shall not contain 
an <BNF name="external object reference"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>

</clause>


<clause id="gql_typelts">
<clauseHeading>Type elements</clauseHeading>

<comment>WG3:MMX-028R2</comment>
<comment>WG3:UTC-042</comment>
<subClause id="gql_graph_type">
<clauseHeading><BNF name="nested graph type specification"/></clauseHeading>

<bodyMatter>

<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-09 Align wording</comment>
<para>Specify a graph type.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="nested graph type specification">
<rhs>
<BNF name="left brace"/> <BNF name="graph type specification body"/> <BNF name="right brace"/>
</rhs>
</BNFdef>

<BNFdef name="graph type specification body">
<rhs>
<BNF name="element type list"/>
</rhs>
</BNFdef>

<BNFdef name="element type list">
<rhs>
<BNF name="element type specification"/>
<opt> <group> <BNF name="comma"/> <BNF name="element type specification"/> </group><repeat/> </opt>
</rhs>
</BNFdef>

<BNFdef name="element type specification">
<rhs>
<alt> <BNF name="node type specification"/> </alt>
<alt> <BNF name="edge type specification"/> </alt>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>NGTS</symdef> be the <BNF name="nested graph type specification"/>.
</item>

<comment>WG3:W23-029R1</comment>
<comment>WG3:W26-022R2</comment>
<item>Let <symdef>GTSB</symdef> be the <BNF name="graph type specification body"/> simply contained
in <sym>NGTS</sym>.
</item>

<comment>WG3:W26-022R2 Removed 6 Syntax Rules</comment>

<comment>WG3:W26-022R2</comment>
<item>An <newterm>element type specification</newterm> of <sym>GTSB</sym> is
a <BNF name="node type specification"/> or an <BNF name="edge type specification"/> simply contained
in <sym>GTSB</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The <newterm>property names</newterm> of an element type specification <symdef>AETS</symdef>
are given by the set of names of all property types of <sym>AETS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>For two element type specifications <symdef>ET1</symdef> and <symdef>ET2</symdef> of
a <BNF name="graph type specification body"/>, whether <sym>ET1</sym> and <sym>ET2</sym> are
<newterm>property name-sharing</newterm> is defined as follows:

<para>Case:
</para>

<olist>

<comment>WG3:W26-022R2</comment>
<item>If the intersection of the property names of <sym>ET1</sym> and <sym>ET2</sym> is 
non-empty, then <sym>ET1</sym> and <sym>ET2</sym> are property name-sharing.
</item>

<comment>WG3:W26-022R2</comment>
<item>Otherwise, the intersection of property names of <sym>ET1</sym> and <sym>ET2</sym> is empty
and <sym>ET1</sym> and <sym>ET2</sym> are not property name-sharing.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item id="gql_graph_type_SR_imply">For an element type specification <symdef>SUB_ELTS</symdef> and
an element type specification <symdef>SUPER_ELTS</symdef>,
whether <sym>SUB_ELTS</sym> <newterm>implies</newterm> <sym>SUPER_ELTS</sym> is defined as follows.

<para>Case:
</para>

<comment>WG3:W26-022R2</comment>
<olist>

<comment>WG3:W26-022R2</comment>
<item>If all the following are true, then <sym>SUB_ELTS</sym> implies <sym>SUPER_ELTS</sym>.

<olist>

<comment>WG3:W26-022R2</comment>
<item>Either <sym>SUB_ELTS</sym> and <sym>SUPER_ELTS</sym> both are node types or
they both are edge types.
</item>

<comment>WG3:W26-022R2</comment>
<item>The effective key label set of <sym>SUPER_ELTS</sym> is not <quote>omitted</quote>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The effective key label set of <sym>SUPER_ELTS</sym> is a subset of the label set of
<sym>SUB_ELTS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>One of the following is true:

<olist>

<comment>WG3:W26-022R2</comment>
<item>The effective key label set of <sym>SUB_ELTS</sym> is <quote>omitted</quote>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The effective key label set of <sym>SUPER_ELTS</sym> and the effective key label set of
<sym>SUB_ELTS</sym> are different.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>Otherwise, <sym>SUB_ELTS</sym> does not imply <sym>SUPER_ELTS</sym>.
</item>


</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item id="gql_graph_type_SR_struct_consistent">For an element type specification
<symdef>SUB_ELTS</symdef> and an element type specification <symdef>SUPER_ELTS</symdef>, whether
<sym>SUB_ELTS</sym> is <newterm>structurally consistent</newterm> with <sym>SUPER_ELTS</sym> is
defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W26-022R2</comment>
<item>If all the following are true, then <sym>SUB_ELTS</sym> is structurally consistent
with <sym>SUPER_ELTS</sym>:

<olist>

<comment>WG3:W26-022R2</comment>
<item>Either <sym>SUB_ELTS</sym> and <sym>SUPER_ELTS</sym> both are node types or
they both are edge types.
</item>

<comment>WG3:W26-022R2</comment>
<item>The label set of <sym>SUPER_ELTS</sym> is a subset of the label set of <sym>SUB_ELTS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The property names of <sym>SUPER_ELTS</sym> is a subset of
the property names of <sym>SUB_ELTS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>For every property name <symdef>PN</symdef> of <sym>SUPER_ELTS</sym>, all of
the following are true:

<olist>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>VT_SUPER</symdef> be the value type of the property type with name <sym>PN</sym>
in the property type set of <sym>SUPER_ELTS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>VT_SUB</symdef> be the value type of the property type
with name <symdef>PN</symdef> in the property type set of <sym>SUB_ELTS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>A hypothetical application of the Syntax Rules of <specref ref="gql_gts_combo_vts"/>,
with the set comprising <sym>VT_SUPER</sym> and <sym>VT_SUB</sym> as <symdef>DTSET</symdef>
would succeed; let <symdef>CVT</symdef> be the <symdef>RESTYPE</symdef> that would be returned
from such a hypothetical application.
</item>

<comment>WG3:W26-022R2</comment>
<item><sym>CVT</sym> is <sym>VT_SUPER</sym>.

<comment>WG3:W26-022R2</comment>
<note><sym>CVT</sym> is a supported property value type since <sym>VT_SUPER</sym> and
<sym>VT_SUB</sym> necessarily are supported property value types. 
</note>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>Otherwise, <sym>SUB_ELTS</sym> is not structurally consistent with <sym>SUPER_ELTS</sym>.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>For every <BNF name="node type specification"/> <symdef>NTS</symdef> simply contained in 
<sym>GTSB</sym> and whose effective key label set is not <quote>omitted</quote>, <sym>GTSB</sym>
shall not simply contain a <BNF name="node type specification"/> <symdef>ONTS</symdef> other than
<sym>NTS</sym> such that the effective key label set of <sym>NTS</sym> and
the effective key label set of <sym>ONTS</sym> are the same.
</item>

<comment>WG3:W26-022R2</comment>
<item>For every <BNF name="node type specification"/> <symdef>ONTS</symdef> that is simply contained
in <sym>GTSB</sym> and that implies <sym>NTS</sym>, <sym>ONTS</sym> shall be structurally consistent
with <sym>NTS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>For every <BNF name="node type specification"/> <symdef>NTS</symdef> simply contained in
<sym>GTSB</sym>, <sym>GTSB</sym> shall not simply contain
a <BNF name="node type specification"/> <symdef>ONTS</symdef> other than <sym>NTS</sym> such that
the local node type alias of <sym>NTS</sym> and the local node type alias of <sym>ONTS</sym> are
the same.
</item>

<comment>WG3:W26-022R2</comment>
<item>For every <BNF name="edge type specification"/> <symdef>ETS</symdef> simply contained in
<sym>GTSB</sym>:

<olist>

<comment>WG3:W26-022R2</comment>
<item><sym>GTSB</sym> shall simply contain a <BNF name="node type specification"/> that specifies
the node type that is the source node type of <sym>ETS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item><sym>GTSB</sym> shall simply contain a <BNF name="node type specification"/> that specifies
the node type that is the destination node type of <sym>ETS</sym>.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>The <newterm>source node type specification</newterm> of
an <BNF name="edge type specification"/> <symdef>AETS</symdef> simply contained in <sym>GTSB</sym>
is the <BNF name="node type specification"/> simply contained in <sym>GTSB</sym> that specifies
the node type that is the same type as the source node type of <sym>AETS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The <newterm>destination node type specification</newterm> of
an <BNF name="edge type specification"/> <symdef>AETS</symdef> simply contained in <sym>GTSB</sym>
is the <BNF name="node type specification"/> simply contained in <sym>GTSB</sym> that specifies
the node type that is the same type as the destination node type of <sym>AETS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>For every <BNF name="edge type specification"/> <symdef>ETS</symdef> that is simply contained
in <sym>GTSB</sym> and whose effective key label set is not <quote>omitted</quote>, <sym>GTSB</sym> 
shall not simply contain an <BNF name="edge type specification"/> <symdef>OETS</symdef> other than
<sym>ETS</sym> such that the effective key label set of <sym>ETS</sym> and
the effective key label set of <sym>OETS</sym> are the same and at least one of
the following is true:

<olist>

<comment>WG3:W26-022R2</comment>
<item><sym>ETS</sym> specifies a directed edge type and <sym>OETS</sym> specifies
an undirected edge type.
</item>

<comment>WG3:W26-022R2</comment>
<item><sym>ETS</sym> specifies an undirected edge type and <sym>OETS</sym> specifies
a directed edge type.
</item>

<comment>WG3:W26-022R2</comment>
<item>The label set of <sym>ETS</sym> and the label set of <sym>OETS</sym> are not the same.
</item>

<comment>WG3:W26-022R2</comment>
<item>The property type set of <sym>ETS</sym> and the property type set of <sym>OETS</sym>
are not the same.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item id="gql_graph_type_SR_struct_ep_consistent">For an <BNF name="edge type specification"/> 
<symdef>SUB_ETS</symdef> implying
an <BNF name="edge type specification"/> <symdef>SUPER_ETS</symdef>, whether
<sym>SUB_ETS</sym> is <newterm>structurally endpoint-consistent</newterm> with <sym>SUPER_ETS</sym>
is defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W26-022R2</comment>
<item>If one of the following is true, then <sym>SUB_ETS</sym> is structurally endpoint-consistent 
with <sym>SUPER_ETS</sym>:

<olist>

<comment>WG3:W26-022R2</comment>
<item><sym>SUPER_ETS</sym> and <sym>SUB_ETS</sym> both specify directed edge types,
the source node type specification of <sym>SUB_ETS</sym> is structurally consistent with
the source node type specification of <sym>SUPER_ETS</sym> and
the destination node type specification of <sym>SUB_ETS</sym> is structurally consistent with
the destination node type specification of <sym>SUPER_ETS</sym>.
</item>

<item><sym>SUPER_ETS</sym> and <sym>SUB_ETS</sym> both specify undirected edge types and one of
the following is true:

<olist>

<comment>WG3:W26-022R2</comment>
<item>The source node type specification of <sym>SUB_ETS</sym> is structurally consistent with
the source node type specification of <sym>SUPER_ETS</sym> and
the destination node type specification of <sym>SUB_ETS</sym> is structurally consistent with
the destination node type specification of <sym>SUPER_ETS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The source node type specification of <sym>SUB_ETS</sym> is structurally consistent with
the destination node type specification of <sym>SUPER_ETS</sym> and the destination node type 
specification of <sym>SUB_ETS</sym> is structurally consistent with
the source node type specification of <sym>SUPER_ETS</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>Otherwise, <sym>SUB_ETS</sym> is not structurally endpoint-consistent
with <sym>SUPER_ETS</sym>.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item id="gql_graph_type_SR_ets">For every <BNF name="edge type specification"/> 
<symdef>OETS</symdef> that is simply contained in <sym>GTSB</sym> and implies <sym>ETS</sym>, 
all of the following shall be true:

<olist>

<comment>WG3:W26-022R2</comment>
<item><sym>OETS</sym> is structurally consistent with <sym>ETS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item id="gql_graph_type_SR_ets_b"><sym>OETS</sym> is structurally endpoint-consistent with 
<sym>ETS</sym>.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>The <newterm>set of node type key label sets</newterm> of
a <BNF name="graph type specification body"/> <symdef>AGTSB</symdef> is the set of
the effective key label sets of all <BNF name="node type specification"/>s simply contained in
<sym>AGTSB</sym> except for those <BNF name="node type specification"/>s
whose effective key label sets are <quote>omitted</quote>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The <newterm>set of edge type key label sets</newterm> of
a <BNF name="graph type specification body"/> <symdef>AGTSB</symdef> is the set of
the effective key label sets of all <BNF name="edge type specification"/>s simply contained in
<sym>AGTSB</sym> except for those <BNF name="edge type specification"/>s
whose effective key label sets are <quote>omitted</quote>.
</item>

<comment>WG3:W26-022R2</comment>
<item><sym>NGTS</sym> specifies the graph type specified by <sym>GTSB</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item><sym>GTSB</sym> specifies the graph type with

<olist>

<comment>WG3:W26-022R2</comment>
<item>The node type set that is the set of node types specified by
the <BNF name="node type specification"/>s simply contained in <sym>GTSB</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The edge type set that is the set of edge types specified by
the <BNF name="edge type specification"/>s simply contained in <sym>GTSB</sym>.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<comment>Editorial: Stephen Cannan, 2024-10-01 Remove unused symbol definition</comment>
<item>The node type key label set dictionary of a graph type specified by
a <BNF name="graph type specification body"/> <sym>AGTSB</sym> is a dictionary that maps every
key label set <symdef>NTKLS</symdef> in the set of node type key label sets of <sym>AGTSB</sym> to
the node type specified by a <BNF name="node type specification"/> <symdef>NTS</symdef> that is
simply contained in <sym>AGTSB</sym> and where <sym>NTKLS</sym> is the key label set of
<sym>NTS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<comment>Editorial: Stephen Cannan, 2024-10-01 Remove unused symbol definition</comment>
<item>The edge type key label set dictionary of a graph type specified by
a <BNF name="graph type specification body"/> <symdef>AGTSB</symdef> is a dictionary that maps
every key label set <symdef>ETKLS</symdef> in the set of edge type key label sets of
<sym>AGTSB</sym> to the set of all edge types specified by
an <BNF name="edge type specification"/> <symdef>ETS</symdef> that is simply contained in 
<sym>AGTSB</sym> and where <sym>ETKLS</sym> is the key label set of <sym>ETS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>For each graph type <symdef>GT</symdef>, there is an <impDef code="IV003"/> graph type, 
<symdef>GTNF</symdef>(<sym>GT</sym>), known as the normal form of <sym>GT</sym>
(which can be <sym>GT</sym> itself), such that:

<olist>

<comment>WG3:W26-022R2</comment>
<item>If <symdef>GT1</symdef> and <symdef>GT2</symdef> are two graph types, the sets of
the normal forms of the node types of <sym>GT1</sym> and <sym>GT2</sym> are the same, and
the sets of the normal forms of the edge types of <sym>GT1</sym> and <sym>GT2</sym> are the same,
then <sym>GTNF</sym>(<sym>GT1</sym>) = <sym>GTNF</sym>(<sym>GT2</sym>).
</item>

<comment>WG3:W26-022R2</comment>
<item><sym>GTNF</sym>(<sym>GTNF</sym>(<sym>GT</sym>)) = <sym>GTNF</sym>(<sym>GT</sym>).
</item>

<comment>WG3:W26-022R2</comment>
<item>The results of all invocations of <sym>GTNF</sym>(<sym>GT</sym>) are the same.

<comment>WG3:W26-022R2</comment>
<note>This ensures that all invocations of the <impDef code="IV003"/> choice of
the normal form of a graph type from amongst the equivalent graph types are deterministic.
</note>
</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:W26-022R2 Removed 1 (one) General Rule</comment>

<comment>WG3:W23-029R1</comment>
<comment>WG3:W26-022R2</comment>
<item>The graph type descriptor is created for the graph type <symdef>GT</symdef>
specified by <sym>GTSB</sym> that describes <sym>GT</sym> and comprises:

<olist>

<comment>WG3:BER-040R3</comment>
<comment>WG3:W23-029R1</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<comment>WG3:W26-022R2</comment>
<item>The declared name of the primary base type of all graph types (GRAPH DATA).

<note>See <specref ref="gql_graph_type_desc"/>. 
</note>
</item>
<comment>WG3:W22-034R1 deleted two items</comment>

<comment>WG3:W26-022R2</comment>
<item>The preferred name of <sym>GT</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The set of the node type descriptors of all node types of <sym>GT</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The set of the edge type descriptors of all edge types of <sym>GT</sym>.
</item>

<comment>WG3:W23-029R1</comment>
<comment>WG3:W26-022R2</comment>
<item>The node type key label set dictionary of <sym>GT</sym>.
</item>

<comment>WG3:W23-029R1</comment>
<comment>WG3:W26-022R2</comment>
<item>The edge type key label set dictionary of <sym>GT</sym>.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W26-022R2</comment>
<item>Without <feature code="GG23"/>, in conforming GQL language,
a <BNF name="graph type specification body"/> shall not contain
a <BNF name="node type specification"/> or an <BNF name="edge type specification"/>
whose effective key label set is <quote>omitted</quote>.
</item>

<comment>WG3:W26-022R2</comment>
<item>Without <feature code="GG24"/>, in conforming GQL language,
for every two property name-sharing element type specifications <symdef>ET1</symdef> and
<symdef>ET2</symdef> of a <BNF name="graph type specification body"/> and every property name
<symdef>PN</symdef> in the intersection of the property names of <sym>ET1</sym> and <sym>ET2</sym>,
it holds that a hypothetical application of the Syntax Rules of <specref ref="gql_gts_combo_vts"/>
with the set comprising the value types of the property types of <sym>ET1</sym> and <sym>ET2</sym> 
whose name is <sym>PN</sym> as <sym>DTSET</sym> would succeed.
</item>

<comment>WG3:W26-022R2</comment>
<item>Without <feature code="GG25"/>, in conforming GQL language,
a <BNF name="graph type specification body"/> shall not simply contain
two <BNF name="edge type specification"/>s whose effective key label sets both are the same
but are not <quote>omitted</quote>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:MMX-028R2</comment>
<comment>WG3:UTC-042</comment>
<subClause id="gql_node_type_defn" newpage="true">
<clauseHeading><BNF name="node type specification"/></clauseHeading>

<bodyMatter>

<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-09 Align wording</comment>
<para>Specify a node type.
</para>

</Function>


<Format>

<comment>WG3:W26-022R2</comment>
<grammar>

<comment>WG3:BER-040R3</comment>
<BNFdef name="node type specification">
<rhs>
<alt> <BNF name="node type pattern"/> </alt>
<alt> <BNF name="node type phrase"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="node type pattern">
<rhs>
<opt> <BNF name="node synonym"/> <opt> <kw>TYPE</kw> </opt> <BNF name="node type name"/> </opt>
<breakindent/>
<BNF name="left paren"/> 
<opt> <BNF name="local node type alias"/> </opt>
<opt> <BNF name="node type filler"/> </opt>
<BNF name="right paren"/> 
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="node type phrase">
<rhs>
<BNF name="node synonym"/> <opt> <kw>TYPE</kw> </opt> <BNF name="node type phrase filler"/>
<breakindent/>
<opt> <kw>AS</kw> <BNF name="local node type alias"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="node type phrase filler">
<rhs>
<alt> <BNF name="node type name"/> <opt> <BNF name="node type filler"/> </opt> </alt>
<alt> <BNF name="node type filler"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="node type filler">
<rhs>
<alt><BNF name="node type key label set"/> <opt> <BNF name="node type implied content"/> </opt>
</alt>
<alt> <BNF name="node type implied content"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<comment>WG3:W27-011</comment>
<BNFdef name="local node type alias">
<rhs>
<BNF name="regular identifier"/>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="node type implied content">
<rhs>
<alt> <BNF name="node type label set"/> </alt>
<alt> <BNF name="node type property types"/> </alt>
<alt> <BNF name="node type label set"/> <BNF name="node type property types"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="node type key label set">
<rhs>
<opt> <BNF name="label set phrase"/> </opt> <BNF name="implies"/>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="node type label set">
<rhs>
<BNF name="label set phrase"/>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="node type property types">
<rhs>
<BNF name="property types specification"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>NTS</symdef> be the <BNF name="node type specification"/>.
</item>

<comment>WG3:BER-040R3</comment>
<comment>WG3:W24-027</comment>
<comment>WG3:UTC-086R1</comment>
<comment>WG3:W26-022R2</comment>
<item>If <sym>NTS</sym> is simply contained in a <BNF name="closed node reference value type"/>, 
then <sym>NTS</sym> shall not simply contain a <BNF name="local node type alias"/>,
a <BNF name="node type key label set"/>, or a <BNF name="node type name"/>.
</item>

<comment>WG3:W26-022R2 Removed 3 productions</comment>

<comment>WG3:W26-022R2</comment>
<item id="gql_node_type_defn_SR_node_type_name">If <sym>NTS</sym> simply contains 
a <BNF name="node type name"/>, then:

<olist>

<comment>WG3:W26-022R2</comment>
<item><sym>NTS</sym> shall not simply contain a <BNF name="node type key label set"/>.
</item>

<comment>WG3:W26-022R2</comment>
<item id="gql_node_type_defn_SR_node_type_alias"><sym>NTS</sym> shall not simply contain 
a <BNF name="local node type alias"/>.
<ednote id="gql_PPgql391">Explicit type name for node or edge type prevents definition of 
local type alias, but edge specification requires a programmer to know what the alias is, 
which is hard if the system generates it.
See <PPref ref="PPgql391"/> and <PPref ref="PPgql403"/>.
</ednote>
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item id="gql_node_type_defn_SR_local_node_type_alias">The <newterm>local node type alias</newterm> 
of a <BNF name="node type specification"/> <symdef>ANTS</symdef> is defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W26-022R2</comment>
<comment>WG3:W27-011</comment>
<comment>WG3:GYD-012</comment>
<item>If <sym>ANTS</sym> simply contains a <BNF name="local node type alias"/> 
<symdef>LNTA</symdef>, then the local node type alias of <sym>ANTS</sym> is the name specified by
the <BNF name="regular identifier"/> that constitutes <sym>LNTA</sym>.
</item>

<comment>WG3:GYD-012</comment>
<item>If <sym>ANTS</sym> simply contains a <BNF name="node type name"/> 
<symdef>NTN</symdef>, then the local node type alias of <sym>ANTS</sym> is 
the name specified by the <BNF name="identifier"/> that constitutes 
<sym>NTN</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<comment>WG3:GYD-012</comment>
<item>Otherwise, neither <BNF name="local node type alias"/> nor 
<BNF name="node type name"/> are specified and the local node type alias of 
<sym>ANTS</sym> is the name of a new system-generated regular identifier.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>The <newterm>key label set</newterm> of a <BNF name="node type specification"/> 
<symdef>ANTS</symdef> is defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W26-022R2</comment>
<item>If <sym>ANTS</sym> simply contains a <BNF name="node type key label set"/> 
<symdef>NTKLS</symdef> that simply contains a <BNF name="label set phrase"/> 
<symdef>LSP</symdef>, then the key label set of <sym>ANTS</sym> is the label set specified by 
<sym>LSP</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>If <sym>ANTS</sym> simply contains a <BNF name="node type key label set"/> <sym>NTKLS</sym>
that does not simply contain a <BNF name="label set phrase"/>, then
the key label set of <sym>ANTS</sym> is an empty label set.
</item>

<comment>WG3:W26-022R2</comment>
<item>If <sym>ANTS</sym> simply contains a <BNF name="node type name"/> <symdef>NTN</symdef>, then
the key label set of <sym>ANTS</sym> is the label set specified by the following
<BNF name="label set phrase"/>:
<code>
:<sym>NTN</sym>
</code>
</item>

<comment>WG3:W26-022R2</comment>
<item>Otherwise, no key label set is suitably specified and
the key label set of <sym>ANTS</sym> is
<quote>omitted</quote>.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>The <newterm>implied label set</newterm> of
a <BNF name="node type specification"/> <symdef>ANTS</symdef> is defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W26-022R2</comment>
<item>If <sym>ANTS</sym> simply contains
an implicit or explicit <BNF name="node type label set"/> <symdef>NTLS</symdef>, then
the implied label set of <sym>ANTS</sym> is the label set specified by
the <BNF name="label set phrase"/> that constitutes <sym>NTLS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>Otherwise, no <BNF name="node type label set"/> is suitably specified and
the implied label set of <sym>ANTS</sym> is the empty label set.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>If the key label set of <sym>NTS</sym> is not <quote>omitted</quote>, then
the key label set of <sym>NTS</sym> and the implied label set of <sym>NTS</sym> shall be disjoint.
</item>

<comment>WG3:W26-022R2</comment>
<item>The <newterm>label set</newterm> of
a <BNF name="node type specification"/> <symdef>ANTS</symdef> is the union of
the key label set of <sym>ANTS</sym> and the implied label set of <sym>ANTS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The <newterm>effective key label set</newterm> of
a <BNF name="node type specification"/> <symdef>ANTS</symdef> is defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W26-022R2</comment>
<comment>Email from: Hannes Voigt, 2023-11-14 0807</comment>
<item>If <sym>ANTS</sym> is simply contained in
a <BNF name="graph type specification body"/> <symdef>GTSB</symdef>, then

<para>Case:
</para>

<olist>

<comment>WG3:W26-022R2</comment>
<comment>Email from: Hannes Voigt, 2023-11-14 0807</comment>
<item>If <feature code="GG22"/> is supported and the key label set of <sym>ANTS</sym> is 
<quote>omitted</quote>, then:

<olist>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>ONTSS</symdef> be the set of all <BNF name="node type specification"/>s simply
contained in <sym>GTSB</sym> other than <sym>ANTS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>OLS</symdef> be the union of the label sets of all
<BNF name="node type specification"/>s in <sym>ONTSS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>ULS</symdef> be the set of all labels that are in
the implied label set of <sym>ANTS</sym> but not in <sym>OLS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>If <sym>ULS</sym> is an empty label set, then the effective key label set of <sym>ANTS</sym>
is <quote>omitted</quote>; otherwise, the effective key label set of <sym>ANTS</sym> is
<sym>ULS</sym>.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<comment>Email from: Hannes Voigt, 2023-11-14 0807</comment>
<item>Otherwise, the key label set of <sym>ANTS</sym> is not <quote>omitted</quote> and
the effective key label set of <sym>ANTS</sym> is the key label set of <sym>ANTS</sym>.
</item>
</olist>

</item>

<comment>WG3:W26-022R2</comment>
<comment>Email from: Hannes Voigt, 2023-11-14 0807</comment>
<item>Otherwise, the effective key label set of <sym>ANTS</sym> is the key label set of
<sym>ANTS</sym>.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>If the effective key label set of <sym>NTS</sym> is not <quote>omitted</quote> and
the cardinality of the effective key label set of <sym>NTS</sym> is less than
the <impDef code="IL003"/> node type key label set minimum cardinality, then
an exception condition is raised: <raise class="42" subclass="012"/>.
</item>

<comment>WG3:W26-022R2</comment>
<item>If the effective key label set of <sym>NTS</sym> is not <quote>omitted</quote> and the 
cardinality of the effective key label set of <sym>NTS</sym> is greater than
the <impDef code="IL003"/> node type key label set maximum cardinality, then
an exception condition is raised: <raise class="42" subclass="013"/>.
</item>

<comment>WG3:OHD-015</comment>
<comment>WG3:W24-027</comment>
<comment>WG3:W26-022R2</comment>
<item>If the cardinality of the label set of <sym>NTS</sym> is less than
the <impDef code="IL001"/> node label set minimum cardinality, then
an exception condition is raised: <raise class="42" subclass="009"/>.
</item>

<comment>WG3:OHD-015</comment>
<comment>WG3:W24-027</comment>
<comment>WG3:W26-022R2</comment>
<item>If the cardinality of the label set of <sym>NTS</sym> is greater than
the <impDef code="IL003"/> node label set maximum cardinality, then
an exception condition is raised: <raise class="42" subclass="010"/>.
</item>

<comment>WG3:W26-022R2 Removed 1 production</comment>

<comment>WG3:OHD-047</comment>
<comment>WG3:W24-027</comment>
<comment>WG3:W26-022R2</comment>
<item>The <newterm>property type set</newterm> of
a <BNF name="node type specification"/> <symdef>ANTS</symdef> is defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W26-022R2</comment>
<comment>Email from: Hannes Voigt, 2023-11-14 1807</comment>
<item>If <symdef>ANTS</symdef> contains
a <BNF name="node type property types"/> <symdef>NTPTS</symdef>, then the property type set of
<sym>ANTS</sym> is the property type set that is specified by
the <BNF name="property types specification"/> that constitutes <sym>NTPTS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>Otherwise, no <BNF name="property types specification"/> is suitably specified and
the property type set of <symdef>ANTS</symdef> is an empty property types set.
</item>

</olist>

</item>


<comment>WG3:W26-022R2</comment>
<item>If the cardinality of the property type set of <sym>NTS</sym> is greater than
the <impDef code="IL002"/> node property set maximum cardinality, then
an exception condition is raised: <raise class="42" subclass="011"/>.
</item>

<comment>WG3:W26-022R2</comment>
<item><sym>NTS</sym> specifies the node type with

<olist>

<item>The node type label set that is the label set of <sym>NTS</sym>.
</item>

<item>The node type property type set that is the property type set of <sym>NTS</sym>.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>For each node type <symdef>NT</symdef>, there is an <impDef code="IV003"/> node type, 
<symdef>NTNF</symdef>(<sym>NT</sym>), known as the normal form of <sym>NT</sym> (which can be 
<sym>NT</sym> itself), such that:

<olist>

<comment>WG3:W26-022R2</comment>
<item>If <symdef>NT1</symdef> and <symdef>NT2</symdef> are two node types that have
the same label sets and the same property names <symdef>PNS</symdef>, and
for each property name <symdef>PN</symdef> from <sym>PNS</sym> it holds that
the value types of the respective property types of <sym>NT1</sym> and <sym>NT2</sym> whose name
is <sym>PN</sym> have the same normal form, then
<sym>NTNF</sym>(<sym>NT1</sym>) = <sym>NTNF</sym>(<sym>NT2</sym>).
</item>

<comment>WG3:W26-022R2</comment>
<item><sym>NTNF</sym>(<sym>NTNF</sym>(<sym>NT</sym>)) = <sym>NTNF</sym>(<sym>NT</sym>).
</item>

<comment>WG3:W26-022R2</comment>
<item>The results of all invocations of <sym>NTNF</sym>(<sym>NT</sym>) are the same.

<comment>WG3:W26-022R2</comment>
<note>This ensures that all invocations of the <impDef code="IV003"/> choice of
the normal form of a node type from amongst the equivalent node types are deterministic.
</note>
</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:BER-040R3</comment>
<comment>WG3:W24-027</comment>
<comment>WG3:W26-022</comment>
<item>A node type descriptor is created for the node type <symdef>NT</symdef> specified by
<sym>NTS</sym> that describes <sym>NT</sym> and comprises:

<olist>

<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<item>The declared name of the primary base type of all node types (NODE DATA).

<note>See <specref ref="gql_conc_intro_obj_type"/>. 
</note>
</item>

<comment>WG3:W26-022</comment>
<item>The preferred name of <sym>NT</sym>.
</item>

<comment>WG3:W26-022</comment>
<item>The node type label set of <sym>NT</sym>.
</item>

<comment>WG3:W26-022</comment>
<item>The node type property type set of <sym>NT</sym>.
</item>

</olist>

</item>

<comment>WG3:W26-022R2 Removed 1 (one) General Rule</comment>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W26-022R2 Removed 1 (one) Conformance Rule</comment>

<comment>WG3:W26-022R2</comment>
<item>Without <feature code="GG20"/>, in conforming GQL language,
a <BNF name="node type specification"/> shall not simply contain
a <BNF name="node type name"/>.
</item>

<comment>WG3:W26-022R2</comment>
<item>Without <feature code="GG21"/>, in conforming GQL language,
a <BNF name="node type specification"/> shall not simply contain
a <BNF name="node type key label set"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:MMX-028R2</comment>
<comment>WG3:UTC-042</comment>
<subClause id="gql_edge_type_defn" newpage="true">
<clauseHeading><BNF name="edge type specification"/></clauseHeading>

<bodyMatter>


<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-09 Align wording</comment>
<para>Specify an edge type.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:BER-040R3</comment>
<comment>WG3:W26-022R2</comment>
<BNFdef name="edge type specification">
<rhs>
<alt> <BNF name="edge type pattern"/> </alt>
<alt> <BNF name="edge type phrase"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="edge type pattern">
<rhs>
<opt>
<opt> <BNF name="edge kind"/> </opt> <BNF name="edge synonym"/>
<opt> <kw>TYPE</kw> </opt> <BNF name="edge type name"/>
</opt>
<breakindent/>
<group>
<alt br="no"> <BNF name="edge type pattern directed"/> </alt>
<alt br="no"> <BNF name="edge type pattern undirected"/> </alt>
</group>
</rhs>
</BNFdef>

<comment>WG3:CMN-019 P00-USA-112</comment>
<comment>WG3:W26-022R2</comment>
<BNFdef name="edge type phrase">
<rhs>
<BNF name="edge kind"/> <BNF name="edge synonym"/>
<opt> <kw>TYPE</kw> </opt> <BNF name="edge type phrase filler"/>
<BNF name="endpoint pair phrase"/>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="edge type phrase filler">
<rhs>
<alt> <BNF name="edge type name"/> <opt> <BNF name="edge type filler"/> </opt> </alt>
<alt> <BNF name="edge type filler"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="edge type filler">
<rhs>
<alt> <BNF name="edge type key label set"/> <opt> <BNF name="edge type implied content"/> </opt>
</alt>
<alt> <BNF name="edge type implied content"/>
</alt>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="edge type implied content">
<rhs>
<alt> <BNF name="edge type label set"/> </alt>
<alt> <BNF name="edge type property types"/> </alt>
<alt> <BNF name="edge type label set"/> <BNF name="edge type property types"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="edge type key label set">
<rhs>
<opt> <BNF name="label set phrase"/> </opt> <BNF name="implies"/>
</rhs>
</BNFdef>

<BNFdef name="edge type label set">
<rhs>
<BNF name="label set phrase"/>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="edge type property types">
<rhs>
<BNF name="property types specification"/>
</rhs>
</BNFdef>
<comment>WG3:W26-022R2 Removed 1 (one) production</comment>

<comment>WG3:W26-022R2</comment>
<BNFdef name="edge type pattern directed">
<rhs>
<alt> <BNF name="edge type pattern pointing right"/> </alt>
<alt> <BNF name="edge type pattern pointing left"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="edge type pattern pointing right">
<rhs>
<BNF name="source node type reference"/> <BNF name="arc type pointing right"/> 
<BNF name="destination node type reference"/>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="edge type pattern pointing left">
<rhs>
<BNF name="destination node type reference"/> <BNF name="arc type pointing left"/> 
<BNF name="source node type reference"/>
</rhs>
</BNFdef>

<comment>WG3:W22-051</comment>
<comment>WG3:W26-022R2</comment>
<BNFdef name="edge type pattern undirected">
<rhs>
<BNF name="source node type reference"/> <BNF name="arc type undirected"/> 
<BNF name="destination node type reference"/>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="arc type pointing right">
<rhs>
<BNF name="minus left bracket"/> <BNF name="edge type filler"/> <BNF name="bracket right arrow"/>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="arc type pointing left">
<rhs>
<BNF name="left arrow bracket"/> <BNF name="edge type filler"/> <BNF name="right bracket minus"/>
</rhs>
</BNFdef>

<comment>WG3:W22-051</comment>
<comment>WG3:W26-022R2</comment>
<BNFdef name="arc type undirected">
<rhs>
<BNF name="tilde left bracket"/> <BNF name="edge type filler"/> <BNF name="right bracket tilde"/>
</rhs>
</BNFdef>
<comment>WG3:W26-022R2 Removed 6 productions</comment>

<comment>WG3:W26-022R2</comment>
<BNFdef name="source node type reference">
<rhs>
<alt> <BNF name="left paren"/> <BNF name="source node type alias"/> <BNF name="right paren"/> </alt>
<alt>
<BNF name="left paren"/> <opt> <BNF name="node type filler"/> </opt> <BNF name="right paren"/> 
</alt>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="destination node type reference">
<rhs>
<alt> 
<BNF name="left paren"/> <BNF name="destination node type alias"/> <BNF name="right paren"/> 
</alt>
<alt>
<BNF name="left paren"/> <opt> <BNF name="node type filler"/> </opt> <BNF name="right paren"/> 
</alt>
</rhs>
</BNFdef>

<BNFdef name="edge kind">
<rhs>
<alt> <kw>DIRECTED</kw> </alt>
<alt> <kw>UNDIRECTED</kw> </alt>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="endpoint pair phrase">
<rhs>
<kw>CONNECTING</kw> <BNF name="endpoint pair"/>
</rhs>
</BNFdef>

<comment>WG3:W22-051</comment>
<comment>WG3:W26-022R2</comment>
<BNFdef name="endpoint pair">
<rhs>
<alt> <BNF name="endpoint pair directed"/> </alt>
<alt> <BNF name="endpoint pair undirected"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="endpoint pair directed">
<rhs>
<alt> <BNF name="endpoint pair pointing right"/> </alt>
<alt> <BNF name="endpoint pair pointing left"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="endpoint pair pointing right">
<rhs>
<BNF name="left paren"/> <BNF name="source node type alias"/> <BNF name="connector pointing right"/>
<breakindent/>
<BNF name="destination node type alias"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="endpoint pair pointing left">
<rhs>
<BNF name="left paren"/> <BNF name="destination node type alias"/> <BNF name="left arrow"/>
<breakindent/>
<BNF name="source node type alias"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<comment>WG3:W22-051</comment>
<comment>WG3:W26-022R2</comment>
<BNFdef name="endpoint pair undirected">
<rhs>
<BNF name="left paren"/> <BNF name="source node type alias"/> <BNF name="connector undirected"/>
<breakindent/>
<BNF name="destination node type alias"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<BNFdef name="connector pointing right">
<rhs>
<alt> <kw>TO</kw> </alt>
<alt> <BNF name="right arrow"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W22-051</comment>
<BNFdef name="connector undirected">
<rhs>
<alt> <kw>TO</kw> </alt>
<alt> <BNF name="tilde"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<comment>WG3:W27-011</comment>
<BNFdef name="source node type alias">
<rhs>
<BNF name="regular identifier"/>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<comment>WG3:W27-011</comment>
<BNFdef name="destination node type alias">
<rhs>
<BNF name="regular identifier"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>ETS</symdef> be the <BNF name="edge type specification"/>.
</item>

<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-086R1</comment>
<comment>WG3:W26-022R2</comment>
<item>If <sym>ETS</sym> is simply contained in a <BNF name="closed edge reference value type"/>, 
then:

<olist>

<comment>WG3:W24-027</comment>
<comment>WG3:W26-022R2</comment>
<item><sym>ETS</sym> shall not simply contain an <BNF name="edge type key label set"/> or
an <BNF name="edge type name"/>.
</item>

<comment>WG3:W26-022R2</comment>
<item><sym>ETS</sym> shall not simply contain a <BNF name="source node type alias"/> or 
a <BNF name="destination node type alias"/>.
</item>

<comment>WG3:W26-022R2</comment>
<item><sym>ETS</sym> shall not simply contain a <BNF name="source node type reference"/> that
simply contains a <BNF name="node type key label set"/>.
</item>

<comment>WG3:W26-022R2</comment>
<item><sym>ETS</sym> shall not simply contain a <BNF name="destination node type reference"/> that 
simply contains a <BNF name="node type key label set"/>.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<comment>Email from: Hannes Voigt, 2023-11-14 1807</comment>
<item>If <sym>ETS</sym> simply contains an <BNF name="edge type name"/>, then <sym>ETS</sym> shall
not simply contain an <BNF name="edge type key label set"/>.
</item>
<comment>WG3:W26-022R2 Removed 4 Syntax Rules</comment>

<comment>WG3:W26-022R2</comment>
<item>Case:

<olist>

<comment>Editorial: Stephen Cannan, 2021-04-06</comment>
<comment>WG3:W22-051</comment>
<comment>WG3:W26-022R2</comment>
<item>If <kw>DIRECTED</kw> is simply contained in <sym>ETS</sym>, then
<sym>ETS</sym> shall simply contain an <BNF name="endpoint pair directed"/> or 
an <BNF name="edge type pattern directed"/>.
</item>

<comment>Editorial: Stephen Cannan, 2021-04-06</comment>
<comment>WG3:W22-051</comment>
<comment>WG3:W26-022R2</comment>
<item>Otherwise, <kw>UNDIRECTED</kw> is simply contained in <sym>ETS</sym> and
<sym>ETS</sym> shall simply contain an <BNF name="endpoint pair undirected"/> or 
an <BNF name="edge type pattern undirected"/>.
</item>

</olist>

</item>
<comment>WG3:W26-022R2 Removed 2 Syntax Rules</comment>

<comment>WG3:W26-022R2</comment>
<item>If <sym>ETS</sym> is an <BNF name="edge type phrase"/>, then:

<olist>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>SNTA</symdef> be the <BNF name="source node type alias"/> simply contained
in <sym>ETS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>DNTA</symdef> be the <BNF name="destination node type alias"/> simply contained 
in <sym>ETS</sym>. 
</item>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>ETF</symdef> be defined as follows 

<para>Case:
</para>

<olist>

<comment>WG3:W26-022R2</comment>
<item>If <sym>ETS</sym> simply contains an implicit or explicit <BNF name="edge type filler"/>, then
<sym>ETF</sym> is that <BNF name="edge type filler"/>.
</item>

<comment>WG3:W26-022R2</comment>
<item>Otherwise, no <BNF name="edge type filler"/> is suitably specified and <sym>ETF</sym> is
the zero-length character string.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>Case:

<olist>

<comment>WG3:W26-022R2</comment>
<item>If <kw>DIRECTED</kw> is simply contained in <sym>ETS</sym>, then <sym>ETS</sym> is equivalent
to the <BNF name="edge type pattern directed"/>:
<code>
( <sym>SNTA</sym> ) -[ <sym>ETF</sym> ]-> ( <sym>DNTA</sym> )
</code>
</item>

<comment>WG3:W26-022R2</comment>
<item>Otherwise, <kw>UNDIRECTED</kw> is simply contained in <sym>ETS</sym> and <sym>ETS</sym> is 
equivalent to the <BNF name="edge type pattern undirected"/>:
<code>
( <sym>SNTA</sym> ) ~[ <sym>ETF</sym> ]~ ( <sym>DNTA</sym> )
</code>
</item>

</olist>

</item>

</olist>

</item>
<comment>WG3:W26-022R2 Removed 6 Syntax Rules</comment>

<comment>WG3:W26-022R2</comment>
<item>The <newterm>key label set</newterm> of
an <BNF name="edge type specification"/> <symdef>AETS</symdef> is determined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W26-022R2</comment>
<item>If <sym>AETS</sym> simply contains an <BNF name="edge type key label set"/> 
<symdef>ETKLS</symdef> that simply contains a <BNF name="label set phrase"/> <symdef>LSP</symdef>,
then the key label set of <sym>AETS</sym> is the label set specified by the <sym>LSP</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>If <sym>AETS</sym> simply contains an <BNF name="edge type key label set"/> <sym>ETKLS</sym>
that does not simply contains a <BNF name="label set phrase"/>, then
the key label set of <sym>AETS</sym> is an empty label set.
</item>

<comment>WG3:W26-022R2</comment>
<item>If <sym>AETS</sym> simply contains an <BNF name="edge type name"/> <symdef>ETN</symdef>, then
the key label set of <sym>AETS</sym> is the label set specified by
the <BNF name="label set phrase"/>:
<code>
:<sym>ETN</sym>
</code>
</item>

<comment>WG3:W26-022R2</comment>
<item>Otherwise, no <BNF name="label set phrase"/> is suitably specified and
the key label set of <sym>AETS</sym> is <quote>omitted</quote>.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>The <newterm>implied label set</newterm> of an <BNF name="edge type specification"/> 
<symdef>AETS</symdef> is defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W26-022R2</comment>
<item>If <sym>AETS</sym> simply contains an <BNF name="edge type label set"/> <symdef>ETLS</symdef>,
then the implied label set of <sym>AETS</sym> is the label set specified by
the <BNF name="label set phrase"/> that constitutes <sym>ETLS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>Otherwise, no <BNF name="label set phrase"/> is suitably specified and
the implied label set of <sym>AETS</sym> is an empty label set.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>If the key label set of <sym>ETS</sym> is not <quote>omitted</quote>, then
the key label set of <sym>ETS</sym> and the implied label set of <sym>ETS</sym> shall be disjoint.
</item>

<comment>WG3:W26-022R2</comment>
<item>The <newterm>label set</newterm> of
an <BNF name="edge type specification"/> <symdef>AETS</symdef> is
the union of the key label set of <sym>AETS</sym> and the implied label set of <sym>AETS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The <newterm>effective key label set</newterm> of
an <BNF name="edge type specification"/> <symdef>AETS</symdef> is defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W26-022R2</comment>
<comment>Email from: Hannes Voigt, 2023-11-14 0807</comment>
<item>If <sym>AETS</sym> is simply contained in
a <BNF name="graph type specification body"/> <symdef>GTSB</symdef>, then

<para>Case:
</para>

<olist>

<comment>WG3:W26-022R2</comment>
<comment>Email from: Hannes Voigt, 2023-11-14 0807</comment>
<item>If <feature code="GG22"/> is supported and the key label set of <sym>AETS</sym> is 
<quote>omitted</quote>, then:

<olist>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>OETSS</symdef> be the set of all <BNF name="edge type specification"/>s simply 
contained in <sym>GTSB</sym> other than <sym>AETS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>OLS</symdef> be the union of the label sets of
all <BNF name="edge type specification"/>s in <sym>OETSS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>ULS</symdef> be the set of all labels that are in
the implied label set of <sym>AETS</sym> but not in <sym>OLS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<comment>Email from: Hannes Voigt, 2023-11-14 1807</comment>
<item>If <sym>ULS</sym> is an empty label set, then the effective key label set of <sym>ULS</sym>
is <quote>omitted</quote>; otherwise, the effective key label set of <sym>AETS</sym> is
<sym>ULS</sym>.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<comment>Email from: Hannes Voigt, 2023-11-14 0807</comment>
<item>Otherwise, the key label set of <sym>AETS</sym> is not <quote>omitted</quote> and
the effective key label set of <sym>AETS</sym> is the key label set of <sym>AETS</sym>.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<comment>Email from: Hannes Voigt, 2023-11-14 0807</comment>
<item>Otherwise, the effective key label set of <sym>AETS</sym> is
the key label set of <sym>AETS</sym>.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>If the effective key label set of <sym>ETS</sym> is not <quote>omitted</quote> and
the cardinality of the effective key label set of <sym>ETS</sym> is less than 
the <impDef code="IL003"/> edge type key label set minimum cardinality, then
an exception condition is raised: <raise class="42" subclass="014"/>.
</item>

<comment>WG3:W26-022R2</comment>
<item>If the effective key label set of <sym>ETS</sym> is not <quote>omitted</quote> and 
the cardinality of the effective key label set of ETS is greater than
the <impDef code="IL003"/> edge type key label set maximum cardinality, then
an exception condition is raised: <raise class="42" subclass="015"/>.
</item>
<comment>WG3:W26-022R1 Removed 1 (one) Syntax Rule</comment>

<comment>WG3:W26-022R2</comment>
<comment>WG3:OHD-015</comment>
<comment>WG3:W24-027</comment>
<comment>WG3:W26-022R2</comment>
<item>If the cardinality of the label set of <sym>ETS</sym> is less than
the <impDef code="IL001"/> edge label set minimum cardinality, then
an exception condition is raised: <raise class="42" subclass="006"/>.
</item>

<comment>WG3:OHD-015</comment>
<comment>WG3:W24-027</comment>
<comment>WG3:W26-022R2</comment>
<item>If the cardinality of the label set of <sym>ETLS</sym> is greater than
the <impDef code="IL001"/> edge label set maximum cardinality, then
an exception condition is raised: <raise class="42" subclass="007"/>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The <newterm>property type set</newterm> of
an <BNF name="edge type specification"/> <symdef>AETS</symdef> is defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W26-022R2</comment>
<item>If <sym>AETS</sym> contains an <BNF name="edge type property types"/> <symdef>ETPTS</symdef>, 
then the property type set of <sym>AETS</sym> is the property type set that is specified by
the <BNF name="property types specification"/> that constitutes <sym>ETPTS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>Otherwise, no <BNF name="property types specification"/> is suitably specified and
the property type set of <sym>AETS</sym> is an empty property type set.
</item>

</olist>

</item>
<comment>WG3:W26-022R2 Removed 1 Syntax Rule</comment>

<comment>WG3:OHD-047</comment>
<comment>WG3:W24-027</comment>
<comment>WG3:W26-022R2</comment>
<item>If the cardinality of the property type set of <sym>ETS</sym> is greater than
the <impDef code="IL002"/> edge property set maximum cardinality, then
an exception condition is raised: <raise class="42" subclass="008"/>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The <newterm>source node type</newterm> of
an <BNF name="edge type specification"/> <symdef>AETS</symdef> is defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W26-022R2</comment>
<item>If the <BNF name="source node type reference"/> simply contained in <sym>AETS</sym> 
simply contains a <BNF name="source node type alias"/> <symdef>SNTA</symdef>, then:

<olist>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>AGTSB</symdef> be the <BNF name="graph type specification body"/> 
that simply contains <sym>AETS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<comment>WG3:W27-011</comment>
<item><sym>AGTSB</sym> shall simply contain a <BNF name="node type specification"/> whose
local node type alias is the same as the name specified by the <BNF name="regular identifier"/> 
that constitutes <sym>SNTA</sym>. 
Let <symdef>SNTS</symdef> be that <BNF name="node type specification"/>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The source node type of <sym>AETS</sym> is the node type specified by <sym>SNTS</sym>.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>If the <BNF name="source node type reference"/> simply contained in <sym>AETS</sym>
simply contains a <BNF name="node type key label set"/> <symdef>SNTKLS</symdef>, then:

<olist>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>AGTSB</symdef> be the <BNF name="graph type specification body"/> 
that simply contains <sym>AETS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item><sym>AGTSB</sym> shall simply contain a <BNF name="node type specification"/>
whose key label set is the same as the label set specified by
the <BNF name="label set phrase"/> simply contained in <sym>SNTKLS</sym>.
Let <symdef>SNT</symdef> be the node type specified by that <BNF name="node type specification"/>.
</item>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>SNTF</symdef> be the <BNF name="node type filler"/> simply contained in
the <BNF name="source node type reference"/> simply contained in <sym>AETS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>ISNT</symdef> be the constraining GQL-object type of the node reference value type
specified by the <BNF name="closed node reference value type"/>:
<code>
( <sym>SNTF</sym> )
</code>
</item>

<comment>WG3:W26-022R2</comment>
<item><sym>SNT</sym> and <sym>ISNT</sym> shall have the same normal form.
</item>

<comment>WG3:W26-022R2</comment>
<item>The source node type of <sym>AETS</sym> is <sym>SNT</sym>.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>Otherwise:

<olist>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>SNTF</symdef> be defined as follows:
If the <BNF name="source node type reference"/> simply contained in <symdef>AETS</symdef>
simply contains a <BNF name="node type filler"/>, then
<sym>SNTF</sym> is that <BNF name="node type filler"/>;
otherwise, <sym>SNTF</sym> is the zero-length character string.
</item>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>ISNT</symdef> be the constraining GQL-object type of
the node reference value type specified by the <BNF name="closed node reference value type"/>:
<code>
( <sym>SNTF</sym> )
</code>
</item>

<comment>WG3:W26-022R2</comment>
<item>The source node type of <sym>AETS</sym> is <sym>ISNT</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>The <newterm>destination node type</newterm> of
an <BNF name="edge type specification"/> <symdef>AETS</symdef> is defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W26-022R2</comment>
<item>If the <BNF name="destination node type reference"/> simply contained in <sym>AETS</sym> 
simply contains a <BNF name="destination node type alias"/> <symdef>DNTA</symdef>, then:

<olist>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>AGTSB</symdef> be the <BNF name="graph type specification body"/> 
that simply contains <sym>AETS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<comment>WG3:W27-011</comment>
<item><sym>AGTSB</sym> shall simply contain a <BNF name="node type specification"/> whose
local node type alias is the same as the name specified by the <BNF name="regular identifier"/>
that constitutes <sym>DNTA</sym>. 
Let <symdef>DNTS</symdef> be that <BNF name="node type specification"/>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The destination node type of <sym>AETS</sym> is the node type specified by <sym>DNTS</sym>.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>If the <BNF name="destination node type reference"/> simply contained in <sym>AETS</sym>
simply contains a <BNF name="node type key label set"/> <symdef>DNTKLS</symdef>, then:

<olist>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>AGTSB</symdef> be the <BNF name="graph type specification body"/>
that simply contains <sym>AETS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item><sym>AGTSB</sym> shall simply contain a <BNF name="node type specification"/>
whose key label set is the same as the label set specified by
the <BNF name="label set phrase"/> simply contained in <sym>DNTKLS</sym>.
Let <symdef>DNT</symdef> be the node type specified by that <BNF name="node type specification"/>.
</item>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>DNTF</symdef> be the <BNF name="node type filler"/> simply contained in
the <BNF name="destination node type reference"/> simply contained in <sym>AETS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>IDNT</symdef> be the constraining GQL-object type of the node reference value type
specified by the <BNF name="closed node reference value type"/>:
<code>
( <sym>DNTF</sym> )
</code>

</item>

<comment>WG3:W26-022R2</comment>
<item><sym>DNT</sym> and <sym>IDNT</sym> shall have the same normal form.
</item>

<comment>WG3:W26-022R2</comment>
<item>The destination node type of <sym>AETS</sym> is <sym>DNT</sym>.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>Otherwise:

<olist>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>DNTF</symdef> be defined as follows: 
If the <BNF name="destination node type reference"/> simply contained in <sym>AETS</sym>
simply contains a <BNF name="node type filler"/>, then
<sym>DNTF</sym> is that <BNF name="node type filler"/>;
otherwise, <sym>DNTF</sym> is the zero-length character string.
</item>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>IDNT</symdef> be the constraining GQL-object type of the node reference value type
specified by the <BNF name="closed node reference value type"/>:
<code>
( <sym>DNTF</sym> )
</code>
</item>

<comment>WG3:W26-022R2</comment>
<item>The destination node type of <sym>AETS</sym> is <sym>IDNT</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W26-022R2 Removed 1 (one) production</comment>

<comment>WG3:W26-022R2</comment>
<item><sym>ETS</sym> specifies an edge type as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W26-022R2</comment>
<item>If <sym>ETS</sym> simply contains an <BNF name="edge type pattern directed"/>, then
<sym>ETS</sym> specifies the directed edge type with:

<olist>

<comment>WG3:W26-022R2</comment>
<item>The edge type label set that is the label set of <sym>ETS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The edge type property type set that is the property type set of <sym>ETS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The source node type that is the source node type of <sym>ETS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The destination node type that is the destination node type of <sym>ETS</sym>.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>Otherwise, <sym>ETS</sym> simply contains an <BNF name="edge type pattern undirected"/> and
<sym>ETS</sym> specifies the undirected edge type with:

<olist>

<comment>WG3:W26-022R2</comment>
<item>The edge type label set that is the label set of <sym>ETS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The edge type property type set that is the property type set of <sym>ETS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The set of endpoint node types that is the set comprising
the source node type of <sym>ETS</sym> and the destination node type of <sym>ETS</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>For each edge type <symdef>ET</symdef>, there is an <impDef code="IV003"/> edge type,
<symdef>ETNF</symdef>(<sym>ET</sym>), known as the <newterm>normal form</newterm> of <sym>ET</sym> 
(which can be <sym>ET</sym> itself), such that:

<olist>

<comment>WG3:W26-022R2</comment>
<item>If <symdef>ET1</symdef> and <symdef>ET2</symdef> are two directed edge types that have
the same label sets, the same property names <symdef>PNS</symdef>, respective source node types
with the same normal form, and respective destination node types with the same normal form, and
for each property name <symdef>PN</symdef> from <sym>PNS</sym> it holds that
the value types of the respective property types of <sym>ET1</sym> and <sym>ET2</sym> whose name
is <sym>PN</sym> have the same normal form, then
<sym>ETNF</sym>(<sym>ET1</sym>) = <sym>ETNF</sym>(<sym>ET2</sym>).
</item>

<comment>WG3:W26-022R2</comment>
<item>If <symdef>ET1</symdef> and <symdef>ET2</symdef> are two undirected edge types that have
the same label sets, the same property names <symdef>PNS</symdef>, and the same sets of normal forms
of their respective endpoint node types, and
for each property name <symdef>PN</symdef> from <sym>PNS</sym> it holds that
the value types of the respective property types of <sym>ET1</sym> and <sym>ET2</sym> whose name
is <sym>PN</sym> have the same normal form, then
then <sym>ETNF</sym>(<sym>ET1</sym>) = <sym>ETNF</sym>(<sym>ET2</sym>).
</item>

<comment>WG3:W26-022R2</comment>
<item><sym>ETNF</sym>(<sym>ETNF</sym>(<sym>ET</sym>)) = <sym>ETNF</sym>(<sym>ET</sym>).
</item>

<comment>WG3:W26-022R2</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-09 Align with other normal forms</comment>
<item>The results of all invocations of <sym>ETNF</sym>(<sym>ET</sym>) are the same.

<comment>WG3:W26-022R2</comment>
<note>This ensures that all invocations of the <impDef code="IV003"/> choice of
the normal form of an edge type from amongst the equivalent edge types
are deterministic.
</note>
</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:BER-040R3</comment>
<comment>WG3:W24-027</comment>
<comment>WG3:W26-022R2</comment>
<item>An edge type descriptor is created for the edge type <symdef>ET</symdef>
specified by <sym>ETS</sym> that describes <sym>ET</sym> and comprises: 

<olist>

<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<item>The declared name of the primary base type of all edge types (EDGE DATA).

<note>See <specref ref="gql_conc_intro_obj_type"/>. 
</note>
</item>

<comment>WG3:W26-022R2</comment>
<item>The preferred name of <sym>ET</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The edge type label set of <sym>ET</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The edge type property type set of <sym>ET</sym>.
</item>

<item>Case:

<olist>

<comment>WG3:W22-051</comment>
<comment>WG3:W24-027</comment>
<comment>WG3:W26-022R2</comment>
<item>If <sym>ET</sym> is directed, then:

<olist>

<comment>WG3:W26-022R2</comment>
<item>The indication that the edge type is directed.
</item>

<comment>WG3:W24-027</comment>
<comment>WG3:W26-022R2</comment>
<item>The source node type of <sym>ET</sym>.
</item>

<comment>WG3:W24-027</comment>
<comment>WG3:W26-022R2</comment>
<item>The destination node type of <sym>ET</sym>.
</item>

</olist>

</item>

<comment>WG3:W26-022R2</comment>
<item>Otherwise:

<olist>

<comment>WG3:W26-022R2</comment>
<item>The indication that the edge type is undirected.
</item>

<comment>WG3:W26-022R2</comment>
<item>The set of endpoint node types of <sym>ET</sym>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W26-022R2 Removed 1 (one) General Rule</comment>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W09-036</comment>
<comment>WG3:W12-025</comment>
<comment>WG3:W22-051</comment>
<comment>WG3:W24-027</comment>
<comment>WG3:W26-022R2</comment>
<item>Without <feature code="GH02"/>, conforming GQL language shall not contain 
an <BNF name="edge type specification"/> that simply contains an <BNF name="edge kind"/> that is 
<kw>UNDIRECTED</kw>, an <BNF name="endpoint pair"/> that is 
an <BNF name="endpoint pair undirected"/>, or
an <BNF name="edge type pattern undirected"/>.
</item>
<comment>WG3:W26-022R2 Removed 1 (one) Conformance Rule</comment>

<comment>WG3:W26-022R2</comment>
<item>Without <feature code="GG20"/>, in conforming GQL language,
an <BNF name="edge type specification"/> shall not simply contain an <BNF name="edge type name"/>.
</item>

<comment>WG3:W26-022R2</comment>
<item>Without <feature code="GG21"/>, in conforming GQL language,
an <BNF name="edge type specification"/> shall not simply contain
an <BNF name="edge type key label set"/> or a <BNF name="node type key label set"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:MMX-028R2</comment>
<comment>WG3:UTC-042</comment>
<subClause id="gql_lbl_set_defn" newpage="true">
<clauseHeading><BNF name="label set phrase"/> and
<BNF name="label set specification"/></clauseHeading>

<bodyMatter>

<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-09 Align wording</comment>
<para>Specify label sets.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:RKE-027 P16-USA-747</comment>
<comment>WG3:W24-027</comment>
<comment>WG3:W25-013</comment>
<comment>WG3:W26-022R2</comment>
<BNFdef name="label set phrase">
<rhs>
<alt> <kw>LABEL</kw> <BNF name="label name"/> </alt>
<alt> <kw>LABELS</kw> <BNF name="label set specification"/> </alt>
<alt> <BNF name="is or colon"/> <BNF name="label set specification"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:RKE-027 P16-USA-747</comment>
<comment>WG3:BER-036</comment>
<comment>WG3:OHD-012</comment>
<comment>WG3:W25-026</comment>
<comment>WG3:W26-022R2</comment>
<BNFdef name="label set specification">
<rhs>
<BNF name="label name"/>
<opt> <group> <BNF name="ampersand"/> <BNF name="label name"/> </group><repeat/> </opt>
</rhs>
</BNFdef>

<comment>WG3:W25-013 Deleted 1 (one) production</comment>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:W26-022R2 Removed 2 Syntax Rules</comment>

<comment>WG3:W26-022R2</comment>
<item>If a <BNF name="label set phrase"/> <symdef>LSP</symdef> simply contains <kw>LABEL</kw> and
the <BNF name="label name"/> <symdef>LN</symdef>, then <sym>LSP</sym> is equivalent to:
<code>
:<sym>LN</sym>
</code>
</item>

<comment>WG3:W26-022R2</comment>
<item>Every <BNF name="label set phrase"/> <symdef>LSP</symdef> specifies
the label set specified by the implicit or explicit <BNF name="label set specification"/>
immediately contained in <sym>LSP</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>Every <BNF name="label set specification"/> <symdef>LSS</symdef> specifies
the set of distinct label names specified by the <BNF name="label name"/>s simply contained in 
<sym>LSS</sym>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:MMX-028R2</comment>
<comment>WG3:UTC-042</comment>
<subClause id="gql_prop_type_set_defn" newpage="true">
<clauseHeading><BNF name="property types specification"/></clauseHeading>

<bodyMatter>

<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-09 Align wording</comment>
<para>Specify property types.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:W26-022R2</comment>
<BNFdef name="property types specification">
<rhs>
<BNF name="left brace"/> <opt> <BNF name="property type list"/> </opt> 
<BNF name="right brace"/>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="property type list">
<rhs>
<BNF name="property type"/>
<opt> 
<group> <BNF name="comma"/> <BNF name="property type"/> </group><repeat/> 
</opt>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:W26-022R2 Removed 2 Syntax Rules</comment>

<comment>WG3:W26-022R2</comment>
<item>For every <BNF name="property type"/> <symdef>PT</symdef> simply contained in 
a <BNF name="property types specification"/> <symdef>PTSS</symdef>, the name of <sym>PT</sym> shall
be different from the name of every other <BNF name="property type"/> simply contained
in <sym>PTSS</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>Every <BNF name="property types specification"/> specifies the property types specified by
the <BNF name="property type list"/> that it immediately contains.

</item>

<comment>WG3:W26-022R2</comment>
<item>Every <BNF name="property type list"/> <symdef>PTL</symdef> specifies the property types
that are specified by the <BNF name="property type"/>s immediately contained in <sym>PTL</sym>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-042</comment>
<subClause id="gql_prop_type_def" newpage="true">
<clauseHeading><BNF name="property type"/></clauseHeading>

<bodyMatter>

<Function>

<para>Define a property type.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="property type">
<rhs>
<BNF name="property name"/> <opt> <BNF name="typed"/> </opt> <BNF name="property value type"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:W26-022R2 Removed 4 Syntax Rules</comment>

<comment>WG3:W26-022R2</comment>
<item>The <newterm>name</newterm> of a <BNF name="property type"/> <symdef>APT</symdef> is
the name specified by the <BNF name="property name"/> simply contained in <sym>APT</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<comment>Editorial: Stephen Cannan, 2024-04-13</comment>
<item>The value type of a <BNF name="property type"/> <symdef>APT</symdef> is
the value type specified by the <BNF name="property value type"/> simply contained
in <sym>APT</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>The property type specified by the <BNF name="property type"/> <symdef>TPT</symdef> is
the pair comprising the name of <sym>TPT</sym> and the value type of <sym>TPT</sym>.
</item>

<comment>WG3:W26-026R2</comment>
<item>The value type of the property type specified by a <BNF name="property type"/> shall be
a supported property value type.

<note>See <specref ref="gql_conc_props_and_spvts"/>.
</note>

</item>

</olist>

</SyntaxRules>


<GeneralRules>

<olist>

<item>A data type descriptor is created that describes the value type of the property type
being defined.
</item>

<item>A property type descriptor is created that describes the property type being defined. 
The property type descriptor includes the following:

<olist>

<item>The name of the property type.
</item>

<comment>Email from: Hannes Voigt, 2023-11-14 1807</comment>
<comment>WG3:W26-022R1 Consequence</comment>
<item>The value type of the property type.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<ConformanceRules>

<olist>

<item>Without <feature code="GV48"/>, conforming GQL language shall not contain 
a <BNF name="property type"/> that simply contains a <BNF name="record type"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-042</comment>
<subClause id="gql_prop_vt" newpage="true">
<clauseHeading><BNF name="property value type"/></clauseHeading>

<bodyMatter>

<Function>

<para>Specify a property value type.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="property value type">
<rhs>
<BNF name="value type"/>
</rhs>
</BNFdef>


</grammar>


</Format>


<SyntaxRules>

<olist>

<item>Let <symdef>PV</symdef> be the <BNF name="property value type"/>.
</item>

<item>Let <symdef>VT</symdef> be the <BNF name="value type"/> immediately contained in 
<sym>PV</sym>.
</item>

<item><sym>PV</sym> specifies the property value type that is specified by <sym>VT</sym>.
</item>

<item>The property value type specified by <sym>PV</sym> shall be a supported property value type.

<comment>WG3:UTC-098</comment>
<note>See <specref ref="gql_conc_props_and_spvts"/>, for the definition of supported property
value type.
</note>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-042</comment>
<subClause id="gql_btt" newpage="true">
<clauseHeading><BNF name="binding table type"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-10-11 Sketched binding table type literal</comment>
<bodyMatter>


<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<para>Define a binding table type.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:BER-040R3</comment>
<comment>WG3:W24-026R2</comment>
<BNFdef name="binding table type">
<rhs>
<opt> <kw>BINDING</kw> </opt> <kw>TABLE</kw> <BNF name="field types specification"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:W24-026R2</comment>
<item>Every <BNF name="binding table type"/> <symdef>BTT</symdef> specifies a material binding 
table type whose record type is the closed material record type whose field types are specified 
by the <BNF name="field types specification"/> immediately contained in <sym>BTT</sym>.
</item>

<comment>Additional change from discussion of WG3:W24-026R2</comment>
<comment>Editorial: Stefan Plantikow 2023-11-09 Consolidate impDef codes</comment>
<item>For each binding table type <sym>BTT</sym>, there is an <impDef code="IV003"/> 
binding table type, <symdef>BTNF</symdef>(<sym>BTT</sym>), known as
the <newterm>normal form</newterm> of <sym>BTT</sym> (which can be <sym>BTT</sym> itself),
such that:

<olist>

<item>If <symdef>BTT1</symdef> and <symdef>BTT2</symdef> are two binding table types whose 
record types have the same normal form and whose indications regarding the inclusion of the 
null value are the same, then <sym>BTNF</sym>(<sym>BTT1</sym>) = <sym>BTNF</sym>(<sym>BTT2</sym>).
</item>

<item><sym>BTNF</sym>(<sym>BTNF</sym>(<sym>BTT</sym>)) = <sym>BTNF</sym>(<sym>BTT</sym>).
</item>

<comment>Editorial: Stefan Plantikow, 2023-11-09 Align with other normal forms</comment>
<item>The results of all invocations of <sym>BTNF</sym>(<sym>BTT</sym>) are the same.

<comment>WG3:W26-022R2</comment>
<note>This ensures that all invocations of the <impDef code="IV003"/> choice of
the normal form of a binding table type from amongst the equivalent binding table types
are deterministic.
</note>
</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>Editorial: Stephen Cannan 2023-01-31 UTC-009 P00-USA-312</comment>
<item>Let <symdef>BTT</symdef> be the binding table type specified by 
<BNF name="binding table type"/>.
</item>

<item>A record data type descriptor for the record type <symdef>RT</symdef> of <sym>BTT</sym> is 
created that comprises:

<olist>

<item>The base type name of all record types (RECORD DATA).
</item>

<comment>WG3:CMN-057R1</comment>
<item>The indication that <sym>RT</sym> is closed.
</item>

<item>A field type descriptor for every <BNF name="field type"/> simply contained in 
<BNF name="binding table type"/>, according to the Syntax Rules and General Rules of 
<specref ref="gql_field_type"/>, applied to the <BNF name="field type"/>s in the order in which 
they were specified.
</item>

<comment>WG3:UTC-051</comment>
<item>The indication that <sym>RT</sym> excludes the null value.
</item>

</olist>

</item>

<item>A binding table data type descriptor is created that comprises:

<olist>

<item>The base type name of all binding table types (BINDING TABLE DATA).
</item>

<item>The record data type descriptor <sym>RT</sym>.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:UTC-042</comment>
<subClause id="gql_value_type" newpage="true">
<clauseHeading><BNF name="value type"/></clauseHeading>

<bodyMatter>


<Function>

<para>Specify a value type.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow 2020-02-09</comment>
<comment>Editorial: Stefan Plantikow 2020-03-11</comment>
<comment>Editorial: Stefan Plantikow 2020-10-09 Extracted from collection type</comment>
<comment>Editorial: Stefan Plantikow 2020-10-13 Added result object types here</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:BER-094R1</comment>
<comment>WG3:W22-036</comment>
<comment>WG3:W24-035R1</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:UTC-015</comment>
<BNFdef name="value type">
<rhs>
<alt> <BNF name="predefined type"/> </alt>
<alt> <BNF name="constructed value type"/> </alt>
<alt> <BNF name="dynamic union type"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-015</comment>
<BNFdef name="typed">
<rhs>
<alt br="no"> <BNF name="double colon"/> </alt> 
<alt br="no"> <kw>TYPED</kw> </alt>
</rhs>
</BNFdef>

<comment>WG3:W12-029: Stefan Plantikow 2021-06-20</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:W26-026R2</comment>
<comment>WG3:POS-011R1</comment>
<BNFdef name="predefined type">
<rhs>
<alt> <BNF name="boolean type"/> </alt>
<alt> <BNF name="character string type"/> </alt>
<alt> <BNF name="byte string type"/> </alt>
<alt> <BNF name="numeric type"/> </alt>
<alt> <BNF name="temporal type"/> </alt>
<alt> <BNF name="vector type"/> </alt>
<alt> <BNF name="reference value type"/> </alt>
<alt> <BNF name="immaterial value type"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W12-029: Stefan Plantikow 2021-06-20</comment>
<comment>WG3:UTC-051</comment>
<BNFdef name="boolean type">
<rhs>
<group> <alt br="no"> <kw>BOOL</kw> </alt> <alt br="no"> <kw>BOOLEAN</kw> </alt> </group>
<opt> <BNF name="not null"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:W12-029: Stefan Plantikow 2021-06-20</comment>
<comment>WG3:UTC-051</comment>
<comment>WG3:W26-026R2</comment>
<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<BNFdef name="character string type">
<rhs>
<alt>
<kw>STRING</kw> <opt> <BNF name="left paren"/> 
<opt> <BNF name="min length"/> <BNF name="comma"/> </opt> <BNF name="max length"/> 
<BNF name="right paren"/> </opt>
<breakindent/>
<opt> <BNF name="not null"/> </opt>
</alt>
<alt>
<kw>CHAR</kw> 
<opt> <BNF name="left paren"/> <BNF name="fixed length"/> <BNF name="right paren"/> </opt> 
<opt> <BNF name="not null"/> </opt>
</alt>
<alt>
<kw>VARCHAR</kw> 
<opt> <BNF name="left paren"/> <BNF name="max length"/> <BNF name="right paren"/> </opt> 
<opt> <BNF name="not null"/> </opt>
</alt>
</rhs>
</BNFdef>
<comment>WG3:W12-029: Stefan Plantikow 2021-06-20</comment>
<comment>WG3:W24-026R2</comment>
<comment>WG3:UTC-051</comment>
<BNFdef name="byte string type">
<rhs>
<alt>
<kw>BYTES</kw> <opt> <BNF name="left paren"/>
<opt> <BNF name="min length"/> <BNF name="comma"/> </opt> <BNF name="max length"/>
<BNF name="right paren"/> </opt>
<breakindent/>
<opt> <BNF name="not null"/> </opt>
</alt>
<alt>
<kw>BINARY</kw> 
<opt> <BNF name="left paren"/> <BNF name="fixed length"/> <BNF name="right paren"/> </opt>
<opt> <BNF name="not null"/> </opt>
</alt>
<alt>
<kw>VARBINARY</kw> 
<opt> <BNF name="left paren"/> <BNF name="max length"/> <BNF name="right paren"/> </opt>
<opt> <BNF name="not null"/> </opt>
</alt>
</rhs>
</BNFdef>

<comment>WG3:W12-029: Stefan Plantikow 2021-06-20</comment>
<comment>WG3:W24-026R2</comment>
<BNFdef name="min length">
<rhs>
<BNF name="unsigned integer"/>
</rhs>
</BNFdef>

<comment>WG3:W12-029: Stefan Plantikow 2021-06-20</comment>
<comment>WG3:W24-026R2</comment>
<BNFdef name="max length">
<rhs>
<BNF name="unsigned integer"/>
</rhs>
</BNFdef>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>WG3:W24-026R2</comment>
<BNFdef name="fixed length">
<rhs>
<BNF name="unsigned integer"/>
</rhs>
</BNFdef>

<BNFdef name="numeric type">
<rhs>
<alt> <BNF name="exact numeric type"/> </alt>
<alt> <BNF name="approximate numeric type"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="exact numeric type">
<rhs>
<alt> <BNF name="binary exact numeric type"/> </alt>
<alt> <BNF name="decimal exact numeric type"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>WG3:BER-067R1</comment>
<BNFdef name="binary exact numeric type">
<rhs>
<alt> <BNF name="signed binary exact numeric type"/> </alt>
<alt> <BNF name="unsigned binary exact numeric type"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10</comment>
<comment>WG3:BER-067R1</comment>
<comment>WG3:UTC-051</comment>
<comment>WG3:CMN-019 P00-USA-114</comment>
<comment>WG3:CMN-019 P00-USA-115</comment>
<BNFdef name="signed binary exact numeric type">
<rhs>
<alt> <kw>INT8</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>INT16</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>INT32</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>INT64</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>INT128</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>INT256</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>SMALLINT</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt>
<kw>INT</kw>
<opt> <BNF name="left paren"/> <BNF name="precision"/> <BNF name="right paren"/> </opt>
<opt> <BNF name="not null"/> </opt>
</alt>
<alt> <kw>BIGINT</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> 
<opt> <kw>SIGNED</kw> </opt> <BNF name="verbose binary exact numeric type"/> 
</alt>
</rhs>
</BNFdef>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10</comment>
<comment>WG3:BER-067R1</comment>
<comment>WG3:UTC-051</comment>
<comment>WG3:CMN-019 P00-USA-115</comment>
<BNFdef name="unsigned binary exact numeric type">
<rhs>
<alt> <kw>UINT8</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>UINT16</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>UINT32</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>UINT64</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>UINT128</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>UINT256</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>USMALLINT</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt>
<kw>UINT</kw>
<opt> <BNF name="left paren"/> <BNF name="precision"/> <BNF name="right paren"/> </opt>
<opt> <BNF name="not null"/> </opt>
</alt>
<alt> <kw>UBIGINT</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> 
<kw>UNSIGNED</kw> <BNF name="verbose binary exact numeric type"/> 
</alt>
</rhs>
</BNFdef>

<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10</comment>
<comment>WG3:BER-067R1</comment>
<comment>WG3:UTC-051</comment>
<BNFdef name="verbose binary exact numeric type">
<rhs>
<alt> <kw>INTEGER8</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>INTEGER16</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>INTEGER32</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>INTEGER64</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>INTEGER128</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>INTEGER256</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>SMALL</kw> <kw>INTEGER</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt>
<kw>INTEGER</kw>
<opt> <BNF name="left paren"/> <BNF name="precision"/> <BNF name="right paren"/> </opt>
<opt> <BNF name="not null"/> </opt>
</alt>
<alt> <kw>BIG</kw> <kw>INTEGER</kw> <opt> <BNF name="not null"/> </opt> </alt>
</rhs>
</BNFdef>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>Editorial: Stefan Plantikow, 2022-10-28 Correct application of WG3:W12-029</comment>
<comment>WG3:UTC-051</comment>
<BNFdef name="decimal exact numeric type">
<rhs>
<group> <alt br="no"> <kw>DECIMAL</kw> </alt> <alt br="no"> <kw>DEC</kw> </alt> </group>
<opt>
<BNF name="left paren"/> <BNF name="precision"/> 
<opt> <BNF name="comma"/> <BNF name="scale"/> </opt>
<BNF name="right paren"/>
<breakindent/>
<opt> <BNF name="not null"/> </opt> 
</opt>
</rhs>
</BNFdef>

<comment>WG3:MMX-011R1, 2020-06-14</comment>
<BNFdef name="precision">
<rhs>
<BNF name="unsigned decimal integer"/>
</rhs>
</BNFdef>

<comment>WG3:MMX-011R1, 2020-06-14</comment>
<BNFdef name="scale">
<rhs>
<BNF name="unsigned decimal integer"/>
</rhs>
</BNFdef>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>Email from: Keith Hare, 2021-12-09 2130</comment>
<comment>WG3:UTC-051</comment>
<BNFdef name="approximate numeric type">
<rhs>
<alt> <kw>FLOAT16</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>FLOAT32</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>FLOAT64</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>FLOAT128</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>FLOAT256</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt>
<kw>FLOAT</kw>
<opt>
<BNF name="left paren"/>
<BNF name="precision"/>
<opt> <BNF name="comma"/> <BNF name="scale"/> </opt>
<BNF name="right paren"/>
</opt>
<opt> <BNF name="not null"/> </opt>
</alt>
<alt> <kw>REAL</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt> <kw>DOUBLE</kw> <opt> <kw>PRECISION</kw> </opt> <opt> <BNF name="not null"/> </opt> </alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-051</comment>
<comment>WG3:UTC-117</comment>
<BNFdef name="temporal type">
<rhs>
<alt> <BNF name="temporal instant type"/> </alt>
<alt> <BNF name="temporal duration type"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-117</comment>
<BNFdef name="temporal instant type">
<rhs>
<alt> <BNF name="datetime type"/> </alt>
<alt> <BNF name="localdatetime type"/> </alt>
<alt> <BNF name="date type"/> </alt>
<alt> <BNF name="time type"/> </alt>
<alt> <BNF name="localtime type"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:CMN-048 Removed 1 (one) production</comment>

<comment>WG3:UTC-051</comment>
<comment>WG3:UTC-117</comment>
<BNFdef name="datetime type">
<rhs>
<alt><kw>ZONED</kw> <kw>DATETIME</kw> <opt> <BNF name="not null"/> </opt></alt>
<alt><kw>TIMESTAMP</kw> <kw>WITH</kw> <kw>TIME</kw> <kw>ZONE</kw> 
<opt> <BNF name="not null"/> </opt></alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-051</comment>
<comment>WG3:UTC-117</comment>
<BNFdef name="localdatetime type">
<rhs>
<alt><kw>LOCAL</kw> <kw>DATETIME</kw> <opt> <BNF name="not null"/> </opt></alt>
<alt>
<kw>TIMESTAMP</kw> <opt> <kw>WITHOUT</kw> <kw>TIME</kw> <kw>ZONE</kw> </opt> 
<opt> <BNF name="not null"/> </opt>
</alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-051</comment>
<comment>WG3:UTC-117</comment>
<BNFdef name="date type">
<rhs>
<kw>DATE</kw> <opt> <BNF name="not null"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:UTC-051</comment>
<comment>WG3:UTC-117</comment>
<BNFdef name="time type">
<rhs>
<alt><kw>ZONED</kw> <kw>TIME</kw> <opt> <BNF name="not null"/> </opt></alt>
<alt><kw>TIME</kw> <kw>WITH</kw> <kw>TIME</kw> <kw>ZONE</kw>
<opt> <BNF name="not null"/> </opt></alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-051</comment>
<comment>WG3:UTC-117</comment>
<BNFdef name="localtime type">
<rhs>
<alt><kw>LOCAL</kw> <kw>TIME</kw> <opt> <BNF name="not null"/> </opt></alt>
<alt><kw>TIME</kw> <kw>WITHOUT</kw> <kw>TIME</kw> <kw>ZONE</kw>
<opt> <BNF name="not null"/> </opt></alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-051</comment>
<comment>WG3:CMN-048</comment>
<BNFdef name="temporal duration type">
<rhs>
<kw>DURATION</kw>
<BNF name="left paren"/> <BNF name="temporal duration qualifier"/> <BNF name="right paren"/>
<opt> <BNF name="not null"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:CMN-048</comment>
<BNFdef name="temporal duration qualifier">
<rhs>
<alt><kw>YEAR</kw> <kw>TO</kw> <kw>MONTH</kw></alt>
<alt><kw>DAY</kw> <kw>TO</kw> <kw>SECOND</kw></alt>
</rhs>
</BNFdef>

<comment>WG3:POS-011R1</comment>
<BNFdef name="vector type">
<rhs>
<kw>VECTOR</kw>
<BNF name="left paren"/>
<BNF name="dimension"/>
<BNF name="comma"/>
<BNF name="coordinate type"/>
<BNF name="right paren"/>
<opt> <BNF name="not null"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:POS-011R1</comment>
<BNFdef name="dimension">
<rhs>
<BNF name="unsigned integer"/>
</rhs>
</BNFdef>

<comment>WG3:POS-011R1</comment>
<BNFdef name="coordinate type">
<rhs>
<alt><BNF name="numeric type"/></alt>
<alt><BNF name="vector-only numeric coordinate type"/></alt>
</rhs>
</BNFdef>

<comment>WG3:POS-011R1</comment>
<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<bar note="Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references"/>
<BNFdef name="vector-only numeric coordinate type">
<rhs>
<seeTheRules><itemref ref="gql_impDef_vect_num_coord_type" type="SR"/></seeTheRules>
</rhs>
</BNFdef>
<endbar/>

<comment>WG3:CMN-048</comment>
<ednote id="gql_PP371">Support for mixed duration types should be considered.

<para>See <PPref ref="PPgql371"/>.
</para>

</ednote>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-30</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:W22-051</comment>
<BNFdef name="reference value type">
<rhs>
<alt> <BNF name="graph reference value type"/> </alt>
<alt> <BNF name="binding table reference value type"/> </alt>
<alt> <BNF name="node reference value type"/> </alt>
<alt> <BNF name="edge reference value type"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W22-051</comment>
<comment>WG3:UTC-086R1</comment>
<BNFdef name="graph reference value type">
<rhs>
<alt> <BNF name="open graph reference value type"/> </alt>
<alt> <BNF name="closed graph reference value type"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W22-051</comment>
<comment>WG3:UTC-086R1</comment>
<comment>WG3:UTC-051</comment>
<comment>WG3:W25-025</comment>
<BNFdef name="closed graph reference value type">
<rhs>
<opt> <kw>PROPERTY</kw> </opt> <kw>GRAPH</kw> <BNF name="nested graph type specification"/> 
<opt> <BNF name="not null"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:W22-051</comment>
<comment>WG3:W23-029R1</comment>
<comment>WG3:W25-025</comment>
<comment>WG3:SYX-021 USA-001 and NLD-002</comment>
<BNFdef name="open graph reference value type">
<rhs>
<opt> <kw>ANY</kw> </opt> <opt> <kw>PROPERTY</kw> </opt> <kw>GRAPH</kw> 
<opt> <BNF name="not null"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:W22-051</comment>
<BNFdef name="binding table reference value type">
<rhs>
<BNF name="binding table type"/> <opt> <BNF name="not null"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-086R1</comment>
<BNFdef name="node reference value type">
<rhs>
<alt> <BNF name="open node reference value type"/> </alt>
<alt> <BNF name="closed node reference value type"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-086R1</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:UTC-051</comment>
<comment>WG3:W26-022R2</comment>
<BNFdef name="closed node reference value type">
<rhs>
<BNF name="node type specification"/> <opt> <BNF name="not null"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-051</comment>
<comment>WG3:W25-025</comment>
<BNFdef name="open node reference value type">
<rhs>
<opt> <kw>ANY</kw> </opt> <BNF name="node synonym"/> <opt> <BNF name="not null"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-086R1</comment>
<BNFdef name="edge reference value type">
<rhs>
<alt> <BNF name="open edge reference value type"/> </alt>
<alt> <BNF name="closed edge reference value type"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-086R1</comment>
<comment>WG3:UTC-086R1</comment>
<comment>WG3:W26-022R2</comment>
<BNFdef name="closed edge reference value type">
<rhs>
<BNF name="edge type specification"/> <opt> <BNF name="not null"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:W25-025</comment>
<BNFdef name="open edge reference value type">
<rhs>
<opt> <kw>ANY</kw> </opt> <BNF name="edge synonym"/> <opt> <BNF name="not null"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:W26-026R2</comment>
<comment>Email from: Hannes Voigt, 2024-06-05 1604 moved three productions</comment>
<BNFdef name="immaterial value type">
<rhs>
<alt> <BNF name="null type"/> </alt>
<alt> <BNF name="empty type"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W26-026R2</comment>
<BNFdef name="null type">
<rhs>
<kw>NULL</kw>
</rhs>
</BNFdef>

<comment>WG3:W26-026R2</comment>
<BNFdef name="empty type">
<rhs>
<alt> <kw>NULL</kw> <BNF name="not null"/> </alt>
<alt> <kw>NOTHING</kw> </alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-015</comment>
<comment>WG3:UTC-015</comment>
<BNFdef name="constructed value type">
<rhs>
<alt> <BNF name="path value type"/> </alt>
<alt> <BNF name="list value type"/> </alt>
<alt> <BNF name="record type"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W24-035R1</comment>
<comment>WG3:UTC-051</comment>
<BNFdef name="path value type">
<rhs>
<kw>PATH</kw> <opt> <BNF name="not null"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:W24-026R2</comment>
<comment>Editorial: Stefan Plantikow, 2023-01-06 Correct grammar mistake</comment>
<comment>WG3:UTC-051</comment>
<comment>WG3:CMN-057R1</comment>
<BNFdef name="list value type">
<rhs>
<group>
<alt> <BNF name="list value type name"/> 
<BNF name="left angle bracket"/> <BNF name="value type"/> <BNF name="right angle bracket"/> 
</alt>
<alt> <opt> <BNF name="value type"/> </opt> <BNF name="list value type name"/> </alt>
</group>
<opt> <BNF name="left bracket"/> <BNF name="max length"/> <BNF name="right bracket"/> </opt>
<opt> <BNF name="not null"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:UTC-123R2</comment>
<BNFdef name="list value type name">
<rhs>
<opt> <kw>GROUP</kw> </opt> <BNF name="list value type name synonym"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-123R2</comment>
<BNFdef name="list value type name synonym">
<rhs>
<alt br="no"> <kw>LIST</kw> </alt> <alt br="no"> <kw>ARRAY</kw> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stephen Cannan, 2020-05-21 Remove cyclic and duplicate BNFdefs</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-09 Added record type</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:W24-026R2</comment>
<comment>WG3:W25-025</comment>
<BNFdef name="record type">
<rhs>
<alt> <opt> <kw>ANY</kw> </opt> <kw>RECORD</kw> <opt> <BNF name="not null"/> </opt> </alt>
<alt>
<opt> <kw>RECORD</kw> </opt> <BNF name="field types specification"/> 
<opt> <BNF name="not null"/> </opt> 
</alt>
</rhs>
</BNFdef>

<comment>WG3:BER-040R3</comment>
<comment>WG3:W24-026R2</comment>
<BNFdef name="field types specification">
<rhs>
<BNF name="left brace"/> <opt> <BNF name="field type list"/> </opt> <BNF name="right brace"/>
</rhs>
</BNFdef>

<BNFdef name="field type list">
<rhs>
<BNF name="field type"/>
<opt> <group> <BNF name="comma"/> <BNF name="field type"/> </group><repeat/> </opt>
</rhs>
</BNFdef>

<comment>WG3:UTC-015</comment>
<BNFdef name="dynamic union type">
<rhs>
<alt> <BNF name="open dynamic union type"/> </alt>
<alt> <BNF name="dynamic property value type"/> </alt>
<alt> <BNF name="closed dynamic union type"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-051</comment>
<comment>WG3:W25-025</comment>
<BNFdef name="open dynamic union type">
<rhs>
<kw>ANY</kw> <opt> <kw>VALUE</kw> </opt> <opt> <BNF name="not null"/> </opt> 
</rhs>
</BNFdef>

<comment>WG3:UTC-051</comment>
<BNFdef name="dynamic property value type">
<rhs>
<opt> <kw>ANY</kw> </opt> <kw>PROPERTY</kw> <kw>VALUE</kw> <opt> <BNF name="not null"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:W25-025</comment>
<BNFdef name="closed dynamic union type">
<rhs>
<alt>
<kw>ANY</kw> <opt> <kw>VALUE</kw> </opt>
<BNF name="left angle bracket"/> <BNF name="component type list"/> <BNF name="right angle bracket"/>
</alt>
<alt> <BNF name="component type list"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="component type list">
<rhs>
<BNF name="component type"/> 
<opt> <group> <BNF name="vertical bar"/> <BNF name="component type"/> </group><repeat/> </opt>
</rhs>
</BNFdef>

<BNFdef name="component type">
<rhs>
<BNF name="value type"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-051</comment>
<BNFdef name="not null">
<rhs>
<kw>NOT</kw> <kw>NULL</kw>
</rhs>
</BNFdef>

</grammar>

<comment>Email from: Hannes Voigt, 2024-12-06 0834</comment>
<ednote id="PPgql442_1">Disallowing <BNF name="component type list"/>s that specify only one type
should be considered.
See <PPref ref="PPgql442"/>.
</ednote>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:BER-040R3</comment>
<comment>WG3:CMN-035</comment>
<item>Every <BNF name="value type"/> specifies the value type that is the 
data type specified by the immediately contained BNF non-terminal instance.
</item>

<comment>WG3:CMN-035</comment>
<item>Every <BNF name="predefined type"/> specifies the data type specified by the immediately 
contained BNF non-terminal instance.
</item>

<comment>WG3:W22-051</comment>
<item>Every <BNF name="reference value type"/> specifies the 
reference value type that is the data type specified by the immediately 
contained <BNF name="graph reference value type"/>,
<BNF name="binding table reference value type"/>, <BNF name="node reference value type"/>, or
<BNF name="edge reference value type"/>.
</item>

<comment>WG3:UTC-051</comment>
<comment>WG3:UTC-051 and WG3:UTC-015</comment>
<item>The nullability specified by a BNF non-terminal instance <symdef>NT</symdef> that is 
a <BNF name="value type"/> but not a <BNF name="closed dynamic union type"/> is defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>NT</sym> contains <BNF name="not null"/> without an intervening instance of 
<BNF name="value type"/>, then <sym>NT</sym> specifies known not nullable.
</item>

<comment>WG3:W26-026R2</comment>
<item>If <sym>NT</sym> is <kw>NOTHING</kw>, then <sym>NT</sym> specifies known not nullable.
</item>

<item>Otherwise, <sym>NT</sym> specifies possibly nullable.
</item>

</olist>

<note>See <specref ref="gql_conc_nullability"/>.
</note>

</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>WG3:UTC-051</comment>
<item>Every <BNF name="boolean type"/> <symdef>BT</symdef> specifies the 
<newterm>Boolean type</newterm> with the nullability specified by <sym>BT</sym>.
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>WG3:UTC-051</comment>
<comment>Editorial: Stefan Plantikow, 2023-08-28 Add impdef code</comment>
<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<item>For each Boolean type <symdef>BT</symdef>, there is an <impDef code="IV008"/> Boolean type
<symdef>BNF</symdef>(<sym>BT</sym>), known as the <newterm>normal form</newterm> of <sym>BT</sym>
(which can be <sym>BT</sym> itself), such that:

<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<olist>

<item>The nullability of <sym>BNF</sym>(<sym>BT</sym>) is the nullability of <sym>BT</sym>.
</item>

<item>The declared name of <sym>BNF</sym>(<sym>BT</sym>) is the preferred name of Boolean types.
</item>

<item>All invocations of <sym>BNF</sym>(<sym>BT</sym>) are the same.

<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<note>This ensures that all invocations of the <impDef code="IV003"/> choice of
the normal form of a Boolean type from amongst the equivalent Boolean types are deterministic.
</note>

</item>

</olist>

</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<item>The value of every <BNF name="max length"/> shall be greater than or equal to 1 (one).
</item>

<comment>WG3:W26-026R2</comment>
<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10</comment>
<item>The value of every <BNF name="min length"/> shall be greater than or equal to 0 (zero).
</item>

<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10</comment>
<item>If <BNF name="min length"/> is omitted, then a <BNF name="min length"/> of 0 (zero) is
implicit.
</item>

<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10</comment>
<item>The value of every <BNF name="fixed length"/> shall be greater than or equal to 1 (one).
</item>

<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10</comment>
<item>If <BNF name="fixed length"/> is omitted, then a <BNF name="fixed length"/> of 1 (one) is
implicit.
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>WG3:UTC-051</comment>
<item>Every <BNF name="character string type"/> <symdef>CST</symdef> specifies the 
<newterm>character string type</newterm> with the nullability specified by <sym>CST</sym>.
</item>

<comment>WG3:W26-026R2</comment>
<item>If both <BNF name="min length"/> <symdef>MINL</symdef> and  <BNF name="max length"/> 
<symdef>MAXL</symdef> are specified or implicit in a <BNF name="character string type"/>, then 
<sym>MINL</sym> shall be less than or equal to <sym>MAXL</sym>.
</item>

<comment>WG3:W26-026R2</comment>
<item>If <BNF name="min length"/> <symdef>CSMINL</symdef> is specified or implicit in 
a <BNF name="character string type"/> <symdef>CST</symdef>, then the minimum length of the 
character string type specified by <sym>CST</sym> is the value of <sym>CSMINL</sym>.
</item>

<comment>WG3:W26-026R2</comment>
<item>If <BNF name="max length"/> <symdef>CSMAL</symdef> is specified in 
a <BNF name="character string type"/> <symdef>CST</symdef>, then the maximum length of the 
character string type specified by <sym>CST</sym> is the value of <sym>CSMAXL</sym>.
</item>

<comment>WG3:W26-026R2</comment>
<item>If <BNF name="fixed length"/> <symdef>CSFIXL</symdef> is specified or implicit in 
a <BNF name="character string type"/> <symdef>CST</symdef>, then the minimum length of the 
character string type specified by <sym>CST</sym> is the value of <sym>CSFIXL</sym> and the
maximum length of the character string type specified by <sym>CST</sym> is the value of 
<sym>CSFIXL</sym>.
</item>

<comment>WG3:W26-026R2</comment>
<item id="gql_value_type_maxlen_SR">If neither <BNF name="max length"/> nor 
<BNF name="fixed length"/> are specified or implicit in a <BNF name="character string type"/> 
<symdef>CST</symdef>, then the maximum length of the character string type specified by 
<sym>CST</sym> is <impDef code="IL013"/> but shall be greater than or equal to
2<super>14</super>&minus;1 = 16383 characters.
</item>

<comment>WG3:W26-026R2</comment>
<item>For each character string type <symdef>CST</symdef>, there is an <impDef code="IV008"/> 
character string type <symdef>CSNF</symdef>(<sym>CST</sym>), known as
the <newterm>normal form</newterm> of <sym>CST</sym> (which can be <sym>CST</sym> itself),
such that <sym>CSNF</sym>(<sym>CST</sym>) and <sym>CST</sym> have the same minimum length and
the same maximum length and the nullability of <sym>CSNF</sym>(<sym>CST</sym>) is
the nullability of <sym>CST</sym> and

<para>Case:
</para>

<olist>

<item>If <sym>CST</sym> is a fixed-length character string type, then:

<olist>

<item>The declared name of <sym>CSNF</sym>(<sym>CST</sym>) is the preferred name of 
fixed-length character string types.
</item>

<item>All invocations of <sym>CSNF</sym>(<sym>CST</sym>) are the same.

<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<note>This ensures that all invocations of the <impDef code="IV003"/> choice of
the normal form of a fixed-length character string type from amongst the equivalent 
fixed-length character string types are deterministic.
</note>

</item>

</olist>

</item>

<item>If <sym>CST</sym> is a variable-length character string type, then:

<olist>

<item>The declared name of <sym>CSNF</sym>(<sym>CST</sym>) is the preferred name of 
variable-length character string types.
</item>

<item>All invocations of <sym>CSNF</sym>(<sym>CST</sym>) are the same.

<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<note>This ensures that all invocations of the <impDef code="IV003"/> choice of the normal form of
a variable-length character string type from amongst the equivalent 
variable-length character string types are deterministic.
</note>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W26-026R2</comment>
<item>The material values of a character string type with minimum length <symdef>CSMINL</symdef> 
and maximum length <symdef>CSMAXL</symdef> are the character strings whose length is both 
greater than or equal to <sym>CSMINL</sym> and less than or equal to <sym>CSMAXL</sym>.
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>WG3:UTC-051</comment>
<item>Every <BNF name="byte string type"/> <symdef>BST</symdef> specifies the 
<newterm>byte string type</newterm> with the nullability specified by <sym>BST</sym>.
</item>

<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10</comment>
<comment>WG3:W26-026R2</comment>
<item>If both <BNF name="min length"/> <symdef>MINL</symdef> and <BNF name="max length"/>
<symdef>MAXL</symdef> are specified or implicit in a <BNF name="byte string type"/>, then 
<sym>MINL</sym> shall be less than or equal to <sym>MAXL</sym>.
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10</comment>
<item>If <BNF name="min length"/> <symdef>BSMINL</symdef> is specified or implicit in 
a <BNF name="byte string type"/> <symdef>BST</symdef>, then the minimum length of the
byte string type specified by <sym>BST</sym> is the value of <sym>BSMINL</sym>.
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10</comment>
<comment>Editorial: Stefan Plantikow, 2021-08-10 Corrected WG3:W14-014</comment>
<item>If <BNF name="max length"/> <symdef>BSMAXL</symdef> is specified in 
a <BNF name="byte string type"/> <symdef>BST</symdef>, then the maximum length of the
byte string type specified by <sym>BST</sym> is the value of <sym>BSMAXL</sym>.
</item>

<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10</comment>
<item>If <BNF name="fixed length"/> <symdef>BSFIXL</symdef> is specified or implicit in 
a <BNF name="byte string type"/> <symdef>BST</symdef>, then the minimum length of the byte string
type specified by <sym>BST</sym> is the value of <sym>BSFIXL</sym> and the maximum length of
the byte string type specified by <sym>BST</sym> is the value of <sym>BSFIXL</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2021-08-10 Corrected WG3:W14-014</comment>
<comment>Editorial: Stefan Plantikow, 2022-11-22 WG3:W23-009R1 956. P00-USA-452</comment>
<item>If neither <BNF name="max length"/> nor <BNF name="fixed length"/> are specified or implicit 
in a <BNF name="byte string type"/> <symdef>BST</symdef>, then the maximum length of 
the byte string type specified by <sym>BST</sym> is <impDef code="IL013"/> but 
shall be greater than or equal to 2<super>16</super>-2 = 65534 bytes.
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>WG3:UTC-051</comment>
<comment>Editorial: Stefan Plantikow, 2023-08-28 Add impdef code</comment>
<item>For each byte string type <symdef>BST</symdef>, there is an <impDef code="IV008"/> 
byte string type <symdef>BSNF</symdef>(<sym>BST</sym>), known as the <newterm>normal form</newterm>
of <sym>BST</sym> (which can be <sym>BST</sym> itself), such that <sym>BSNF</sym>(<sym>BST</sym>)
and <sym>BST</sym> have the same minimum length and the same maximum length and the nullability
of <sym>BSNF</sym>(<sym>BST</sym>) is the nullability of <sym>BST</sym>.

<comment>Editorial: Stefan Plantikow, 2021-06-22 Case: all the things</comment>
<para>Case:
</para>

<olist>

<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<item>If <sym>BST</sym> is a fixed-length byte string type, then:

<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<olist>

<item>The declared name of <sym>BSNF</sym>(<sym>BST</sym>) is the preferred name of 
fixed-length byte string types.
</item>

<item>All invocations of <sym>BSNF</sym>(<sym>BST</sym>) are the same.

<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<note>This ensures that all invocations of the <impDef code="IV003"/> choice of the normal form of
a fixed-length byte string type from amongst the equivalent fixed-length byte string types are 
deterministic.
</note>

</item>

</olist>

</item>

<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<item>If <sym>BST</sym> is a variable-length byte string type, then:

<olist>

<item>The declared name of <sym>BSNF</sym>(<sym>BST</sym>) is the preferred name of 
variable-length byte string types.
</item>

<item>All invocations of <sym>BSNF</sym>(<sym>BST</sym>) are the same.

<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<note>This ensures that all invocations of the <impDef code="IV003"/> choice of the normal form 
of a variable-length byte string type from amongst the equivalent 
variable-length byte string types are deterministic.
</note>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>WG3:W26-026R2</comment>
<item>The material values of a byte string type with minimum length <symdef>BSMINL</symdef> and 
maximum length <symdef>BSMAXL</symdef> are the byte strings whose length is both greater than or 
equal to <sym>BSMINL</sym> and less than or equal to <sym>BSMAXL</sym>.
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<item>The minimum length of every byte string type <symdef>BST</symdef> shall be less than or equal
to the maximum length of <sym>BST</sym>.
</item>
<comment>WG3:W23-009R1 956. P00-USA-452 removed one SR</comment>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<item>The value of every <BNF name="precision"/> shall be greater than or equal to 1 (one).
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<item>Every <BNF name="numeric type"/> specifies the <newterm>numeric type</newterm> specified by
the immediately contained <BNF name="exact numeric type"/> or the immediately contained
<BNF name="approximate numeric type"/>.
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<item>For each exact numeric type <symdef>ENT</symdef>, there is 
an <impDef code="IV008"/> exact numeric type <symdef>ENNF</symdef>(<sym>ENT</sym>), 
known as the <newterm>normal form</newterm> of <sym>ENT</sym> 
(which can be <sym>ENT</sym> itself), such that:

<olist>

<item>If <symdef>ENT1</symdef> and <symdef>ENT2</symdef> are exact numeric types whose declared
names individually are either <kw>SIGNED</kw> INTEGER, <kw>INTEGER</kw>, or <kw>INT</kw>, then
<sym>ENNF</sym>(<sym>ENT1</sym>) is the same as <sym>ENNF</sym>(<sym>ENT2</sym>). 
</item>

<comment>WG3:BER-067R1</comment>
<item>If <symdef>ENT1</symdef> and <symdef>ENT2</symdef> are exact numeric types whose declared 
names individually are either <kw>SIGNED</kw> <kw>SMALL</kw> <kw>INTEGER</kw>, 
<kw>SMALL</kw> <kw>INTEGER</kw>, or <kw>SMALLINT</kw>, then 
<sym>ENNF</sym>(<sym>ENT1</sym>) is the same as <sym>ENNF</sym>(<sym>ENT2</sym>).
</item>

<comment>WG3:BER-067R1</comment>
<item>If <symdef>ENT1</symdef> and <symdef>ENT2</symdef> are exact numeric types whose declared 
names individually are either <kw>SIGNED</kw> <kw>BIG</kw> <kw>INTEGER</kw>, 
<kw>BIG</kw> <kw>INTEGER</kw>, or <kw>BIGINT</kw>, then 
<sym>ENNF</sym>(<sym>ENT1</sym>) is the same as <sym>ENNF</sym>(<sym>ENT2</sym>).
</item>

<item>For each <symdef>p</symdef> from the set {16, 32, 64, 128, 256}, if <symdef>ENT1</symdef> and
<symdef>ENT2</symdef> are exact numeric types whose declared names individually are either
<kw>SIGNED</kw> <kw>INTEGER</kw><sym>p</sym>, <kw>INTEGER</kw><sym>p</sym>, or
<kw>INT</kw><sym>p</sym>, then <sym>ENNF</sym>(<sym>ENT1</sym>) is the same as
<sym>ENNF</sym>(<sym>ENT2</sym>).
</item>

<item>If <symdef>ENT1</symdef> and <symdef>ENT2</symdef> are exact numeric types whose declared
names individually are either <kw>UNSIGNED</kw> <kw>INTEGER</kw> or <kw>UINT</kw>, then
<sym>ENNF</sym>(<sym>ENT1</sym>) is the same as <sym>ENNF</sym>(<sym>ENT2</sym>). 
</item>

<comment>WG3:BER-067R1</comment>
<item>If <symdef>ENT1</symdef> and <symdef>ENT2</symdef> are exact numeric types whose declared 
names individually are either <kw>UNSIGNED</kw> <kw>SMALL</kw> <kw>INTEGER</kw>, 
or <kw>USMALLINT</kw>, then 
<sym>ENNF</sym>(<sym>ENT1</sym>) is the same as <sym>ENNF</sym>(<sym>ENT2</sym>).
</item>

<comment>WG3:BER-067R1</comment>
<item>If <symdef>ENT1</symdef> and <symdef>ENT2</symdef> are exact numeric types whose declared 
names individually are either <kw>UNSIGNED</kw> <kw>BIG</kw> <kw>INTEGER</kw>, 
or <kw>UBIGINT</kw>, then 
<sym>ENNF</sym>(<sym>ENT1</sym>) is the same as <sym>ENNF</sym>(<sym>ENT2</sym>).
</item>

<item>For each <sym>p</sym> from the set {16, 32, 64, 128, 256}, if <symdef>ENT1</symdef> and
<symdef>ENT2</symdef> are exact numeric types whose declared names individually are either
<kw>UNSIGNED</kw> <kw>INTEGER</kw><sym>p</sym> or <kw>UINT</kw><sym>p</sym>, then
<sym>ENNF</sym>(<sym>ENT1</sym>) is the same as <sym>ENNF</sym>(<sym>ENT2</sym>).
</item>

<item>If <symdef>ENT1</symdef> and <symdef>ENT2</symdef> are exact numeric types whose declared
names individually are either <kw>DEC</kw> or <kw>DECIMAL</kw>, then
<sym>ENNF</sym>(<sym>ENT1</sym>) is the same as <sym>ENNF</sym>(<sym>ENT2</sym>).
</item>

<item>The precision, scale, and radix of <sym>ENNF</sym>(<sym>ENT</sym>) are the same as the
precision, scale, and radix, respectively, of <sym>ENT</sym>.

<note>The precision, scale, and radix are determined when an exact numeric type is specified prior
to the construction of its descriptor.
</note>
</item>

<comment>WG3:UTC-051</comment>
<item>The nullability of <sym>ENNF</sym>(<sym>ENT</sym>) is the nullability of <sym>ENT</sym>.
</item>

<item><sym>ENNF</sym>(<sym>ENNF</sym>(<sym>ENT</sym>)) = <sym>ENNF</sym>(<sym>ENT</sym>).
</item>

<comment>WG3:CMN-043</comment>
<item>The results of all invocations of <sym>ENNF</sym>(<sym>ENT</sym>) are the same.

<note>This ensures that all invocations of the <impDef code="IV008"/> choice of the normal form 
of an exact numeric type from amongst the equivalent exact numeric types are deterministic.
</note>

</item>

</olist>

</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<item>For the <BNF name="exact numeric type"/>s:

<olist>

<item>The maximum value of a <BNF name="precision"/> is <impDef code="IL011"/>.
<BNF name="precision"/> shall not be greater than this value.
</item>

<item>The maximum value of a <BNF name="scale"/> is <impDef code="IL011"/>.
<BNF name="scale"/> shall not be greater than this maximum value.
</item>

</olist>

</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<item>Every <BNF name="exact numeric type"/> specifies the <newterm>exact numeric type</newterm>
specified by the immediately contained <BNF name="binary exact numeric type"/> or the immediately
contained <BNF name="decimal exact numeric type"/>.
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>WG3:BER-067R1</comment>
<item>Every<BNF name="binary exact numeric type"/> specifies the 
<newterm>binary exact numeric type</newterm> specified by the immediately contained 
<BNF name="signed binary exact numeric type"/> or the immediately contained 
<BNF name="unsigned binary exact numeric type"/>. 
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<comment>WG3:BER-067R1</comment>
<item>Every <BNF name="signed binary exact numeric type"/> <symdef>BESNT</symdef> specifies 
a <newterm>signed binary exact numeric type</newterm>.

<para>Case:
</para>

<comment>WG3:UTC-051</comment>
<olist>

<item>If <sym>BESNT</sym> starts with <kw>SIGNED</kw> <kw>INTEGER8</kw>, <kw>INTEGER8</kw>, or 
<kw>INT8</kw>, then <sym>BESNT</sym> specifies the <newterm>signed 8-bit integer type</newterm>
with precision of 7 and with scale 0 (zero) and with the nullability specified by <sym>BESNT</sym>. 
</item>

<item>If <sym>BESNT</sym> starts with <kw>SIGNED</kw> <kw>INTEGER16</kw>, <kw>INTEGER16</kw>, or
<kw>INT16</kw>, then <sym>BESNT</sym> specifies the <newterm>signed 16-bit integer type</newterm>
with precision of 15 and with scale 0 (zero) and with the nullability specified by 
<sym>BESNT</sym>. 
</item>

<item>If <sym>BESNT</sym> starts with <kw>SIGNED</kw> <kw>INTEGER32</kw>, <kw>INTEGER32</kw>, or
<kw>INT32</kw>, then <sym>BESNT</sym> specifies the <newterm>signed 32-bit integer type</newterm>
with precision of 31 and with scale 0 (zero) and with the nullability specified by 
<sym>BESNT</sym>. 
</item>

<item>If <sym>BESNT</sym> starts with <kw>SIGNED</kw> <kw>INTEGER64</kw>, <kw>INTEGER64</kw>, or
<kw>INT64</kw>, then <sym>BESNT</sym> specifies the <newterm>signed 64-bit integer type</newterm>
with precision of 63 and with scale 0 (zero) and with the nullability specified by 
<sym>BESNT</sym>. 
</item>

<item>If <sym>BESNT</sym> starts with <kw>SIGNED</kw> <kw>INTEGER128</kw>, <kw>INTEGER128</kw>, or
<kw>INT128</kw>, then <sym>BESNT</sym> specifies the <newterm>signed 128-bit integer type</newterm>
with precision of 127 and with scale 0 (zero) and with the nullability specified by 
<sym>BESNT</sym>. 
</item>

<item>If <sym>BESNT</sym> starts with <kw>SIGNED</kw> <kw>INTEGER256</kw>, <kw>INTEGER256</kw>, or
<kw>INT256</kw>, then <sym>BESNT</sym> specifies the <newterm>signed 256-bit integer type</newterm>
with precision of 255 and with scale 0 (zero) and with the nullability specified by 
<sym>BESNT</sym>. 
</item>

<item>If <sym>BESNT</sym> starts with <kw>SIGNED</kw> <kw>INTEGER</kw>, <kw>INTEGER</kw>, or 
<kw>INT</kw>, then <sym>BESNT</sym> specifies the <newterm>signed regular integer type</newterm> 
with <impDef code="ID028"/> precision greater than or equal to 31 and with scale 0 (zero) and with 
the nullability specified by <sym>BESNT</sym>.
</item>

<item>If <sym>BESNT</sym> starts with <kw>SIGNED</kw> <kw>SMALL</kw> <kw>INTEGER</kw>, 
<kw>SMALL</kw> <kw>INTEGER</kw>, or <kw>SMALLINT</kw>, then <sym>BESNT</sym> specifies the
<newterm>signed small integer type</newterm> with <impDef code="ID028"/> precision less than
or equal to the precision of the signed regular integer type and with scale 0 (zero) and with the 
nullability specified by <sym>BESNT</sym>.
</item>

<item>If <sym>BESNT</sym> starts with <kw>SIGNED</kw> <kw>BIG</kw> <kw>INTEGER</kw>, 
<kw>BIG</kw> <kw>INTEGER</kw>, or <kw>BIGINT</kw>, then <sym>BESNT</sym> specifies the
<newterm>signed big integer type</newterm> with <impDef code="ID028"/> precision greater than or
equal to the precision of the signed regular integer type and with scale 0 (zero) and with the 
nullability specified by <sym>BESNT</sym>.
</item>

<item>Otherwise, <sym>BESNT</sym> specifies the
<newterm>signed user-specified integer type</newterm> with <impDef code="ID028"/> precision greater
than or equal to the value of the <BNF name="precision"/> immediately contained in
<sym>BESNT</sym> as its binary precision in bits and with scale 0 (zero) and with the nullability
specified by <sym>BESNT</sym>.
</item>

</olist>

</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<item>Every <BNF name="unsigned binary exact numeric type"/> <symdef>BEUNT</symdef> specifies 
an <newterm>unsigned binary exact numeric type</newterm>.

<para>Case:
</para>

<comment>WG3:BER-067R1</comment>
<comment>WG3:W26-023</comment>
<olist>

<item>If <sym>BEUNT</sym> starts with <kw>UNSIGNED</kw> <kw>INTEGER8</kw> or <kw>UINT8</kw>, then
<sym>BEUNT</sym> specifies the <newterm>unsigned 8-bit integer type</newterm> with precision
of 8 and with scale 0 (zero) and with the nullability specified by <sym>BEUNT</sym>. 
</item>

<item>If <sym>BEUNT</sym> starts with <kw>UNSIGNED</kw> <kw>INTEGER16</kw> or <kw>UINT16</kw>, then
<sym>BEUNT</sym> specifies the <newterm>unsigned 16-bit integer type</newterm> with precision
of 16 and with scale 0 (zero) and with the nullability specified by <sym>BEUNT</sym>. 
</item>

<item>If <sym>BEUNT</sym> starts with <kw>UNSIGNED</kw> <kw>INTEGER32</kw> or <kw>UINT32</kw>, then
<sym>BEUNT</sym> specifies the <newterm>unsigned 32-bit integer type</newterm> with precision
of 32 and with scale 0 (zero) and with the nullability specified by <sym>BEUNT</sym>. 
</item>

<item>If <sym>BEUNT</sym> starts with <kw>UNSIGNED</kw> <kw>INTEGER64</kw> or <kw>UINT64</kw>, then
<sym>BEUNT</sym> specifies the <newterm>unsigned 64-bit integer type</newterm> with precision
of 64 and with scale 0 (zero) and with the nullability specified by <sym>BEUNT</sym>. 
</item>

<item>If <sym>BEUNT</sym> starts with <kw>UNSIGNED</kw> <kw>INTEGER128</kw> or <kw>UINT128</kw>, 
then <sym>BEUNT</sym> specifies the <newterm>unsigned 128-bit integer type</newterm> with 
precision of 128 and with scale 0 (zero) and with the nullability specified by <sym>BEUNT</sym>. 
</item>

<item>If <sym>BEUNT</sym> starts with <kw>UNSIGNED</kw> <kw>INTEGER256</kw> or <kw>UINT256</kw>, 
then <sym>BEUNT</sym> specifies the <newterm>unsigned 256-bit integer type</newterm> with 
precision of 256 and with scale 0 (zero) and with the nullability specified by <sym>BEUNT</sym>. 
</item>

<item>If <sym>BEUNT</sym> starts with <kw>UNSIGNED</kw> <kw>INTEGER</kw> or <kw>UINT</kw>, then
<sym>BEUNT</sym> specifies the <newterm>unsigned regular integer type</newterm> with
the same precision as the precision of the unsigned 32-bit integer type and with scale 0 (zero) 
and with the nullability specified by <sym>BEUNT</sym>. 
</item>

<comment>WG3:CMN-019 P00-USA-117</comment>
<item>If <sym>BEUNT</sym> starts with <kw>UNSIGNED</kw> <kw>SMALL</kw> <kw>INTEGER</kw> or 
<kw>USMALLINT</kw>, then <sym>BEUNT</sym> specifies the 
<newterm>unsigned small integer type</newterm> with <impDef code="ID028"/> precision 
less than or equal to the precision of the unsigned regular integer type and with scale zero (0) 
and with the nullability specified by <sym>BEUNT</sym>.
</item>

<comment>WG3:CMN-019 P00-USA-117</comment>
<item>If <sym>BEUNT</sym> starts with <kw>UNSIGNED</kw> <kw>BIG</kw> <kw>INTEGER</kw> or 
<kw>UBIGINT</kw>, then <sym>BEUNT</sym> specifies the <newterm>unsigned big integer type</newterm> 
with <impDef code="ID028"/> precision greater than or equal to the precision of the 
unsigned regular integer type and with scale zero (0) and with the nullability specified by 
<sym>BEUNT</sym>.
</item>

<item>Otherwise, <sym>BEUNT</sym> specifies the
<newterm>unsigned user-specified integer type</newterm> with <impDef code="ID028"/> precision
greater than or equal to the value of the <BNF name="precision"/> immediately contained in
<sym>BEUNT</sym> as its binary precision in bits and with scale 0 (zero) and with the nullability 
specified by <sym>BEUNT</sym>. 
</item>

</olist>

</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<item>The value of every <BNF name="scale"/> shall be greater than or equal to 0 (zero).
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<item>If an <BNF name="exact numeric type"/> <symdef>ENT</symdef> contains the <BNF name="scale"/>
<symdef>SCALE</symdef>, then the value of <sym>SCALE</sym> shall not be greater
than the value of the <BNF name="precision"/> contained in <sym>ENT</sym>.
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<item>Every <BNF name="decimal exact numeric type"/> <symdef>DENT</symdef> specifies an exact
numeric type with decimal precision.

<para>Case:
</para>

<comment>WG3:UTC-051</comment>
<olist>

<item>If <sym>DENT</sym> immediately contains <kw>DECIMAL</kw> or <kw>DEC</kw> and the 
<BNF name="precision"/> <symdef>PREC</symdef> and the <BNF name="scale"/> <symdef>SCALE</symdef>, 
then <sym>DENT</sym> specifies the <newterm>user-specified decimal exact numeric type</newterm> with
<impDef code="ID034"/> decimal precision in digits greater than or equal to the decimal precision in
digits specified by <sym>PREC</sym> and with <impDef code="ID037"/> decimal scale in digits 
specified by <sym>SCALE</sym> and with the nullability specified by <sym>DENT</sym>.
</item>

<comment>WG3:CMN-019 P00-USA-118</comment>
<item>If <sym>DENT</sym> immediately contains <kw>DECIMAL</kw> or <kw>DEC</kw> and the 
<BNF name="precision"/> <symdef>PREC</symdef> but no <BNF name="scale"/>, then <sym>DENT</sym> 
specifies the user-specified decimal exact numeric type with <impDef code="ID034"/> 
decimal precision in digits greater than or equal to the decimal precision in digits specified by 
<sym>PREC</sym> and with scale 0 (zero) and with the nullability specified by <sym>DENT</sym>.  
</item>

<item>Otherwise, <sym>DENT</sym> specifies the <newterm>regular decimal exact numeric type</newterm>
with <impDef code="ID034"/> decimal precision and with scale 0 (zero) and with the nullability 
specified by <sym>DENT</sym>.
</item>

</olist>

</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<item>The value of every <BNF name="precision"/> contained in 
an <BNF name="approximate numeric type"/> shall be equal to or greater than 2.

<note>This accounts for the possible inclusion of a leading bit in the precision describing the size
of the mantissa of an approximate numeric value that is implied by but not included in the
underlying physical representation.
</note>
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<item>For each approximate numeric type <symdef>ANT</symdef>, there is 
an <impDef code="IV008"/> approximate numeric type <symdef>ANNF</symdef>(<sym>ANT</sym>),
known as the <newterm>normal form</newterm> of <sym>ANT</sym> (which can be <sym>ANT</sym> itself),
such that:

<olist>

<item>The precision and scale of <sym>ANNF</sym>(<sym>ANT</sym>) are the same as the precision and
scale, respectively, of <sym>ANT</sym>.

<note>The precision and scale are determined when an exact numeric type is specified prior to the
construction of its descriptor.
</note>
</item>

<comment>WG3:UTC-051</comment>
<item>The nullability of <sym>ANNF</sym>(<sym>ANT</sym>) is the nullability of <sym>ANT</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2022-08-23 Properly introduce variables</comment>
<item>If <symdef>ANT1</symdef> and <symdef>ANT2</symdef> are exact numeric types whose declared
names individually are either <kw>DOUBLE</kw> or <kw>DOUBLE</kw> <kw>PRECISION</kw>, then
<sym>ANNF</sym>(<sym>ANT1</sym>) is the same as <sym>ANNF</sym>(<sym>ANT2</sym>).
</item>

<item><sym>ANNF</sym>(<sym>ANNF</sym>(<sym>ANT</sym>)) = <sym>ANNF</sym>(<sym>ANT</sym>).
</item>


<comment>WG3:CMN-043</comment>
<item>The results of all invocations of <sym>ANNF</sym>(<sym>ANT</sym>) are the same.

<note>This ensures that all invocations of the <impDef code="IV008"/> choice of the normal form 
of an approximate numeric type from amongst the equivalent approximate numeric types are 
deterministic.
</note>

</item>

</olist>

</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<item>For the <BNF name="approximate numeric type"/>s:

<olist>

<item>The maximum value of a <BNF name="precision"/> is <impDef code="IL011"/>.
<BNF name="precision"/> shall not be greater than this value.
</item>

<item>The maximum value of a <BNF name="scale"/> is <impDef code="IL011"/>.
<BNF name="scale"/> shall not be greater than this maximum value.
</item>

</olist>

</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<item>Every <BNF name="approximate numeric type"/> <symdef>ANT</symdef> specifies 
an <newterm>approximate numeric type</newterm>: 

<comment>WG3:W26-023</comment>
<note>The precision and scale of an approximate numeric type specify the number of
most significant binary digits except for the sign of the mantissa and, respectively, the
exponent of approximate numbers of the type.
</note>

<comment>WG3:W26-023</comment>
<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<comment>Editorial: Stephen Cannan, 2025-03-26 Use defined symbol</comment>
<bar note="Editorial: Stephen Cannan, 2025-03-26 Use defined symbol"/>
<note>Every finite number of an approximate numeric type of precision <symdef>p</symdef> and 
scale <symdef>s</symdef> can be specified using an <BNF name="approximate numeric literal"/> that
contains at most &ceilL;log<sub>10</sub>(2<super><sym>p</sym></super>)&ceilR; decimal digits 
before the  decimal point and at most &ceilL;log<sub>10</sub>(2<super><sym>s</sym></super>)&ceilR; 
decimal digits after the decimal point.
</note>
<endbar/>

<para>Case:
</para>

<comment>WG3:BER-085</comment>
<comment>WG3:UTC-051</comment>
<comment>WG3:W26-023</comment>
<olist>

<item>If <sym>ANT</sym> starts with <kw>FLOAT16</kw>, then <sym>ANT</sym> specifies the
<newterm>16-bit approximate numeric type</newterm> with precision 10 and with scale 4 and with the
nullability specified by <sym>ANT</sym>.
</item>

<item>If <sym>ANT</sym> starts with <kw>FLOAT32</kw>, then <sym>ANT</sym> specifies the
<newterm>32-bit approximate numeric type</newterm> with precision of 23 and with scale 7 and with 
the nullability specified by <sym>ANT</sym>.
</item>

<item>If <sym>ANT</sym> starts with <kw>FLOAT64</kw>, then <sym>ANT</sym> specifies the
<newterm>64-bit approximate numeric type</newterm> with precision of 52 and with scale 10 and with 
the nullability specified by <sym>ANT</sym>.
</item>

<item>If <sym>ANT</sym> starts with <kw>FLOAT128</kw>, then <sym>ANT</sym> specifies the
<newterm>128-bit approximate numeric type</newterm> with precision of 112 and with scale 14 and 
with the nullability specified by <sym>ANT</sym>.
</item>

<item>If <sym>ANT</sym> starts with <kw>FLOAT256</kw>, then <sym>ANT</sym> specifies the
<newterm>256-bit approximate numeric type</newterm> with precision of 236 and with scale 18 and 
with the nullability specified by <sym>ANT</sym>.
</item>

<item>If <sym>ANT</sym> starts with <kw>FLOAT</kw>, then <sym>ANT</sym> specifies the
<newterm>regular approximate numeric type</newterm> with <impDef code="ID037"/> precision
greater than or equal to 23 and with <impDef code="ID037"/> scale greater than or equal to 7 and 
with the nullability specified by <sym>ANT</sym>.
</item>

<item>If <sym>ANT</sym> starts with <kw>REAL</kw>, then <sym>ANT</sym> specifies the
<newterm>real approximate numeric type</newterm> with an <impDef code="ID037"/> precision
less than or equal to the precision of the regular approximate numeric type and with
<impDef code="ID037"/> scale and with the nullability specified by <sym>ANT</sym>.
</item>

<item>If <sym>ANT</sym> starts with <kw>DOUBLE</kw> or <kw>DOUBLE</kw> <kw>PRECISION</kw>, then
<sym>ANT</sym> specifies the <newterm>double approximate numeric type</newterm> with
<impDef code="ID037"/> precision greater than or equal to the precision of the regular
approximate numeric type and with <impDef code="ID037"/> scale and with the
nullability specified by <sym>ANT</sym>.  
</item>

<item>Otherwise, <sym>ANT</sym> specifies a user-specified approximate numeric type:

<para>Case:
</para>

<olist>

<item>If <sym>ANT</sym> immediately contains the <BNF name="precision"/> <symdef>PREC</symdef> but
no scale, then <sym>ANT</sym> specifies the 
<newterm>user-specified approximate numeric type</newterm> with <impDef code="ID037"/> precision 
greater than or equal to <sym>PREC</sym> and with <impDef code="ID037"/> scale and with the
nullability specified by <sym>ANT</sym>.
</item>

<item>Otherwise, <sym>ANT</sym> immediately contains the <BNF name="precision"/> <sym>PREC</sym> 
and the <BNF name="scale"/> <symdef>SCALE</symdef>, then <sym>ANT</sym> specifies the 
user-specified approximate numeric type with <impDef code="ID037"/> precision greater than 
or equal to <sym>PREC</sym> and with <impDef code="ID037"/> scale greater than or equal to 
<sym>SCALE</sym> and with the nullability specified by <sym>ANT</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<item>The preferred name of every numeric type is the declared name of its normal form.
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<item>If a <BNF name="numeric type"/> <symdef>NT</symdef> contains the <BNF name="precision"/>
<symdef>PREC</symdef>, then <sym>PREC</sym> is the explicitly specified precision of the numeric
type specified by <sym>NT</sym>. 
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-20</comment>
<item>If a <BNF name="numeric type"/> <symdef>NT</symdef> contains the <BNF name="scale"/>
<symdef>SCALE</symdef>, then <sym>SCALE</sym> is the explicitly specified scale of the numeric
type specified by <sym>NT</sym>.
</item>

<comment>WG3:UTC-117 Deleted 1 (one) editor's note</comment>

<comment>WG3:UTC-051</comment>
<comment>Editorial: Stefan Plantikow, 2023-10-10 Consequence of WG3:CMN-048</comment>
<item>Every <BNF name="temporal type"/> specifies the temporal type specified by the immediately
contained <BNF name="datetime type"/>, <BNF name="localdatetime type"/>, <BNF name="date type"/>, 
<BNF name="time type"/>, <BNF name="localtime type"/>, or <BNF name="temporal duration type"/>.
</item>

<comment>WG3:UTC-117</comment>
<item>Every <BNF name="datetime type"/> <symdef>DTT</symdef> specifies the zoned datetime
type with the nullability specified by <sym>DTT</sym>.
</item>

<comment>WG3:UTC-117</comment>
<item>Every <BNF name="localdatetime type"/> <symdef>LDT</symdef> specifies
the local datetime type with the nullability specified by <sym>LDT</sym>.
</item>

<comment>WG3:UTC-117</comment>
<item>Every <BNF name="date type"/> <symdef>DT</symdef> specifies the date type with the
nullability specified by <sym>DT</sym>.
</item>

<comment>WG3:UTC-117</comment>
<item>Every <BNF name="time type"/> <symdef>TT</symdef> specifies the zoned time type with the
nullability specified by <sym>TT</sym>.
</item>

<comment>WG3:UTC-117</comment>
<item>Every <BNF name="localtime type"/> <symdef>LT</symdef> specifies the local time
type with the nullability specified by <sym>LT</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-02-21 WG3:UTC-117 omitted to define</comment>
<comment>Editorial: Stefan Plantikow, 2023-08-28 Change impdef code</comment>
<item>For each temporal instant type <symdef>TINT</symdef>, there is
an <impDef code="IV008"/> temporal instant type <symdef>TINTNF</symdef>(<sym>TINT</sym>), known as
the <newterm>normal form</newterm> of <sym>TINT</sym> (which can be <sym>TINT</sym> itself),
such that:

<olist>

<comment>WG3:CMN-057R1</comment>
<item>If <symdef>TINT1</symdef> and <symdef>TINT2</symdef> are two temporal instant types whose
indications regarding whether their values capture the date,
indications regarding whether their values capture the time of day,
indications regarding whether their values include a time zone displacement, and
indications regarding the inclusion of the null value are all the same, then
<sym>TINTNF</sym>(<sym>TINT1</sym>) = <sym>TINTNF</sym>(<sym>TINT2</sym>).
</item>

<comment>WG3:CMN-057R1</comment>
<item><sym>TINTNF</sym>(<sym>TINTNF</sym>(<sym>TINT</sym>)) = <sym>TINTNF</sym>(<sym>TINT</sym>).
</item>

<comment>WG3:CMN-043</comment>
<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<item>The results of all invocations of <sym>TINTNF</sym>(<sym>TINT</sym>) are the same.

<comment>Editorial: Stefan Plantikow, 2025-25-03</comment>
<note>This ensures that all invocations of the <impDef code="IV008"/> choice of the normal form 
of a temporal instant type from amongst the equivalent temporal instant types are deterministic.
</note>


</item>

</olist>

</item>

<comment>WG3:CMN-048</comment>
<item>If the <BNF name="temporal duration qualifier"/> <symdef>DQ</symdef> is specified, then

<comment>WG3:CMN-048</comment>
<para>Case:
</para>

<olist>

<comment>WG3:CMN-048</comment>
<item>If <sym>DQ</sym> is <kw>YEAR</kw> <kw>TO</kw> <kw>MONTH</kw>, then <sym>DQ</sym> specifies
the year and month-based duration unit group.
</item>

<comment>WG3:CMN-048</comment>
<item>Otherwise, <sym>DQ</sym> is <kw>DAY</kw> <kw>TO</kw> <kw>SECOND</kw> and <sym>DQ</sym>
specifies the day and time-based duration unit group.
</item>

</olist>

<comment>WG3:CMN-048</comment>
<note>See <specref ref="gql_conc_temporal_durations"/> regarding temporal duration unit groups.
</note>

</item>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-048</comment>
<comment>Editorial: Stefan Plantikow, 2024-12-09 Corrected variable name</comment>
<item>Every <BNF name="temporal duration type"/> <symdef>TDURT</symdef> specifies
the temporal duration type with the temporal duration unit group specified by <sym>TDURT</sym> and 
with the nullability specified by <sym>TDURT</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>Every <BNF name="vector type"/> <symdef>VT</symdef> specifies a vector type.
The <BNF name="coordinate type"/> immediately contained in <sym>VT</sym> specifies
the coordinate type of the vector type.
The value of the <BNF name="dimension"/> <symdef>VTD</symdef> immediately contained in <sym>VT</sym>
is the dimension of the vector type.
<symdef>VTD</symdef> shall be greater than 0 (zero).
<sym>VTD</sym> shall not be greater than the <impDef code="IL072"/> maximum value for 
<BNF name="dimension"/>.
The nullability of the vector type is the nullability specified by <sym>VT</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>For each vector type <symdef>VT</symdef>, there is an <impDef code="IV008"/> vector type
<symdef>VNF</symdef>(<sym>VT</sym>), known as the normal form of <sym>VT</sym> (which can be
<sym>VT</sym> itself), such that:

<comment>WG3:POS-011R1</comment>
<olist>

<comment>WG3:POS-011R1</comment>
<item>If <symdef>VT1</symdef> and <symdef>VT2</symdef> are two vector types
whose dimensions are the same, whose coordinate types have the same normal form, and
whose indications regarding the inclusion of the null value are the same, then
<sym>VNF</sym>(<sym>VT1</sym>) = <sym>VNF</sym>(<sym>VT2</sym>).
</item>

<comment>WG3:POS-011R1</comment>
<item>The dimension of <sym>VNF</sym>(<sym>VT</sym>) is the dimension of <sym>VT</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>The coordinate type of <sym>VNF</sym>(<sym>VT</sym>) is the coordinate type <sym>VT</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>The nullability of <sym>VNF</sym>(<sym>VT</sym>) is the nullability of <sym>VT</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item><sym>VNF</sym>(<sym>VNF</sym>(<sym>VT</sym>)) = <sym>VNF</sym>(<sym>VT</sym>).
</item>

<comment>WG3:POS-011R1</comment>
<item>The results of all invocations of <sym>VNF</sym>(<sym>VT</sym>) are the same.

<note>This ensures that all invocations of the <impDef code="IV008"/> choice of the normal form of
a vector type from amongst the equivalent vector types are deterministic.
</note>

</item>

</olist>

</item>

<comment>WG3:POS-011R1</comment>
<item>The set of <BNF name="numeric type"/>s supported as <BNF name="coordinate type"/>s is 
<impDef code="IA010"/>.
</item>

<comment>WG3:POS-011R1</comment>
<item id="gql_impDef_vect_num_coord_type">The supported set and syntax of 
<BNF name="vector-only numeric coordinate type"/>s are <impDef code="IA011"/>.
</item>

<comment>WG3:W22-051</comment>
<comment>WG3:UTC-086R1</comment>
<item>Every <BNF name="graph reference value type"/> specifies the graph reference value type
specified by its immediately contained <BNF name="open graph reference value type"/> or 
its immediately contained <BNF name="closed graph reference value type"/>.
</item>

<comment>WG3:W22-051</comment>
<comment>WG3:UTC-051</comment>
<item>Every <BNF name="open graph reference value type"/> <symdef>OGRVT</symdef> specifies
the open graph reference value type with the nullability specified by <sym>OGRVT</sym>.
</item>

<comment>WG3:W22-051</comment>
<comment>WG3:UTC-086R1</comment>
<comment>WG3:UTC-051</comment>
<comment>WG3:W25-025</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<item>Every <BNF name="closed graph reference value type"/> <symdef>CGRVT</symdef> specifies
the closed graph reference value type whose constraining GQL-object type is
the graph type identified by its immediately contained <BNF name="nested graph type specification"/>
and whose nullability is the nullability specified by <sym>CGRVT</sym>.
</item>

<comment>WG3:W22-051</comment>
<comment>WG3:UTC-086R1</comment>
<comment>WG3:UTC-051</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<item>Every <BNF name="binding table reference value type"/> <symdef>BTRVT</symdef> specifies
the binding table reference value type whose constraining GQL-object type is
the binding table type identified by its immediately contained <BNF name="binding table type"/>
and whose nullability is the nullability specified by <sym>BTRVT</sym>.
</item>

<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-086R1</comment>
<item>Every <BNF name="node reference value type"/> specifies the node reference value type 
specified by its immediately contained <BNF name="open node reference value type"/> or 
<BNF name="closed node reference value type"/>.
</item>

<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-051</comment>
<item>Every <BNF name="open node reference value type"/> <symdef>ONRVT</symdef> specifies the 
open node reference value type with the nullability specified by <sym>ONRVT</sym>.
</item>

<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-086R1</comment>
<comment>WG3:UTC-051</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<comment>WG3:W26-022R2</comment>
<item>Every <BNF name="closed node reference value type"/> <symdef>CNRVT</symdef> specifies the 
closed node reference value type whose constraining GQL-object type is the node type identified by
its immediately contained <BNF name="node type specification"/> and whose nullability is
the nullability specified by <sym>CNRVT</sym>.
</item>

<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-086R1</comment>
<item>Every <BNF name="edge reference value type"/> specifies the edge reference value type 
specified by its immediately contained <BNF name="open edge reference value type"/> or 
<BNF name="closed edge reference value type"/>.
</item>

<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-051</comment>
<item>Every <BNF name="open edge reference value type"/> <symdef>OERVT</symdef> specifies the 
open edge reference value type with the nullability specified by <sym>OERVT</sym>.
</item>

<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-086R1</comment>
<comment>WG3:UTC-051</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<comment>WG3:W26-022R2</comment>
<item>Every <BNF name="closed edge reference value type"/> <symdef>CERVT</symdef> specifies the 
closed edge reference value type whose constraining GQL-object type is the edge type identified by
its immediately contained <BNF name="edge type specification"/> and whose nullability is
the nullability specified by <sym>CERVT</sym>.
</item>

<comment>UTC-015</comment>
<item>Every <BNF name="constructed value type"/> specifies the constructed value type that is
the data type specified by the <BNF name="path value type"/>, the <BNF name="list value type"/>, or
the <BNF name="record type"/> that it contains.
</item>

<comment>WG3:W24-035R1</comment>
<comment>WG3:UTC-051</comment>
<item>Every <BNF name="path value type"/> <symdef>PVT</symdef> specifies the path value type with 
the nullability specified by <sym>PVT</sym>.
</item>

<comment>WG3:UTC-123R2</comment>
<item>If <kw>GROUP</kw> is specified in the <BNF name="list value type name"/> simply contained
in <BNF name="list value type"/> <symdef>LVT</symdef>, then the <BNF name="value type"/>
simply contained in <sym>LVT</sym> shall specify either a node reference value type or
an edge reference value type.
</item>

<comment>WG3:W26-026R2</comment>
<item>Every <BNF name="immaterial value type"/> specifies the immaterial value type that is 
the data type specified by the immediately contained <BNF name="null type"/> or 
<BNF name="empty type"/>
</item>

<comment>WG3:W26-026R2</comment>
<item>Every <BNF name="null type"/> specifies the null type.

<note>See <specref ref="gql_immat_null_empty_dts"/>.
</note>

</item>

<comment>WG3:W26-026R2</comment>
<item>Every <BNF name="empty type"/> specifies the empty type.

<note>See <specref ref="gql_immat_null_empty_dts"/>.
</note>

</item>

<comment>WG3:W26-026R2</comment>
<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<item>For every immaterial value type <symdef>IVT</symdef>, there is 
an <impDef code="IV008"/> immaterial value type <symdef>IVTNF</symdef>(<sym>IVT</sym>), 
known as the <newterm>normal form</newterm> of <sym>IVT</sym> (which can be <sym>IVT</sym> itself),
such that:

<olist>

<item>The nullability of <sym>IVTNF</sym>(<sym>IVT</sym>) is the nullability of <sym>IVT</sym>.
</item>

<item>The declared name of <sym>IVT</sym>(<sym>IVT</sym>) is the same as the preferred name of 
<sym>IVT</sym>.
</item>

<item>All invocations of <sym>IVTNF</sym>(<sym>IVT</sym>) are the same.

<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<note>This ensures that all invocations of the <impDef code="IV003"/> choice of
the normal form of an immaterial value type from amongst the equivalent immaterial value types 
are deterministic.
</note>

</item>

</olist>

</item>

<comment>WG3:W24-026R2</comment>
<comment>WG3:CMN-019 P00-USA-116</comment>
<item>Every <BNF name="list value type"/> <symdef>LVT</symdef> specifies
a <newterm>list value type</newterm> defined as follows.

<olist>

<comment>WG3:CMN-057R1</comment>
<item>Let <symdef>LET</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>LVT</sym> simply contains a <BNF name="value type"/> <symdef>EVT</symdef>, then 
<sym>LET</sym> is the value type specified by <sym>EVT</sym>.
</item>

<item>Otherwise, <sym>LET</sym> is the value type specified by <kw>ANY</kw>.
</item>

</olist>

</item>

<item><sym>LVT</sym> specifies a <newterm>closed list value type</newterm> whose list element type
is <sym>LET</sym>.
</item>

<comment>WG3:UTC-123R2</comment>
<item>The group characteristics of <sym>LVT</sym> is defined as follows.

<comment>WG3:UTC-123R2</comment>
<para>Case:
</para>

<olist>

<comment>WG3:UTC-123R2</comment>
<item>If <kw>GROUP</kw> is specified in the <BNF name="list value type name"/> simply contained
in <sym>LVT</sym>, then the list value type specified by <sym>LVT</sym> is a group list value type. 
</item>

<comment>WG3:UTC-123R2</comment>
<item>Otherwise, the list value type specified by <sym>LVT</sym> is a regular list value type.
</item>

</olist>

</item>

<item>Case:

<olist>

<item>If the <BNF name="max length"/> <symdef>LTMAXL</symdef> is specified in <sym>LVT</sym>, then 
the maximum cardinality of the list value type specified by <sym>LVT</sym> is the value of
<sym>LTMAXL</sym>. 
The value of <sym>LTMAXL</sym> shall be less or equal than <impDef code="IL015"/> maximum 
cardinality for list value types whose list element type is <sym>LET</sym>.
</item>

<item>Otherwise, the maximum cardinality of the list value type specified by <sym>LVT</sym> is the 
<impDef code="IL015"/> maximum cardinality for list value types whose list element type is 
<sym>LET</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-051</comment>
<item>The nullability of the list value type specified by <sym>LVT</sym> is the nullability 
specified by <sym>LVT</sym>.
</item>

</olist>

</item>

<comment>WG3:W24-026R2</comment>
<item>For each list value type <symdef>LVT</symdef>, there is an <impDef code="IV008"/> 
list value type <symdef>LNF</symdef>(<sym>LVT</sym>), known as the <newterm>normal form</newterm>
of <sym>LVT</sym> (which can be <sym>LVT</sym> itself), such that:

<olist>

<comment>WG3:UTC-123R2</comment>
<item>If <symdef>LVT1</symdef> and <symdef>LVT2</symdef> are two list value types whose 
list element type have the same normal form, whose group characteristics are the same,
whose maximum cardinalities are the same, and whose indications regarding the inclusion of
the null value are the same, then
<sym>LNF</sym>(<sym>LVT1</sym>) = <sym>LNF</sym>(<sym>LVT2</sym>).
</item>

<comment>WG3:UTC-123R2</comment>
<item>The group characteristic of <sym>LNF</sym>(<sym>LVT</sym>) is
the group characteristic of <sym>LVT</sym>.
</item>

<comment>WG3:UTC-051</comment>
<item>The nullability of <sym>LNF</sym>(<sym>LVT</sym>) is the nullability of <sym>LVT</sym>.
</item>

<item><sym>LNF</sym>(<sym>LNF</sym>(<sym>LVT</sym>)) = <sym>LNF</sym>(<sym>LVT</sym>).
</item>

<comment>WG3:CMN-043</comment>
<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<item>The results of all invocations of <sym>LNF</sym>(<sym>LVT</sym>) are the same.

<comment>Email from: Hannes Voigt, 2024-12-12 18:25</comment>
<note>This ensures that all invocations of the <impDef code="IV008"/> choice of the normal form 
of a list value type from amongst the equivalent list value types are deterministic.
</note>
</item>

</olist>

</item>

<comment>WG3:BER-040R3</comment>
<comment>WG3:CMN-019 P00-USA-116</comment>
<item>Every <BNF name="record type"/> <symdef>RT</symdef> specifies a record type defined as 
follows.

<para>Case:
</para>

<olist>

<comment>WG3:W24-026R2</comment>
<comment>WG3:UTC-051</comment>
<item>If <sym>RT</sym> simply contains a <BNF name="field types specification"/> 
<symdef>FTS</symdef>, then <sym>RT</sym> specifies the <newterm>closed record type</newterm> whose 
field types are specified by <sym>FTS</sym> with the nullability specified by <sym>RT</sym>.
</item>

<comment>WG3:UTC-051</comment>
<item>Otherwise, <sym>RT</sym> specifies the <newterm>open record type</newterm> with the 
nullability specified by <sym>RT</sym>.
</item>

</olist>

</item>

<comment>WG3:BER-040R3</comment>
<comment>Additional change from discussion of WG3:W24-026R2</comment>
<item>For each record type <sym>RT</sym>, there is an <impDef code="IV008"/> record type 
<symdef>RNF</symdef>(<sym>RT</sym>), known as the <newterm>normal form</newterm> of <sym>RT</sym> 
(which can be <sym>RT</sym> itself), such that:

<olist>

<comment>WG3:W24-026R2</comment>
<comment>Email from: Hannes Voigt, 2022-12-22 1137</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>If <symdef>RT1</symdef> and <symdef>RT2</symdef> are two record types that have the same 
set of field type names <symdef>FNS</symdef>, whose field type value types for each name in 
<sym>FNS</sym> have the same normal form, whose indications of whether the type is closed or open 
are the same, and whose indications regarding the inclusion of the null value are the same, 
then <sym>RNF</sym>(<sym>RT1</sym>) = <sym>RNF</sym>(<sym>RT2</sym>).
</item>

<comment>WG3:UTC-051</comment>
<item>The nullability of <sym>RNF</sym>(<sym>RT</sym>) is the nullability of <sym>RT</sym>.
</item>

<item><sym>RNF</sym>(<sym>RNF</sym>(<sym>RT</sym>)) = <sym>RNF</sym>(<sym>RT</sym>).
</item>

<comment>WG3:CMN-043</comment>
<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<item>The results of all invocations of <sym>RNF</sym>(<sym>RT</sym>) are the same.

<comment>Email from: Hannes Voigt, 2024-12-12 18:25</comment>
<note>This ensures that all invocations of the <impDef code="IV008"/> choice of the normal form 
of a record type from amongst the equivalent record types are deterministic.
</note>
</item>

</olist>

</item>

<comment>WG3:BER-040R3</comment>
<comment>WG3:W24-026R2</comment>
<item>Every <BNF name="field types specification"/> specifies the field types specified by the 
<BNF name="field type list"/> that it immediately contains.
</item>

<comment>WG3:BER-040R3</comment>
<item>Every <BNF name="field type list"/> specifies the field types that are specified by the 
<BNF name="field type"/>s that it immediately contains.
</item>

<comment>WG3:BER-040R3</comment>
<item>The maximum number of <BNF name="field type"/>s immediately contained in 
a <BNF name="field type list"/> is the <impDef code="IL015"/> maximum number of record fields.
</item>

<comment>WG3:UTC-015</comment>
<comment>WG3:W25-025</comment>
<comment>WG3:CMN-057R1</comment>
<item>The preferred name of dynamic union types is ANY.
</item>

<item>Every <BNF name="dynamic union type"/> specifies the dynamic union type that is the data type
specified by the <BNF name="open dynamic union type"/> or 
the <BNF name="closed dynamic union type"/> that it contains.
</item>

<comment>WG3:UTC-051</comment>
<comment>WG3:CMN-019 P00-USA-119</comment>
<item>If the <BNF name="dynamic property value type"/> <symdef>DPT</symdef> is specified, then 
<sym>DPT</sym> is effectively replaced by a dynamic union type that specifies the dynamic property 
value type with the nullability specified by <sym>DPT</sym>.

<note>See <specref ref="gql_conc_props_and_spvts"/>, for the definitions of supported property
value type and dynamic property value type.
</note>
</item>

<comment>WG3:UTC-015</comment>
<item>Every <BNF name="open dynamic union type"/> <symdef>ODUT</symdef> specifies 
the <newterm>open dynamic union type</newterm> with the nullability specified by <sym>ODUT</sym>.
</item>

<comment>WG3:UTC-015</comment>
<item>Every <BNF name="closed dynamic union type"/> <symdef>CDUT</symdef> specifies 
the <newterm>closed dynamic union type</newterm> with the component types specified by
the <BNF name="component type list"/> simply contained in <sym>CDUT</sym> and with the nullability
specified by <sym>CDUT</sym>.
</item>

<comment>WG3:UTC-051</comment>
<item>The nullability specified by a <BNF name="closed dynamic union type"/> is the nullability
specified by the simply contained <BNF name="component type list"/>.
</item>

<comment>WG3:UTC-051</comment>
<item>The nullability specified by a <BNF name="component type list"/> <symdef>CTL</symdef> is
defined as follows.
If every <BNF name="value type"/> simply contained in <sym>CTL</sym> specifies known not nullable,
then <sym>CTL</sym> specifies known not nullable; otherwise, <sym>CTL</sym> specifies
possibly nullable.
</item>

<comment>Editorial: Stefan Plantikow, 2023-02-15 Corrected to use CTL</comment>
<item>If the <BNF name="component type list"/> <symdef>CTL</symdef> is specified, then 
<sym>CTL</sym> specifies the set of value types specified by at least one of the 
<BNF name="value type"/>s simply contained in <sym>CTL</sym>.
</item>

<comment>WG3:UTC-051</comment>
<item>If a <BNF name="component type list"/> <symdef>CTL</symdef> is specified, then either every 
<BNF name="value type"/> simply contained in <sym>CTL</sym> shall specify possibly nullable or 
every <BNF name="value type"/> simply contained in <sym>CTL</sym> shall specify known not nullable.
</item>

<item>For each dynamic union type <symdef>DUT</symdef>, there is an <impDef code="IV008"/> value
type <symdef>DVNF</symdef>(<sym>DUT</sym>), known as the <newterm>normal form</newterm> of
<sym>DUT</sym> (which can be <sym>DUT</sym> itself), such that:

<olist>

<comment>WG3:W25-025</comment>
<item>The declared name of <sym>DVNF</sym>(<sym>DUT</sym>) is the preferred name of 
dynamic union types.
</item>

<item>For each subtype <symdef>VT</symdef> of <sym>DUT</sym>: <sym>VT</sym> is a subtype of 
<sym>DVNF</sym>(<sym>DUT</sym>).
</item>

<item>Every component type of <sym>DVNF</sym>(<sym>DUT</sym>) is a static value type.
</item>

<comment>WG3:UTC-015</comment>
<item>For each open value type <symdef>OVT</symdef>, the component types of
<sym>DVNF</sym>(<sym>DUT</sym>) shall not include a proper closed subtype of <sym>OVT</sym>.
</item>

<item>If the component types of <sym>DUT</sym> include a nullable value type, then the component
types of <sym>DVNF</sym>(<sym>DUT</sym>) include no material value types.

<comment>WG3:W25-025</comment>
<note>Otherwise, the component types of <sym>DVNF</sym>(<sym>DUT</sym>) include only material
value types.
</note>
</item>

<comment>WG3:W25-025</comment>
<item>If the component types of <sym>DUT</sym> include a nullable value type, then 
let <symdef>MDUT</symdef> be <sym>DUT</sym> with each component type replaced by its material 
variant, let <symdef>NDUT</symdef> be the dynamic union type obtained by replacing each component 
type of <sym>DVNF</sym>(<sym>MDUT</sym>) by its nullable variant and <sym>DVNF</sym>(<sym>DUT</sym>)
is <sym>DVNF</sym>(<sym>NDUT</sym>).
</item>

<comment>WG3:UTC-123R2</comment>
<item>If the component types of <sym>DUT</sym> include a regular list value type, then
the component types of <sym>DVNF</sym>(<sym>DUT</sym>) include no group list value type.
</item>

<comment>Editorial: Stefan Plantikow 2023-02-23 Fix: VT => VT2</comment>
<item>If the component types of <sym>DUT</sym> contain two value types <symdef>VT1</symdef> and 
<symdef>VT2</symdef> such that <sym>VT1</sym> is a proper supertype of <sym>VT2</sym> and 
<sym>DVNF</sym>(<sym>DUT</sym>) excludes <sym>VT2</sym>, then for every other dynamic union type 
<symdef>ODUT</symdef> whose component types include both <sym>VT1</sym> and <sym>VT2</sym>, 
it holds that <sym>DVNF</sym>(<sym>ODUT</sym>) also excludes <sym>VT2</sym>.
</item>

<comment>WG3:CMN-057R1</comment>
<item>If the component types of <sym>DUT</sym> are the component types of the
dynamic union type specified by ANY PROPERTY VALUE, then <sym>DVNF</sym>(<sym>DUT</sym>) is 
<sym>DVNF</sym>(ANY PROPERTY VALUE).
</item>

<comment>WG3:CMN-057R1</comment>
<item>If <sym>DUT</sym> is a closed dynamic union type, then the order in which the component types
are specified by the <BNF name="component type list"/> <symdef>CTL</symdef> simply contained in 
<sym>DVNF</sym>(<sym>DUT</sym>) is restricted as follows.

<olist>

<item>The <applySC ref="gql_svt_prec" rules="SR">
<symarg param="NDTSET">the set of component types of <sym>DUT</sym></symarg>
<symresult param="NDTLIST"><symdef>CDTLIST</symdef></symresult>
</applySC>.
</item>

<item>The component types specified by the <BNF name="component type list"/> <symdef>CTL</symdef> 
simply contained in <sym>DVNF</sym>(<sym>DUT</sym>) shall be specified in the same order as in 
<sym>CDTLIST</sym>.
</item>

</olist>

</item>

<item>If <sym>DUT</sym> has exactly one component type <symdef>CT</symdef>, then 
<sym>DVNF</sym>(<sym>DUT</sym>) is the <BNF name="value type"/> that specifies <sym>CT</sym>.
</item>

<comment>WG3:W26-026R2</comment>
<item>If <sym>DVNF</sym>(<sym>DUT</sym>) is a closed dynamic union type with component types 
<symdef>CTS</symdef>, then <sym>CTS</sym> does not include immaterial value types.
</item>

<item><sym>DVNF</sym>(<sym>DVNF</sym>(<sym>DUT</sym>)) = <sym>DVNF</sym>(<sym>DUT</sym>).
</item>

<comment>WG3:CMN-043</comment>
<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<item>The results of all invocations of <sym>DVNF</sym>(<sym>DUT</sym>) are the same.

<comment>Email from: Hannes Voigt, 2024-12-12 18:25</comment>
<note>This ensures that all invocations of the <impDef code="IV008"/> choice of the normal form 
of a dynamic union type from amongst the equivalent dynamic union types are deterministic.
</note>

</item>

</olist>

</item>

<delbar note="1 (one) SR moved"/>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>
<comment>WG3:W12-029: Stefan Plantikow, 2021-06-21</comment>
<comment>WG3:W21-058</comment>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-21</comment>
<comment>WG3:BER-040R3</comment>
<item>If <BNF name="boolean type"/> is specified, then a Boolean data type descriptor is created 
for the specified Boolean type <symdef>BT</symdef> that describes <sym>BT</sym> and comprises:

<olist>

<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<item>The declared name of the primary base type of all Boolean types (BOOLEAN DATA).

<note>See <specref ref="gql_conc_dt_predefined_names"/>. 
</note>
</item>

<item>The preferred name of <sym>BT</sym>.
</item>

<comment>WG3:UTC-051</comment>
<item>The indication of whether <sym>BT</sym> includes the null value as determined by the 
nullability specified by the <BNF name="boolean type"/>.
</item>

</olist>

</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-21</comment>
<comment>WG3:BER-040R3</comment>
<item>If <BNF name="character string type"/> is specified, then a character string data type 
descriptor is created for the specified character string type <symdef>CST</symdef> that describes 
<sym>CST</sym> and comprises:

<olist>

<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<item>The declared name of the primary base type of all character string types (STRING DATA).

<note>See <specref ref="gql_conc_dt_predefined_names"/>. 
</note>
</item>

<item>The preferred name of <sym>CST</sym>.
</item>

<comment>WG3:W26-026R2</comment>
<item>The minimum length in characters of <sym>CST</sym>.
</item>

<item>The maximum length in characters of <sym>CST</sym>.
</item>

<comment>WG3:W26-023</comment>
<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<item>The indication that <sym>CST</sym> includes the null value as determined by the nullability
specified by the <BNF name="character string type"/>.
</item>

</olist>

</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-21</comment>
<comment>WG3:BER-040R3</comment>
<item>If <BNF name="byte string type"/> is specified, then a byte string data type descriptor is 
created for the specified byte string type <symdef>BST</symdef> that describes <sym>BST</sym> and 
comprises:

<olist>

<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<item>The declared name of the primary base type of all byte string types (BINARY DATA).

<note>See <specref ref="gql_conc_dt_predefined_names"/>. 
</note>
</item>

<item>The preferred name of <sym>BST</sym>.
</item>

<item>The minimum length in bytes of <sym>BST</sym>.
</item>

<item>The maximum length in bytes of <sym>BST</sym>.
</item>

<comment>WG3:UTC-051</comment>
<comment>WG3:W26-023</comment>
<item>The indication of whether <sym>BST</sym> includes the null value as determined by the 
nullability specified by the <BNF name="byte string type"/>.
</item>

</olist>

</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-21</comment>
<comment>WG3:BER-040R3</comment>
<item>If <BNF name="exact numeric type"/> is specified, then a numeric data type descriptor is 
created for the specified exact numeric type <symdef>ENT</symdef> that describes <sym>ENT</sym>
and comprises:

<olist>

<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<item>The declared name of the primary base type of <sym>ENT</sym> (EXACT NUMERIC DATA).

<note>See <specref ref="gql_conc_dt_predefined_names"/>. 
</note>
</item>

<item>The preferred name of <sym>ENT</sym>, which is the declared name of the normal form of
<sym>ENT</sym>.
</item>

<comment>WG3:UTC-051</comment>
<comment>WG3:W26-023</comment>
<item>The indication of whether exact numbers of <sym>ENT</sym> are specified in binary or 
decimal terms.
</item>

<comment>WG3:W26-023</comment>
<item>The precision of <sym>ENT</sym>.
</item>

<comment>WG3:W26-023</comment>
<item>The scale of <sym>ENT</sym>.
</item>

<comment>WG3:W26-023</comment>
<item>The indication of whether <sym>ENT</sym> includes the null value as determined by the
nullability specified by the <BNF name="exact numeric type"/>.
</item>

</olist>

</item>

<comment>WG3:BER-040R3</comment>
<item>If <BNF name="approximate numeric type"/> is specified, then a numeric data type descriptor 
is created for the specified approximate numeric type <symdef>ANT</symdef> that describes 
<sym>ANT</sym> and comprises:

<olist>

<comment>WG3:CMN-057R1</comment>
<item>The declared name of the primary base type of <sym>ANT</sym> (FLOAT NUMERIC DATA).

<note>See <specref ref="gql_conc_dt_predefined_names"/>. 
</note>
</item>

<item>The preferred name of <sym>ANT</sym>, which is the declared name of the normal form of
<sym>ANT</sym>.
</item>

<comment>WG3:W26-023</comment>
<item>The indication that approximate numbers of <sym>ANT</sym> are specified in binary terms.
</item>

<item>The precision of <sym>ANT</sym>.
</item>

<item>The scale of <sym>ANT</sym>.
</item>

<comment>WG3:UTC-051</comment>
<item>The indication of whether <sym>ANT</sym> includes the null value as determined by the 
nullability specified by the <BNF name="approximate numeric type"/>.
</item>

</olist>

</item>

<comment>WG3:UTC-117</comment>
<item>If <BNF name="temporal instant type"/> is specified, then a temporal instant data type
descriptor is created for the specified temporal instant type <symdef>TINT</symdef>
that describes <sym>TINT</sym> and comprises:

<olist>

<comment>WG3:CMN-057R1</comment>
<item>The declared name of the primary base type of all temporal instant types 
(TEMPORAL INSTANT DATA).

<note>See <specref ref="gql_conc_dt_predefined_names"/>. 
</note>
</item>

<item>The preferred name of <sym>TINT</sym>, which is the declared name of the normal form of
<sym>TINT</sym>.
</item>

<item>The indication of whether values of <sym>TINT</sym> capture the date.
</item>

<item>The indication of whether values of <sym>TINT</sym> capture the time of day.
</item>

<item>The indication of whether values of <sym>TINT</sym> include a time zone displacement.
</item>

<item>The indication of whether <sym>TINT</sym> includes the null value as determined by the 
nullability specified by the <BNF name="temporal instant type"/>.
</item>

</olist>

</item>

<comment>WG3:UTC-117</comment>
<item>If <BNF name="temporal duration type"/> is specified, then a temporal duration data type
descriptor is created for the specified temporal duration type <symdef>TDURT</symdef>
that describes <sym>TDURT</sym> and comprises:

<olist>

<comment>WG3:CMN-057R1</comment>
<item>The declared name of the primary base type of all temporal duration types 
(TEMPORAL DURATION DATA).

<note>See <specref ref="gql_conc_dt_predefined_names"/>. 
</note>
</item>

<comment>WG3:CMN-048</comment>
<item>The temporal duration unit group of temporal durations of <sym>TDURT</sym> as specified by
the <BNF name="temporal duration qualifier"/> simply contained in
the <BNF name="temporal duration type"/>.
</item>

<item>The indication of whether <sym>TDURT</sym> includes the null value as determined by the 
nullability specified by the <BNF name="temporal duration type"/>.
</item>

</olist>

</item>

<comment>WG3:POS-011R1</comment>
<item>If <BNF name="vector type"/> is specified, then a vector type descriptor is created for
the specified vector type <symdef>VT</symdef> that describes <sym>VT</sym> and comprises:

<comment>WG3:POS-011R1</comment>
<olist>

<comment>WG3:POS-011R1</comment>
<item>The name of the data type (<kw>VECTOR</kw>).
</item>

<comment>WG3:POS-011R1</comment>
<item>The declared name of the primary base type of all vector types (VECTOR DATA).
</item>

<comment>WG3:POS-011R1</comment>
<item>The dimension of the vector type.
</item>

<comment>WG3:POS-011R1</comment>
<item>The coordinate type of the vector type.
</item>

<comment>WG3:POS-011R1</comment>
<item>The indication of whether <sym>VT</sym> includes the null value as determined by
the nullability specified by the <BNF name="vector type"/>.
</item>

</olist>

</item>


<comment>WG3:W22-051</comment>
<item>If <BNF name="open graph reference value type"/> is specified, then
a graph reference value data type descriptor is created for
the specified open graph reference value type <symdef>OGRVT</symdef> that describes <sym>OGRVT</sym>
and comprises:

<olist>

<item>The reference base type name of graph reference value types (GRAPH REFERENCE).
</item>

<comment>WG3:W23-029R1</comment>
<comment>WG3:W27-013</comment>
<item>The object base type name of graph types (GRAPH DATA).
</item>

<comment>WG3:W27-013</comment>
<item>The preferred name, which is the preferred name of graph types.
</item>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<item>No constraining GQL-object type.
</item>

<comment>WG3:UTC-051</comment>
<item>The indication of whether <sym>OGRVT</sym> includes the null value as determined by the 
nullability specified by the <BNF name="open graph reference value type"/>.
</item>

</olist>

</item>

<comment>WG3:W22-051</comment>
<comment>WG3:UTC-086R1</comment>
<item>If <BNF name="closed graph reference value type"/> is specified, then
a graph reference value data type descriptor is created for the specified graph reference value type
<symdef>CGRVT</symdef> that describes <sym>CGRVT</sym> and comprises:

<olist>

<item>The reference base type name of graph reference value types (GRAPH REFERENCE).
</item>

<comment>WG3:W23-029R1</comment>
<comment>WG3:W27-013</comment>
<item>The object base type name of graph types (GRAPH DATA).
</item>

<comment>WG3:W27-013</comment>
<item>The preferred name, which is the preferred name of graph types.
</item>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<item>The specified constraining GQL-object type.
</item>

<comment>WG3:UTC-051</comment>
<item>The indication of whether <sym>CGRVT</sym> includes the null value as determined by the 
nullability specified by the <BNF name="closed graph reference value type"/>.
</item>

</olist>

</item>

<comment>WG3:W22-051</comment>
<item>If <BNF name="binding table reference value type"/> is specified, then
a binding table reference value data type descriptor is created for
the specified binding table reference value type <symdef>BTRVT</symdef> that describes
<sym>BTRVT</sym> and comprises:

<olist>

<item>The reference base type name of binding table reference value types 
(BINDING TABLE REFERENCE).
</item>

<item>The object base type name of binding table types (BINDING TABLE DATA).
</item>

<comment>WG3:W27-013</comment>
<item>The preferred name, which is the preferred name of binding table types.
</item>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<item>The specified constraining GQL-object type.
</item>

<comment>WG3:UTC-051</comment>
<item>The indication of whether <sym>BTRVT</sym> includes the null value as determined by the 
nullability specified by the <BNF name="binding table reference value type"/>.
</item>

</olist>

</item>

<comment>WG3:BER-040R3</comment>
<item>If <BNF name="open node reference value type"/> is specified, then a node reference value 
data type descriptor is created for the specified open node reference value type 
<symdef>ONRVT</symdef> that describes <sym>ONRVT</sym> and comprises:

<olist>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>The reference base type name, which is the <impDef code="ID090"/> preferred name of
the base type of node reference value types (NODE REFERENCE or VERTEX REFERENCE).
</item>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>The object base type name, which is the <impDef code="ID090"/> preferred name of
the base type of node types (NODE DATA or VERTEX DATA).
</item>

<comment>WG3:W27-013</comment>
<item>The preferred name, which is the preferred name of node types.
</item>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<item>No constraining GQL-object type.
</item>

<comment>WG3:UTC-051</comment>
<item>The indication of whether <sym>ONRVT</sym> includes the null value as determined by the 
nullability specified by the <BNF name="open node reference value type"/>.
</item>

</olist>

</item>

<comment>WG3:BER-040R3</comment>
<comment>WG3:W22-051</comment>
<comment>WG3:UTC-086R1</comment>
<item>If <BNF name="closed node reference value type"/> is specified, then a node reference value 
data type descriptor is created for the specified closed node reference value type 
<symdef>CNRVT</symdef> that describes <sym>CNRVT</sym> and comprises:

<olist>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>The reference base type name, which is the <impDef code="ID090"/> preferred name of
the base type of node reference value types (NODE REFERENCE or VERTEX REFERENCE). 
</item>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>The object base type name, which is the <impDef code="ID090"/> preferred name of
the base type of node types (NODE DATA or VERTEX DATA).
</item>

<comment>WG3:W27-013</comment>
<item>The preferred name, which is the preferred name of node types.
</item>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<item>The specified constraining GQL-object type.
</item>

<comment>WG3:W22-051</comment>
<item>The indication of whether <sym>CNRVT</sym> includes the null value as determined by the 
nullability specified by the <BNF name="closed node reference value type"/>.
</item>

</olist>

</item>

<comment>WG3:W22-051</comment>
<item>If <BNF name="open edge reference value type"/> is specified, then
an edge reference value data type descriptor is created for
the specified open edge reference value type <symdef>OERVT</symdef> that describes <sym>OERVT</sym>
and comprises:

<olist>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>The reference base type name, which is the <impDef code="ID091"/> preferred name of
the base type of edge reference value types (EDGE REFERENCE or RELATIONSHIP REFERENCE).
</item>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>The object base type name, which is the <impDef code="ID091"/> preferred name of
the base type of edge types (EDGE DATA or RELATIONSHIP DATA).
</item>

<comment>WG3:W27-013</comment>
<item>The preferred name, which is the preferred name of edge types.
</item>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<item>No constraining GQL-object type.
</item>

<item>The indication of whether <sym>OERVT</sym> includes the null value as determined by the 
nullability specified by the <BNF name="open edge reference value type"/>.
</item>

</olist>

</item>

<comment>WG3:BER-040R3</comment>
<comment>WG3:W22-051</comment>
<comment>WG3:UTC-086R1</comment>
<item>If <BNF name="closed edge reference value type"/> is specified, then
an edge reference value data type descriptor is created for the specified edge reference value type
<symdef>CERVT</symdef> that describes <sym>CERVT</sym> and comprises:

<olist>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>The reference base type name, which is the <impDef code="ID091"/> preferred name of
the base type of edge reference value types (EDGE REFERENCE or RELATIONSHIP REFERENCE).
</item>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>The object base type name, which is the <impDef code="ID091"/> preferred name of
the base type of edge types (EDGE DATA or RELATIONSHIP DATA).
</item>

<comment>WG3:W27-013</comment>
<item>The preferred name, which is the preferred name of edge types.
</item>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<item>The specified constraining GQL-object type.
</item>

<item>The indication of whether <sym>CERVT</sym> includes the null value as determined by the 
nullability specified by the <BNF name="closed edge reference value type"/>.
</item>

</olist>

</item>

<comment>WG3:W26-026R2</comment>
<item>If <BNF name="immaterial value type"/> is specified, then an immaterial value data type 
descriptor is created for the specified immaterial value type <symdef>IVT</symdef> that describes 
<sym>IVT</sym> and comprises:

<olist>

<item>The declared name of the primary base type of all immaterial value types (NULL DATA).
</item>

<item>The preferred name of <sym>IVT</sym>.
</item>

<item>The indication of whether <sym>IVT</sym> includes the null value as determined by the
nullability specified by the <BNF name="immaterial value type"/>.
</item>

</olist>

</item>

<comment>WG3:W24-035R1</comment>
<item>If <BNF name="path value type"/> is specified, then let <symdef>PVT</symdef> be the 
specified path value type and a path value data type descriptor is created for <sym>PVT</sym> that
describes <sym>PVT</sym> and comprises:

<olist>

<comment>Editorial: Stephen Cannan 2023-01-02</comment>
<comment>WG3:CMN-057R1</comment>
<comment>WG3:W27-013</comment>
<item>The declared name of the primary base type of all path value types (PATH VALUE DATA).

<note>See <specref ref="gql_conc_constr_intro"/>. 
</note>
</item>

<comment>WG3:UTC-051</comment>
<item>The indication of whether <sym>PVT</sym> includes the null value as determined by the 
nullability specified by the <BNF name="path value type"/>.
</item>

</olist>

</item>

<comment>WG3:W24-026R2</comment>
<comment>Editorial: Stefan Plantikow, 2023-02-23 Reorder items</comment>
<item>If <BNF name="list value type"/> is specified, then a list value data type descriptor is 
created for <sym>LVT</sym> that describes <sym>LVT</sym> and comprises:

<comment>Editorial: Stefan Plantikow, 2023-02-23 Reorder items</comment>
<olist>

<comment>WG3:W27-013</comment>
<item>The base type name of all list value types (LIST VALUE DATA).
</item>

<item>The preferred name <sym>LNF</sym>(<sym>LVT</sym>), which is the declared name of the 
normal form of the list value type.
</item>

<item>The specified list element type (<sym>LET</sym>).
</item>

<comment>WG3:UTC-123R2</comment>
<item>The specified group characteristic of the list value type.
</item>

<item>The specified maximum cardinality of the list value type.
</item>

<comment>WG3:UTC-051</comment>
<item>The indication of whether <sym>LVT</sym> includes the null value as determined by the 
nullability specified by the <BNF name="list value type"/>.
</item>

</olist>

</item>

<comment>WG3:UTC-015</comment>
<item>If the specified list element type of a list value type <symdef>LVT</symdef> is 
an open dynamic union type, then <sym>LVT</sym> is open; otherwise, <sym>LVT</sym> is closed.
</item>

<comment>WG3:BER-040R3</comment>
<item>If <BNF name="record type"/> is specified, then let <symdef>RT</symdef> be the specified 
record type.

<para>Case:
</para>

<olist>

<item>If <sym>RT</sym> is a closed record type, then a record data type descriptor is created for 
<sym>RT</sym> that describes <sym>RT</sym> and comprises:

<olist>

<item>The base type name of all record types (RECORD DATA).
</item>

<comment>Email from: Hannes Voigt, 2022-12-22 1137</comment>
<item>The indication that <sym>RT</sym> is closed.
</item>

<item>A field type descriptor for every <BNF name="field type"/> simply contained in the 
<BNF name="record type"/>, according to the Syntax Rules and General Rules of 
<specref ref="gql_field_type"/>, applied to the <BNF name="field type"/>s in the order in which 
they were specified.
</item>

<comment>WG3:UTC-051</comment>
<item>The indication of whether <sym>RT</sym> includes the null value as determined by the 
nullability specified by the <BNF name="record type"/>.
</item>

</olist>

</item>

<comment>WG3:W24-026R2</comment>
<item>Otherwise, <sym>RT</sym> is the open record type and a record data type descriptor is 
created for <sym>RT</sym> that describes <sym>RT</sym> and comprises:

<olist>

<item>The base type name of all record types (RECORD DATA).
</item>

<comment>Email from: Hannes Voigt, 2022-12-22 1137</comment>
<item>The indication that <sym>RT</sym> is open.
</item>

<comment>WG3:UTC-051</comment>
<item>The indication of whether <sym>RT</sym> includes the null value as determined by the 
nullability specified by the <BNF name="record type"/>.
</item>

</olist>

</item>

</olist>

</item>
<comment>WG3:UTC-015 Moved 1 (one) GR</comment>

<comment>WG3:UTC-015</comment>
<comment>WG3:W26-023</comment>
<item>If <BNF name="dynamic union type"/> is specified, then let <symdef>DUT</symdef> be the 
specified dynamic union type and a dynamic union data type descriptor is created for <sym>DUT</sym>
that describes <sym>DUT</sym> and comprises:

<olist>

<comment>Editorial; Jim Melton, 2023-09-04; fix which/that problems</comment>
<comment>WG3:CMN-057R1</comment>
<item>The declared name of the primary base type of all dynamic union types, which is the 
dynamic base type of all value types (ANY DATA).

<note>See <specref ref="gql_dyn_union_type_intro"/>.
</note>
</item>

<comment>WG3:W25-025</comment>
<item>The preferred name of <sym>DUT</sym>, which is the declared name of the normal form of 
<sym>DUT</sym>.
</item>

<comment>WG3:W25-025</comment>
<item>The indication of whether <sym>DUT</sym> is open or closed as determined by the 
<BNF name="dynamic union type"/>.
</item>

<item>The component types of <sym>DUT</sym> are defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>DUT</sym> specifies a closed dynamic union type, then the component types of 
<sym>DUT</sym> are given by the set of all data types specified by the 
<BNF name="component type list"/> simply contained in the <BNF name="dynamic union type"/>.
</item>

<item>Otherwise, <sym>DUT</sym> specifies an open dynamic union type.

<olist>

<item>Let <symdef>COMPTYPES</symdef> be an <impDef code="IV014"/> set of nullable value types that 
includes at least one supertype of every static value type supported by the GQL-implementation.
</item>

<item>If the <BNF name="dynamic union type"/> specifies possibly nullable, then the component types 
of <sym>DUT</sym> are <sym>COMPTYPES</sym>; otherwise, the component types of <sym>DUT</sym> are 
given by the set of all material variants of value types from <sym>COMPTYPES</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>Editorial: Stefan Plantikow, 2023-06-02 Align wording</comment>
<item>The indication of whether <sym>DUT</sym> includes the null value as determined by the 
nullability specified by the <BNF name="dynamic union type"/>.
</item>

</olist>

</item>

<item>A dynamic union type <symdef>DUT</symdef> includes every material value of one of its 
component types <sym>DUT</sym>. 
If <sym>DUT</sym> is nullable, then it additionally includes the null value. 
No other values are included in <sym>DUT</sym>.
</item>

<delbar note="1 (one) GR moved"/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-123R2</comment>
<comment>Consequence of WG3:W25-024</comment>
<comment>WG3:UTC-123R2</comment>
<item>Conforming GQL language shall not specify a <BNF name="list value type name"/> that 
contains <kw>GROUP</kw>. 

<comment>WG3:UTC-123R2</comment>
<note>A <BNF name="list value type name"/> that contains <kw>GROUP</kw> is a specification device 
to indicate the group characteristic of a list value type in the syntactic representation of the 
type and is not syntax available to the user.
</note>

</item>

<comment>WG3:UTC-065</comment>
<item>Without <feature code="GV02"/>, conforming GQL language shall not contain 
a <BNF name="signed binary exact numeric type"/> that contains <kw>SIGNED</kw> <kw>INTEGER8</kw>, 
<kw>INTEGER8</kw>, or <kw>INT8</kw>.
</item>

<comment>WG3:CMN-019 P00-USA-122</comment>
<comment>WG3:POS-019</comment>
<item>Without <feature code="GV18"/>, conforming GQL language shall not contain 
a <BNF name="signed binary exact numeric type"/> that contains <kw>SMALLINT</kw> or
<kw>SMALL</kw> <kw>INTEGER</kw>.
</item>

<comment>WG3:CMN-019 P00-USA-122</comment>
<comment>WG3:POS-019</comment>
<item>Without <feature code="GV19"/>, conforming GQL language shall not contain 
a <BNF name="signed binary exact numeric type"/> that contains <kw>BIGINT</kw> or
<kw>BIG</kw> <kw>INTEGER</kw>.
</item>

<comment>WG3:UTC-065</comment>
<item>Without <feature code="GV04"/>, conforming GQL language shall not contain 
a <BNF name="signed binary exact numeric type"/> that contains <kw>SIGNED</kw> <kw>INTEGER16</kw>, 
<kw>INTEGER16</kw>, or <kw>INT16</kw>.
</item>

<comment>WG3:UTC-065</comment>
<item>Without <feature code="GV07"/>, conforming GQL language shall not contain 
a <BNF name="signed binary exact numeric type"/> that contains <kw>SIGNED</kw> <kw>INTEGER32</kw>,
<kw>INTEGER32</kw>, or <kw>INT32</kw>.
</item>

<comment>WG3:UTC-065</comment>
<item>Without <feature code="GV12"/>, conforming GQL language shall not contain 
a <BNF name="signed binary exact numeric type"/> that contains <kw>SIGNED</kw> <kw>INTEGER64</kw>,
<kw>INTEGER64</kw>, or <kw>INT64</kw>.
</item>

<comment>WG3:W22-052R1</comment>
<item>Without <feature code="GV14"/>, conforming GQL language shall not contain 
a <BNF name="signed binary exact numeric type"/> that contains <kw>INT128</kw>, 
<kw>INTEGER128</kw>, or <kw>SIGNED</kw> <kw>INTEGER128</kw>.
</item>

<comment>WG3:W22-052R1</comment>
<item>Without <feature code="GV16"/>, conforming GQL language shall not contain 
a <BNF name="signed binary exact numeric type"/> that contains <kw>INT256</kw>,
<kw>INTEGER256</kw>, or <kw>SIGNED</kw> <kw>INTEGER256</kw>.
</item>

<comment>WG3:UTC-065</comment>
<item>Without <feature code="GV01"/>, conforming GQL language shall not contain 
an <BNF name="unsigned binary exact numeric type"/> that contains 
<kw>UNSIGNED</kw> <kw>INTEGER8</kw> or <kw>UINT8</kw>.
</item>

<comment>WG3:UTC-065</comment>
<item>Without <feature code="GV03"/>, conforming GQL language shall not contain 
an <BNF name="unsigned binary exact numeric type"/> that contains 
<kw>UNSIGNED</kw> <kw>INTEGER16</kw> or <kw>UINT16</kw>.
</item>

<comment>WG3:UTC-065</comment>
<item>Without <feature code="GV06"/>, conforming GQL language shall not contain 
an <BNF name="unsigned binary exact numeric type"/> that contains 
<kw>UNSIGNED</kw> <kw>INTEGER32</kw> or <kw>UINT32</kw>.
</item>

<comment>WG3:UTC-065</comment>
<item>Without <feature code="GV11"/>, conforming GQL language shall not contain 
an <BNF name="unsigned binary exact numeric type"/> that contains 
<kw>UNSIGNED</kw> <kw>INTEGER64</kw> or <kw>UINT64</kw>.
</item>

<comment>WG3:UTC-065</comment>
<comment>WG3:POS-019</comment>
<item>Without <feature code="GV05"/>, conforming GQL language shall not contain 
an <BNF name="unsigned binary exact numeric type"/> that contains <kw>USMALLINT</kw> or
<kw>UNSIGNED</kw> <kw>SMALL</kw> <kw>INTEGER</kw>.
</item>

<comment>WG3:UTC-065</comment>
<comment>WG3:POS-019</comment>
<item>Without <feature code="GV08"/>, conforming GQL language shall not contain 
an <BNF name="unsigned binary exact numeric type"/> that contains <kw>UINT</kw> or
<kw>UNSIGNED</kw> <kw>INTEGER</kw>.
</item>

<comment>WG3:UTC-065</comment>
<comment>WG3:POS-019</comment>
<item>Without <feature code="GV10"/>, conforming GQL language shall not contain 
an <BNF name="unsigned binary exact numeric type"/> that contains <kw>UBIGINT</kw> or
<kw>UNSIGNED</kw> <kw>BIG</kw> <kw>INTEGER</kw>.
</item>

<comment>WG3:UTC-065</comment>
<comment>WG3:POS-019</comment>
<item>Without <feature code="GV09"/>, conforming GQL language shall not contain 
an <BNF name="exact numeric type"/> that contains a <BNF name="precision"/> or 
a <BNF name="scale"/>.
</item>

<comment>WG3:W22-052R1</comment>
<comment>WG3:UTC-065</comment>
<item>Without <feature code="GV13"/>, conforming GQL language shall not contain 
an <BNF name="unsigned binary exact numeric type"/> that contains <kw>UINT128</kw> or 
<kw>UNSIGNED</kw> <kw>INTEGER128</kw>.
</item>

<comment>WG3:W22-052R1</comment>
<comment>WG3:UTC-065</comment>
<item>Without <feature code="GV15"/>, conforming GQL language shall not contain 
an <BNF name="unsigned binary exact numeric type"/> that contains <kw>UINT256</kw> or 
<kw>UNSIGNED</kw> <kw>INTEGER256</kw>.
</item>

<comment>WG3:UTC-065</comment>
<item>Without <feature code="GV20"/>, conforming GQL language shall not contain
an <BNF name="approximate numeric type"/> that contains <kw>FLOAT16</kw>.
</item>

<comment>WG3:UTC-065</comment>
<item>Without <feature code="GV21"/>, conforming GQL language shall not contain
an <BNF name="approximate numeric type"/> that contains <kw>FLOAT32</kw>.
</item>

<comment>WG3:UTC-065</comment>
<item>Without <feature code="GV24"/>, conforming GQL language shall not contain
an <BNF name="approximate numeric type"/> that contains <kw>FLOAT64</kw>.
</item>

<comment>WG3:W22-052R1</comment>
<item>Without <feature code="GV25"/>, conforming GQL language shall not contain 
an <BNF name="approximate numeric type"/> that contains <kw>FLOAT128</kw>.
</item>

<comment>WG3:W22-052R1</comment>
<item>Without <feature code="GV26"/>, conforming GQL language shall not contain 
an <BNF name="approximate numeric type"/> that contains <kw>FLOAT256</kw>.
</item>

<comment>WG3:W22-052R1</comment>
<item>Without <feature code="GV23"/>, conforming GQL language shall not contain
an <BNF name="approximate numeric type"/> that contains <kw>REAL</kw> or <kw>DOUBLE</kw>.
</item>

<comment>WG3:W22-052R1</comment>
<item>Without <feature code="GV22"/>, conforming GQL language shall not
contain an <BNF name="approximate numeric type"/> that contains a <BNF name="precision"/> or 
a <BNF name="scale"/>.
</item>

<comment>WG3:W22-052R1</comment>
<item>Without <feature code="GV17"/>, conforming GQL language shall not contain
an <BNF name="exact numeric type"/> that contains <kw>DECIMAL</kw> or <kw>DEC</kw>.
</item>

<comment>WG3:W22-052R1</comment>
<item>Without <feature code="GV35"/>, conforming GQL language shall not contain
a <BNF name="byte string type"/>.
</item>

<comment>WG3:UTC-065</comment>
<item>Without <feature code="GV36"/>, conforming GQL language shall not contain 
a <BNF name="byte string type"/> that contains a <BNF name="min length"/>.
</item>

<comment>WG3:UTC-065</comment>
<item>Without <feature code="GV37"/>, conforming GQL language shall not contain 
a <BNF name="byte string type"/> that contains a <BNF name="max length"/>.
</item>

<comment>WG3:UTC-065</comment>
<item>Without <feature code="GV38"/>, conforming GQL language shall not contain 
a <BNF name="byte string type"/> that contains a <BNF name="fixed length"/>.
</item>

<comment>WG3:W26-026R2</comment>
<item>Without <feature code="GV30"/>, conforming GQL language shall not contain 
a <BNF name="character string type"/> that contains a <BNF name="min length"/>.
</item>

<comment>WG3:UTC-065</comment>
<item>Without <feature code="GV31"/>, conforming GQL language shall not contain 
a <BNF name="character string type"/> that contains a <BNF name="max length"/>.
</item>

<comment>WG3:W26-026R2</comment>
<item>Without <feature code="GV32"/>, conforming GQL language shall not contain 
a <BNF name="character string type"/> that contains a <BNF name="fixed length"/>.
</item>

<comment>WG3:CMN-052R1</comment>
<comment>WG3:POS-020R1</comment>
<item>Without <feature code="GV39"/>, conforming GQL language shall not contain
a <BNF name="temporal type"/>.
</item>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-052R1</comment>
<item>Without <feature code="GV40"/>, conforming GQL language shall not contain
a <BNF name="temporal instant type"/> that is a <BNF name="datetime type"/> or
a <BNF name="time type"/>.
</item>

<comment>WG3:UTC-117</comment>
<item>Without <feature code="GV41"/>, conforming GQL language shall not contain
a <BNF name="temporal duration type"/>.
</item>

<comment>WG3:POS-011R1</comment>
<item>Without <feature code="GV42"/>, conforming GQL language shall not contain
a <BNF name="vector type"/>.
</item>

<comment>WG3:W26-026R2</comment>
<item>Without <feature code="GV71"/>, conforming GQL language shall not contain
a <BNF name="null type"/>.
</item>

<comment>WG3:W26-026R2</comment>
<item>Without <feature code="GV72"/>, conforming GQL language shall not contain
an <BNF name="empty type"/>.
</item>

<comment>WG3:W24-026R2</comment>
<item>Without <feature code="GV50"/>, conforming GQL language shall not contain
a <BNF name="list value type"/>.
</item>

<comment>WG3:POS-019</comment>
<item>Without <feature code="GV51"/>, conforming GQL language shall not contain
a <BNF name="list value type"/> that contains <BNF name="max length"/>.
</item>

<comment>WG3:W24-026R2</comment>
<item>Without <feature code="GV45"/>, conforming GQL language shall not contain
a <BNF name="record type"/>.
</item>

<comment>WG3:W24-026R2</comment>
<item>Without <feature code="GV46"/>, conforming GQL language shall not contain
a <BNF name="record type"/> containing a <BNF name="field types specification"/>.
</item>

<comment>WG3:W24-026R2</comment>
<item>Without <feature code="GV47"/>, conforming GQL language shall not contain
a <BNF name="record type"/> not containing a <BNF name="field types specification"/>.
</item>

<comment>WG3:W24-035R1</comment>
<item>Without <feature code="GV55"/>, conforming GQL language shall not contain
a <BNF name="path value type"/>.
</item>

<comment>WG3:UTC-039R1</comment>
<item>Without <feature code="GV60"/>, conforming GQL language shall not contain
a <BNF name="graph reference value type"/>.
</item>

<comment>WG3:UTC-039R1</comment>
<item>Without <feature code="GV61"/>, conforming GQL language shall not contain
a <BNF name="binding table reference value type"/>.
</item>

<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-057R1</comment>
<item>Without <feature code="GV66"/>, conforming GQL language shall not contain 
an <BNF name="open dynamic union type"/> or a <BNF name="list value type"/> that does not 
simply contain a <BNF name="value type"/>.
</item>

<item>Without <feature code="GV67"/>, conforming GQL language shall not contain 
a <BNF name="closed dynamic union type"/>.
</item>

<item>Without <feature code="GV68"/>, conforming GQL language shall not contain 
a <BNF name="dynamic property value type"/>.
</item>

<comment>WG3:UTC-051</comment>
<item>Without <feature code="GV90"/>, conforming GQL language shall not contain 
a <BNF name="not null"/>.
</item>

<comment>WG3:CMN-057R1</comment>
<item>Conforming GQL language shall not contain a <BNF name="dynamic union type"/> that simply
contains exactly one <BNF name="component type"/>.
</item>

<delbar note="1 (one) CR removed"/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-042</comment>
<subClause id="gql_field_type" newpage="true">
<clauseHeading><BNF name="field type"/></clauseHeading>

<bodyMatter>

<Function>

<para>Specify a field type.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="field type">
<rhs>
<BNF name="field name"/> <opt> <BNF name="typed"/> </opt> <BNF name="value type"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<item>Let <symdef>FTL</symdef> be the <BNF name="field type list"/> that simply contains 
the <BNF name="field type"/> <symdef>FT</symdef>.
</item>

<item>The <BNF name="field name"/> shall not be equivalent to the <BNF name="field name"/> of any 
other <BNF name="field type"/> simply contained in <sym>FTL</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Align wording</comment>
<item>The <newterm>name</newterm> of <sym>FT</sym> is the name specified by
the <BNF name="field name"/> simply contained in <sym>FT</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Align wording</comment>
<comment>Editorial: Stephen Cannan, 2024-04-13</comment>
<item>The value type of <sym>FT</sym> is the value type specified by 
the <BNF name="value type"/> simply contained in <sym>FT</sym>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Align wording</comment>
<item>A data type descriptor is created that describes the value type of the field type being
defined.
</item>

<item>A field type descriptor is created that describes the field type being defined. 
The field type descriptor includes the following:

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Align wording</comment>
<item>The name of the field type.
</item>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Align wording</comment>
<item>The value type of the field type.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<item>Without <feature code="GV48"/>, conforming GQL language shall not contain 
a <BNF name="field type"/> that simply contains a <BNF name="record type"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>

</clause>


<clause id="gql_predicates">
<clauseHeading>Predicates</clauseHeading>

<subClause id="gql_search">
<clauseHeading><BNF name="search condition"/></clauseHeading>

<bodyMatter>


<Function>

<para>Specify a condition that is <bool>True</bool>, <bool>False</bool>, or <bool>Unknown</bool>,
depending on the result of a <BNF name="boolean value expression"/>.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="search condition">
<rhs>
<BNF name="boolean value expression"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<None/>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<item>The result of the <BNF name="search condition"/> is the result of the
<BNF name="boolean value expression"/>.
</item>

<item>A <BNF name="search condition"/> is said to be <newterm>satisfied</newterm> if and only if
the result of the <BNF name="boolean value expression"/> is <bool>True</bool>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>Editorial: Stefan Plantikow, 2020-02-07</comment>
<subClause id="gql_pred" newpage="true">
<clauseHeading><BNF name="predicate"/></clauseHeading>

<bodyMatter>


<Function>

<comment>Editorial: Stephen Cannan, 2021-04-02 See WG3:W09-024</comment>
<comment>Editorial: Stefan Plantikow, 2021-06-19 Lower-case Boolean value</comment>
<para>Specify a condition that can be evaluated to give a Boolean value.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stephen Cannan, 2020-05-26 Add place-holders for probably needed items</comment>
<comment>WG3:W10-017</comment>
<comment>WG3:W15-010</comment>
<comment>WG3:UTC-127R1</comment>
<comment>WG3:CMN-019 P00-USA-126</comment>
<BNFdef name="predicate">
<rhs>
<alt> <BNF name="comparison predicate"/> </alt>
<alt> <BNF name="exists predicate"/> </alt>
<alt> <BNF name="null predicate"/> </alt>
<alt> <BNF name="normalized predicate"/> </alt>
<alt> <BNF name="value type predicate"/> </alt>
<alt> <BNF name="directed predicate"/> </alt>
<alt> <BNF name="labeled predicate"/> </alt>
<alt> <BNF name="source/destination predicate"/> </alt>
<alt> <BNF name="all_different predicate"/> </alt>
<alt> <BNF name="same predicate"/> </alt>
<alt> <BNF name="property_exists predicate"/> </alt>
</rhs>
</BNFdef>

<ednote id="gql_PP177_1">SQL contains other possibly relevant predicates such as:

<ulist>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>The <BNF name="in predicate" standard="9075" part="02"/>, which is effectively a syntactic 
shorthand for a <BNF name="search condition"/> involving 
a <BNF name="quantified comparison predicate" standard="9075" part="02"/>
The SQL variant allows table subqueries as well as lists, TigerGraph<apos/>s variant supports bags, 
but Cypher does not have the syntax although it does have an equivalent for the quantified 
comparison predicate and a predicate function none() that is roughly equivalent to NOT IN.
</item>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>The <BNF name="quantified comparison predicate" standard="9075" part="02"/>, which can 
operate on arrays and multisets.
TigerGraph has no direct equivalent (but see the IN predicate), Cypher has radically different 
syntax for the same result, it uses the all() and any() predicate functions as well as the single()
predicate function, which has no direct equivalent in SQL.
Discussion is needed on how to represent this functionality in GQL.
</item>

<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<item>The <BNF name="overlaps predicate" standard="9075" part="02"/>, which is syntactic shorthand 
for a complex <BNF name="search condition"/> involving <BNF name="comparison predicate"/>s and 
is very tricky to get right.
</item>

<item>The <BNF name="member predicate" standard="9075" part="02"/>, which operates on multisets.
</item>

<item>The <BNF name="submultiset predicate" standard="9075" part="02"/>, which operates on 
multisets.
</item>

<item>The <BNF name="set predicate" standard="9075" part="02"/>, which operates on multisets.
</item>

<item>The <BNF name="type predicate" standard="9075" part="02"/>, which concerns user-defined types.
Does this have relevance in the dynamic type context of GQL?
</item>

<item>The <BNF name="period predicate" standard="9075" part="02"/>, which concerns periods.
But see also the <BNF name="overlaps predicate" standard="9075" part="02"/>.
</item>

</ulist>

<para>Discussion on the inclusion or non-inclusion of the above predicates is required.
</para>

<para>See <PPref ref="PPgql177"/>.
</para>

</ednote>

<ednote id="gql_PP177_2">SQL contains other predicates that may not be relevant:

<ulist>

<comment>Editorial; Jim Melton, 2023-09-04; fix which/that problems</comment>
<item>The <BNF name="exists predicate" standard="9075" part="02"/>, which operates on tables, 
whereas GQL has an equivalent predicate that operates on graphs.
</item>

<item>The <BNF name="unique predicate" standard="9075" part="02"/>, which operates on tables.
</item>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>The <BNF name="match predicate" standard="9075" part="02"/>, which operates on tables.
</item>

<comment>WG3:UTC-082R1 Deleted 1 (one) item</comment>

</ulist>

<para>See <PPref ref="PPgql177"/>.
</para>

</ednote>

<ednote id="gql_PP177_3">TigerGraph contains another predicate that may be relevant:

<ulist>

<item>ISEMPTY, which operates on bags.
</item>

</ulist>

<para>Discussion is required as to whether the functions named above should be incorporated 
into GQL.
</para>

<para>See <PPref ref="PPgql177"/>.
</para>

</ednote>

</grammar>

</Format>


<SyntaxRules>

<olist>

<None/>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>Editorial: Stephen Cannan, 2020-05-26 Add place-holders for probably needed items</comment>
<comment>WG3:W10-017</comment>
<comment>WG3:W11-014</comment>
<comment>WG3:W15-010</comment>
<comment>Editorial: Stefan Plantikow, 2022-03-27 1113 Corrected wording</comment>
<comment>WG3:UTC-127R1</comment>
<comment>WG3:CMN-019 P00-USA-126</comment>
<item>The result of a <BNF name="predicate"/> is the result of the immediately contained
<BNF name="comparison predicate"/>, <BNF name="exists predicate"/>, <BNF name="null predicate"/>, 
<BNF name="value type predicate"/>, <BNF name="normalized predicate"/>, 
<BNF name="directed predicate"/>, <BNF name="labeled predicate"/>, 
<BNF name="source/destination predicate"/>, <BNF name="all_different predicate"/>, 
<BNF name="same predicate"/>, or <BNF name="property_exists predicate"/>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_comp" newpage="true">
<clauseHeading><BNF name="comparison predicate"/></clauseHeading>

<bodyMatter>

<Function>

<para>Specify a comparison of two values.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:W21-058</comment>
<comment>WG3:W24-037</comment>
<BNFdef name="comparison predicate">
<rhs>
<BNF name="comparison predicand"/>
<BNF name="comparison predicate part 2"/>
</rhs>
</BNFdef>

<comment>WG3:W21-058</comment>
<BNFdef name="comparison predicate part 2">
<rhs>
<BNF name="comp op"/> <BNF name="comparison predicand"/>
</rhs>
</BNFdef>

<BNFdef name="comp op">
<rhs>
<alt> <BNF name="equals operator"/> </alt>
<alt> <BNF name="not equals operator"/> </alt>
<alt> <BNF name="less than operator"/> </alt>
<alt> <BNF name="greater than operator"/> </alt>
<alt> <BNF name="less than or equals operator"/> </alt>
<alt> <BNF name="greater than or equals operator"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W24-037</comment>
<BNFdef name="comparison predicand">
<rhs>
<alt> <BNF name="common value expression"/> </alt>
<alt> <BNF name="boolean predicand"/> </alt>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:W21-058</comment>
<comment>WG3:W24-037</comment>
<item>Let <symdef>L</symdef> and <symdef>R</symdef> respectively denote the first and second
<BNF name="comparison predicand"/>s.
</item>

<item>Case:

<olist>

<item>If <BNF name="comp op"/> is <BNF name="equals operator"/> or
<BNF name="not equals operator"/>, then <sym>L</sym> and <sym>R</sym> are operands of an equality
operation.
The Syntax Rules and Conformance Rules of <specref ref="gql_equality_ops"/>, apply.
</item>

<item>Otherwise, <sym>L</sym> and <sym>R</sym> are operands of an ordering operation.
The Syntax Rules and Conformance Rules of <specref ref="gql_ordering_ops"/>, apply.
</item>

</olist>

</item>

<comment>WG3:W24-026R2</comment>
<item>Case:

<olist>

<item>If the declared types of <sym>L</sym> and <sym>R</sym> are list value types with
list element types <symdef>LET</symdef> and <symdef>RET</symdef>, respectively, then 
let <symdef>LV</symdef> and <symdef>RV</symdef> be <BNF name="value expression"/>s whose
declared types are <sym>LET</sym> and <sym>RET</sym>, respectively. 
The Syntax Rules of this Subclause are applied to:

<code>
<sym>LV</sym> <BNF name="comp op"/> <sym>RV</sym>
</code>

</item>

<comment>WG3:CMN-019 P00-USA-207</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>If the declared types of <sym>L</sym> and <sym>R</sym> are record types with identical sets of
field type names <symdef>FNS</symdef>, then let <symdef>N</symdef> be
the cardinality of <sym>FNS</sym>, let <symdef>FN</symdef><sub><sym>i</sym></sub>, 
1 (one) <leq/> <symdef>i</symdef> <leq/> <sym>N</sym>, be the <sym>i</sym>-th name in 
a permutation of <sym>FNS</sym>, let <symdef>LFV</symdef><sub><sym>i</sym></sub> denote 
some <BNF name="value expression"/> whose declared type is the value type of the field type
with name <sym>FN</sym><sub><sym>i</sym></sub> of the declared types of <sym>L</sym>, and 
let <symdef>RFV</symdef><sub><sym>i</sym></sub> denote some <BNF name="value expression"/> whose 
declared type is the value type of the field type with name <sym>FN</sym><sub><sym>i</sym></sub>
of the declared types of <sym>R</sym>. 
For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>, the Syntax Rules of this 
Subclause are applied to:

<code>
<sym>LFV</sym><sub><sym>i</sym></sub> <BNF name="comp op"/> <sym>RFV</sym><sub><sym>i</sym></sub>
</code>

</item>

</olist>

</item>

<comment>WG3:W21-058</comment>
<item>Let <symdef>CP</symdef> be the <BNF name="comparison predicate"/>.
The following syntactic transformations are applied.

<para>Case:
</para>

<olist>

<item>If the <BNF name="comp op"/> is <BNF name="not equals operator"/>, then <sym>CP</sym>
is equivalent to:

<code>
<kw>NOT</kw> ( <sym>L</sym> = <sym>R</sym> )
</code>

</item>

<item>If the <BNF name="comp op"/> is <BNF name="greater than operator"/>, then <sym>CP</sym>
is equivalent to:

<code>
( <sym>R</sym> &lt; <sym>L</sym> )
</code>

</item>

<item>If the <BNF name="comp op"/> is <BNF name="less than or equals operator"/>, then
<sym>CP</sym> is equivalent to:

<comment>WG3:W21-058</comment>
<code>
( <sym>L</sym> &lt; <sym>R</sym>
    <kw>OR</kw>
  <sym>L</sym> = <sym>R</sym> )
</code>

</item>

<item>If the <BNF name="comp op"/> is <BNF name="greater than or equals operator"/>, then
<sym>CP</sym> is equivalent to:

<code>
( <sym>R</sym> &lt; <sym>L</sym>
    <kw>OR</kw>
  <sym>R</sym> = <sym>L</sym> )
</code>

</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:W21-058</comment>
<comment>WG3:W24-037</comment>
<item>Let <symdef>LV</symdef> and <symdef>RV</symdef> be the results of the
<BNF name="comparison predicand"/>s <sym>L</sym> and <sym>R</sym>, respectively.
</item>
<comment>WG3:W26-024 Removed 1 (one) General Rule</comment>

<comment>Editorial: Stefan Plantikow, 2023-11-22 Consolidate implicit Case</comment>
<item>The result of <symdef>CP</symdef> is defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W26-024</comment>
<comment>Email from: Nathalie Charbel, 2023-11-20 1628 WG3 W26</comment>
<item>If <sym>LV</sym> and <sym>RV</sym> are universally comparable values, then

<para>Case:
</para>

<olist>

<item>If the <BNF name="comp op"/> is <BNF name="equals operator"/>, then
the result of <sym>CP</sym> is <bool>False</bool>.

<note>This ensures that every two values that are defined in this document as
not essentially comparable values are never considered equal.
</note>

</item>

<comment>Editorial: Stefan Plantikow, 2023-11-21 Wording</comment>
<item>Otherwise, the <BNF name="comp op"/> is <BNF name="less than operator"/> and
the result of <sym>CP</sym> is determined according to an <impDef code="IV010"/> total order.
This total order shall be stable during the execution of the currently executing GQL-request.
</item>

</olist>

</item>

<comment>WG3:W21-058</comment>
<item>If <symdef>LV</symdef> and <symdef>RV</symdef> are essentially comparable values, then:

<para>Case:
</para>

<olist>

<item>If at least one of <sym>LV</sym> and <sym>RV</sym> is the null value, then the result of 
<sym>CP</sym> is <bool>Unknown</bool>.
</item>

<comment>WG3:CMN-019 P00-NLD-050</comment>
<comment>Wording</comment>
<item>If <sym>LV</sym> and <sym>RV</sym> are list values, then:

<olist>

<item>Let <symdef>NL</symdef> and <symdef>NR</symdef> be the cardinalities of
<sym>LV</sym> and <sym>RV</sym>, respectively.
</item>

<item>Let <symdef>MINL</symdef> be the minimum of <sym>NL</sym> and <sym>NR</sym>.
</item>

<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NL</sym>:
Let <symdef>LE</symdef><sub><sym>i</sym></sub> denote a <BNF name="value expression"/>
whose value and declared type is that of the <sym>i</sym>-th element of <sym>LV</sym>.
</item>

<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NR</sym>:
Let <symdef>RE</symdef><sub><sym>i</sym></sub> denote a <BNF name="value expression"/> 
whose value and declared type is that of the <sym>i</sym>-th element of <sym>RV</sym>.
</item>

<item>Case:

<olist>

<item>If the <BNF name="comp op"/> is <BNF name="equals operator"/>, then

<para>Case:
</para>

<olist>

<item>If <sym>NL</sym> = 0 (zero) and <sym>NR</sym> = 0 (zero), then the result of <sym>CP</sym> is 
<bool>True</bool>.
</item>

<item>If <sym>NL</sym> = <sym>NR</sym> and 
<sym>LE</sym><sub><sym>i</sym></sub> = <sym>RE</sym><sub><sym>i</sym></sub> is <bool>True</bool> 
for all <sym>i</sym>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NL</sym> = <sym>NR</sym>, then
the result of <sym>CP</sym> is <bool>True</bool>.
</item>

<item>If <sym>NL</sym> <neq/> <sym>NR</sym> or 
<kw>NOT</kw> ( <sym>LE</sym><sub><sym>i</sym></sub> = <sym>RE</sym><sub><sym>i</sym></sub> ) is 
<bool>True</bool> for some <sym>i</sym>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>MINL</sym> then
the result of <sym>CP</sym> is <bool>False</bool>.
</item>

<item>Otherwise, the result of <sym>CP</sym> is <bool>Unknown</bool>.
</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-127</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-21 Wording</comment>
<item>Otherwise, the <BNF name="comp op"/> is <BNF name="less than operator"/> and
the result of <sym>CP</sym> is <impDef code="IV002"/>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-207</comment>
<comment>WG3:CMN-019 P00-NLD-050</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<comment>Wording</comment>
<item>If <sym>LV</sym> and <sym>RV</sym> are records, then:

<olist>

<item><sym>LV</sym> and <sym>RV</sym> have the same set of field names <symdef>FNS</symdef>. 
</item>

<item>Let <symdef>N</symdef> be the cardinality of <sym>FNS</sym>.
</item>

<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>:
Let <symdef>FN</symdef><sub><sym>i</sym></sub> be the <sym>i</sym>-th field name in 
a permutation of <sym>FNS</sym>, 
let <symdef>LFV</symdef><sub><sym>i</sym></sub> denote a <BNF name="value expression"/> whose value
is the value of the field with name <sym>FN</sym><sub><sym>i</sym></sub> of <sym>LV</sym> and
whose declared type is the value type of the field type with name
<sym>FN</sym><sub><sym>i</sym></sub> of the declared type of <sym>LV</sym>, and 
let <symdef>RFV</symdef><sub><sym>i</sym></sub> denote a <BNF name="value expression"/> whose value
is the value of the field with name <sym>FN</sym><sub><sym>i</sym></sub> of <sym>RV</sym> and
whose declared type is the value type of the field type with name
<sym>FN</sym><sub><sym>i</sym></sub> of the declared type of <sym>RV</sym>. 
</item>

<item>Case:

<olist>

<item>If the <BNF name="comp op"/> is <BNF name="equals operator"/>, then

<para>Case:
</para>

<olist>

<item>If <sym>LFV</sym><sub><sym>i</sym></sub> = <sym>RFV</sym><sub><sym>i</sym></sub> is 
<bool>True</bool> for all <sym>i</sym>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym> then
the result of <sym>CP</sym> is <bool>True</bool>.
</item>

<item>If 
<kw>NOT</kw> ( <sym>LFV</sym><sub><sym>i</sym></sub> = <sym>RFV</sym><sub><sym>i</sym></sub> ) is 
<bool>True</bool> for some <sym>i</sym>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym> then
the result of <sym>CP</sym> is <bool>False</bool>.
</item>

<item>Otherwise, the result of <sym>CP</sym> is <bool>Unknown</bool>.
</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-128</comment>
<item>Otherwise, the <BNF name="comp op"/> is <BNF name="less than operator"/> and
the result of <sym>CP</sym> is <impDef code="IV002"/>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W26-024 Removed 1 (one) Subrule</comment>

<comment>WG3:W24-035R1</comment>
<comment>Email from: Nathalie Charbel, 2023-11-20 1628 WG3 W26</comment>
<comment>WG3:W27-014R1</comment>
<item>If <sym>LV</sym> and <sym>RV</sym> are path values, then:

<olist>

<comment>WG3:W27-014R1</comment>
<item>Let <symdef>LPEL</symdef> and <symdef>RPEL</symdef> be the path element lists of <sym>LV</sym>
and <sym>RV</sym>, respectively.
</item>

<comment>WG3:W27-014R1</comment>
<item>Case:

<olist>

<comment>WG3:W27-014R1</comment>
<item>If the <BNF name="comp op"/> is <BNF name="equals operator"/>, then

<comment>WG3:W27-014R1</comment>
<para>Case:
</para>

<olist>

<comment>WG3:W27-014R1</comment>
<item>If <sym>LPEL</sym> = <sym>RPEL</sym> is <bool>True</bool>, then the result of <sym>CP</sym>
is <bool>True</bool>.
</item>

<comment>WG3:W27-014R1</comment>
<item>Otherwise, the result of <sym>CP</sym> is <bool>False</bool>.
</item>

</olist>

</item>

<comment>WG3:W27-014R1</comment>
<item>Otherwise, the <BNF name="comp op"/> is <BNF name="less than operator"/> and

<comment>WG3:W27-014R1</comment>
<para>Case:
</para>

<olist>

<comment>WG3:W27-014R1</comment>
<item>If <sym>LPEL</sym> &lt; <sym>RPEL</sym> is <bool>True</bool>, then the result of <sym>CP</sym>
is <bool>True</bool>.
</item>

<comment>WG3:W27-014R1</comment>
<item>Otherwise, the result of <sym>CP</sym> is <bool>False</bool>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>


<comment>Editorial: Stefan Plantikow, 2023-11-22 Expand otherwise</comment>
<comment>WG3:W27-014R1</comment>
<item>Otherwise, <sym>LV</sym> and <sym>RV</sym> are values of predefined value types and:

<olist>

<item>If the <BNF name="comp op"/> is <BNF name="equals operator"/>, then:

<olist>

<item>If <sym>LV</sym> and <sym>RV</sym> are equal, then the result of <sym>CP</sym> is 
<bool>True</bool>.

<comment>WG3:W27-014R1</comment>
<note>Whether <sym>LV</sym> is equal to <sym>RV</sym> is determined by an application of
<itemref ref="gql_comp_GR_ess_comp_vals" type="GR"/> of this Subclause, which defines
the comparison of essentially comparable values of predefined value types.
</note>

</item>

<item>Otherwise, the result of <sym>CP</sym> is <bool>False</bool>.
</item>

</olist>

</item>

<item>If the <BNF name="comp op"/> is <BNF name="less than operator"/>, then:

<olist>

<item>If <sym>LV</sym> is less than <sym>RV</sym>, then the result of <sym>CP</sym> is 
<bool>True</bool>.

<comment>WG3:W27-014R1</comment>
<note>Whether <sym>LV</sym> is less than <sym>RV</sym> is determined by an application of
<itemref ref="gql_comp_GR_ess_comp_vals" type="GR"/> of this Subclause, which defines
the comparison of essentially comparable values of predefined value types.
</note>

</item>

<item>Otherwise, the result of <sym>CP</sym> is <bool>False</bool>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W26-024</comment>
<item>Otherwise, <sym>LV</sym> and <sym>RV</sym> are not comparable values and
an exception condition is raised: <raise class="22" subclass="G04"/>.
</item>

</olist>

</item>

<comment>WG3:W27-014R1</comment>
<item id="gql_comp_GR_ess_comp_vals">Given two essentially comparable values <symdef>V1</symdef> and
<symdef>V2</symdef> of predefined value types, the comparison of <sym>V1</sym> and <sym>V2</sym>, 
<ie/> whether <sym>V1</sym> is less than, equal to, or greater than <sym>V2</sym>, is defined 
as follows:

<olist>

<comment>Email from: Nathalie Charbel, 2023-11-20 1628 WG3 W26</comment>
<comment>WG3:W27-014R1</comment>
<item>If <sym>V1</sym> and <sym>V2</sym> are numbers, then they are compared with respect to
their numerical values.
</item>

<comment>Email from: Nathalie Charbel, 2023-11-22 1635 WG3 W26024</comment>
<comment>WG3:W27-014R1</comment>
<item>If <sym>V1</sym> and <sym>V2</sym> are character strings, then:

<olist>

<item>If the length in characters of <sym>V1</sym> is not equal to the length in characters of
<sym>V2</sym>, then it is <impDef code="IA015"/> if the shorter character string is effectively 
replaced, for the purposes of comparison, with a copy of itself that has been extended to the 
length of the longer character string by concatenation on the right of one or more 
<BNF name="space"/> characters.
</item>

<comment>WG3:W21-058</comment>
<item>The <applySC rules="SR" ref="gql_collationdeterm">
<symresult param="COLL"><symdef>CS</symdef></symresult>
</applySC>.

<ednote id="SQL_diff20">Consider explicit support for additional collations other than 
UCS_BASIC and UNICODE (<eg/> case insensitive variants, use of alternative collation 
tables).
See <PPref ref="PPgql012"/>.
</ednote>
</item>

<item>The result of the comparison of <sym>V1</sym> and <sym>V2</sym> is given by the 
collation <sym>CS</sym>.
</item>

</olist>

</item>

<comment>WG3:W21-058</comment>
<comment>Editorial: Nathalie Charbel, 2023-11-22 1635 WG3 W26024</comment>
<comment>WG3:W27-014R1</comment>
<item>If <sym>V1</sym> and <sym>V2</sym> are byte strings, then:

<olist>

<item>Let <symdef>LENGTH_V1</symdef> be the length in bytes of <sym>V1</sym> and 
let <symdef>LENGTH_V2</symdef> be the length in bytes of <sym>V2</sym>. 
For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>LENGTH_V1</sym>, 
let <symdef>V1</symdef><sub><sym>i</sym></sub> be the <sym>i</sym>-th byte of <sym>V1</sym>, and 
For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <sym>LENGTH_V2</sym>, 
let <symdef>V2</symdef><sub><sym>i</sym></sub> be the <sym>i</sym>-th byte of <sym>V2</sym>.
</item>

<comment>WG3:CMN-019 P00-NLD-050</comment>
<item>If <sym>LENGTH_V1</sym> = <sym>LENGTH_V2</sym> and 
for <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>LENGTH_V1</sym>, 
<sym>V1</sym><sub><sym>i</sym></sub> = <sym>V2</sym><sub><sym>i</sym></sub>, then
<sym>V1</sym> is equal to <sym>V2</sym>.
</item>

<item>If <sym>LENGTH_V1</sym> &lt; <sym>LENGTH_V2</sym>,
<sym>V1</sym><sub><sym>i</sym></sub> = <sym>V2</sym><sub><sym>i</sym></sub>
for all <sym>i</sym> <leq/> <sym>LENGTH_V1</sym>, and the right-most 
<sym>LENGTH_V2</sym> &minus; <sym>LENGTH_V1</sym> bytes of <sym>V2</sym>
are all X<string>00</string>s, then it is <impDef code="IA016"/> whether 
<sym>V1</sym> is equal to <sym>V2</sym> or whether <sym>V1</sym> is 
less than <sym>V2</sym>.
</item>

<item>If <sym>LENGTH_V1</sym> &lt; <sym>LENGTH_V2</sym>,
<sym>V1</sym><sub><sym>i</sym></sub> = <sym>V2</sym><sub><sym>i</sym></sub>
for all <sym>i</sym> <leq/> <sym>LENGTH_V1</sym>, and at least one of the right-most
<sym>LENGTH_V2</sym> &minus; <sym>LENGTH_V1</sym> bytes of <sym>V2</sym>
is not X<string>00</string>s, then <sym>V1</sym> is less than <sym>V2</sym>.
</item>

<item>If <sym>V1</sym><sub><sym>j</sym></sub> &lt; <sym>V2</sym><sub><sym>j</sym></sub>,
for some <sym>j</sym>, 0 (zero) &lt; <symdef>j</symdef> <leq/> 
minimum( <sym>LENGTH_V1</sym>, <sym>LENGTH_V2</sym>), and
<sym>V1</sym><sub><sym>i</sym></sub> = <sym>V2</sym><sub><sym>i</sym></sub>
for all <sym>i</sym> &lt; <sym>j</sym>, then <sym>V1</sym> is less than <sym>V2</sym>.
</item>

<item>Otherwise, <sym>V1</sym> is greater than <sym>V2</sym>.
</item>

</olist>

</item>
<comment>WG3:UTC-117 Deleted 1 (one) GR</comment>

<comment>WG3:UTC-117</comment>
<comment>Email from: Nathalie Charbel, 2023-11-22 1635 WG3 W26024</comment>
<comment>WG3:W27-014R1</comment>
<item>If <sym>V1</sym> and <sym>V2</sym> are temporal instants, then:

<olist>

<item>Let <symdef>RD</symdef> be
the duration that results from <kw>DURATION_BETWEEN</kw>(<sym>V1</sym>, <sym>V2</sym>).
</item>

<item>Case:

<olist>

<comment>WG3:W26-024 Removed 1 (one) Subrule</comment>

<comment>Editorial: Stephen Cannan, 2023-06-23, Correct symbols</comment>
<item>If <sym>RD</sym> is zero, then <sym>V1</sym> is equal to <sym>V2</sym>.
</item>

<comment>WG3:W26-024 Removed 1 (one) Subrule</comment>

<comment>Editorial: Stephen Cannan, 2023-06-23, Correct symbols</comment>
<item>If <sym>RD</sym> is negative, then <sym>V1</sym> is less than <sym>V2</sym>.
</item>

<comment>Email from: Nathalie Charbel, 2023-11-20 1628 WG3 W26</comment>
<item>Otherwise, <sym>RD</sym> is positive and <sym>V1</sym> is greater than <sym>V2</sym>.
</item>

<comment>WG3:W26-024 Removed 2 Subrules</comment>

</olist>

</item>

</olist>

</item>
<comment>WG3:UTC-117 Deleted 1 (one) GR</comment>

<comment>WG3:UTC-117</comment>
<comment>WG3:W27-014R1</comment>
<item>If <sym>V1</sym> and <sym>V2</sym> are year and month-based durations, then they are compared
with respect to their corresponding values after conversion to a duration expressed in months.
</item>

<comment>WG3:UTC-117</comment>
<comment>WG3:W27-014R1</comment>
<item>If <sym>V1</sym> and <sym>V2</sym> are day and time-based durations, then they are compared
with respect to their corresponding values after conversion to a duration expressed in seconds.
</item>

<comment>Editorial: Stephen Cannan, 2021-04-02 See WG3:W09-024</comment>
<comment>Editorial: Stefan Plantikow, 2021-06-19 Lower-case Boolean value</comment>
<comment>WG3:W27-014R1</comment>
<item>If <sym>V1</sym> and <sym>V2</sym> are Boolean values, then

<comment>WG3:W27-014R1</comment>
<para>Case:
</para>

<olist>

<comment>WG3:W27-014R1</comment>
<item>If <sym>V1</sym> and <sym>V2</sym> are either both <bool>False</bool> or
both <bool>True</bool>, then <sym>V1</sym> and <sym>V2</sym> are equal.
</item>

<comment>WG3:W27-014R1</comment>
<item>If <sym>V1</sym> is <bool>False</bool> and <sym>V2</sym> is <bool>True</bool>, then 
<sym>V1</sym> is less than <sym>V2</sym>.
</item>

<comment>WG3:W27-014R1</comment>
<item>Otherwise, <sym>V1</sym> is <bool>True</bool>, <sym>V2</sym> is <bool>False</bool>, and
<sym>V1</sym> is greater than <sym>V2</sym>.
</item>

</olist>

</item>

<comment>WG3:BER-040R3</comment>
<comment>WG3:UTC-015</comment>
<comment>Email from: Nathalie Charbel, 2023-11-20 1628 WG3 W26</comment>
<comment>WG3:W27-014R1</comment>
<item>Otherwise, <symdef>V1</symdef> and <symdef>V2</symdef> are reference values of
the same static base type, and:

<comment>WG3:W27-014R1</comment>
<para>Case:
</para>

<olist>

<comment>WG3:W27-014R1</comment>
<item>If <sym>V1</sym> and <sym>V2</sym> reference the same referent, then <sym>V1</sym> is equal to
<sym>V2</sym>.
</item>

<comment>WG3:CMN-031</comment>
<comment>WG3:W27-014R1</comment>
<item>Otherwise, <sym>V1</sym> and <sym>V2</sym> reference different referents and then:

<olist>

<comment>WG3:W27-014R1</comment>
<item><sym>V1</sym> is not equal to <sym>V2</sym>.
</item>

<comment>WG3:W27-014R1</comment>
<item>Whether <sym>V1</sym> is less than or greater than <sym>V2</sym> is <impDef code="IV002"/>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-130 1 (one) SR removed</comment>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W26-024 Removed 1 (one) Conformance Rule and related note</comment>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>Editorial: Stefan Plantikow, 2020-02-07</comment>
<subClause id="gql_exists" newpage="true">
<clauseHeading><BNF name="exists predicate"/></clauseHeading>

<bodyMatter>


<Function>

<para>Specify an existential subquery.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-10-09 Add parenthesis</comment>
<comment>Editorial: Stefan Plantikow, 2021-04-26 Fixed wrongly nested grouping</comment>
<comment>WG3:W24-012</comment>
<comment>WG3:UTC-046</comment>
<BNFdef name="exists predicate">
<rhs>
<kw>EXISTS</kw>
<group> 
<alt> <BNF name="left brace"/> <BNF name="graph pattern"/> <BNF name="right brace"/> </alt>
<alt> <BNF name="left paren"/> <BNF name="graph pattern"/> <BNF name="right paren"/> </alt>
<alt> <BNF name="left brace"/> <BNF name="match statement block"/> <BNF name="right brace"/> </alt>
<alt> <BNF name="left paren"/> <BNF name="match statement block"/> <BNF name="right paren"/> </alt>
<alt> <BNF name="nested query specification"/> </alt>
</group>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>Editorial: Stefan Plantikow, 2020-10-09 Added SRs for shorthand</comment>
<item>Let <symdef>EP</symdef> be the <BNF name="exists predicate"/>.
</item>

<item id="gql_exists_gp_SR">If <sym>EP</sym> immediately contains the <BNF name="graph pattern"/>
<symdef>GP</symdef>, then:

<olist>

<comment>WG3:W26-037R3</comment>
<item>Let <symdef>RIA</symdef> be a new system-generated identifier.
</item>

<comment>WG3:W24-012</comment>
<item><sym>EP</sym> is effectively replaced by:
<code>
<kw>EXISTS</kw> { <kw>MATCH</kw> <sym>GP</sym> <kw>RETURN</kw> <kw>TRUE</kw> <kw>AS</kw> <sym>RIA</sym> }
</code>
</item>

</olist>

</item>

<comment>WG3:UTC-046</comment>
<item>If <sym>EP</sym> immediately contains the
<BNF name="match statement block"/> <symdef>MSB</symdef>, then:

<olist>

<comment>WG3:W26-037R3</comment>
<item>Let <symdef>RIA2</symdef> be a new system-generated identifier.
</item>

<item><sym>EP</sym> is effectively replaced by:
<code>
<kw>EXISTS</kw> { <sym>MSB</sym> <kw>RETURN</kw> <kw>TRUE</kw> <kw>AS</kw> <sym>RIA2</sym> }
</code>
</item>

</olist>

</item>

<comment>WG3:W24-012</comment>
<item>Let <symdef>NQS</symdef> be the <BNF name="nested query specification"/> 
immediately contained in <sym>EP</sym>.
</item>

<comment>WG3:W24-012</comment>
<item>The declared type of <sym>NQS</sym> shall be a binding table type.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2020-10-09 Sketch GRs</comment>
<olist>

<item>In a new child execution context:

<olist>

<comment>Editorial: Stefan Plantikow, 2022-03-25 WG3:RKE-010 P00-NLD-219 Wording</comment>
<item>The General Rules of <sym>NQS</sym> are applied.
</item>

<comment>WG3:W24-012</comment>
<item>If the current execution result is a non-empty table, then the result of <sym>EP</sym> is
<bool>True</bool>; otherwise, the result of <sym>EP</sym> is <bool>False</bool>.
</item>

</olist>

</item>

</olist>


</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-046</comment>
<comment>WG3:CMN-019 P00-USA-077</comment>
<item>Without <feature code="GQ22"/>, in conforming GQL language, an <BNF name="exists predicate"/> 
shall not directly contain a <BNF name="match statement block"/>
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>Editorial: Stephen Cannan, 2020-05-26 Add place-holders for probably needed items</comment>
<subClause id="gql_null" newpage="true">
<clauseHeading><BNF name="null predicate"/></clauseHeading>

<bodyMatter>

<Function>

<para>Specify a test for a null value.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:W09-033</comment>
<BNFdef name="null predicate">
<rhs>
<BNF name="value expression primary"/> <BNF name="null predicate part 2"/>
</rhs>
</BNFdef>

<comment>WG3:W09-033</comment>
<BNFdef name="null predicate part 2">
<rhs>
<kw>IS</kw> <opt> <kw>NOT</kw> </opt> <kw>NULL</kw>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<None/>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:W23-031</comment>
<item>Let <symdef>VEP</symdef> be the <BNF name="value expression primary"/>. 
</item>

<comment>WG3:W23-031</comment>
<item>Let <symdef>VEPR</symdef> be the result of <sym>VEP</sym>.
</item>

<comment>WG3:W23-031</comment>
<item>Case:

<olist>

<comment>WG3:W23-031</comment>
<item>If <sym>VEPR</sym> is the null value, then 
<quote><mono><sym>VEP</sym> <kw>IS</kw> <kw>NULL</kw></mono></quote> is <bool>True</bool> and 
the result of <quote><mono><sym>VEP</sym> <kw>IS</kw> <kw>NOT</kw> <kw>NULL</kw></mono></quote>
is <bool>False</bool>.
</item>

<comment>WG3:W23-031</comment>
<item>Otherwise, 
<quote><mono><sym>VEP</sym> <kw>IS</kw> <kw>NULL</kw></mono></quote> is <bool>False</bool> and 
the result of <quote><mono><sym>VEP</sym> <kw>IS</kw> <kw>NOT</kw> <kw>NULL</kw></mono></quote>
is <bool>True</bool>.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:UTC-015</comment>
<subClause id="gql_val_type_pred" newpage="true">
<clauseHeading><BNF name="value type predicate"/></clauseHeading>

<bodyMatter>

<Function>

<para>Specify a value type test.
</para>

</Function>

<Format>

<grammar>

<BNFdef name="value type predicate">
<rhs>
<BNF name="value expression primary"/> <BNF name="value type predicate part 2"/>
</rhs>
</BNFdef>

<BNFdef name="value type predicate part 2">
<rhs>
<kw>IS</kw> <opt> <kw>NOT</kw> </opt> <BNF name="typed"/> <BNF name="value type"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<item>Let <symdef>VTP</symdef> be the <BNF name="value type predicate"/>.
</item>

<comment>Editorial: Stephen Cannan, 2023-10-13</comment>
<item>Let <symdef>VE</symdef> be the <BNF name="value expression primary"/> simply contained in 
<sym>VTP</sym>, and let <symdef>VT</symdef> be the <BNF name="value type"/> simply contained in 
<sym>VTP</sym>.
</item>

<item>The declared type of <sym>VTP</sym> is the Boolean type.
</item>

</olist>

</SyntaxRules>


<GeneralRules>

<olist>

<item>Let <symdef>VALUE</symdef> be the result of <sym>VE</sym> and let <symdef>TYPE</symdef> be
the value type specified by <sym>VT</sym>.
</item>

<item>The result of <sym>VTP</sym> is defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>VALUE</sym> is of <sym>TYPE</sym> and <kw>NOT</kw> is not specified, then the result 
of <sym>VTP</sym> is <bool>True</bool>.
</item>

<item>If <sym>VALUE</sym> is not of <sym>TYPE</sym> and <kw>NOT</kw> is specified, then the result 
of <sym>VTP</sym> is <bool>True</bool>.
</item>

<item>Otherwise, the result of <sym>VTP</sym> is <bool>False</bool>.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<item>Without <feature code="GA06"/>, conforming GQL language shall not contain
a <BNF name="value type predicate"/> or a <BNF name="value type predicate part 2"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W15-010</comment>
<subClause id="gql_normalized" newpage="true">
<clauseHeading><BNF name="normalized predicate"/></clauseHeading>

<bodyMatter>


<Function>

<para>Determine whether a character string value is normalized.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="normalized predicate">
<rhs>
<BNF name="string value expression"/>
<BNF name="normalized predicate part 2"/>
</rhs>
</BNFdef>

<BNFdef name="normalized predicate part 2">
<rhs>
<kw>IS</kw> <opt> <kw>NOT</kw> </opt> <opt> <BNF name="normal form"/> </opt> <kw>NORMALIZED</kw>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<item>Let <BNF name="string value expression"/> be <symdef>SVE</symdef>.
</item>

<item>Case:

<olist>

<item>If <BNF name="normal form"/> is specified, then let <symdef>NF</symdef> be
<BNF name="normal form"/>.
</item>

<item>Otherwise, let <symdef>NF</symdef> be <kw>NFC</kw>.
</item>

</olist>

</item>

<item>The expression

<code>
<sym>SVE</sym> <kw>IS</kw> <kw>NOT</kw> <sym>NF</sym> <kw>NORMALIZED</kw>
</code>

is equivalent to:

<code>
<kw>NOT</kw> ( <sym>SVE</sym> <kw>IS</kw> <sym>NF</sym> <kw>NORMALIZED</kw> )
</code>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<item>The result of <mono><sym>SVE</sym> <kw>IS</kw> <sym>NF</sym> <kw>NORMALIZED</kw></mono> is

<para>Case:
</para>

<olist>

<item>If the result of <sym>SVE</sym> is the null value, then <bool>Unknown</bool>.
</item>

<comment>WG3:CMN-032</comment>
<item>If the result of <sym>SVE</sym> is in the normalization form specified by <sym>NF</sym>, in
accordance with <docref ref="Unicode15"/>, then <bool>True</bool>.
</item>

<item>Otherwise, <bool>False</bool>.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W15-010</comment>
<subClause id="gql_directed_pred" newpage="true">
<clauseHeading><BNF name="directed predicate"/></clauseHeading>

<bodyMatter>


<Function>

<para>Determine whether an edge variable is bound to a directed edge.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="directed predicate">
<rhs>
<BNF name="element variable reference"/> <BNF name="directed predicate part 2"/>
</rhs>
</BNFdef>

<BNFdef name="directed predicate part 2">
<rhs>
<kw>IS</kw> <opt> <kw>NOT</kw> </opt> <kw>DIRECTED</kw>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:UTC-127R1</comment>
<item>Let <symdef>DP</symdef> be the <BNF name="directed predicate"/>.
</item>

<comment>WG3:UTC-127R1</comment>
<item>Let <symdef>EVR</symdef> be the <BNF name="element variable reference"/> simply contained
in <sym>DP</sym>.
<sym>EVR</sym> shall have singleton degree of reference.
</item>

<comment>WG3:UTC-127R1</comment>
<item>The declared type of <sym>EVR</sym> shall be an edge reference value type.
</item>

<item>If <kw>NOT</kw> is specified, then the <BNF name="directed predicate"/> is equivalent to:

<code>
<kw>NOT</kw> ( <sym>EVR</sym> <kw>IS</kw> <kw>DIRECTED</kw> )
</code>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>
<comment>WG3:UTC-127R1 Deleted 2 GRs</comment>

<comment>WG3:UTC-127R1</comment>
<item>Let <symdef>GE</symdef> be the result of <sym>EVR</sym>.
</item>

<comment>WG3:UTC-127R1</comment>
<item>The result of <sym>DP</sym> is defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>GE</sym> is the null value, then the result of <sym>DP</sym> is <bool>Unknown</bool>.
</item>

<item>If <sym>GE</sym> is a reference value whose referent is a directed edge,
then the result of <sym>DP</sym> is <bool>True</bool>.
</item>

<item>Otherwise, <sym>GE</sym> is a reference value whose referent is an undirected edge and
the result of <sym>DP</sym> is <bool>False</bool>.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>Editorial: Stephen Cannan, 2022-02-25 Correct indefinite article</comment>
<comment>Editorial: Stephen Cannan, 2023-02-24 Complete CR for part 2</comment>
<item>Without <feature code="G110"/>, conforming GQL language shall not contain 
a <BNF name="directed predicate"/> or a <BNF name="directed predicate part 2"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W15-010</comment>
<subClause id="gql_labeled_pred" newpage="true">
<clauseHeading><BNF name="labeled predicate"/></clauseHeading>

<bodyMatter>


<Function>

<para>Determine whether a graph element satisfies a <BNF name="label expression"/>.
</para>

</Function>


<Format>

<grammar>


<BNFdef name="labeled predicate">
<rhs>
<BNF name="element variable reference"/> <BNF name="labeled predicate part 2"/>
</rhs>
</BNFdef>

<comment>WG3:RKE-017</comment>
<BNFdef name="labeled predicate part 2">
<rhs>
<BNF name="is labeled or colon"/> <BNF name="label expression"/>
</rhs>
</BNFdef>

<comment>WG3:RKE-017</comment>
<BNFdef name="is labeled or colon">
<rhs>
<alt> <kw>IS</kw> <opt> <kw>NOT</kw> </opt> <kw>LABELED</kw> </alt>
<alt> <BNF name="colon"/> </alt>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:UTC-127R1</comment>
<item>Let <symdef>LP</symdef> be the <BNF name="labeled predicate"/>.
</item>

<comment>WG3:UTC-127R1</comment>
<item id="gql_labeled_pred_SR_singleton">Let <symdef>EVR</symdef> be
the <BNF name="element variable reference"/> simply contained in <sym>LP</sym>.
<sym>EVR</sym> shall have singleton degree of reference.
</item>

<comment>WG3:UTC-127R1</comment>
<item>Let <symdef>LE</symdef> be the <BNF name="label expression"/> simply contained
in <sym>LP</sym>.
</item>

<comment>WG3:UTC-127R1</comment>
<item>If <kw>NOT</kw> is specified, then <sym>LP</sym> is effectively replaced by:

<code>
<kw>NOT</kw> ( <sym>EVR</sym> <kw>IS</kw> <kw>LABELED</kw> <sym>LE</sym> )
</code>
</item>

<comment>WG3:RKE-017</comment>
<item>If <sym>LP</sym> simply contains an <BNF name="is labeled or colon"/> <symdef>ILOC</symdef> 
that is <BNF name="colon"/>, then <sym>ILOC</sym> is effectively replaced by 
<kw>IS</kw> <kw>LABELED</kw>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>
<comment>WG3:UTC-127R1 Deleted 2 GRs</comment>

<comment>WG3:UTC-127R1</comment>
<item>Let <symdef>GE</symdef> be the result of <sym>EVR</sym>.
</item>

<comment>WG3:UTC-127R1</comment>
<item>The result of <sym>LP</sym> is defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>GE</sym> is the null value, then the result of <sym>LP</sym> is <bool>Unknown</bool>.
</item>

<item>Otherwise, <sym>GE</sym> is a graph element reference value and:

<olist>

<item>The <applySC ref="gql_satisf_lbl_expr_by_lbl_set" rules="SR">
<symarg param="LABEL EXPRESSION"><sym>LE</sym></symarg>
<symarg param="LABEL SET">the label set of <sym>GE</sym></symarg>
<symresult param="TRUTH VALUE"><symdef>TV</symdef></symresult>
</applySC>.
</item>

<item>The result of <sym>LP</sym> is <sym>TV</sym>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>Editorial: Stephen Cannan, 2022-02-25 Correct indefinite article</comment>
<comment>Editorial: Stephen Cannan, 2023-02-24 Complete CR for part 2</comment>
<item>Without <feature code="G111"/>, conforming GQL language shall not contain 
a <BNF name="labeled predicate"/> or a <BNF name="labeled predicate part 2"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W15-010</comment>
<subClause id="gql_src_dest_pred" newpage="true">
<clauseHeading><BNF name="source/destination predicate"/></clauseHeading>

<bodyMatter>


<Function>

<para>Determine whether a node is the source or destination of an edge.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="source/destination predicate">
<rhs>
<alt> <BNF name="node reference"/> <BNF name="source predicate part 2"/> </alt>
<alt> <BNF name="node reference"/> <BNF name="destination predicate part 2"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="node reference">
<rhs>
<BNF name="element variable reference"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-128</comment>
<BNFdef name="source predicate part 2">
<rhs>
<kw>IS</kw> <opt> <kw>NOT</kw> </opt> <kw>SOURCE</kw> <kw>OF</kw> <BNF name="edge reference"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-128</comment>
<BNFdef name="destination predicate part 2">
<rhs>
<kw>IS</kw> <opt> <kw>NOT</kw> </opt> <kw>DESTINATION</kw> <kw>OF</kw> <BNF name="edge reference"/>
</rhs>
</BNFdef>

<BNFdef name="edge reference">
<rhs>
<BNF name="element variable reference"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:UTC-127R1</comment>
<item>Let <symdef>SDP</symdef> be the <BNF name="source/destination predicate"/>.
</item>

<comment>WG3:UTC-127R1 Deleted 2 SRs</comment>

<item>Let <symdef>NR</symdef> be the <BNF name="element variable reference"/> immediately contained
in the <BNF name="node reference"/> simply contained in <sym>SDP</sym>.
<sym>NR</sym> shall have singleton degree of reference.
The declared type of <sym>NR</sym> shall be a node reference value type.  
</item>

<item>Let <symdef>ER</symdef> be the <BNF name="element variable reference"/> immediately contained
in the <BNF name="edge reference"/> simply contained in <sym>SDP</sym>. 
<sym>ER</sym> shall have singleton degree of reference.
The declared type of <sym>ER</sym> shall be an edge reference value type.
</item>

<comment>Editorial: Stephen Cannan, 2023-07-11, Standardize the spelling of keyword</comment>
<item>Let <symdef>SOD</symdef> be the keyword <kw>SOURCE</kw> or <kw>DESTINATION</kw> simply 
contained in the <BNF name="source/destination predicate"/>.
</item>

<item>If <kw>NOT</kw> is specified, then the <BNF name="source/destination predicate"/> is 
equivalent to:

<code>
<kw>NOT</kw> ( <sym>NR</sym> <kw>IS</kw> <sym>SOD</sym> <kw>OF</kw> <sym>ER</sym> )
</code>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:UTC-127R1 Deleted 2 SRs</comment>

<comment>WG3:UTC-127R1</comment>
<item>Let <symdef>GEN</symdef> be the result of <sym>NR</sym> and let <symdef>GEE</symdef> be
the result of <sym>ER</sym>.
</item>

<comment>WG3:UTC-127R1</comment>
<item>The result of <sym>SDP</sym> is defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>GEN</sym> is the null value or <sym>GEE</sym> is the null value, then
the result of <sym>SDP</sym> is <bool>Unknown</bool>.
</item>

<item>If the referent of <sym>GEE</sym> is an undirected edge, then
the result of <sym>SDP</sym> is <bool>False</bool>.
</item>

<item>If <sym>SOD</sym> is <kw>SOURCE</kw> and the referent of <sym>GEN</sym> is the source node of
the referent of <sym>GEE</sym>, then the result of <sym>SDP</sym> is <bool>True</bool>.
</item>

<item>If <sym>SOD</sym> is <kw>DESTINATION</kw> and the referent of <sym>GEN</sym> is
the destination node of the referent of <sym>GEE</sym>, then
the result of <sym>SDP</sym> is <bool>True</bool>.
</item>

<item>Otherwise, the result of <sym>SDP</sym> is <bool>False</bool>.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>Editorial: Stephen Cannan, 2023-02-24 Complete CR for part 2</comment>
<item>Without <feature code="G112"/>, conforming GQL language shall not contain 
a <BNF name="source/destination predicate"/>, a <BNF name="source predicate part 2"/>, or 
a <BNF name="destination predicate part 2"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W15-010</comment>
<subClause id="gql_all_diff_pred" newpage="true">
<clauseHeading><BNF name="all_different predicate"/></clauseHeading>

<bodyMatter>


<Function>

<para>Determine whether all graph elements bound to a list of element references are pairwise 
different from one another.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="all_different predicate">
<rhs>
<kw>ALL_DIFFERENT</kw> <BNF name="left paren"/>
<breakindent/>
<BNF name="element variable reference"/>
<BNF name="comma"/> <BNF name="element variable reference"/>
<breakindent/>
<opt> <group> <BNF name="comma"/> <BNF name="element variable reference"/> </group><repeat/> </opt>
<breakindent/>
<BNF name="right paren"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:UTC-127R1</comment>
<item>Let <symdef>ADP</symdef> be the <BNF name="all_different predicate"/>.
</item>

<comment>WG3:UTC-127R1</comment>
<comment>Email from: Finbar Good, 2023-03-01 1305 WG3:UTC-127R1</comment>
<item>Every <BNF name="element variable reference"/> simply contained in <symdef>ADP</symdef> shall
have singleton degree of reference.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:UTC-127R1 Deleted 3 GRs</comment>

<comment>WG3:UTC-127R1</comment>
<comment>Email from: Finbar Good, 2023-03-01 1305 WG3:UTC-127R1</comment>
<item>Let <symdef>N</symdef> be the number of <BNF name="element variable reference"/>s
simply contained in <sym>ADP</sym>,
let <symdef>EVR</symdef><sub>1</sub>, <ellipsis/>, <sym>EVR</sym><sub><sym>N</sym></sub> be
an enumeration of those <BNF name="element variable reference"/>s, and
for every <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>,
let <symdef>GE</symdef><sub><sym>i</sym></sub> be the result of
<sym>EVR</sym><sub><sym>i</sym></sub>.
</item>

<comment>WG3:UTC-127R1</comment>
<item>The result of <symdef>ADP</symdef> is defined as follows.

<para>Case:
</para>

<olist>

<item>If there exists <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>, such that
<sym>GE</sym><sub><sym>i</sym></sub> is the null value, then an exception condition is raised:
<raise class="22" subclass="004"/>.
</item>

<comment>WG3:W26-024</comment>
<item>If there exists <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> &lt; <sym>N</sym>, and
<symdef>j</symdef>, <sym>i</sym> &lt; <sym>j</sym> <leq/> <sym>N</sym> such that
<sym>GE</sym><sub><sym>i</sym></sub> and <sym>GE</sym><sub><sym>j</sym></sub> are not comparable
values, then an exception condition is raised: <raise class="22" subclass="G04"/>.
</item>

<item>If there exist <symdef>j</symdef> and <symdef>k</symdef>,
1 (one) <leq/> <sym>j</sym> &lt; <sym>k</sym> <leq/> <sym>N</sym>, such that
<sym>GE</sym><sub><sym>j</sym></sub> and <sym>GE</sym><sub><sym>k</sym></sub> reference
the same graph element, then the result of <sym>ADP</sym> is <bool>False</bool>.
</item>

<item>Otherwise, the result of <sym>ADP</sym> is <bool>True</bool>.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<item>Without <feature code="G113"/>, conforming GQL language shall not contain 
an <BNF name="all_different predicate"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W15-010</comment>
<subClause id="gql_same_pred" newpage="true">
<clauseHeading><BNF name="same predicate"/></clauseHeading>

<bodyMatter>


<Function>

<para>Determine whether all element references in a list of element references bind to the same
graph element.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="same predicate">
<rhs>
<kw>SAME</kw> <BNF name="left paren"/> 
<breakindent/>
<BNF name="element variable reference"/> 
<BNF name="comma"/> <BNF name="element variable reference"/>
<breakindent/>
<opt> <group> <BNF name="comma"/> <BNF name="element variable reference"/> </group><repeat/> </opt>
<breakindent/>
<BNF name="right paren"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:UTC-127R1</comment>
<item>Let <symdef>SDP</symdef> be the <BNF name="same predicate"/>.
</item>

<comment>WG3:UTC-127R1</comment>
<comment>Email from: Finbar Good, 2023-03-01 1305 WG3:UTC-127R1</comment>
<item>Every <BNF name="element variable reference"/> simply contained in <symdef>SDP</symdef> shall
have singleton degree of reference.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:UTC-127R1 Deleted 3 GRs</comment>

<comment>WG3:UTC-127R1</comment>
<comment>Email from: Finbar Good, 2023-03-01 1305 WG3:UTC-127R1</comment>
<item>Let <symdef>N</symdef> be the number of <BNF name="element variable reference"/>s
simply contained in <sym>SDP</sym>,
let <symdef>EVR</symdef><sub>1</sub>, <ellipsis/>, <sym>EVR</sym><sub><sym>N</sym></sub> be
an enumeration of those <BNF name="element variable reference"/>s, and
for every <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>,
let <symdef>GE</symdef><sub><sym>i</sym></sub> be the result of
<sym>EVR</sym><sub><sym>i</sym></sub>.
</item>

<comment>WG3:UTC-127R1</comment>
<item>The result of <symdef>SDP</symdef> is defined as follows.

<para>Case:
</para>

<olist>

<item>If there exists <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>, such that
<sym>GE</sym><sub><sym>i</sym></sub> is the null value, then an exception condition is raised:
<raise class="22" subclass="004"/>.
</item>

<comment>WG3:W26-024</comment>
<item>If there exists <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> &lt; <sym>N</sym>, and
<symdef>j</symdef>, <sym>i</sym> &lt; <sym>j</sym> <leq/> <sym>N</sym> such that
<sym>GE</sym><sub><sym>i</sym></sub> and <sym>GE</sym><sub><sym>j</sym></sub> are not comparable
values, then an exception condition is raised: <raise class="22" subclass="G04"/>.
</item>

<item>If every <sym>GE</sym><sub><sym>i</sym></sub>,
1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>, references the same graph element, 
then the result of <sym>SDP</sym> is <bool>True</bool>.
</item>

<item>Otherwise, the result of <sym>SDP</sym> is <bool>False</bool>.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<item>Without <feature code="G114"/>, conforming GQL language shall not contain 
a <BNF name="same predicate"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_prop_ex" newpage="true">
<clauseHeading><BNF name="property_exists predicate"/></clauseHeading>

<bodyMatter>

<comment>WG3:UTC-127R1</comment>
<Function>

<para>Determine if a referenced graph element has a property.
</para>

</Function>


<comment>WG3:UTC-127R1</comment>
<Format>

<comment>WG3:UTC-127R1</comment>
<grammar>

<comment>WG3:UTC-127R1</comment>
<BNFdef name="property_exists predicate">
<rhs>
<kw>PROPERTY_EXISTS</kw>
<breakindent/>
<BNF name="left paren"/>
<BNF name="element variable reference"/> <BNF name="comma"/> <BNF name="property name"/>
<BNF name="right paren"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<comment>WG3:UTC-127R1</comment>
<SyntaxRules>

<olist>

<comment>WG3:UTC-127R1</comment>
<item>Let <symdef>PEP</symdef> be the <BNF name="property_exists predicate"/>.
</item>

<comment>WG3:UTC-127R1</comment>
<item>Let <symdef>EVR</symdef> be the <BNF name="element variable reference"/> simply contained
in <sym>PEP</sym>.
<sym>EVR</sym> shall have singleton degree of reference.
</item>

<comment>WG3:UTC-127R1</comment>
<item>Let <symdef>PN</symdef> be the name specified by the <BNF name="property name"/>
simply contained in PEP.
</item>

</olist>

</SyntaxRules>


<GeneralRules>

<olist>

<comment>WG3:UTC-127R1</comment>
<item>Let <symdef>GRV</symdef> be the result of <sym>EVR</sym>.
</item>

<comment>WG3:UTC-127R1</comment>
<item>The result of <sym>PEP</sym> is defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>GRV</sym> is the null value, then the result of <sym>PEP</sym> is
<bool>Unknown</bool>.
</item>

<item>If the referent of <sym>GRV</sym> has a property whose name is <sym>PN</sym>, then
the result of <sym>PEP</sym> is <bool>True</bool>.
</item>

<item>Otherwise, the result of <sym>PEP</sym> is <bool>False</bool>.
</item>

</olist>

</item>

</olist>

</GeneralRules>

<ConformanceRules>

<olist>

<comment>WG3:UTC-127R1</comment>
<item>Without <feature code="G115"/>, conforming GQL language shall not contain
a <BNF name="property_exists predicate"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>

</clause>


<clause id="gql_values">
<clauseHeading>Value expressions and specifications</clauseHeading>

<subClause id="gql_valexp">
<clauseHeading><BNF name="value expression"/></clauseHeading>

<bodyMatter>


<Function>

<para>Specify a constant or a value.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-02-09</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-25 Fix grammar</comment>
<comment>Editorial: Stefan Plantikow, 2020-03-11</comment>
<comment>Editorial: Stefan Plantikow, 2020-09-25 Refactored to re-use production</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:BER-094R1</comment>
<BNFdef name="value expression">
<rhs>
<alt> <BNF name="common value expression"/> </alt>
<alt> <BNF name="boolean value expression"/> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-07-29 graph element value expression moved</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-09 Added collection, map, record </comment>
<comment>WG3:BER-094R1</comment>
<comment>WG3:W22-036</comment>
<comment>WG3:W24-035R1</comment>
<BNFdef name="common value expression">
<rhs>
<alt> <BNF name="numeric value expression"/> </alt>
<alt> <BNF name="string value expression"/> </alt>
<alt> <BNF name="datetime value expression"/> </alt>
<alt> <BNF name="duration value expression"/> </alt>
<comment>WG3:POS-011R1</comment>
<alt> <BNF name="vector value expression"/> </alt>
<alt> <BNF name="list value expression"/> </alt>
<alt> <BNF name="record expression"/> </alt>
<alt> <BNF name="path value expression"/> </alt>
<alt> <BNF name="reference value expression"/> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-07-29 WG3:MMX-055</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-09 Hook in object expression</comment>
<comment>WG3:BER-040R3</comment>
<comment>WG3:W22-051</comment>
<comment>WG3:BER-094R1</comment>
<BNFdef name="reference value expression">
<rhs>
<alt> <BNF name="graph reference value expression"/> </alt>
<alt> <BNF name="binding table reference value expression"/> </alt>
<alt> <BNF name="node reference value expression"/> </alt>
<alt> <BNF name="edge reference value expression"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W22-051</comment>
<BNFdef name="graph reference value expression">
<rhs>
<alt> <opt> <kw>PROPERTY</kw> </opt> <kw>GRAPH</kw> <BNF name="graph expression"/> </alt>
<alt> <BNF name="value expression primary"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W22-051</comment>
<BNFdef name="binding table reference value expression">
<rhs>
<alt> <opt> <kw>BINDING</kw> </opt> <kw>TABLE</kw> <BNF name="binding table expression"/> </alt>
<alt> <BNF name="value expression primary"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:BER-094R1</comment>
<BNFdef name="node reference value expression">
<rhs>
<BNF name="value expression primary"/>
</rhs>
</BNFdef>

<comment>WG3:BER-094R1</comment>
<BNFdef name="edge reference value expression">
<rhs>
<BNF name="value expression primary"/>
</rhs>
</BNFdef>

<BNFdef name="record expression">
<rhs>
<BNF name="value expression primary"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-081</comment>
<BNFdef name="aggregating value expression">
<rhs>
<BNF name="value expression"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:W26-026R2</comment>
<item>If a <BNF name="value expression"/> is specified that is not a <BNF name="return item"/>, 
then the declared type of the <BNF name="value expression"/> shall not be the empty type.

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<note>A record type with a field type whose value type is the empty type is unconstructable,
<ie/> comprises no records. 
Hence, a binding table whose declared type is a binding table type with such a record type has no 
records. 
The exception regarding <BNF name="return item"/>s stated by this Syntax Rules enables
renaming of columns of such binding tables since iteration is guaranteed to not occur in 
a <BNF name="select statement"/> or a <BNF name="return statement"/> based on this reasoning.
</note>

</item>

<comment>WG3:W22-051</comment>
<item>The declared type of a <BNF name="graph reference value expression"/> shall be 
a graph reference value type.
</item>

<comment>WG3:W22-051</comment>
<item>The declared type of a <BNF name="binding table reference value expression"/> shall be 
a binding table reference value type.
</item>

<comment>WG3:BER-094R1</comment>
<comment>Editorial: Stefan Plantikow, 2022-08-17 Correct to use node reference value type</comment>
<item>The declared type of a <BNF name="node reference value expression"/> shall be 
a node reference value type.
</item>

<comment>WG3:BER-094R1</comment>
<comment>Editorial: Stefan Plantikow, 2022-08-17 Correct to use edge reference value type</comment>
<item>The declared type of an <BNF name="edge reference value expression"/> shall be 
an edge reference value type.
</item>


<comment>WG3:BER-094R1</comment>
<item>The declared type of a <BNF name="record expression"/> shall be a record type.
</item>

<comment>WG3:UTC-081</comment>
<comment>WG3:UTC-123R2</comment>
<item>If a <BNF name="value expression"/> that is not immediately contained in
an <BNF name="aggregating value expression"/> directly contains
an <BNF name="aggregate function"/> <symdef>AF</symdef>, then:

<olist>

<comment>WG3:UTC-123R2</comment>
<item>The <BNF name="value expression"/> or the <BNF name="dependent value expression"/>
immediately contained in <sym>AF</sym> shall contain one or more 
<BNF name="binding variable reference"/>s to exactly one variable whose declared type is
a material group list value type.
</item>

<item>All <BNF name="binding variable reference"/>s simply contained in <sym>AF</sym>
whose declared type is a group list value type shall have the same name.
</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2020-04-25 Adjusted GRs</comment>
<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W24-026R2</comment>
<item>Without <feature code="GV45"/>, conforming GQL language shall not contain 
a <BNF name="record expression"/>.
</item>

<comment>WG3:UTC-039R1</comment>
<item>Without <feature code="GV60"/>, conforming GQL language shall not contain
a <BNF name="graph reference value expression"/>.
</item>

<comment>WG3:UTC-039R1</comment>
<item>Without <feature code="GV61"/>, conforming GQL language shall not contain
a <BNF name="binding table reference value expression"/>.
</item>

<comment>WG3:UTC-123R2</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-07 Use expression code GE09</comment>
<item>Without <feature code="GE09"/>, conforming GQL language shall not contain
a <BNF name="value expression"/> not immediately contained in
an <BNF name="aggregating value expression"/> that directly contains
an <BNF name="aggregate function"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<subClause id="gql_valexpprim" newpage="true">
<clauseHeading><BNF name="value expression primary"/></clauseHeading>

<bodyMatter>


<Function>

<para>Specify a value that is syntactically self-delimited.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="value expression primary">
<rhs>
<alt> <BNF name="parenthesized value expression"/> </alt>
<alt> <BNF name="non-parenthesized value expression primary"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="parenthesized value expression">
<rhs>
<BNF name="left paren"/> <BNF name="value expression"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-039R1</comment>
<BNFdef name="non-parenthesized value expression primary">
<rhs>
<alt> <BNF name="non-parenthesized value expression primary special case"/> </alt>
<alt> <BNF name="binding variable reference"/> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-02-07</comment>
<comment>Editorial: Stephen Cannan, 2020-03-26</comment>
<comment>Editorial: Stefan Plantikow, 2020-04-25 Added parameter</comment>
<comment>Editorial: Stephen Cannan, 2020-05-26 Add place-holders for probably items</comment>
<comment>Editorial: Stefan Plantikow, 2020-09-16 Support for all parameters</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-14 Renamed</comment>
<comment>WG3:W15-010</comment>
<comment>WG3:BER-094R1</comment>
<comment>WG3:W22-036</comment>
<comment>WG3:W22-053R2</comment>
<comment>WG3:W24-035R1</comment>
<comment>WG3:UTC-039R1 Deleted 1 alternative</comment>
<comment>WG3:UTC-100 Deleted 1 (one) alternative</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-019 P00-USA-134</comment>
<BNFdef name="non-parenthesized value expression primary special case">
<rhs>
<alt> <BNF name="aggregate function"/> </alt>
<alt> <BNF name="unsigned value specification"/> </alt>
<alt> <BNF name="list value constructor"/> </alt>
<alt> <BNF name="record constructor"/> </alt>
<alt> <BNF name="path value constructor"/> </alt>
<alt> <BNF name="property reference"/> </alt>
<alt> <BNF name="value query expression"/> </alt>
<alt> <BNF name="case expression"/> </alt>
<alt> <BNF name="cast specification"/> </alt>
<alt> <BNF name="element_id function"/> </alt>
<alt> <BNF name="let value expression"/> </alt>
</rhs>
</BNFdef>

<ednote id="gql_PP017_tab">It needs to be decided if evaluating aggregate functions over the
current working table should be supported by occurrence of a <BNF name="value expression"/>.
See <PPref ref="PPgql017"/>.
</ednote>

</grammar>

</Format>


<SyntaxRules>

<olist>

<None/>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2020-02-08</comment>
<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-049</comment>
<item>Without <feature code="GE01"/>, conforming GQL language shall not contain 
a <BNF name="value expression"/> that simply contains 
a <BNF name="graph reference value expression"/>.
</item>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-049</comment>
<item>Without <feature code="GE02"/>, conforming GQL language shall not contain 
a <BNF name="value expression"/> that simply contains 
a <BNF name="binding table reference value expression"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>

<subClause id="gql_valuespec" newpage="true">
<clauseHeading><BNF name="value specification"/></clauseHeading>

<bodyMatter>


<Function>

<comment>Editorial: Stefan Plantikow, 2023-11-09 Correct wording</comment>
<para>Specify a value.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:CMN-061R1</comment>
<BNFdef name="value specification">
<rhs>
<alt> <BNF name="literal"/> </alt>
<alt> <BNF name="general value specification"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:CMN-061R1</comment>
<BNFdef name="unsigned value specification">
<rhs>
<alt> <BNF name="unsigned literal"/> </alt>
<alt> <BNF name="general value specification"/> </alt>
</rhs>
</BNFdef>

<comment>Adaptation to allow incorporation of WG3:W04-009R1</comment>
<comment>WG3:W15-020</comment>
<comment>WG3:CMN-061R1</comment>
<BNFdef name="non-negative integer specification">
<rhs>
<alt> <BNF name="unsigned integer"/> </alt>
<alt> <BNF name="dynamic parameter specification"/> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-02-06</comment>
<comment>Editorial: Stefan Plantikow, 2020-07-12 CURRENT_CATALOG</comment>
<comment>Editorial: Stefan Plantikow, 2020-09-19 Split up</comment>
<comment>WG3:CMN-061R1</comment>
<BNFdef name="general value specification">
<rhs>
<alt> <BNF name="dynamic parameter specification"/> </alt>
<alt> <kw>SESSION_USER</kw> </alt>
</rhs>
</BNFdef>
<comment>WG3:W22-051 deleted three non-terminals</comment>

</grammar>

</Format>


<SyntaxRules>

<comment>Editorial: Stefan Plantikow, 2020-03-06</comment>
<olist>

<comment>WG3:W15-020</comment>
<comment>WG3:UTC-051</comment>
<comment>WG3:CMN-061R1</comment>
<item>The declared type of <BNF name="non-negative integer specification"/> is 
an <impDef code="ID062"/> exact numeric type.
</item>

<comment>Editorial: Stefan Plantikow, 2020-07-12 WG3:MMX-055</comment>
<comment>WG3:W12-012: Stefan Plantikow, 2021-06-15 Removing roles</comment>
<comment>WG3:CMN-019 P00-DEU-020</comment>
<comment>WG3:CMN-060</comment>
<comment>WG3:CMN-061R1</comment>
<item>The declared type of <kw>SESSION_USER</kw> is an <impDef code="ID061"/> 
character string type.
</item>
<comment>WG3:W22-051 deleted three rules</comment>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2020-02-06</comment>
<olist>

<comment>WG3:CMN-061R1</comment>
<item>A <BNF name="value specification"/>, <BNF name="unsigned value specification"/>, or
<BNF name="non-negative integer specification"/> specifies a value that is not matched from 
a graph or selected from a binding table.
</item>
<comment>WG3:W22-051 deleted five rules</comment>

<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-061R1</comment>
<item>If a <BNF name="non-negative integer specification"/> <symdef>NNIS</symdef> is specified, 
then:

<olist>

<item>Let <symdef>NNIV</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>NNIS</sym> is an <BNF name="unsigned integer"/> <symdef>UI</symdef>, then 
<sym>NNIV</sym> is the value of <sym>UI</sym>.
</item>

<item>Otherwise, <sym>NNIS</sym> is a <BNF name="dynamic parameter specification"/> 
<symdef>DPS</symdef>:

<olist>

<item>Let <symdef>PV</symdef> be the result of <sym>DPS</sym>.
</item>

<item>If <sym>PV</sym> is the null value, then an exception condition is raised:
<raise class="22" subclass="004"/>.
</item>

<item>If <sym>PV</sym> is not an exact number with scale 0 (zero), then an exception condition is 
raised: <raise class="22" subclass="G03"/>.
</item>

<item>If <sym>PV</sym> is negative, then an exception condition is raised:
<raise class="22" subclass="G02"/>.
</item>

<item><sym>NNIV</sym> is <sym>PV</sym>.
</item>

</olist>

</item>

</olist>

</item>

<item>If <sym>NNIV</sym> is not included in the declared type of <sym>NNIS</sym>, then 
an exception condition is raised: <raise class="22" subclass="G03"/>.
</item>

<item>The result of <sym>NNIS</sym> is <sym>NNIV</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-060</comment>
<comment>WG3:CMN-061R1</comment>
<item>The value specified by <kw>SESSION_USER</kw> is the <BNF name="authorization identifier"/> 
that identifies the session authorization identifier.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:CMN-049 Removed 2 (two) Conformance Rules</comment>
<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W22-053R2</comment>
<comment>WG3:CMN-061R1</comment>
<subClause id="gql_dyn_param_spec" newpage="true">
<clauseHeading><BNF name="dynamic parameter specification"/></clauseHeading>

<bodyMatter>


<Function>

<comment>WG3:CMN-061R1</comment>
<para>Specify a dynamic parameter for a value.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:CMN-061R1</comment>
<BNFdef name="dynamic parameter specification">
<rhs>
<BNF name="general parameter reference"/>
</rhs>
</BNFdef>
</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:UTC-045R1</comment>
<comment>Editorial: Stephen Cannan, 2023-06-22, Define symbol</comment>
<comment>WG3:CMN-061R1</comment>
<item>Let <symdef>DPS</symdef> be <BNF name="dynamic parameter specification"/>.
</item>

<comment>WG3:CMN-061R1</comment>
<item>Let <symdef>PN</symdef> and <symdef>PVT</symdef> be the parameter name and parameter value 
type, respectively, of <sym>DPS</sym>.

<note>The parameter name and the parameter value type of 
a <BNF name="dynamic parameter specification"/> is determined by the Syntax Rules of
<specref ref="gql_annot_gql_program"/>.
</note>
</item>

<comment>WG3:CMN-061R1</comment>
<item>The declared type of <sym>DPS</sym> is <sym>PVT</sym>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:CMN-061R1</comment>
<item>The result of <sym>DPS</sym> is the parameter value of the current dynamic parameter whose
parameter name is <sym>PN</sym>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-039R1</comment>
<comment>WG3:CMN-061R1</comment>
<comment>WG3:CMN-057R1</comment>
<item>Without <feature code="GE04"/>, in conforming GQL language,
the declared type of a <BNF name="dynamic parameter specification"/> shall not be a supertype of
a graph reference value type.
</item>

<comment>WG3:UTC-039R1</comment>
<comment>WG3:CMN-061R1</comment>
<comment>WG3:CMN-057R1</comment>
<item>Without <feature code="GE05"/>, in conforming GQL language,
the declared type of a <BNF name="dynamic parameter specification"/> shall not be a supertype of
a binding table reference value type.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:UTC-015</comment>
<subClause id="gql_let_val_expr" newpage="true">
<clauseHeading><BNF name="let value expression"/></clauseHeading>

<bodyMatter>

<Function>

<comment>Editorial: Stefan Plantikow, 2023-02-14 Provide a Function text</comment>
<para>Evaluate a value expression using an amended working record. 
</para>

<comment>Editorial: Stefan Plantikow, 2023-02-15 Deleted 1 (one) editor's note</comment>

</Function>


<Format>

<grammar>

<BNFdef name="let value expression">
<rhs>
<kw>LET</kw> <BNF name="let variable definition list"/> <kw>IN</kw> <BNF name="value expression"/>
<kw>END</kw>
</rhs>
</BNFdef>

</grammar>

</Format> 


<SyntaxRules>

<olist>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>LVE</symdef> be the <BNF name="let value expression"/> and 
let <symdef>IWRT</symdef> be the incoming working record type of <sym>LVE</sym>.
</item>
<endbar/>

<comment>WG3:CMN-019 P00-NLD-050</comment>
<item>Let <symdef>LVDL</symdef> be the <BNF name="let variable definition list"/>.
Let <symdef>N</symdef> be the number of elements of <sym>LVDL</sym>.
For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>, 
let <symdef>LVD</symdef><sub><sym>i</sym></sub> be the <sym>i</sym>-th element of <sym>LVDL</sym>.
</item>

<comment>WG3:CMN-019 P00-NLD-050</comment>
<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>:

<olist>

<comment>WG3:CMN-019 P00-USA-172</comment>
<comment>WG3:W27-011</comment>
<item>Let <symdef>FN</symdef><sub><sym>i</sym></sub> be the name specified by the 
<BNF name="binding variable"/> contained in <sym>LVD</sym><sub><sym>i</sym></sub> without 
an intervening instance of <BNF name="value expression"/>.
</item>

<item><sym>FN</sym><sub><sym>i</sym></sub> shall not identify a field type of <sym>IWRT</sym>.
</item>

<comment>WG3:CMN-019 P00-USA-173</comment>
<item>Let <symdef>FE</symdef><sub><sym>i</sym></sub> be the <BNF name="value expression"/> 
simply contained in <sym>LVD</sym><sub><sym>i</sym></sub>.
</item>

</olist>

</item>

<item>For all pairs of <sym>i</sym>, <sym>j</sym> such that 
1 (one) <leq/> <symdef>i</symdef> &lt; <symdef>j</symdef> <leq/> <sym>N</sym>: 
<sym>FN</sym><sub><sym>i</sym></sub> shall not be equal to <sym>FN</sym><sub><sym>j</sym></sub>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>Let <symdef>NRT</symdef> be a record types whose field types are defined as follows.
For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>, the field type
whose name is <sym>FN</sym><sub><sym>i</sym></sub> and whose value type is the declared type of 
<sym>FE</sym><sub><sym>i</sym></sub> is included in <sym>NRT</sym>.
</item>

<item>Let <symdef>RHS</symdef> be the <BNF name="value expression"/> immediately contained in 
<sym>LVE</sym>.
</item>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>RHS</sym> is <sym>IWRT</sym> amended 
with <sym>NRT</sym>.
</item>
<endbar/>

<item>The declared type of <sym>LVE</sym> is the declared type of <sym>RHS</sym>.
</item>

</olist>

</SyntaxRules>


<GeneralRules>

<olist>

<comment>WG3:CMN-019 P00-NLD-036</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>Let <symdef>NR</symdef> be a record whose fields are defined as follows.
For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>, the field whose name
is <sym>FN</sym><sub><sym>i</sym></sub> and whose value type is the result of 
<sym>FE</sym><sub><sym>i</sym></sub> is included in <sym>NR</sym>.
</item>

<item>In a new child execution context amended with <sym>NR</sym>, let <symdef>RESULT</symdef> be 
the result of <sym>RHS</sym>.
</item>

<item>The result of <sym>LVE</sym> is <sym>RESULT</sym>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<item>Without <feature code="GE03"/>, conforming GQL language shall not contain 
a <BNF name="let value expression"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>Editorial: Stefan Plantikow, 2020-10-14 Renamed</comment>
<subClause id="gql_valquery" newpage="true">
<clauseHeading><BNF name="value query expression"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-02-07</comment>
<bodyMatter>
<comment>WG3:UTC-064 Deleted 1 (one) editor's note by implication</comment>

<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<para>Specify a scalar value derived from a <BNF name="nested query specification"/>.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="value query expression">
<rhs>
<kw>VALUE</kw> <BNF name="nested query specification"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<comment>Editorial: Stephen Cannan, 2021-03-09 Informal Semantics removed</comment>
<SyntaxRules>
<comment>WG3:UTC-064 Deleted 1 (one) editor's note</comment>

<olist>

<comment>WG3:UTC-064</comment>
<item>Let <symdef>VQE</symdef> be the <BNF name="value query expression"/>.
</item>

<comment>WG3:UTC-064</comment>
<item>Let <symdef>NQS</symdef> be the <BNF name="nested query specification"/> simply contained
in <sym>VQE</sym>.
</item>

<comment>WG3:UTC-064</comment>
<item id="gql_valquery_SR_scol">The declared type of <sym>NQS</sym> shall be a binding table type
with a single column <symdef>SC</symdef>.
</item>

<comment>WG3:UTC-064</comment>
<comment>WG3:CMN-047R1</comment>
<item>The <newterm>immediately emitting statement</newterm> of
a <BNF name="nested query specification"/> <symdef>NQSXX</symdef> is
the last <BNF name="statement"/> simply contained in <sym>NQSXX</sym>.
</item>

<comment>WG3:UTC-064</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<comment>WG3:GYD-030</comment>
<item>The <newterm>emitting result statement set</newterm> of
a <BNF name="nested query specification"/> <symdef>NQSX</symdef> is defined as follows:

<olist>

<comment>WG3:UTC-064</comment>
<comment>WG3:GYD-030</comment>
<item>The immediately emitting statement of <sym>NQSX</sym> shall be
a <BNF name="linear query statement"/> or a <BNF name="searched conditional statement"/>.
</item>

<comment>WG3:UTC-064</comment>
<item>Case:

<olist>

<comment>WG3:UTC-064</comment>
<comment>WG3:CMN-047R1</comment>
<comment>WG3:GYD-030</comment>
<item>If the immediately emitting statement of <sym>NQSX</sym> implicitly or explicitly simply
contains a <BNF name="primitive result statement"/> <symdef>PRSX</symdef>, then
the emitting result statement set of <sym>NQSX</sym> comprises <sym>PRSX</sym>.
</item>

<comment>WG3:GYD-030</comment>
<item>If the immediately emitting statement of <sym>NQSX</sym> implicitly or explicitly simply
contains a <BNF name="searched conditional statement"/> <symdef>SCS</symdef>, then

<olist>

<item>Let <symdef>CERS</symdef> be the collection of the emitting result statement sets of all
<BNF name="conditional statement result"/>s simply contained in <sym>SCS</sym>.
</item>

<item><sym>CERS</sym> shall not contain the empty set.
</item>

<item>The emitting result statement set of <sym>NQSX</sym> is the union of all members of 
<sym>CERS</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-064</comment>
<comment>WG3:CMN-047R1</comment>
<comment>WG3:GYD-030</comment>
<item>If the immediately emitting statement of <sym>NQSX</sym> is
a <BNF name="focused nested query specification"/> or
an <BNF name="ambient linear query statement"/> that immediately contains
a <BNF name="nested query specification"/> <symdef>NNQSX</symdef>, then 
the emitting result statement set of <sym>NQSX</sym> is the emitting result statement set of 
<sym>NNQSX</sym>.

<comment>Email from: Hannes Voigt, 2023-03-01 1716 Deleted 1 (one) editor's note</comment>
</item>

<comment>WG3:CMN-047R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-13 Use omitted</comment>
<comment>WG3:GYD-030</comment>
<item>Otherwise, the emitting result statement set of <sym>NQSX</sym> is empty.
</item>

</olist>

</item>

</olist>

<comment>WG3:UTC-064</comment>
<note>This is a recursive definition.
</note>
</item>

<comment>WG3:UTC-064</comment>
<comment>WG3:GYD-030</comment>
<item>The emitting result statement set of <sym>NQS</sym> shall not be empty.
</item>

<comment>WG3:UTC-064</comment>
<comment>WG3:GYD-030</comment>
<item>For each emitting result statement <symdef>PRS</symdef> in the emitting result statement set 
of <sym>NQS</sym>:

<olist>

<comment>WG3:UTC-064</comment>
<item><sym>PRS</sym> shall implicitly or explicitly simply contain 
the <BNF name="return statement"/> <symdef>RS</symdef>.

<comment>WG3:UTC-064</comment>
<comment>WG3:CMN-019 P00-USA-154</comment>
<note>The emitting statement of <sym>NQS</sym> can be a <BNF name="select statement"/> as long as
the syntax transformation specified in <specref ref="gql_select"/>
yields a <BNF name="linear query statement"/> that fulfills the Syntax Rules of this Subclause if 
it is taken as the emitting statement of <sym>NQS</sym>.
</note>
</item>

<comment>WG3:UTC-064</comment>
<item>Let <symdef>RI</symdef> be the only <BNF name="return item"/> simply contained in
<sym>RS</sym>.

<comment>WG3:UTC-064</comment>
<note>To fulfill <itemref ref="gql_valquery_SR_scol" type="SR"/>, <sym>RS</sym> can only contain
a single <BNF name="return item"/>.
</note>
</item>

<comment>WG3:UTC-064</comment>
<item>One of the following shall be true:

<olist>

<comment>WG3:UTC-064</comment>
<item><sym>PRS</sym> shall contain an <BNF name="order by and page statement"/> that 
simply contains a <BNF name="limit clause"/> <kw>LIMIT</kw> 1.
</item>

<comment>WG3:UTC-064</comment>
<item><sym>PRS</sym> shall not simply contain a <BNF name="group by clause"/> and
<sym>RI</sym> shall directly contain an <BNF name="aggregate function"/>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:UTC-064</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>NQS</sym> is the incoming working record type
of <sym>VQE</sym>.
</item>

<comment>WG3:UTC-064</comment>
<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>NQS</sym> is
the material unit binding table type.
</item>
<endbar/>

<comment>WG3:UTC-064</comment>
<item>The declared type of <sym>VQE</sym> is the column type of the column <sym>SC</sym>.

<comment>WG3:UTC-064</comment>
<note>To fulfill <itemref ref="gql_valquery_SR_scol" type="SR"/>, the declared type of
<sym>NQS</sym> is a binding table type with a single column <sym>SC</sym>.
</note>
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:UTC-064</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<comment>WG3:CMN-047R1</comment>
<item>In a new child execution context: The General Rules of <specref ref="gql_procedure_body"/> 
are applied; let <symdef>RNQS</symdef> be the result of the application of these
rules.
</item>

<comment>WG3:UTC-064</comment>
<item>Case:

<olist>

<comment>WG3:UTC-064</comment>
<item>If <sym>RNQS</sym> is an empty binding table, then the result of <sym>VQE</sym> is
the null value.
</item>

<comment>WG3:UTC-064</comment>
<item>Otherwise, <sym>RNQS</sym> is a binding table comprising a single record with
a single field <symdef>F</symdef> and the result of <sym>VQE</sym> is the value of <sym>F</sym>.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-064</comment>
<item>Without <feature code="GQ18"/>, conforming GQL language shall not contain
a <BNF name="value query expression"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_case_expr" newpage="true">
<clauseHeading><BNF name="case expression"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2021-04-26 WG3:W10-016</comment>
<bodyMatter>


<Function>

<para>Specify a conditional value.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="case expression">
<rhs>
<alt> <BNF name="case abbreviation"/> </alt>
<alt> <BNF name="case specification"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="case abbreviation">
<rhs>
<alt> <kw>NULLIF</kw> <BNF name="left paren"/> <BNF name="value expression"/> <BNF name="comma"/>
<BNF name="value expression"/> <BNF name="right paren"/> </alt>
<alt> <kw>COALESCE</kw> <BNF name="left paren"/> <BNF name="value expression"/>
<breakindent/>
<group> <BNF name="comma"/> <BNF name="value expression"/> </group><repeat/> 
<BNF name="right paren"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="case specification">
<rhs>
<alt> <BNF name="simple case"/> </alt>
<alt> <BNF name="searched case"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="simple case">
<rhs>
<kw>CASE</kw> <BNF name="case operand"/>
<BNF name="simple when clause"/><repeat/>
<opt> <BNF name="else clause"/> </opt>
<kw>END</kw>
</rhs>
</BNFdef>

<BNFdef name="searched case">
<rhs>
<kw>CASE</kw>
<BNF name="searched when clause"/><repeat/>
<opt> <BNF name="else clause"/> </opt>
<kw>END</kw>
</rhs>
</BNFdef>

<BNFdef name="simple when clause">
<rhs>
<kw>WHEN</kw> <BNF name="when operand list"/> <kw>THEN</kw> <BNF name="result"/>
</rhs>
</BNFdef>

<BNFdef name="searched when clause">
<rhs>
<kw>WHEN</kw> <BNF name="search condition"/> <kw>THEN</kw> <BNF name="result"/>
</rhs>
</BNFdef>

<BNFdef name="else clause">
<rhs>
<kw>ELSE</kw> <BNF name="result"/>
</rhs>
</BNFdef>

<comment>WG3:W10-016</comment>
<comment>WG3:W15-010</comment>
<BNFdef name="case operand">
<rhs>
<alt> <BNF name="non-parenthesized value expression primary"/> </alt>
<alt> <BNF name="element variable reference"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="when operand list">
<rhs>
<BNF name="when operand"/> 
<opt> <group> <BNF name="comma"/> <BNF name="when operand"/> </group><repeat/> </opt>
</rhs>
</BNFdef>

<comment>WG3:W10-016</comment>
<comment>WG3:W15-010</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-019 P00-USA-156</comment>
<BNFdef name="when operand">
<rhs>
<alt> <BNF name="non-parenthesized value expression primary"/> </alt>
<alt> <BNF name="comparison predicate part 2"/> </alt>
<alt> <BNF name="null predicate part 2"/> </alt>
<alt> <BNF name="value type predicate part 2"/> </alt>
<alt> <BNF name="normalized predicate part 2"/> </alt>
<alt> <BNF name="directed predicate part 2"/> </alt>
<alt> <BNF name="labeled predicate part 2"/> </alt>
<alt> <BNF name="source predicate part 2"/> </alt>
<alt> <BNF name="destination predicate part 2"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:CMN-019 P00-USA-155</comment>
<BNFdef name="result">
<rhs>
<alt> <BNF name="result expression"/> </alt>
<alt> <BNF name="null literal"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="result expression">
<rhs>
<BNF name="value expression"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<comment>WG3:W10-016</comment>
<SyntaxRules>

<olist>

<comment>WG3:W10-016</comment>
<item>If a <BNF name="case expression"/> specifies a <BNF name="case abbreviation"/>, then:

<olist>

<comment>Editorial; Stephen Cannan, 2023-10-10; fix sym/symdef problem</comment>
<item>Let <symdef>NV</symdef> be the number of <BNF name="value expression"/>s directly
contained in the <BNF name="case abbreviation"/> and
let <symdef>V</symdef><sub><sym>i</sym></sub>,
1 (one) <leq/> <symdef>i</symdef> <leq/> <sym>NV</sym>,
be the <sym>i</sym>-th such <BNF name="value expression"/>. 
</item>

<item id="gql_case_SR_nullif"><mono><kw>NULLIF</kw> (<sym>V</sym><sub>1</sub>,
<sym>V</sym><sub>2</sub>)</mono> is equivalent to the following
<BNF name="case specification"/>:

<code>
<kw>CASE</kw> <kw>WHEN</kw>
<sym>V</sym><sub>1</sub>=<sym>V</sym><sub>2</sub> <kw>THEN</kw>
<kw>NULL</kw> <kw>ELSE</kw> <sym>V</sym><sub>1</sub>
<kw>END</kw>
</code>

</item>

<item id="gql_case_SR_coalesce"><mono><kw>COALESCE</kw> (<sym>V</sym><sub>1</sub>,
<sym>V</sym><sub>2</sub>)</mono> is equivalent to the following
<BNF name="case specification"/>:

<comment>WG3:W09-022R1</comment>
<code>
<kw>CASE</kw>
  <kw>WHEN</kw> <kw>NOT</kw> <sym>V</sym><sub>1</sub> <kw>IS</kw> <kw>NULL</kw> <kw>THEN</kw> <sym>V</sym><sub>1</sub>
  <kw>ELSE</kw> <sym>V</sym><sub>2</sub>
<kw>END</kw>
</code>

</item>

<comment>Editorial; Stephen Cannan, 2023-10-10; fix sym/symdef problem</comment>
<item>For any number <symdef>n</symdef> <geq/> 3 of <BNF name="value expression"/>s,
<mono><kw>COALESCE</kw> (<sym>V</sym><sub>1</sub>, <sym>V</sym><sub>2</sub>, <ellipsis/>,
<sym>V</sym><sub><sym>n</sym></sub>)</mono> is equivalent to the following
<BNF name="case specification"/>:

<comment>WG3:W09-022R1</comment>
<code>
<kw>CASE</kw>
  <kw>WHEN</kw> <kw>NOT</kw> <sym>V</sym><sub>1</sub> <kw>IS</kw> <kw>NULL</kw> <kw>THEN</kw> <sym>V</sym><sub>1</sub>
  <kw>ELSE</kw> <kw>COALESCE</kw> (<sym>V</sym><sub>2</sub>, <ellipsis/>, <sym>V</sym><sub><sym>n</sym></sub>)
<kw>END</kw>
</code>

</item>

</olist>

<comment>WG3:CMN-019 384. P00-USA-158</comment>
<note>This is a recursive definition.
</note>
</item>

<comment>WG3:W10-016</comment>
<item id="gql_case_SR_simplecase">If a <BNF name="case specification"/> specifies 
a <BNF name="simple case"/>, then let <symdef>CO</symdef> be the <BNF name="case operand"/>.

<olist>

<comment>WG3:W15-010</comment>
<item>If any <BNF name="when operand"/> is <BNF name="directed predicate part 2"/>,
<BNF name="labeled predicate part 2"/>, <BNF name="source predicate part 2"/> or 
<BNF name="destination predicate part 2"/>, then <sym>CO</sym> shall be 
<BNF name="element variable reference"/> and every <BNF name="when operand"/> shall be 
<BNF name="directed predicate part 2"/>, <BNF name="labeled predicate part 2"/>, 
<BNF name="source predicate part 2"/> or <BNF name="destination predicate part 2"/>; 
otherwise, <sym>CO</sym> shall not be <BNF name="element variable reference"/> and no 
<BNF name="when operand"/> shall be <BNF name="directed predicate part 2"/>, 
<BNF name="labeled predicate part 2"/>, <BNF name="source predicate part 2"/> or 
<BNF name="destination predicate part 2"/>.
</item>

<item>Let <symdef>N</symdef> be the number of <BNF name="simple when clause"/>s.
</item>

<comment>WG3:CMN-019 P00-USA-157 and P00-NLD-030</comment>
<comment>Editorial: Stephen Cannan, 2023-10-10</comment>
<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>:

<olist>

<item>Let <symdef>WOL</symdef><sub><sym>i</sym></sub> be the <BNF name="when operand list"/> of 
the <sym>i</sym>-th <BNF name="simple when clause"/>.
</item>

<item>Let <symdef>R</symdef><sub><sym>i</sym></sub> be the <BNF name="result"/> of the
<sym>i</sym>-th <BNF name="simple when clause"/>.
</item>

<item>Let <symdef>M</symdef>(<sym>i</sym>) be the number of <BNF name="when operand"/>s 
simply contained in <sym>WOL</sym><sub><sym>i</sym></sub>.
</item>

<item>For <symdef>j</symdef>, 1 (one) <leq/> <sym>j</sym> <leq/> <sym>M</sym>(<sym>i</sym>):

<olist>

<item>let <symdef>WO</symdef><sub><sym>i</sym>,<sym>j</sym></sub> be the <sym>j</sym>-th 
<BNF name="when operand"/> simply contained in <sym>WOL</sym><sub><sym>i</sym></sub>.

</item>

<item>Case:

<olist>

<item>If <sym>WO</sym><sub><sym>i</sym>,<sym>j</sym></sub>
is a <BNF name="non-parenthesized value expression primary"/>, then 
let <symdef>EWO</symdef><sub><sym>i</sym>,<sym>j</sym></sub> be:

<code>
= <sym>WO</sym><sub><sym>i</sym>,<sym>j</sym></sub>
</code>
</item>

<item>Otherwise, let <symdef>EWO</symdef><sub><sym>i</sym>,<sym>j</sym></sub> be
<sym>WO</sym><sub><sym>i</sym>,<sym>j</sym></sub>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<comment>Editorial: Stephen Cannan, 2021-05-27 Standardize terms</comment>
<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10 Standardize terms</comment>
<item>If <BNF name="else clause"/> is specified, then let <symdef>CEEC</symdef> be that
<BNF name="else clause"/>; otherwise, let <symdef>CEEC</symdef> be the zero-length character string.
</item>

<item>The <BNF name="simple case"/> is equivalent to a <BNF name="searched case"/> in which
the <sym>i</sym>-th <BNF name="searched when clause"/> takes the form:

<code>
<kw>WHEN</kw> ( <sym>CO</sym> <sym>EWO</sym><sub><sym>i</sym>,1</sub> ) <kw>OR</kw>
<ellipsis/> <kw>OR</kw>
( <sym>CO</sym> <sym>EWO</sym><sub><sym>i</sym>,<sym>M</sym>(<sym>i</sym>)</sub> )
<kw>THEN</kw> <sym>R</sym><sub><sym>i</sym></sub>
</code>

</item>

<item>The <BNF name="else clause"/> of the equivalent <BNF name="searched case"/> takes the
form:

<code>
<sym>CEEC</sym>
</code>

</item>

<item>The Conformance Rules of the Subclauses of <specref ref="gql_predicates"/>,
are applied to the result of this syntactic transformation.

<note>The specific Subclauses of <specref ref="gql_predicates"/>, are determined by the
predicates that are created as a result of the syntactic transformation.
</note>

</item>

</olist>

</item>

<item>At least one <BNF name="result"/> in a <BNF name="case specification"/> shall specify 
a <BNF name="result expression"/>.
</item>

<item>If an <BNF name="else clause"/> is not specified, then <kw>ELSE</kw>
<kw>NULL</kw> is implicit.
</item>

<comment>WG3:BER-094R1</comment>
<comment>WG3:OHD-044R1</comment>
<item>The <applySC ref="gql_gen_combo_vts" rules="SR">
<symarg param="DTSET">the set of declared types of all <BNF name="result expression"/>s in the 
<BNF name="case specification"/>
</symarg>
<symresult param="RESTYPE"><symdef>DT</symdef></symresult>
</applySC>.
<comment>WG3:CMN-019 P00-NLD-031</comment>
The declared type of the <BNF name="case specification"/> is <sym>DT</sym>.
</item>

</olist>

</SyntaxRules>


<GeneralRules>

<olist>

<item>Case:

<olist>

<item>If a <BNF name="result"/> specifies <kw>NULL</kw>, then its value is the
null value.
</item>

<comment>WG3:CMN-019 P00-USA-159</comment>
<item>Otherwise, a <BNF name="result"/> specifies a <BNF name="value expression"/> and its value is
the result of that <BNF name="value expression"/>.
</item>

</olist>

</item>

<item id="gql_case_GR_searched_when_result">Case:

<olist>

<item id="gql_case_GR_searched_when_result_true">If the result of the <BNF name="search condition"/>
of some <BNF name="searched when clause"/> in a <BNF name="case specification"/>
is <bool>True</bool>, then the result of the <BNF name="case expression"/> is the result of
the <BNF name="result"/> of the first (leftmost) <BNF name="searched when clause"/> whose
<BNF name="search condition"/> evaluates to <bool>True</bool>, cast as the declared type of
the <BNF name="case specification"/>.
</item>

<comment>WG3:CMN-019 P00-USA-159</comment>
<item>Otherwise, no <BNF name="search condition"/> in a <BNF name="case specification"/> evaluates
to <bool>True</bool> and the result of the <BNF name="case expression"/> is the result of
the <BNF name="result"/> of the explicit or implicit <BNF name="else clause"/>, cast as
the declared type of the <BNF name="case specification"/>.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<comment>Editorial: Stefan Plantikow, 2023-02-24 Add missing Conformance Rules section</comment>
<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>


</bodyMatter>

</subClause>


<comment>Editorial: Stephen Cannan, 2020-05-26 Add place-holders for probably needed items</comment>
<subClause id="gql_cast_spec" newpage="true">
<clauseHeading><BNF name="cast specification"/></clauseHeading>

<bodyMatter>

<Function>

<para>Specify a data conversion.
</para>

</Function>


<Format>

<comment>WG3:W13-012</comment>
<grammar>

<BNFdef name="cast specification">
<rhs>
<kw>CAST</kw> <BNF name="left paren"/>
<BNF name="cast operand"/> <kw>AS</kw> <BNF name="cast target"/>
<BNF name="right paren"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-033</comment>
<BNFdef name="cast operand">
<rhs>
<alt><BNF name="value expression"/></alt>
<alt><BNF name="null literal"/></alt>
</rhs>
</BNFdef>

<comment>WG3:W24-026R2</comment>
<BNFdef name="cast target">
<rhs>
<BNF name="value type"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<comment>WG3:W13-012</comment>
<olist>

<comment>WG3:UTC-015</comment>
<item>Let <symdef>CS</symdef> be the <BNF name="cast specification"/>.
</item>

<item>Let <symdef>CO</symdef> be the <BNF name="cast operand"/>.
</item>

<comment>WG3:W24-026R2</comment>
<item id="gql_cast_SR_datatype">Let <symdef>TD</symdef> be the data type identified by 
<BNF name="value type"/>.
</item>

<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<item><sym>TD</sym> shall not specify an immaterial value type.
</item>

<comment>WG3:UTC-015</comment>
<comment>WG3:W26-026R2</comment>
<item>If <sym>CO</sym> specifies <kw>NULL</kw>, then <sym>TD</sym> shall be nullable, 
the declared type of <sym>CS</sym> is <sym>TD</sym> and no further Syntax Rules of this 
Subclause are applied; otherwise, <sym>TD</sym> shall not be an immaterial value type.
</item>

<comment>WG3:UTC-096R1</comment>
<item id="gql_cast_SR_decltype">The declared type of <sym>CS</sym> is <sym>TD</sym>.
</item>

<item id="gql_cast_SR_valexptype">If <sym>CO</sym> is a <BNF name="value expression"/>, 
then let <symdef>SD</symdef> be the declared type of the <BNF name="value expression"/>.
</item>

<comment>WG3:W24-026R2</comment>
<comment>WG3:W24-035R1</comment>
<comment>WG3:CMN-019 P00-ISO-03</comment>
<item id="gql_cast_valid_SR">If <sym>CO</sym> is a <BNF name="value expression"/>, then the valid 
combinations of <sym>TD</sym> and <sym>SD</sym> in <sym>CS</sym> are given in 
<specref ref="gql_case_tbl"/>.
<quote>Y</quote> indicates that the combination is syntactically valid
without restriction; <quote>M</quote> indicates that the combination is valid
subject to other Syntax Rules in this Subclause being satisfied; and
<quote>N</quote> indicates that the combination is invalid.
The combination of <sym>TD</sym> and <sym>SD</sym> shall not be invalid according to this 
classification.

<comment>WG3:W24-026R2</comment>
<comment>WG3:W24-035R1</comment>
<comment>WG3:POS-011R1</comment>
<table id="gql_case_tbl" keep="yes">
<tableTitle>Valid combinations of source and target and types</tableTitle>
<table-common>

<table-setup numcols="1">
<table-coldef colnum="1" colwidth="7in"/>
</table-setup>

</table-common>

<table-body>

<table-row>

<table-cell><code>
<bold><sym>SD</sym></bold>     <bold><sym>TD</sym></bold>
<bold>       EN  UN  AN  C   D   T   DT  DU  BO  B   L   R   P   DY  GR  NR  ER  TR  V</bold>
<bold>EN</bold>     Y   Y   Y   Y   N   N   N   N   N   N   N   N   N   M   N   N   N   N   N
<bold>UN</bold>     Y   Y   Y   Y   N   N   N   N   N   N   N   N   N   M   N   N   N   N   N
<bold>AN</bold>     Y   Y   Y   Y   N   N   N   N   N   N   N   N   N   M   N   N   N   N   N
<bold>C</bold>      Y   Y   Y   Y   Y   Y   Y   Y   Y   N   N   N   N   M   N   N   N   N   N
<bold>D</bold>      N   N   N   Y   Y   N   Y   N   N   N   N   N   N   M   N   N   N   N   N
<bold>T</bold>      N   N   N   Y   N   Y   Y   N   N   N   N   N   N   M   N   N   N   N   N
<bold>DT</bold>     N   N   N   Y   Y   Y   Y   N   N   N   N   N   N   M   N   N   N   N   N
<bold>DU</bold>     N   N   N   Y   N   N   N   Y   N   N   N   N   N   M   N   N   N   N   N
<bold>BO</bold>     N   N   N   Y   N   N   N   N   Y   N   N   N   N   M   N   N   N   N   N
<bold>B</bold>      N   N   N   N   N   N   N   N   N   Y   N   N   N   M   N   N   N   N   N
<bold>L</bold>      N   N   N   N   N   N   N   N   N   N   M   N   Y   M   N   N   N   N   N
<bold>R</bold>      N   N   N   N   N   N   N   N   N   N   N   M   N   M   N   N   N   N   N
<bold>P</bold>      N   N   N   N   N   N   N   N   N   N   N   N   Y   M   N   N   N   N   N
<bold>DY</bold>     M   M   M   M   M   M   M   M   M   M   M   M   M   M   M   M   M   M   N
<bold>GR</bold>     N   N   N   N   N   N   N   N   N   N   N   N   N   M   Y   N   N   N   N
<bold>NR</bold>     N   N   N   N   N   N   N   N   N   N   N   N   Y   M   N   Y   N   N   N
<bold>ER</bold>     N   N   N   N   N   N   N   N   N   N   N   N   Y   M   N   N   Y   N   N
<bold>TR</bold>     N   N   N   N   N   N   N   N   N   N   N   N   Y   M   N   N   N   Y   N
<bold>V</bold>      N   N   N   N   N   N   N   N   N   N   N   N   N   N   N   N   N   N   M
Where:
EN  = Signed Exact Numeric
UN  = Unsigned Exact Numeric
AN  = Approximate Numeric
C   = Character String
D   = Date
T   = Zoned Time &amp; Local Time
DT  = Zoned Datetime &amp; Local Datetime
DU  = Duration
BO  = Boolean
B   = Byte String
L   = List Value
R   = Record
P   = Path Value
DY  = Dynamic Union
GR  = Graph Reference Value
NR  = Node Reference Value
ER  = Edge Reference Value
TR  = Binding Table Reference Value
V   = Vector
</code>
</table-cell>
</table-row>

</table-body>

</table>

<!-- Delete this code if the changes for P00-ISO-035 are agreed; otherwise, reinstate.
<item id="gql_cast_valid_SR">If <sym>CO</sym> is a <BNF name="value expression"/>, then the valid 
combinations of <sym>TD</sym> and <sym>SD</sym> in <sym>CS</sym> are given by the following table.
<quote>Y</quote> indicates that the combination is syntactically valid
without restriction; <quote>M</quote> indicates that the combination is valid
subject to other Syntax Rules in this Subclause being satisfied; and
<quote>N</quote> indicates that the combination is invalid.
The combination of <sym>TD</sym> and <sym>SD</sym> shall not be invalid according to this 
classification.

<code>
      <sym>SD</sym>                     <sym>TD</sym>
             EN  UN  AN  C   D   T   DT  DU  BO  B   L   R   P   DY  GR  NR  ER  TR
      EN     Y   Y   Y   Y   N   N   N   N   N   N   N   N   N   M   N   N   N   N
      UN     Y   Y   Y   Y   N   N   N   N   N   N   N   N   N   M   N   N   N   N
      AN     Y   Y   Y   Y   N   N   N   N   N   N   N   N   N   M   N   N   N   N
      C      Y   Y   Y   Y   Y   Y   Y   Y   Y   N   N   N   N   M   N   N   N   N
      D      N   N   N   Y   Y   N   Y   N   N   N   N   N   N   M   N   N   N   N
      T      N   N   N   Y   N   Y   Y   N   N   N   N   N   N   M   N   N   N   N
      DT     N   N   N   Y   Y   Y   Y   N   N   N   N   N   N   M   N   N   N   N
      DU     N   N   N   Y   N   N   N   Y   N   N   N   N   N   M   N   N   N   N
      BO     N   N   N   Y   N   N   N   N   Y   N   N   N   N   M   N   N   N   N
      B      N   N   N   N   N   N   N   N   N   Y   N   N   N   M   N   N   N   N
      L      N   N   N   N   N   N   N   N   N   N   M   N   Y   M   N   N   N   N
      R      N   N   N   N   N   N   N   N   N   N   N   M   N   M   N   N   N   N
      P      N   N   N   N   N   N   N   N   N   N   N   N   Y   M   N   N   N   N
      DY     M   M   M   M   M   M   M   M   M   M   M   M   M   M   M   M   M   M
      GR     N   N   N   N   N   N   N   N   N   N   N   N   N   M   Y   N   N   N
      NR     N   N   N   N   N   N   N   N   N   N   N   N   Y   M   N   Y   N   N
      ER     N   N   N   N   N   N   N   N   N   N   N   N   Y   M   N   N   Y   N
      TR     N   N   N   N   N   N   N   N   N   N   N   N   Y   M   N   N   N   Y
Where:
      EN  = Signed Exact Numeric
      UN  = Unsigned Exact Numeric
      AN  = Approximate Numeric
      C   = Character String
      D   = Date
      T   = Zoned Time &amp; Local Time
      DT  = Zoned Datetime &amp; Local Datetime
      DU  = Duration
      BO  = Boolean
      B   = Byte String
      L   = List Value
      R   = Record
      P   = Path Value
      DY  = Dynamic Union
      GR  = Graph Reference Value
      NR  = Node Reference Value
      ER  = Edge Reference Value
      TR  = Binding Table Reference Value
</code>
-->

</item>

<item>If <sym>TD</sym> is a dynamic union type, then <sym>SD</sym> shall be a subtype of 
<sym>TD</sym>.
</item>

<item>If <sym>SD</sym> is a dynamic union type and <sym>TD</sym> is a static value type, then 
there shall be a component type <symdef>SCT</symdef> of <sym>SD</sym> such that

<code>
<kw>CAST</kw> ( <symdef>VALUE</symdef> <kw>AS</kw> <sym>TD</sym> )
</code>

<para>where <sym>VALUE</sym> is a <BNF name="value expression"/> whose declared type is 
<sym>SCT</sym>, shall be a valid <BNF name="cast specification"/>.
</para>

</item>

<comment>WG3:W24-026R2</comment>
<item>If <sym>SD</sym> is a list value type, then:

<olist>

<comment>WG3:UTC-123R2</comment>
<item>If <sym>SD</sym> is a regular list value type, then
<sym>TD</sym> shall be a regular list value type.
</item>

<item>Let <symdef>ESD</symdef> be the list element type of <sym>SD</sym>.
</item>

<item>Let <symdef>ETD</symdef> be the list element type of <sym>TD</sym>.
</item>

<comment>WG3:CMN-043</comment>
<item>The <BNF name="cast specification"/>:
<code>
<kw>CAST</kw> ( <sym>VALUE</sym> <kw>AS</kw> <sym>ETD</sym> )
</code>

<para>where <symdef>VALUE</symdef> is a <BNF name="value expression"/> of declared type 
<sym>ESD</sym>, shall be a valid <BNF name="cast specification"/>.
</para>

</item>

</olist>

</item>

<comment>WG3:W24-026R2</comment>
<comment>WG3:CMN-019 P00-USA-163</comment>
<item>If <sym>SD</sym> is a closed record type and <sym>TD</sym> is a closed record type, then:

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>Let <symdef>TFNS</symdef> be the set of field type names of <sym>TD</sym>.
</item>

<comment>Email from: Hannes Voigt, 2022-12-22 1137</comment>
<comment>WG3:CMN-043</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>The set of field type names of <sym>SD</sym> shall include <symdef>TFNS</symdef>.
</item>

<item>For every name <symdef>FN</symdef> in <sym>TFNS</sym>:

<olist>

<comment>WG3:CMN-043</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>Let <symdef>SFVT</symdef> be the value type of the field type with name <sym>FN</sym>
in <sym>SD</sym>.
</item>

<comment>WG3:CMN-043</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>Let <symdef>TFVT</symdef> be the value type of the field type with name <sym>FN</sym>
in <sym>TD</sym>.
</item>

<comment>WG3:CMN-043</comment>
<item>The <BNF name="cast specification"/>:
<code>
<kw>CAST</kw> ( <sym>VALUE</sym> <kw>AS</kw> <sym>TFVT</sym> )
</code>

<para>where <symdef>VALUE</symdef> is a <BNF name="value expression"/> of declared type 
<sym>SFVT</sym>, shall be a valid <BNF name="cast specification"/>.
</para>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:POS-011R1</comment>
<item>If <sym>CO</sym> is a <BNF name="value expression"/> and <sym>SD</sym> and <sym>TD</sym> are
vector types, then:

<comment>WG3:POS-011R1</comment>
<olist>

<comment>WG3:POS-011R1</comment>
<item>The dimension of <sym>SD</sym> shall be the same as the dimension of <sym>TD</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>Let <symdef>SDC</symdef> be the coordinate type of <sym>SD</sym> and
let <symdef>TDC</symdef> be the coordinate type of <sym>TD</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>Case:

<olist>

<item>If <sym>SDC</sym> and <sym>TDC</sym> are <BNF name="numeric type"/>s, then
the <BNF name="cast specification"/>:
<code>
<kw>CAST</kw> ( <sym>VALUE</sym> <kw>AS</kw> <sym>TDC</sym> )
</code>

<para>where <symdef>VALUE</symdef> is a <BNF name="value expression"/> of declared type 
<sym>SDC</sym>, shall be a valid <BNF name="cast specification"/>.
</para>
</item>

<comment>WG3:POS-011R1</comment>
<item>Otherwise, <sym>SDC</sym> or <sym>TDC</sym> is
a <BNF name="vector-only numeric coordinate type"/> and it is
<impDef code="IA239"/> whether <sym>SDC</sym> and <sym>TDC</sym>
shall be the same.
If the GQL-implementation does not require <sym>SDC</sym> and <sym>TDC</sym> to be the same,
then any additional restrictions on <sym>SDC</sym> and <sym>TDC</sym> are
<impDef code="IA240"/>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>WG3:W13-012</comment>
<olist>

<comment>WG3:UTC-015</comment>
<item>If <sym>CO</sym> is a <BNF name="value expression"/> <symdef>VE</symdef>, then 
let <symdef>SV</symdef> be the result of <sym>VE</sym>.
</item>

<item id="gql_cast_GR_nullempty">Case:

<olist>

<item>If <sym>CO</sym> is <kw>NULL</kw>, then the result of <sym>CS</sym> is the null value and 
no further General Rules of this Subclause are applied.
</item>

<item>If <sym>SV</sym> is the null value, then

<para>Case:
</para>

<olist>

<item>If <sym>TD</sym> is nullable, then the result of <sym>CS</sym> is the null value and no 
further General Rules of this Subclause are applied.
</item>

<item>Otherwise, <sym>TD</sym> is material and the following exception condition is raised:
<raise class="22" subclass="G03"/>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:CMN-033</comment>
<comment>Editorial: Stephen Cannan, 2023-10-20 - Moved one rule out of the case</comment>
<item>Let <symdef>STZ</symdef> be the current time zone displacement.
</item>

<comment>WG3:CMN-054</comment>
<item>Let <symdef>TV</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>TD</sym> is a dynamic union type, then <sym>TV</sym> is <sym>SV</sym>.
</item>

<comment>WG3:CMN-033</comment>
<item>If <sym>SD</sym> is a dynamic union type and <sym>TD</sym> is a static value type, then:

<olist>

<item>Let <symdef>MST</symdef> be the most specific static value type of <sym>SV</sym>.

<note><sym>MST</sym> is never a dynamic union type.
</note>

</item>

<comment>WG3:CMN-019 P00-USA-164</comment>
<item>If <kw>CAST</kw> ( <sym>VALUE</sym> <kw>AS</kw> <sym>TD</sym> ), where <sym>VALUE</sym> is
a <BNF name="value expression"/> of declared type <sym>MST</sym>, is not a valid
<BNF name="cast specification"/>, then an exception condition is raised:
<raise class="22" subclass="G03"/>.
</item>

<item>For the remaining General Rules of this Subclause, <sym>SD</sym> is effectively replaced by 
<sym>MST</sym>.
</item>

</olist>

</item>

<item>If <sym>TD</sym> is a reference value type, then:

<para>Case:
</para>

<olist>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<item>If <sym>TD</sym> is a closed reference value type and the GQL-object referenced by 
<sym>SV</sym> is not an object of the constraining GQL-object type of <sym>TD</sym>, then
an exception condition is raised: <raise class="22" subclass="G03"/>.
</item>

<item>Otherwise, <sym>TV</sym> is <sym>SV</sym>.
</item>

</olist>

</item>

<comment>WG3:W24-026R2</comment>
<item>If <sym>TD</sym> is a list value type and <sym>SD</sym> is a list value type, then:

<olist>

<item>Let <symdef>NS</symdef> be the cardinality of <sym>SV</sym>.
</item>

<comment>WG3:CMN-019 P00-NLD-050</comment>
<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NS</sym>, 
let <symdef>VE</symdef><sub><sym>i</sym></sub>, be the <sym>i</sym>-th element of <sym>SV</sym>.
</item>

<item>Let <symdef>TLET</symdef> be the list element type of <sym>TD</sym>.
</item>

<comment>WG3:CMN-019 P00-NLD-050</comment>
<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NS</sym>, the following 
<BNF name="cast specification"/> is applied:

<code>
<kw>CAST</kw> ( <sym>VE</sym><sub><sym>i</sym></sub> <kw>AS</kw> <sym>TLET</sym> )
</code>

<para>yielding value <symdef>TVE</symdef><sub><sym>i</sym></sub>.
</para>

</item>

<item>Let <symdef>NT</symdef> be the maximum cardinality of <sym>TD</sym>.
</item>

<item>Case:

<olist>

<comment>WG3:W28-014</comment>
<item>If <sym>NS</sym> is greater than <sym>NT</sym>, then an exception condition is raised:
<raise class="22" subclass="02F"/>.
</item>

<item>Otherwise, <sym>TV</sym> is the list value with elements 
<sym>TVE</sym><sub><sym>i</sym></sub>, 1 (one) <leq/> <symdef>i</symdef> <leq/> <sym>NS</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W24-026R2</comment>
<item>If <sym>TD</sym> is a record type and <sym>SD</sym> is a record type, then

<para>Case:
</para>

<olist>

<item>If <sym>TD</sym> is a closed record type, then:

<olist>

<comment>WG3:CMN-043</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>If the set of field type names of <sym>TD</sym> is included in the set of field names of 
<sym>SV</sym>, then:

<olist>

<comment>WG3:CMN-019 P00-USA-207</comment>
<comment>WG3:CMN-043</comment>
<item>Let <symdef>N</symdef> be the number of field types in <sym>TD</sym>.
</item>

<comment>WG3:CMN-019 P00-USA-207</comment>
<item>For <sym>i</sym>, 1 (one) <leq/> <symdef>i</symdef> <leq/> <sym>N</sym>, 
let <symdef>FN</symdef><sub><sym>i</sym></sub> be the <sym>i</sym>-th name in a permutation 
of the set of field type names of <sym>TD</sym>, 
let <symdef>SFV</symdef><sub><sym>i</sym></sub> be the value of the field
with name <sym>FN</sym><sub><sym>i</sym></sub> of <sym>SV</sym> and 
let <symdef>TFVT</symdef><sub><sym>i</sym></sub> be the value type of the field type
with name <sym>FN</sym><sub><sym>i</sym></sub> of <sym>TD</sym>.
</item>

<item><sym>TV</sym> is the record resulting from the evaluation of:

<comment>WG3:CMN-019 P00-USA-207</comment>
<code>
<kw>RECORD</kw> { <kw>CAST</kw> ( <sym>SFV</sym><sub>1</sub> <kw>AS</kw> <symdef>TFVT</symdef><sub>1</sub> ),
<kw>CAST</kw> ( <sym>SFV</sym><sub>2</sub> <kw>AS</kw> <symdef>TFVT</symdef><sub>2</sub> )
<ellipsis/>
<kw>CAST</kw> ( <sym>SFV</sym><sub><sym>N</sym></sub> <kw>AS</kw> <symdef>TFVT</symdef><sub><sym>N</sym></sub> ) }
</code>

</item>

</olist>

</item>

<item>Otherwise, an exception condition is raised: <raise class="22" subclass="G0U"/>.
</item>

</olist>

</item>

<item>Otherwise, <sym>TV</sym> is <sym>SV</sym>.
</item>

</olist>

</item>

<comment>WG3:W24-035R1</comment>
<item>If <sym>TD</sym> is a path value type and <sym>SD</sym> is a list value type, then

<para>Case:
</para>

<olist>

<item>If <sym>SV</sym> includes the null value or does not identify a path, then 
an exception condition is raised: <raise class="22" subclass="G0Z"/>.
</item>

<comment>Editorial: Correction to W24-035R1</comment>
<item>Otherwise, <sym>TV</sym> is the path value whose path element list is <sym>SV</sym>.
</item>

</olist>

</item>

<item>If <sym>TD</sym> is a signed exact numeric type, then

<para>Case:
</para>

<olist>

<item>If <sym>SD</sym> is a numeric type, then

<para>Case:
</para>

<olist>

<item>If there is a representation of <sym>SV</sym> in the value type <sym>TD</sym> that does not 
lose any leading significant digits after rounding or truncating if necessary, 
then <sym>TV</sym> is that representation.
The choice of whether to round or truncate is <impDef code="IA005"/>.
</item>

<item>Otherwise, an exception condition is raised: <raise class="22" subclass="003"/>.
</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-165</comment>
<item>If <sym>SD</sym> is a character string type, then <sym>SV</sym> is effectively replaced by 
<sym>SV</sym> with any leading or trailing <BNF name="truncating whitespace"/> removed.

<para>Case:
</para>

<olist>

<item>If <sym>SV</sym> does not comprise a <BNF name="signed numeric literal"/> as
defined by the rules for <BNF name="literal"/> in <specref ref="gql_literals"/>, then
an exception condition is raised: <raise class="22" subclass="018"/>.
</item>

<comment>WG3:CMN-054</comment>
<item>Otherwise, let <symdef>LT</symdef> be that <BNF name="signed numeric literal"/>
such that <sym>TV</sym> is the result of:
<code><kw>CAST</kw> ( <sym>LT</sym> <kw>AS</kw> <sym>TD</sym> )
</code>
</item>

</olist>

</item>

</olist>

</item>

<item>If <sym>TD</sym> is an unsigned exact numeric type, then

<para>Case:
</para>

<olist>

<item>If <sym>SD</sym> is a numeric type, then

<para>Case:
</para>

<olist>

<item>If there is a representation of <sym>SV</sym> in the value type <sym>TD</sym> that does not 
lose any leading significant digits or the sign after rounding or truncating if necessary, 
then <sym>TV</sym> is that representation.
The choice of whether to round or truncate is <impDef code="IA005"/>.
</item>

<item>Otherwise, an exception condition is raised: <raise class="22" subclass="003"/>.
</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-165</comment>
<item>If <sym>SD</sym> is a character string type, then <sym>SV</sym> is effectively replaced by 
<sym>SV</sym> with any leading or trailing <BNF name="truncating whitespace"/> removed.

<para>Case:
</para>

<olist>

<item>If <sym>SV</sym> does not comprise an <BNF name="unsigned numeric literal"/> as
defined by the rules for <BNF name="literal"/> in <specref ref="gql_literals"/>, then
an exception condition is raised: <raise class="22" subclass="018"/>.
</item>

<comment>WG3:CMN-054</comment>
<item>Otherwise, let <symdef>LT</symdef> be that <BNF name="unsigned numeric literal"/>.
such that <sym>TV</sym> is the result of:
<code><kw>CAST</kw> ( <sym>LT</sym> <kw>AS</kw> <sym>TD</sym> )
</code>
</item>

</olist>

</item>

</olist>

</item>

<item>If <sym>TD</sym> is an approximate numeric type, then

<para>Case:
</para>

<olist>

<item>If <sym>SD</sym> is a numeric type, then

<para>Case:
</para>

<olist>

<item>If there is a representation of <sym>SV</sym> in the value type <sym>TD</sym> that does not 
lose any leading significant digits after rounding or truncating if necessary, 
then <sym>TV</sym> is that representation.
The choice of whether to round or truncate is <impDef code="IA005"/>.
</item>

<item>Otherwise, an exception condition is raised: <raise class="22" subclass="003"/>.
</item>

</olist>

</item>

<item>If <sym>SD</sym> is a character string type, then <sym>SV</sym> is effectively replaced by 
<sym>SV</sym> with any leading or trailing <BNF name="truncating whitespace"/> removed.

<para>Case:
</para>

<olist>

<item>If <sym>SV</sym> does not comprise a <BNF name="signed numeric literal"/> as
defined by the rules for <BNF name="literal"/> in <specref ref="gql_literals"/>, then
an exception condition is raised: <raise class="22" subclass="018"/>.
</item>

<comment>WG3:CMN-054</comment>
<item>Otherwise, let <symdef>LT</symdef> be that <BNF name="signed numeric literal"/>
such that <sym>TV</sym> is the result of:
<code><kw>CAST</kw> ( <sym>LT</sym> <kw>AS</kw> <sym>TD</sym> )
</code>
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:UTC-015</comment>
<comment>WG3:W26-026R2</comment>
<item>If <sym>TD</sym> is a character string type, then let <symdef>MINL</symdef> and 
<symdef>MAXL</symdef> be the minimum and maximum length, respectively, in characters of 
<sym>TD</sym>.

<para>Case:
</para>

<olist>

<item>If <sym>SD</sym> is an exact numeric type, then:

<olist>

<comment>WG3:UTC-074</comment>
<item>Let <symdef>YP</symdef> be the shortest character string that conforms to the definition of
<BNF name="exact numeric literal"/> in <specref ref="gql_literals"/> that does not simply contain 
an <BNF name="exact number suffix"/>, whose scale is the same as the scale of <sym>SD</sym>,
whose interpreted value is the absolute value of <sym>SV</sym>, and that is not 
an <BNF name="unsigned hexadecimal integer"/>.
</item>

<item>Case:

<olist>

<item>If <sym>SV</sym> is less than 0 (zero), then let <symdef>Y</symdef> be the
result of <mono><string>&minus;</string> || <sym>YP</sym></mono>.
</item>

<item>Otherwise, let <symdef>Y</symdef> be <sym>YP</sym>.
</item>

</olist>

</item>

<item>Case:

<olist>
<comment>WG3:W21-058</comment>

<comment>WG3:CMN-033</comment>
<comment>WG3:W26-026R2</comment>
<item>If the length in characters of <sym>Y</sym> is greater than <sym>MAXL</sym>, then 
an exception condition is raised: <raise class="22" subclass="001"/>.
</item>

<comment>WG3:W26-026R2</comment>
<item>If the length in characters <symdef>M</symdef> of <sym>Y</sym> is less than <sym>MINL</sym>, 
then <sym>TV</sym> is <sym>Y</sym> extended on the right by <sym>MINL</sym>&minus;<sym>M</sym> 
<BNF name="space"/> characters.
</item>

<comment>WG3:W26-026R2</comment>
<item>Otherwise, the length in characters of <sym>Y</sym> is both greater than or equal to 
<sym>MINL</sym> and less than or equal to <sym>MAXL</sym>.
<sym>TV</sym> is <sym>Y</sym>.
</item>

</olist>

</item>

</olist>

</item>

<item>If <sym>SD</sym> is an approximate numeric type, then:

<olist>

<item>Let <symdef>YP</symdef> be a character string defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>SV</sym> equals 0 (zero), then <sym>YP</sym> is <string>0E0</string>.
</item>

<comment>WG3:UTC-074</comment>
<item>Otherwise, <sym>YP</sym> is the shortest character string that
conforms to the definition of <BNF name="approximate numeric literal"/> in
<specref ref="gql_literals"/> that does not simply contain 
an <BNF name="approximate number suffix"/>, whose interpreted value is equal to the
absolute value of <sym>SV</sym> and whose <BNF name="mantissa"/> consists of 
a single <BNF name="digit"/> that is not <string>0</string>, followed by a <BNF name="period"/> 
and an <BNF name="unsigned integer"/>.
</item>

</olist>

</item>

<item>Case:

<olist>

<item>If <sym>SV</sym> is less than 0 (zero), then let <symdef>Y</symdef> be the
result of <mono><string>&minus;</string> || <sym>YP</sym></mono>.
</item>

<item>Otherwise, let <symdef>Y</symdef> be <sym>YP</sym>.
</item>

</olist>

</item>

<item>Case:

<olist>
<comment>WG3:W21-058</comment>

<comment>WG3:CMN-033</comment>
<comment>WG3:W26-026R2</comment>
<item>If the length in characters of <sym>Y</sym> is greater than <sym>MAXL</sym>, then 
an exception condition is raised: <raise class="22" subclass="001"/>.
</item>

<comment>WG3:W26-026R2</comment>
<item>If the length in characters <symdef>M</symdef> of <sym>Y</sym> is less than <sym>MINL</sym>, 
then <sym>TV</sym> is <sym>Y</sym> extended on the right by <sym>MINL</sym>&minus;<sym>M</sym> 
<BNF name="space"/> characters.
</item>

<comment>WG3:W26-026R2</comment>
<item>Otherwise, the length in characters of <sym>Y</sym> is greater than or equal to 
<sym>MINL</sym> and less than or equal to <sym>MAXL</sym>.
<sym>TV</sym> is <sym>Y</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:UTC-015</comment>
<item>If <sym>SD</sym> is a character string type, then

<para>Case:
</para>

<olist>

<comment>WG3:W26-026R2</comment>
<item>If the length in characters of <sym>SV</sym> is greater than <sym>MAXL</sym>, then 
<sym>TV</sym> is the first <sym>MAXL</sym> characters of <sym>SV</sym>. 
If any of the remaining characters of <sym>SV</sym> are not <BNF name="truncating whitespace"/> 
characters, then a completion condition is raised: <raise class="01" subclass="004"/>.
</item>

<comment>WG3:W26-026R2</comment>
<item>If the length in characters <symdef>M</symdef> of <sym>SV</sym> is less than <sym>MINL</sym>, 
then <sym>TV</sym> is <sym>SV</sym> extended on the right by <sym>MINL</sym>&minus;<sym>M</sym> 
<BNF name="space"/> characters.
</item>

<comment>WG3:W26-026R2</comment>
<item>Otherwise, the length in characters of <sym>SV</sym> is both greater than or equal to 
<sym>MINL</sym> and less than or equal to <sym>MAXL</sym>.
<sym>TV</sym> is <sym>SV</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-117</comment>
<item>If <sym>SD</sym> is a temporal instant type or a temporal duration type, then:

<olist>

<comment>Editorial: Stephen Cannan, 2022-05-03 Correct application of W13-012</comment>
<comment>WG3:CMN-033</comment>
<item>Let <symdef>Y</symdef> be the shortest character string that conforms to the definition of 
<BNF name="literal"/> in <specref ref="gql_literals"/>, and such that the interpreted value of 
<sym>Y</sym> is <sym>SV</sym> and the interpreted precision of <sym>Y</sym> is
the precision of <sym>SD</sym>, and such that

<para>Case:
</para>

<olist>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>WG3:UTC-009 P00-USA-169</comment>
<item>If <sym>SD</sym> is a date type, then the character string includes the time scale 
components: [year], [month], and [day].
</item>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>If <sym>SD</sym> is a local time type, then the character string includes the time scale 
components: [hour], [min], and [sec], but does not include the <string>T</string> time designator.
</item>

<item>If <sym>SD</sym> is a zoned time type, then the character string includes the time scale 
components: [hour], [min], [sec], and [shift], but does not include the <string>T</string> time 
designator.
</item>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>If <sym>SD</sym> is a local datetime type, then the character string includes the time scale 
components: [year], [month], [day], [hour], [min], and [sec].
</item>

<item>If <sym>SD</sym> is a zoned datetime type, then the character string includes the time scale 
components: [year], [month], [day], [hour], [min], [sec], and [shift].
</item>

<comment>WG3:CMN-033</comment>
<item>If <sym>SD</sym> is a year and month-based duration, then the character string includes
the time scale components: [year] and [month].
</item>

<comment>WG3:CMN-033</comment>
<item>If <sym>SD</sym> is a day and time-based duration, then the character string includes
the time scale components: [day], [hour], [min], and [sec].
</item>

</olist>

</item>

<item>Case:

<olist>

<comment>WG3:CMN-033</comment>
<comment>WG3:W26-026R2</comment>
<item>If the length in characters of <sym>Y</sym> is greater than <sym>MAXL</sym>, then 
an exception condition is raised: <raise class="22" subclass="001"/>.
</item>

<comment>WG3:W26-026R2</comment>
<item>If the length in characters <symdef>M</symdef> of <sym>Y</sym> is less than <sym>MINL</sym>, 
then <sym>TV</sym> is <sym>Y</sym> extended on the right by <sym>MINL</sym>&minus;<sym>M</sym> 
<BNF name="space"/> characters.
</item>

<comment>WG3:W26-026R2</comment>
<item>Otherwise, the length in characters of <sym>Y</sym> is both greater than or equal to 
<sym>MINL</sym> and less than or equal to <sym>MAXL</sym>.
<sym>TV</sym> is <sym>SV</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W26-026R2</comment>
<item>If <sym>SD</sym> is a Boolean type, then:

<olist>

<item>Let <symdef>Y</symdef> be defined as follows.
If <sym>SV</sym> is <bool>True</bool>, then <sym>Y</sym> is <string>TRUE</string>; 
otherwise, <sym>SV</sym> is <bool>False</bool> and <sym>Y</sym> is <string>FALSE</string>.
</item>

<item>Case:

<olist>

<comment>WG3:W26-026R2</comment>
<item>If the length in characters of <sym>Y</sym> is greater than <sym>MAXL</sym>, then 
an exception condition is raised: <raise class="22" subclass="001"/>.
</item>

<comment>WG3:W26-026R2</comment>
<item>If the length in characters <symdef>M</symdef> of <sym>Y</sym> is less than <sym>MINL</sym>, 
then <sym>TV</sym> is <sym>Y</sym> extended on the right by <sym>MINL</sym>&minus;<sym>M</sym> 
<BNF name="space"/> characters.
</item>

<comment>WG3:W26-026R2</comment>
<item>Otherwise, the length in characters of <sym>Y</sym> is both greater than or equal to 
<sym>MINL</sym> and less than or equal to <sym>MAXL</sym>.
<sym>TV</sym> is <sym>SV</sym>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<item>If <sym>TD</sym> is the date type, then

<para>Case:
</para>

<olist>

<item>If <sym>SD</sym> is character string type, then <sym>SV</sym> is effectively replaced by 
<sym>SV</sym> with any leading or trailing <BNF name="truncating whitespace"/> removed.

<para>Case:
</para>

<olist>

<item>If the rules for <BNF name="literal"/> in <specref ref="gql_literals"/>, can be applied to 
<sym>SV</sym> to determine a valid value of the value type <sym>TD</sym>, 
then let <symdef>TV</symdef> be that value.
</item>

<item>Otherwise, an exception condition is raised: <raise class="22" subclass="007"/>.
</item>

</olist>

</item>

<item>If <sym>SD</sym> is the date type, then <sym>TV</sym> is <sym>SV</sym>.
</item>

<comment>WG3:UTC-090R1</comment>
<comment>WG3:UTC-117 and WG3:UTC-099</comment>
<item>If <sym>SD</sym> is a datetime type, then 
let <symdef>DS</symdef> be the character string obtained by extracting
the first 8 characters from the result of:
<code><kw>CAST</kw> ( <sym>VE</sym> <kw>AS</kw> <kw>STRING</kw> )
</code>
<sym>TV</sym> is the result of:
<code><kw>DATE</kw> ( <sym>DS</sym> )</code>
</item>

</olist>

</item>

<item>If <sym>TD</sym> is a local time type, then

<para>Case:
</para>

<olist>

<item>If <sym>SD</sym> is a character string type, then <sym>SV</sym> is effectively replaced by 
<sym>SV</sym> with any leading or trailing <BNF name="truncating whitespace"/> removed.

<para>Case:
</para>

<olist>

<item>If the rules for <BNF name="literal"/> in <specref ref="gql_literals"/>, can be applied to 
<sym>SV</sym> to determine a valid value of the value type <sym>TD</sym>, 
then let <symdef>TV</symdef> be that value.
</item>

<item>Otherwise, an exception condition is raised: <raise class="22" subclass="007"/>.
</item>

</olist>

</item>

<item>If <sym>SD</sym> is a local time type, then <sym>TV</sym> is <sym>SV</sym>.
</item>

<item>If <sym>SD</sym> is a zoned time type, then:

<comment>WG3:CMN-033</comment>
<olist>

<comment>WG3:UTC-090R1</comment>
<item>Let <symdef>TIME</symdef> be the result of:
<code><kw>CAST</kw> ( <sym>VE</sym> <kw>AS</kw> <kw>STRING</kw> )
</code>
</item>

<item>If the last character of <sym>TIME</sym> is <string>Z</string>, then the last character of 
<sym>TIME</sym> is effectively replaced by <string>+0000</string>.
</item>

<item>Let <symdef>TZ</symdef> be the character string obtained by extracting
the last 5 characters from <sym>TIME</sym>.
</item>

<item>Let <symdef>H</symdef> be the character string obtained by extracting
the first 3 characters from 
<sym>TZ</sym>. 
</item>

<item>Let <symdef>M</symdef> be the character string obtained by extracting
the 4th and 5th characters 
from <sym>TZ</sym>.
</item>

<item>Let <symdef>TZD</symdef> be:
<code><kw>DURATION</kw> ( <string>P</string> || <sym>H</sym> || <string>H</string> || <sym>M</sym> || <string>M</string> )
</code>
</item>

<item>Let <symdef>TL</symdef> be the result of <kw>CHARACTER_LENGTH</kw> ( <sym>TIME</sym> ).
</item>

<item>Let <symdef>T</symdef> be the character string obtained by extracting
the first <sym>TL</sym> &minus; 5 characters from <sym>TIME</sym>.
</item>

<item><sym>TV</sym> is the result of:
<code><kw>LOCAL_TIME</kw> ( <sym>T</sym> ) + <sym>TZD</sym>
</code>.
</item>

</olist>

</item>

<item>If <sym>SD</sym> is a local datetime type, then:

<olist>

<comment>WG3:UTC-090R1</comment>
<item>Let <symdef>T</symdef> be the character string obtained by extracting
the first 10 characters from the result of:
<code><kw>CAST</kw> ( <sym>VE</sym> <kw>AS</kw> <kw>STRING</kw> )
</code>
</item>

<item><sym>TV</sym> is the result of:
<code><kw>LOCAL_TIME</kw> ( <sym>T</sym> )
</code>
</item>

</olist>

</item>

<item>If <sym>SD</sym> is a zoned datetime type, then:

<comment>WG3:CMN-033</comment>
<olist>

<comment>WG3:UTC-090R1</comment>
<item>Let <symdef>TIME</symdef> be the character string obtained by extracting
the first 10 characters from the result of:
<code><kw>CAST</kw> ( <sym>VE</sym> <kw>AS</kw> <kw>STRING</kw> )
</code>
If the last character of <sym>TIME</sym> is <string>Z</string>, then
the last character of <sym>TIME</sym> is effectively replaced by <string>+0000</string>.
</item>

<item>Let <symdef>TZ</symdef> be the character string obtained by extracting
the last 5 characters from <sym>TIME</sym>.
</item>

<item>Let <symdef>H</symdef> be the character string obtained by extracting
the first 3 characters from <sym>TZ</sym>.
</item>

<item>Let <symdef>M</symdef> be the character string obtained by extracting
the 4th and 5th characters from <sym>TZ</sym>.
</item>

<item>Let <symdef>TZD</symdef> be:
<code><kw>DURATION</kw> ( <string>P</string> || <sym>H</sym> || <string>H</string> || <sym>M</sym> || <string>M</string> )
</code>
</item>

<item>Let <symdef>TL</symdef> be the result of:
<code><kw>CHARACTER_LENGTH</kw> ( <sym>TIME</sym> )
</code>
</item>

<item>Let <symdef>T</symdef> be the character string obtained by extracting
the first <sym>TL</sym> &minus; 5 characters from <sym>TIME</sym>.
</item>

<item><sym>TV</sym> is the result of 
<mono><kw>LOCAL_TIME</kw> ( <sym>T</sym> ) + <sym>TZD</sym></mono>.
</item>

</olist>

</item>

</olist>

</item>

<item>If <sym>TD</sym> is a zoned time type, then

<para>Case:
</para>

<olist>

<item>If <sym>SD</sym> is a character string type, then <sym>SV</sym> is effectively replaced by 
<sym>SV</sym> with any leading or trailing <BNF name="truncating whitespace"/> removed.

<para>Case:
</para>

<olist>

<item>If the rules for <BNF name="literal"/> in <specref ref="gql_literals"/>, can be applied to 
<sym>SV</sym> to determine a valid value of the value type <sym>TD</sym>, 
then let <symdef>TV</symdef> be that value.
</item>

<item>Otherwise, an exception condition is raised: <raise class="22" subclass="007"/>.
</item>

</olist>

</item>

<item>If <sym>SD</sym> is a zoned time type, then <sym>TV</sym> is <sym>SV</sym>.
</item>

<item>If <sym>SD</sym> is a local time type, then:

<olist>

<item>Let <symdef>T</symdef> be the result of:
<code><kw>CAST</kw> ( <sym>VE</sym> <kw>AS</kw> <kw>STRING</kw> )
</code>
</item>

<item><sym>TV</sym> is the result of:
<code><kw>ZONED_TIME</kw> ( <sym>T</sym> || <sym>STZ</sym> )
</code>
</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-170</comment>
<item>If <sym>SD</sym> is a zoned datetime type, then:

<olist>

<comment>WG3:UTC-090R1</comment>
<item>Let <symdef>ZDT</symdef> be the result of:
<code><kw>CAST</kw> ( <sym>VE</sym> <kw>AS</kw> <kw>STRING</kw> )
</code>
</item>

<item>Let <symdef>LZDT</symdef> be the result of:
<code><kw>CHARACTER_LENGTH</kw> ( <sym>ZDT</sym> )
</code>
</item>

<comment>WG3:CMN-019 P00-USA-169</comment>
<item>Let <symdef>T</symdef> be the character string obtained by extracting
the last <sym>LZDT</sym> &minus; 10 characters from <sym>ZDT</sym>.
</item>

<item><sym>TV</sym> is the result of:
<code><kw>ZONED_TIME</kw> ( <sym>T</sym> )
</code>
</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-170</comment>
<item>If <sym>SD</sym> is a local datetime type, then:

<olist>

<comment>WG3:UTC-090R1</comment>
<item>Let <symdef>ZDT</symdef> be the result of:
<code><kw>CAST</kw> ( <sym>VE</sym> <kw>AS</kw> <kw>STRING</kw> )
</code>
</item>

<item>Let <symdef>LZDT</symdef> be the result of:
<code><kw>CHARACTER_LENGTH</kw> ( <sym>ZDT</sym> )
</code>
</item>

<comment>WG3:CMN-019 P00-USA-169</comment>
<item> <symdef>T</symdef> be the character string obtained by extracting
the last <sym>LZDT</sym> &minus; 10 characters from <sym>ZDT</sym>.
</item>

<item><sym>TV</sym> is the result of
<mono><kw>ZONED_TIME</kw> ( <sym>T</sym> || <sym>STZ</sym> )</mono>.
</item>

</olist>

</item>

</olist>

</item>

<item>If <sym>TD</sym> is a local datetime type, then 

<para>Case:
</para>

<olist>

<item>If <sym>SD</sym> is a character string type, then <sym>SV</sym> is effectively replaced by 
<sym>SV</sym> with any leading or trailing <BNF name="truncating whitespace"/> removed.

<para>Case:
</para>

<olist>

<item>If the rules for <BNF name="literal"/> in <specref ref="gql_literals"/>, can be applied to 
<sym>SV</sym> to determine a valid value of the value type <sym>TD</sym>, 
then let <symdef>TV</symdef> be that value.
</item>

<item>Otherwise, an exception condition is raised: <raise class="22" subclass="007"/>.
</item>

</olist>

</item>

<item>If <sym>SD</sym> is a date type, then let <symdef>D</symdef> be the result of: 
<code><kw>CAST</kw> ( <sym>VE</sym> <kw>AS</kw> <kw>STRING</kw> )
</code>
<sym>TV</sym> is the result of:
<code><kw>LOCAL_DATETIME</kw> ( <sym>D</sym> || <string>T000000</string> )
</code>
</item>

<item>If <sym>SD</sym> is a local time type, then:

<olist>

<item>Let <symdef>CD</symdef> be the result of: 
<code><kw>CAST</kw> ( <kw>DATE</kw>() <kw>AS</kw> <kw>STRING</kw> )
</code>
</item>

<item>Let <symdef>T</symdef> be the result of:
<code><kw>CAST</kw> ( <sym>VE</sym> <kw>AS</kw> <kw>STRING</kw> )
</code>
</item>

<item><sym>TV</sym> is the result of:
<code><kw>LOCAL_DATETIME</kw> ( <sym>CD</sym> || <string>T</string> || <sym>T</sym> )
</code>
</item>

</olist>

</item>

<item>If <sym>SD</sym> is a zoned time type, then:

<comment>WG3:CMN-033</comment>
<olist>

<comment>WG3:UTC-090R1</comment>
<item>Let <symdef>DATETIME</symdef> be the result of:
<code><kw>CAST</kw> ( <sym>VE</sym> <kw>AS</kw> <kw>STRING</kw> )
</code>
If the last character of <sym>DATETIME</sym> is <string>Z</string>, then
the last character of <sym>DATETIME</sym> is effectively replaced by <string>+0000</string>.
</item>

<item>Let <symdef>TZ</symdef> be the character string obtained by extracting
the last 5 characters from <sym>DATETIME</sym>.
</item>

<item>Let <symdef>H</symdef> be the character string obtained by extracting
the first 3 characters from <sym>TZ</sym>. 
</item>

<item>Let <symdef>M</symdef> be the character string obtained by extracting
the 4th and 5th characters from <sym>TZ</sym>.
</item>

<item>Let <symdef>TZD</symdef> be:
<code><kw>DURATION</kw> ( <string>P</string> || <sym>H</sym> || <string>H</string> || <sym>M</sym> || <string>M</string> )
</code>
</item>

<item>Let <symdef>T</symdef> be the character string obtained by extracting
the first 6 characters from <sym>DATETIME</sym>.
</item>

<item>Let <symdef>CD</symdef> be the result of: 
<code><kw>CAST</kw> ( <kw>DATE</kw>() <kw>AS</kw> <kw>STRING</kw> )
</code>
</item>

<item>Let <symdef>TA</symdef> be the result of: 
<code><kw>CAST</kw> ( <kw>LOCAL_TIME</kw> ( <sym>T</sym> ) + <sym>TZD</sym> ) <kw>AS</kw> <kw>STRING</kw> )
</code>
</item>

<item><sym>TV</sym> is the result of
<mono><kw>LOCAL_DATETIME</kw> ( <sym>CD</sym> || <string>T</string> || <sym>TA</sym> )</mono>.
</item>

</olist>

</item>

<item>If <sym>SD</sym> is a local datetime type, then <sym>TV</sym> is <sym>SV</sym>.
</item>

<comment>WG3:CMN-019 P00-USA-170</comment>
<item>If <sym>SD</sym> is a zoned datetime type, then:

<comment>WG3:CMN-033</comment>
<olist>

<comment>WG3:UTC-090R1</comment>
<item>Let <symdef>ZDT</symdef> be the result of:
<code><kw>CAST</kw> ( <sym>VE</sym> <kw>AS</kw> <kw>STRING</kw> )
</code>
If the last character of <sym>ZDT</sym> is <string>Z</string>, then 
the last character of <sym>TIME</sym> is effectively replaced by <string>+0000</string>.
</item>

<item>Let <symdef>TZ</symdef> be the character string obtained by extracting
the last 5 characters from <sym>ZDT</sym>.
</item>

<item>Let <symdef>H</symdef> be the character string obtained by extracting
the first 3 characters from <sym>TZ</sym>.
</item>

<item>Let <symdef>M</symdef> be the character string obtained by extracting
the 4th and 5th characters from <sym>TZ</sym>.
</item>

<item>Let <symdef>TZD</symdef> be:
<code><kw>DURATION</kw> ( <string>P</string> || <sym>H</sym> || <string>H</string> || <sym>M</sym> || <string>M</string> )
</code>
</item>

<item>Let <symdef>TL</symdef> be the result of:
<code><kw>CHARACTER_LENGTH</kw> ( <sym>TIME</sym> )
</code>
</item>

<item>Let <symdef>DT</symdef> be the character string obtained by extracting
the first 15 characters from the result of:
<code><kw>CAST</kw> ( <sym>VE</sym> <kw>AS</kw> <kw>STRING</kw> )
</code>
</item>

<item><sym>TV</sym> is the result of:
<code><kw>LOCAL_DATETIME</kw> ( <sym>DT</sym> ) + <sym>TZD</sym>
</code>

</item>

</olist>

</item>

</olist>

</item>

<item>If <sym>TD</sym> is a zoned datetime type, then 

<para>Case:
</para>

<olist>

<item>If <sym>SD</sym> is a character string type, then <sym>SV</sym> is effectively replaced by 
<sym>SV</sym> with any leading or trailing <BNF name="truncating whitespace"/> removed.

<para>Case:
</para>

<olist>

<item>If the rules for <BNF name="literal"/> in <specref ref="gql_literals"/>, can be applied to 
<sym>SV</sym> to determine a valid value of the value type <sym>TD</sym>, 
then let <symdef>TV</symdef> be that value.
</item>

<item>Otherwise, an exception condition is raised: <raise class="22" subclass="007"/>.
</item>

</olist>

</item>

<item>If <sym>SD</sym> is a date type, then let <symdef>D</symdef> be the result of:
<code><kw>CAST</kw> ( <sym>VE</sym> <kw>AS</kw> <kw>STRING</kw> )
</code>
<sym>TV</sym> is the result of:
<code><kw>ZONED_DATETIME</kw> ( <sym>D</sym> || <string>T000000</string> || <sym>STZ</sym> )
</code>
</item>

<item>If <sym>SD</sym> is a local time type, then:

<olist>

<item>Let <symdef>CD</symdef> be the result of:
<code><kw>CAST</kw> ( <kw>DATE</kw>() <kw>AS</kw> <kw>STRING</kw> )
</code>
</item>

<item>Let <symdef>T</symdef> be the result of: 
<code><kw>CAST</kw> ( <sym>VE</sym> <kw>AS</kw> <kw>STRING</kw> )
</code>
</item>

<item><sym>TV</sym> is the result of:
<code><kw>ZONED_DATETIME</kw> ( <sym>CD</sym> || <string>T</string> || <sym>T</sym> || <sym>STZ</sym> )
</code>
</item>

</olist>

</item>

<item>If <sym>SD</sym> is a zoned time type, then:

<olist>

<item>Let <symdef>CD</symdef> be the result of:
<code><kw>CAST</kw> ( <kw>DATE</kw>() <kw>AS</kw> <kw>STRING</kw> )
</code>
</item>

<item>Let <symdef>T</symdef> be the result of: 
<code><kw>CAST</kw> ( <sym>VE</sym> <kw>AS</kw> <kw>STRING</kw> )
</code>
</item>

<item><sym>TV</sym> is the result of:
<code><kw>ZONED_DATETIME</kw> ( <sym>CD</sym> || <string>T</string> || <sym>T</sym> )
</code>
</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-170</comment>
<item>If <sym>SD</sym> is a local datetime type, then:

<olist>

<item>Let <symdef>DT</symdef> be the result of:
<code><kw>CAST</kw> ( <sym>VE</sym> <kw>AS</kw> <kw>STRING</kw> )
</code>
</item>

<item><sym>TV</sym> is the result of: 
<code><kw>ZONED_DATETIME</kw> ( <sym>DT</sym> || <sym>STZ</sym> )
</code>
</item>

</olist>

</item>

<item>If <sym>SD</sym> is a zoned datetime type, then <sym>TV</sym> is <sym>SV</sym>.
</item>

</olist>

</item>

<item>If <sym>TD</sym> is a temporal duration type, then

<para>Case:
</para>

<olist>

<item>If <sym>SD</sym> is a character string type, then <sym>SV</sym> is effectively replaced by 
<sym>SV</sym> with any leading or trailing <BNF name="truncating whitespace"/> removed.

<para>Case:
</para>

<olist>

<item>If the rules for <BNF name="literal"/> in <specref ref="gql_literals"/>, can be applied to 
<sym>SV</sym> to determine a valid value of the value type <sym>TD</sym>, 
then let <symdef>TV</symdef> be that value.

</item>

<item>Otherwise, an exception condition is raised: <raise class="22" subclass="G0H"/>.
</item>

</olist>

</item>

<item>If <sym>SD</sym> is a temporal duration type, then <sym>TV</sym> is <sym>SV</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-171</comment>
<item id="gql_cast_GR_bool">If <sym>TD</sym> is a Boolean type, then

<para>Case:
</para>

<olist>

<item>If <sym>SD</sym> is a character string type, then <sym>SV</sym> is effectively replaced by 
<sym>SV</sym> with any leading or trailing <BNF name="truncating whitespace"/> removed.

<para>Case:
</para>

<olist>

<item>If the rules for <BNF name="literal"/> in <specref ref="gql_literals"/>, can be
applied to <sym>SV</sym> to determine a valid value of the value type <sym>TD</sym>, 
then let <symdef>TV</symdef> be that value.
</item>

<item>Otherwise, an exception condition is raised: <raise class="22" subclass="018"/>.
</item>

</olist>

</item>

<item>If <sym>SD</sym> is a Boolean type, then <sym>TV</sym> is <sym>SV</sym>.
</item>

</olist>

</item>

<item>If <sym>TD</sym> and <sym>SD</sym> are byte string types, then:

<olist>

<comment>WG3:CMN-033</comment>
<item>Let <symdef>MINLTD</symdef> and <symdef>MAXLTD</symdef> be the minimum length and
the maximum length, respectively, in bytes of <sym>TD</sym>.
</item>

<comment>WG3:CMN-033</comment>
<item>Case:

<olist>

<item>If the length in bytes of <sym>SV</sym> is greater than <sym>MAXLTD</sym>, then <sym>TV</sym> 
is the first <sym>MAXLTD</sym> bytes of <sym>SV</sym> and a completion condition is raised: 
<raise class="01" subclass="004"/>.
</item>

<item>If the length in bytes <symdef>M</symdef> of <sym>SV</sym>
is smaller than <sym>MINLTD</sym>, then <sym>TV</sym> is <sym>SV</sym>
extended on the right by <sym>MINLTD</sym>&minus;<sym>M</sym> X<string>00</string>s.
</item>

<item>Otherwise, the length in bytes of <sym>SV</sym> is greater than or equal to <sym>MINLTD</sym>
as well as less than or equal to <sym>MAXLTD</sym> and <sym>TV</sym> is <sym>SV</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:POS-011R1</comment>
<item>If <sym>TD</sym> is a vector type, then:

<olist>

<comment>WG3:POS-011R1</comment>
<item>If <sym>SDC</sym> and <sym>TDC</sym> are the same, then <sym>TV</sym> is <sym>SV</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>If <sym>SDC</sym> or <sym>TDC</sym> is a <BNF name="vector-only numeric coordinate type"/>,
then it is <impDef code="IW213"/> how <sym>TV</sym> is derived from <sym>SV</sym>.
If <sym>TV</sym> cannot be derived from <sym>SV</sym>, then the following exception condition is
raised: <raise class="22" subclass="003"/>.
</item>

<comment>WG3:POS-011R1</comment>
<item>Otherwise, <sym>SDC</sym> and <sym>TDC</sym> are both <BNF name="numeric type"/>s and:

<comment>WG3:POS-011R1</comment>
<olist>

<comment>WG3:POS-011R1</comment>
<item>Let <symdef>SDD</symdef> be the dimension of <sym>SD</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>SDD</sym>,
let <symdef>S</symdef><sub><sym>i</sym></sub> be the <sym>i</sym>-th coordinate of <sym>SV</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>SDD</sym>,
let <symdef>T</symdef><sub><sym>i</sym></sub> be the result of:
<code>
<kw>CAST</kw> ( <sym>S</sym><sub><sym>i</sym></sub> <kw>AS</kw> <sym>TDC</sym> )
</code>
</item>

<comment>WG3:POS-011R1</comment>
<item><sym>TV</sym> is a <sym>SDD</sym>-dimensional vector with coordinates
<sym>T</sym><sub><sym>i</sym></sub>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>SDD</sym>.
</item> 

</olist>

</item>

</olist>

</item>


</olist>

</item>

<item>The result of <sym>CS</sym> is <sym>TV</sym>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W22-052R1</comment>
<item>Without <feature code="GA05"/>, conforming GQL language shall not contain 
a <BNF name="cast specification"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_aggregate_func" newpage="true">
<clauseHeading><BNF name="aggregate function"/></clauseHeading>

<bodyMatter>
<comment>WG3:W23-013 One editor's note removed</comment>

<ednote id="gql_PP017_af">Aggregation functionality should be improved for the needs of GQL.
See <PPref ref="PPgql017"/>.
</ednote>
<comment>WG3:UTC-081 Deleted 1 (one) editor's note in consequence</comment>

<Function>

<comment>WG3:W23-009R1 P00-USA-385</comment>
<para>Specify a value computed from a collection of records.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-02-07</comment>
<comment>Editorial: Stephen Cannan, 2020-05-08 Add Cypher functions</comment>
<BNFdef name="aggregate function">
<rhs>
<alt>
<kw>COUNT</kw> <BNF name="left paren"/> <BNF name="asterisk"/> <BNF name="right paren"/>
</alt>
<alt> <BNF name="general set function"/> </alt>
<alt> <BNF name="binary set function"/> </alt>
</rhs>
</BNFdef>

<ednote id="gql_PP186_2">Consider inclusion of aggregate function calls to procedures with formal
parameters of multiple parameter cardinality.
See <PPref ref="PPgql186"/>.
</ednote>

<comment>WG3:UTC-123R2</comment>
<BNFdef name="general set function">
<rhs>
<BNF name="general set function type"/> <breakindent/>
<BNF name="left paren"/>
<opt> <BNF name="set quantifier"/> </opt> <BNF name="value expression"/> 
<BNF name="right paren"/>
</rhs>
</BNFdef>

<BNFdef name="binary set function">
<rhs>
<BNF name="binary set function type"/> 
<breakindent/>
<BNF name="left paren"/> <BNF name="dependent value expression"/> <BNF name="comma"/>
<BNF name="independent value expression"/> 
<breakindent/>
<BNF name="right paren"/>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-05-16 Added times</comment>
<comment>Consequence of WG3:W23-014</comment>
<comment>WG3:UTC-081</comment>
<comment>WG3:W25-028</comment>
<BNFdef name="general set function type">
<rhs>
<alt> <kw>AVG</kw> </alt>
<alt> <kw>COUNT</kw> </alt>
<alt> <kw>MAX</kw> </alt>
<alt> <kw>MIN</kw> </alt>
<alt> <kw>SUM</kw> </alt>
<alt> <kw>COLLECT_LIST</kw> </alt>
<alt> <kw>STDDEV_SAMP</kw> </alt>
<alt> <kw>STDDEV_POP</kw> </alt>
</rhs>
</BNFdef>

<BNFdef name="set quantifier">
<rhs>
<alt> <kw>DISTINCT</kw> </alt>
<alt> <kw>ALL</kw> </alt>
</rhs>
</BNFdef>

<comment>Consequence of WG3:W23-014</comment>
<comment>WG3:UTC-081</comment>
<BNFdef name="binary set function type">
<rhs>
<alt> <kw>PERCENTILE_CONT</kw> </alt>
<alt> <kw>PERCENTILE_DISC</kw> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-05-16 Added set quantifier</comment>
<BNFdef name="dependent value expression">
<rhs>
<opt> <BNF name="set quantifier"/> </opt> <BNF name="numeric value expression"/>
</rhs>
</BNFdef> 

<BNFdef name="independent value expression">
<rhs>
<BNF name="numeric value expression"/>
</rhs>
</BNFdef> 

</grammar>

</Format>


<SyntaxRules>

<olist>

<item>Let <symdef>AF</symdef> be the <BNF name="aggregate function"/>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-02-23 Reword to use AF</comment>
<item>If <sym>AF</sym> immediately contains a <BNF name="general set function"/> that does not
specify the <BNF name="set quantifier"/>, then <kw>ALL</kw> is implicit.
</item>

<comment>WG3:UTC-081 Deleted 1 (one) SR</comment>

<comment>Editorial: Stefan Plantikow, 2020-05-16 Restrict nesting of aggregate functions
</comment>
<item><sym>AF</sym> shall not contain a <BNF name="procedure body"/>.

<comment>WG3:UTC-056R1 Deleted 1 (one) editor's note consequently</comment>
</item>

<comment>WG3:W26-029</comment>
<item><sym>AF</sym> shall not simply contain an <BNF name="aggregate function"/>.
</item>
<comment>WG3:CMN-019 P00-USA-105 One SR removed</comment>

<comment>WG3:UTC-123R2</comment>
<item>Let the <BNF name="value expression"/> or the <BNF name="dependent value expression"/>
<symdef>VE</symdef> be defined as follows.

<para>Case:
</para>

<comment>WG3:CMN-019 308. P00-USA-105</comment>
<olist>

<comment>WG3:UTC-123R2</comment>
<item>If <sym>AF</sym> immediately contains
a <BNF name="general set function"/> <symdef>GSF</symdef>, then <sym>VE</sym> is
the <BNF name="value expression"/> immediately contained in <sym>GSF</sym>. 
</item>

<comment>WG3:UTC-123R2</comment>
<comment>WG3:CMN-019 308. P00-USA-105</comment>
<comment>WG3:W26-029</comment>
<item>If <sym>AF</sym> immediately contains
a <BNF name="binary set function"/> <symdef>BSF</symdef>, then <sym>VE</sym> is
the <BNF name="dependent value expression"/> immediately contained in <sym>BSF</sym>. 
</item>

<comment>WG3:UTC-123R2</comment>
<comment>WG3:CMN-019 308. P00-USA-105</comment>
<item>Otherwise, <sym>VE</sym> is the <BNF name="value expression"/> or
the <BNF name="dependent value expression"/> immediately contained in <sym>AF</sym>. 
</item>

</olist>

</item>

<comment>WG3:UTC-123R2</comment>
<item>Let <symdef>DT</symdef> be the declared type of <sym>VE</sym>.
</item>
<comment>WG3:UTC-081 Deleted 2 SRs</comment>

<comment>WG3:UTC-123R2 Consequence</comment>
<item>If <sym>AF</sym> immediately contains <kw>COUNT</kw>, then:

<olist>

<item>If <sym>AF</sym> immediately contains <BNF name="asterisk"/>, then <sym>AF</sym> shall be 
directly contained in an <BNF name="aggregating value expression"/>.
</item>

<item>The declared type of the result is an <impDef code="ID059"/> exact numeric type
with scale 0 (zero).
</item>

</olist>

</item>

<comment>WG3:W24-037</comment>
<comment>Editorial: Stefan Plantikow 2023-02-23 Use immediately contains for precision</comment>
<item>If <sym>AF</sym> immediately contains a <BNF name="general set function"/>, then:

<olist>
<comment>WG3:UTC-123R2</comment>
<comment>WG3:UTC-123R2 Deleted 1 (one) SR in consequence</comment>
<comment>WG3:UTC-123R2 Deleted 1 (one) SR</comment>

<item>If <sym>AF</sym> specifies a <BNF name="general set function"/> whose 
<BNF name="set quantifier"/> is <kw>DISTINCT</kw>, then <sym>VE</sym> is an operand of 
a grouping operation. 
The Syntax Rules and Conformance Rules of <specref ref="gql_grouping_ops"/>, apply.
</item>

<item>If <sym>AF</sym> specifies a <BNF name="general set function type"/> that is <kw>MAX</kw> or
<kw>MIN</kw>, then <sym>VE</sym> is an operand of an ordering operation. 
The Syntax Rules and Conformance Rules of <specref ref="gql_ordering_ops"/>, apply.
</item>
<comment>WG3:UTC-081 Deleted 1 (one) GR</comment>

<item>If <kw>MAX</kw> or <kw>MIN</kw> is specified, then the declared type of
the result is <sym>DT</sym>.
</item>

<item>If <kw>SUM</kw> or <kw>AVG</kw> is specified, then:

<olist>

<item><sym>DT</sym> shall be a numeric type.

<ednote id="gql_PP382">It would be useful to also be able to apply <kw>SUM</kw> and <kw>AVG</kw> 
(and other data aggregation functions) to temporal duration types.
</ednote>
</item>

<item>If <kw>SUM</kw> is specified and <sym>DT</sym> is exact numeric with scale <symdef>S</symdef>,
then the declared type of the result is an <impDef code="ID095"/> exact numeric type
with scale <sym>S</sym>.
</item>

<item>If <kw>AVG</kw> is specified and <sym>DT</sym> is exact numeric, then the declared type of
the result is an <impDef code="ID096"/> exact numeric type with precision not less than
the precision of <sym>DT</sym> and scale not less than the scale of <sym>DT</sym>.
</item>

<item>If <sym>DT</sym> is approximate numeric, then the declared type of the result is
an <impDef code="ID097"/> approximate numeric type with precision not less than
the precision of <sym>DT</sym>.
</item>

</olist>

</item>

<item>If <kw>STDDEV_POP</kw> or <kw>STDDEV_SAMP</kw> is specified, then <sym>DT</sym> shall
be a numeric type and the declared type of the result shall be
an <impDef code="ID098"/> approximate numeric type.
If <sym>DT</sym> is an approximate numeric type, then the precision of the result is not less
than the precision of <sym>DT</sym>.
</item>

<comment>WG3:UTC-123R2</comment>
<comment>WG3:W25-028</comment>
<item>If <kw>COLLECT_LIST</kw> is specified, then the declared type of the result is the regular 
list value type whose list element type is <sym>DT</sym>.
</item>

</olist>

</item>

<comment>Editorial: Stefan Plantikow 2023-02-23 Use immediately contains for precision</comment>
<item>If <sym>AF</sym> immediately contains a <BNF name="binary set function"/>, then:

<olist>

<comment>Editorial: Stefan Plantikow 2023-02-23 Use immediately contains for precision</comment>
<item>Let <symdef>DVEXP</symdef> be the <BNF name="numeric value expression"/>
immediately contained in the <BNF name="dependent value expression"/>
immediately contained in <sym>AF</sym>.
</item>

<comment>WG3:UTC-081</comment>
<comment>WG3:CMN-019 345. P00-NLD-028 Moved 1 (one) subrule here</comment>
<item><sym>DVEXP</sym> is an operand of an ordering operation.
The Syntax Rules and Conformance Rules of <specref ref="gql_ordering_ops"/>, apply.
</item>

<item>Let <symdef>IVE</symdef> be the <BNF name="independent value expression"/>
simply contained in <sym>AF</sym>.
</item>

<item>If <sym>AF</sym> specifies no <BNF name="set quantifier"/>, then <kw>ALL</kw> is implicit.
</item>

<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>The incoming working record type of the <sym>DVEXP</sym> is
the incoming working record type of <sym>AF</sym> amended with
the record type of incoming working table type of <sym>AF</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>DVEXP</sym> is
the material unit binding table type.
</item>

<comment>WG3:XRH-036</comment>
<item>The incoming working record type of <sym>IVE</sym> is the incoming working record type
of <sym>AF</sym>.
</item>

<comment>WG3:XRH-036</comment>
<item>The incoming working table type of <sym>IVE</sym> is the material unit binding table type.
</item>
<endbar/>

<comment>WG3:UTC-123R2</comment>
<item>Let <symdef>DTIVE</symdef> be the declared type of IVE.
</item>

<item>The declared type of the result is an <impDef code="ID099"/> approximate numeric type.
If <sym>DT</sym> is an approximate numeric type, then the precision of the result is
not less than the precision of <sym>DT</sym>. 
If <sym>DTIVE</sym> is an approximate numeric type, then the precision of the result is
not less than the precision of <sym>DTIVE</sym>.
</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<comment>Editorial: Stefan Plantikow, 2020-05-17 Add GRs</comment>
<olist>

<item>Let <symdef>TABLE</symdef> be the current working table.
</item>

<comment>WG3:W25-028</comment>
<item>If <sym>AF</sym> is <kw>COUNT</kw>(*), then the result of <sym>AF</sym> is
the count of records in <sym>TABLE</sym> and no further General Rules are applied.
</item>

<comment>WG3:UTC-081</comment>
<item>If, during the computation of the result of <sym>AF</sym>, an intermediate result is
not representable in the declared type of the site that contains that intermediate result, then

<para>Case:
</para>

<olist>

<comment>WG3:UTC-081</comment>
<comment>WG3:CMN-019 308. P00-USA-105</comment>
<comment>WG3:W28-014</comment>
<item>If the most specific static value type of the result of <sym>AF</sym> is a list value type,
then an exception condition is raised: <raise class="22" subclass="02F"/>.
</item>

<comment>WG3:UTC-081</comment>
<comment>WG3:CMN-019 308. P00-USA-105</comment>
<item>If the most specific static value type of the result of <sym>AF</sym> is either 
a character string type or a byte string type, then an exception condition is raised:
<raise class="22" subclass="001"/>.
</item>

<comment>WG3:UTC-081</comment>
<item>Otherwise, an exception condition is raised:
<raise class="22" subclass="003"/>.
</item>

</olist>

</item>

<comment>WG3:UTC-123R2</comment>
<item>Let <symdef>SQ</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<comment>Email from: Jeffrey Lovitz, 2023-03-06 1731</comment>
<item>If <sym>AF</sym> is a <BNF name="general set function"/> <symdef>GSF</symdef>, then
<sym>SQ</sym> is the <BNF name="set quantifier"/> immediately contained in <sym>GSF</sym>.
</item>


<comment>WG3:UTC-081</comment>
<comment>Email from: Jeffrey Lovitz, 2023-03-06 1731</comment>
<item>Otherwise, <sym>AF</sym> is a <BNF name="binary set function"/> <symdef>BSF</symdef> and
<sym>SQ</sym> is the <BNF name="set quantifier"/> immediately contained in
the <BNF name="dependent value expression"/> immediately contained in <sym>BSF</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-123R2</comment>
<item>Let the collection <symdef>VALUES</symdef> be determined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:UTC-123R2</comment>
<item>If <sym>AF</sym> is directly contained in a <BNF name="value expression"/> that is not
immediately contained in an <BNF name="aggregating value expression"/>, then:

<olist>

<comment>WG3:UTC-123R2</comment>
<item>Let <symdef>GLBV</symdef> be the binding variable referenced by
<BNF name="binding variable reference"/>s simply contained in <sym>AF</sym>
without an intervening instance of <BNF name="independent value expression"/>
whose declared type is the group list value type.
</item>

<item><applySC ref="gql_app_eval_expr_on_grpvar" rules="GR">
<symarg param="GROUP LIST BINDING VARIABLE"><sym>GLBV</sym></symarg>
<symarg param="EXPRESSION"><sym>VE</sym></symarg>
<symresult param="LIST VALUE"><symdef>VALUES</symdef></symresult>
</applySC>.
</item>

</olist>

</item>

<comment>WG3:UTC-123R2</comment>
<item>Otherwise: 

<olist>

<item>Initially, <sym>VALUES</sym> is an empty collection.
</item>

<comment>WG3:W12-019</comment>
<item>For each record <symdef>R</symdef> of <sym>TABLE</sym> in a new child execution context
amended with <sym>R</sym>:

<olist>

<comment>WG3:UTC-123R2</comment>
<item>Let <symdef>EXPRE</symdef> be the result of <sym>VE</sym>.
</item>

<comment>WG3:W24-009 P00-USA-387</comment>
<item>Case:

<olist>

<comment>WG3:W25-028</comment>
<item>If <sym>EXPRE</sym> is null, then a completion condition is raised:
<raise class="01" subclass="G11"/>.
</item>

<comment>WG3:W25-028</comment>
<item>Otherwise,

<para>Case:
</para>

<olist>

<item>If <sym>SQ</sym> is <kw>DISTINCT</kw> and <sym>EXPRE</sym> is not in <sym>VALUES</sym>, 
then <sym>EXPRE</sym> is added to <sym>VALUES</sym>;
</item>

<item>Otherwise, <sym>SQ</sym> is <kw>ALL</kw> and <sym>EXPRE</sym> is added to <sym>VALUES</sym>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:UTC-081</comment>
<item>Let <symdef>N</symdef> be the cardinality of <sym>VALUES</sym>.
</item>

<comment>WG3:UTC-081</comment>
<item>Let <symdef>RESULT</symdef> be defined as follows.

<para>Case:
</para>

<olist>
<comment>WG3:W25-028 Deleted 1 (one) GR</comment>

<comment>WG3:UTC-081</comment>
<comment>WG3:W24-037</comment>
<item>If <sym>AF</sym> is the <BNF name="general set function"/> <sym>GSF</sym>, then

<para>Case:
</para>

<olist>

<comment>WG3:UTC-081</comment>
<item>If <kw>COUNT</kw> is specified, then <sym>RESULT</sym> is <sym>N</sym>.
</item>

<comment>WG3:UTC-081</comment>
<comment>WG3:W25-028</comment>
<item>If <sym>VALUES</sym> is empty, then <sym>RESULT</sym> is defined as follows.

<comment>WG3:W25-028</comment>
<para>Case:
</para>

<olist>

<comment>WG3:W25-028</comment>
<item>If <sym>AF</sym> is <kw>COLLECT_LIST</kw>, then <sym>RESULT</sym> is the empty list. 
</item>

<comment>WG3:W25-028</comment>
<item>Otherwise, <sym>RESULT</sym> is the null value.
</item>

</olist>

</item>

<comment>WG3:UTC-081</comment>
<item>If <kw>MAX</kw> or <kw>MIN</kw> is specified, then <symdef>RESULT</symdef> is the result, 
respectively, of the maximum value or the minimum value in <sym>VALUES</sym>. 
<sym>RESULT</sym> is determined using the comparison rules specified in <specref ref="gql_comp"/>.
</item>

<comment>WG3:UTC-081</comment>
<item>If <kw>SUM</kw> is specified, then <sym>RESULT</sym> is the sum of the values in
<sym>VALUES</sym>.
If <sym>RESULT</sym> is not within the range of the declared type of <sym>RESULT</sym>, then
an exception condition is raised: 
<raise class="22" subclass="003"/>.
</item>

<comment>WG3:UTC-081</comment>
<item>If <kw>STDDEV_POP</kw> or <kw>STDDEV_SAMP</kw> is specified, then let <symdef>SX</symdef> be
the sum of values in <sym>VALUES</sym> and let <symdef>SXS</symdef> be the sum of the squares of
the values in <sym>VALUES</sym>.

<olist>

<comment>WG3:UTC-081</comment>
<comment>Editorial: Stefan Plantikow, 2023-03-06 Use result of</comment>
<item>If <kw>STDDEV_POP</kw> is specified, then <sym>RESULT</sym> is the result of
<kw>SQRT</kw>((<sym>SXS</sym>&minus;<sym>SX</sym>*<sym>SX</sym>/<sym>N</sym>)/<sym>N</sym>).
</item>

<comment>WG3:UTC-081</comment>
<item>If <kw>STDDEV_SAMP</kw> is specified, then

<para>Case:
</para>

<olist>

<comment>WG3:UTC-081</comment>
<item>If <sym>N</sym> is 1 (one), then <sym>RESULT</sym> is the null value.
</item>

<comment>WG3:UTC-081</comment>
<comment>Editorial: Stefan Plantikow, 2023-03-06 Use result of</comment>
<item>Otherwise, then <sym>RESULT</sym> is the result of
<kw>SQRT</kw>((<sym>SXS</sym>&minus;<sym>SX</sym>*<sym>SX</sym>/<sym>N</sym>)/(<sym>N</sym> &minus;
1)).
</item>

</olist>

</item>

<comment>WG3:UTC-081</comment>
<comment>WG3:W25-028</comment>
<comment>WG3:W28-014</comment>
<item>If <kw>COLLECT_LIST</kw> is specified, then <sym>RESULT</sym> is
the list comprised of all values in <sym>VALUES</sym>.
If <sym>RESULT</sym> is not within the range of the declared type of <sym>RESULT</sym>, then
an exception condition is raised: <raise class="22" subclass="02F"/>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:UTC-081</comment>
<item>Otherwise, <sym>AF</sym> is the <BNF name="binary set function"/> <symdef>BSF</symdef>.
Let <symdef>IVE</symdef> be the <BNF name="independent value expression"/> immediately contained in
<sym>BSF</sym>, let <symdef>IVERE</symdef> be the result of evaluating <sym>IVE</sym> in
a new child execution context, and

<para>Case:
</para>

<olist>

<comment>WG3:UTC-081</comment>
<item>If <sym>VALUES</sym> is empty, then <sym>RESULT</sym> is the null value.
</item>

<comment>WG3:CMN-019 345. P00-NLD-028 Moved 1 (one) subrule</comment>

<comment>WG3:UTC-081</comment>
<item>Let <symdef>ORDERED_VALUES</symdef> be the sequence of non-null elements in <sym>VALUES</sym>
ordered from least to greatest.
<sym>ORDERED_VALUES</sym> is determined using the comparison rules specified in 
<specref ref="gql_comp"/>.
Let <symdef>N_ORDERED_VALUES</symdef> be the cardinality of <sym>ORDERED_VALUES</sym>.
</item>

<comment>WG3:UTC-081</comment>
<item>Let <symdef>INDEX</symdef> be the result of
1 + (<sym>IVERE</sym> * (<sym>N_ORDERED_VALUES</sym> - 1)).
</item>

<comment>WG3:UTC-081</comment>
<item>If <kw>PERCENTILE_CONT</kw> is specified, then

<para>Case:
</para>

<olist>

<comment>WG3:UTC-081</comment>
<item>If <sym>INDEX</sym> is an integer, then <sym>RESULT</sym> is
the value in <sym>ORDERED_VALUES</sym> at position <sym>INDEX</sym>.
</item>


<comment>WG3:UTC-081</comment>
<comment>Email from: Jeffrey Lovitz, 2023-03-06 1731</comment>
<item>Otherwise:

<olist>

<comment>Email from: Jeffrey Lovitz, 2023-03-06 1731</comment>
<item>Let <symdef>INDEX_FLOOR</symdef> be the largest integer less than <sym>INDEX</sym>
<linebreak/>
and let <symdef>RESULT_FLOOR</symdef> be the value in <sym>ORDERED_VALUES</sym> at position
<sym>INDEX_FLOOR</sym>.
</item>

<comment>Email from: Jeffrey Lovitz, 2023-03-06 1731</comment>
<item>Let <symdef>INDEX_CEILING</symdef> be the smallest integer greater than <sym>INDEX</sym>
<linebreak/>
and let <symdef>RESULT_CEILING</symdef> be the value in <sym>ORDERED_VALUES</sym> at position
<sym>INDEX_CEILING</sym>. 
</item>

<comment>Email from: Jeffrey Lovitz, 2023-03-06 1731</comment>
<item><sym>RESULT</sym> is the result of
(<sym>INDEX_CEILING</sym> - <sym>INDEX</sym>) * <sym>RESULT_FLOOR</sym>
<linebreak/>
+ (<sym>INDEX</sym> - <sym>INDEX_FLOOR</sym>) * <sym>RESULT_CEILING</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:UTC-081</comment>
<item>If <kw>PERCENTILE_DISC</kw> is specified, then

<para>Case:
</para>

<olist>

<comment>WG3:UTC-081</comment>
<item>If <sym>INDEX</sym> is an integer, then <sym>RESULT</sym> is
the value in <sym>ORDERED_VALUES</sym> at position <sym>INDEX</sym>.
</item>

<comment>WG3:UTC-081</comment>
<comment>WG3:CMN-025</comment>
<item>Otherwise, <sym>RESULT</sym> is the value in <sym>ORDERED_VALUES</sym> at
the position obtained as a result of rounding or truncating <sym>INDEX</sym>.
The choice of whether to round or truncate is <impDef code="IA005"/>.
</item>

</olist>

</item>

</olist>

</item>

</olist>
<comment>WG3:UTC-081 Deleted 1 (one) editor's note by implication</comment>

</item>

<item>The result of evaluating <sym>AF</sym> is <sym>RESULT</sym>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-060</comment>
<comment>WG3:W25-028</comment>
<item>Without <feature code="GF10"/>, conforming GQL language shall not contain 
an <BNF name="aggregate function"/> that immediately contains 
a <BNF name="general set function type"/> that is that is <kw>COLLECT_LIST</kw>, 
<kw>STDDEV_SAMP</kw>, or <kw>STDDEV_POP</kw>.
</item>

<comment>WG3:UTC-060</comment>
<item>Without <feature code="GF11"/>, conforming GQL language shall not contain 
an <BNF name="aggregate function"/> that immediately contains 
a <BNF name="binary set function type"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W15-010</comment>
<subClause id="gql_ele_id" newpage="true">
<clauseHeading><BNF name="element_id function"/></clauseHeading>

<bodyMatter>


<Function>

<para>Generate a unique identifier for a graph element.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="element_id function">
<rhs>
<kw>ELEMENT_ID</kw> <BNF name="left paren"/> <BNF name="element variable reference"/> 
<BNF name="right paren"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:UTC-127R1</comment>
<item>Let <symdef>EIF</symdef> be the <BNF name="element_id function"/>.
</item>

<comment>WG3:UTC-127R1 Deleted 1 SR</comment>

<comment>WG3:UTC-127R1</comment>
<item>Let <symdef>EVR</symdef> be the <BNF name="element variable reference"/> simply contained
in <sym>EIF</sym>. 
<sym>EIF</sym> shall have singleton degree of reference.
</item>

<item>The declared type of <BNF name="element_id function"/> is an <impDef code="ID076"/> type
that is permitted as the declared type of an operand of an equality operation according to the 
Syntax Rules of <specref ref="gql_equality_ops"/>.

<comment>WG3:W21-058</comment>
<ednote>This rule differs from that in SQL/PGQ.
The SQL/PGQ text adds 
<quote>and as the declared type of an operand of a grouping operation according to the Syntax Rules
of <extref ref="fnd_grouping_ops" standard="9075" part="02"/></quote>.
Since GQL currently does not have any of the data types excluded by the above Subclause and only 
one active collation, there appears to be no need for the additional restriction.
This should be kept under review.
</ednote>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<item>Access Rules for <BNF name="element_id function"/> are <impDef code="ID077"/>.
</item>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>
<comment>WG3:UTC-127R1 Deleted 2 GRs</comment>

<item>Let <symdef>GRV</symdef> be the result of <sym>EVR</sym>.
</item>


<item>The result of <sym>EIF</sym> is defined as follows.

<para>Case:
</para>

<olist>

<comment>Editorial: Stefan Plantikow, 2023-02-27 Move note outside to make it easier to quote the GR
</comment>
<comment>Email from: Finbar Good, 2023-03-01 1305 WG3:UTC-127R1</comment>
<item>If <sym>GRV</sym> is the null value, then the result of <sym>EIF</sym> is the null value.
</item>

<item id="gql_ele_id_val_GR">Otherwise, the result of <sym>EIF</sym> is
an <unDef code="UV004"/> value that encapsulates the identity of the referent of <sym>GRV</sym>
for the duration of the currently executing 
GQL-request.
</item>

</olist>

<comment>Editorial: Stephen Cannan, 2023-08-29 Replace undefined symbol</comment>
<note>The result of <sym>EIF</sym> can be but is not guaranteed to be the global object identifier
of the referent of <sym>GRV</sym>.
</note>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>Email from: Fred Zemke, 2021-12-13 1932</comment>
<item>Without <feature code="G100"/>, conforming GQL language shall not contain 
an <BNF name="element_id function"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_prop_ref" newpage="true">
<clauseHeading><BNF name="property reference"/></clauseHeading>

<bodyMatter>


<Function>

<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-019 P00-USA-148</comment>
<para>Reference a property of a graph element or a field of a record.
</para>

</Function>


<Format>

<grammar>

<comment>Editorial: Stefan Plantikow, 2020-04-25 Replaced target specification with graph 
element primary.
</comment>
<comment>Consequence of WG3:BER-094R1</comment>
<comment>WG3:UTC-015</comment>
<BNFdef name="property reference">
<rhs>
<BNF name="property source"/> <BNF name="period"/> <BNF name="property name"/>
</rhs>
</BNFdef>

<BNFdef name="property source">
<rhs>
<alt> <BNF name="node reference value expression"/> </alt>
<alt> <BNF name="edge reference value expression"/> </alt>
<alt> <BNF name="record expression"/> </alt>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:UTC-015</comment>
<item>Let <symdef>PR</symdef> be the <BNF name="property reference"/>, let <symdef>PS</symdef> be 
the <BNF name="property source"/> immediately contained in <sym>PR</sym>, let <symdef>PSD</symdef>
be the declared type of <sym>PS</sym>, and let <symdef>PN</symdef> be the 
<BNF name="property name"/>, immediately contained in <sym>PR</sym>.
</item>

<comment>Editorial: Stefan Plantikow 2023-07-13 WG3:CMN-019 P00-USA-149</comment>
<item>If <sym>PS</sym> is a <BNF name="record expression"/>, then

<para>Case:
</para>

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>If <sym>PSD</sym> is a closed record type, then <sym>PN</sym> shall identify a field type
<symdef>FIELD</symdef> in <sym>PSD</sym> and the declared type of <sym>PR</sym> is the value 
type of <sym>FIELD</sym>.
</item>

<comment>WG3:CMN-019 P00-USA-150</comment>
<item>Otherwise, <sym>PSD</sym> is an open record type and the declared type of <sym>PR</sym> is
the open dynamic union type.
</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-149</comment>
<item>If <sym>PS</sym> is a <BNF name="node reference value expression"/> or 
an <BNF name="edge reference value expression"/>, then

<para>Case:
</para>

<olist>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>If <sym>PSD</sym> is a closed graph element reference value type, then <sym>PN</sym> shall 
identify a property type <symdef>PT</symdef> in the constraining GQL-object type of <sym>PSD</sym>
and the declared type of <sym>PR</sym> is the value type of <sym>PT</sym>.
</item>

<item>Otherwise, <sym>PSD</sym> is an open graph element reference value type and the declared
type of <sym>PR</sym> is the dynamic property value type.
</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:UTC-015</comment>
<item>Let <symdef>SOURCE</symdef> be the result of <sym>PS</sym>.
</item>

<item>Let <symdef>PRD</symdef> be the declared type of <sym>PR</sym>.
</item>

<item>Case:

<olist>

<item>If <sym>SOURCE</sym> is the null value, then

<para>Case:
</para>

<olist>

<item>If <sym>PRD</sym> is nullable, then the result of <sym>PR</sym> is the null value and no 
further General Rules of this Subclause are applied.
</item>

<comment>WG3:GYD-010</comment>
<item>Otherwise, the following exception is raised: <raise class="22" subclass="G03"/>.
</item>

</olist>

</item>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>If <sym>SOURCE</sym> is a record and <sym>PN</sym> identifies a field <symdef>FIELD</symdef>
in <sym>SOURCE</sym>, then the result of <sym>PR</sym> is the value of <sym>FIELD</sym>.
</item>

<item>If <sym>SOURCE</sym> is a reference to a graph element <symdef>GE</symdef> and <sym>PN</sym>
identifies a property <symdef>PROP</symdef> in <sym>GE</sym>, then:

<olist>

<item>Let <symdef>PV</symdef> be the property value of <sym>PROP</sym>.
</item>

<comment>WG3:GYD-010</comment>
<item>If <sym>PV</sym> is not a value of <sym>PRD</sym>, then an exception condition is raised:
<raise class="22" subclass="G03"/>; otherwise, the result of <sym>PR</sym> is <sym>PV</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-035</comment>
<comment>Email from: Hannes Voigt, 2023-10-23 1242</comment>
<item>Otherwise, either <sym>SOURCE</sym> is a record and <sym>PN</sym> does not identify
a field in <sym>SOURCE</sym> or <sym>SOURCE</sym> is a graph element <symdef>GE</symdef> and 
<sym>PN</sym> does not identify a property in <sym>GE</sym>.

<para>Case:
</para>

<olist>

<item>If <sym>PRD</sym> is nullable, then the result of <sym>PR</sym> is the null value.
</item>

<comment>WG3:GYD-010</comment>
<item>Otherwise, <sym>PRD</sym> is material and an exception condition is raised:
<raise class="22" subclass="G03"/>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:CMN-019 P00-USA-153</comment>
<item>Without <feature code="GV45"/>, conforming GQL language shall not contain
a <BNF name="record expression"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>Editorial: Stefan Plantikow, 2020-04-24 Moved named elements into new Subclause</comment>
<comment>WG3:W22-053R2</comment>
<subClause id="gql_var_refs" newpage="true">
<clauseHeading><BNF name="binding variable reference"/></clauseHeading>

<bodyMatter>

<Function>

<comment>WG3:UTC-087R2</comment>
<para>Specify binding variable references.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:W22-053R2</comment>
<BNFdef name="binding variable reference">
<rhs>
<BNF name="binding variable"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:W22-053R2</comment>
<comment>Editorial: Stephen Cannan 2023-01-01</comment>
<comment>WG3:UTC-087R2</comment>
<item>Let <symdef>BVR</symdef> be the <BNF name="binding variable reference"/>.
</item>

<comment>WG3:UTC-087R2</comment>
<item><sym>BVR</sym> specifies a <newterm>binding variable reference</newterm>.
</item>

<comment>WG3:UTC-087R2</comment>
<item>Let <symdef>BV</symdef> be the <BNF name="binding variable"/> immediately contained in 
<sym>BVR</sym>.
</item>

<comment>WG3:W22-053R2</comment>
<comment>Email from: Jim Melton 2022-12-08 0219</comment>
<comment>WG3:UTC-087R2</comment>
<comment>Editorial: Stefan Plantikow, 2023-03-09 Use binding variable</comment>
<item>The <newterm>referenced binding variable</newterm> of <symdef>BVR</symdef> is
the binding variable identified by <sym>BVR</sym>.

<note>See <specref ref="gql_names"/>.
</note>
</item>

<comment>WG3:UTC-087R2</comment>
<item>The name of <sym>BVR</sym> is the name of the referenced binding variable of <sym>BVR</sym>.
</item>

<comment>WG3:BER-019</comment>
<comment>WG3:W22-053R2</comment>
<comment>WG3:UTC-087R2</comment>
<comment>Editorial: Stefan Plantikow, 2023-03-09 Use binding variable</comment>
<item>Let <symdef>BVN</symdef> be the name of <sym>BVR</sym>.
</item>

<comment>WG3:UTC-087R2</comment>
<bar note="WG3:XRH-036"/>
<comment>WG3:XRH-036</comment>
<item>Let <symdef>IWRT</symdef> be the incoming working record type of <sym>BVR</sym>.
</item>

<comment>WG3:UTC-087R2</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<comment>WG3:XRH-036</comment>
<item><sym>IWRT</sym> shall have a field type whose name is <sym>BVN</sym>.
Let <symdef>BVFT</symdef> be that field type.
<endbar/>

<comment>Editorial: Stefan Plantikow, 2023-02-27 Clarified wording and added reference</comment>
<note>The field value type of the incoming working record corresponding to a referenced
binding variable <symdef>ABV</symdef> of a <BNF name="binding variable reference"/> that is
declared by a <BNF name="graph pattern"/> <symdef>AGP</symdef> is defined by
<itemref type="SR" ref="gql_gql_gpbt_SR_wrt"/> of
<specref ref="gql_gpbt"/> to be the same as the projected field type of
the <BNF name="binding variable reference"/> to <sym>ABV</sym> in
the <BNF name="graph pattern yield clause"/> of <sym>AGP</sym>.
See <itemref type="SR" ref="gql_var_refs_SR_pft"/>, for the definition of projected field type.
</note>

</item>

<comment>WG3:UTC-087R2</comment>
<item>The declared type of <sym>BVR</sym> is the value type of <sym>BVFT</sym>.
</item>

<comment>WG3:UTC-087R2</comment>
<item id="gql_var_refs_SR_bgp">The <newterm>binding graph pattern</newterm> of <sym>BVR</sym> is
defined, if existing, as the innermost <BNF name="graph pattern"/> <symdef>GP</symdef> for which it
holds that:

<olist>

<comment>WG3:CMN-068</comment>
<item><sym>GP</sym> declares an <BNF name="element variable"/>, a <BNF name="path variable"/>, or
a <BNF name="subpath variable"/> equivalent to <sym>BV</sym>.
</item>

<item>At least one of the following is true:

<olist>

<item><sym>BVR</sym> is simply contained in the <BNF name="graph pattern where clause"/> of 
<sym>GP</sym>.
</item>

<item><sym>BVR</sym> is contained in a <BNF name="parenthesized path pattern where clause"/> simply
contained in <sym>GP</sym>.
</item>

<comment>WG3:W26-025R1</comment>
<item><sym>BVR</sym> is contained in a <BNF name="graph pattern yield clause"/> that is simply
contained in a <BNF name="graph pattern binding table"/> that simply contains <sym>GP</sym>.
</item>

</olist>

</item>

</olist>

<comment>WG3:CMN-068</comment>
<note>This Syntax Rule is applied after the syntactic transform that converts any
<BNF name="element pattern where clause"/> to 
a <BNF name="parenthesized path pattern where clause"/>.
</note>

</item>

<item>The <newterm>degree of reference</newterm> of <sym>BVR</sym> is defined as follows.

<para>Case:
</para>

<olist>

<item>If the binding graph pattern <symdef>GP</symdef> of <sym>BVR</sym> is defined and declares 
an <BNF name="element variable"/> <symdef>EV</symdef> equivalent to <sym>BV</sym>, then

<para>Case:
</para>

<olist>

<item>If <sym>BVR</sym> is simply contained in the <BNF name="graph pattern where clause"/> of 
<sym>GP</sym>, then the degree of reference of <sym>BVR</sym> is the degree of exposure of 
<sym>EV</sym> by <sym>GP</sym>.

<note><quote>Degree of exposure</quote> is defined in <specref ref="gql_graph_pattern"/> and
<specref ref="gql_path_pattern_expr"/>.
</note>

</item>

<item>If <sym>BVR</sym> is contained in a <BNF name="parenthesized path pattern where clause"/> 
<symdef>PPPWC</symdef> simply contained in <sym>GP</sym>, then let <symdef>PPPE</symdef> be the 
<BNF name="parenthesized path pattern expression"/> that simply contains <sym>PPPWC</sym>.

<note>This rule is applied after the syntactic transform that converts any 
<BNF name="element pattern where clause"/> to 
a <BNF name="parenthesized path pattern where clause"/>.
</note>

<para>Case:
</para>

<olist>

<item>If <sym>EV</sym> is declared by <sym>PPPE</sym>, then the degree of reference of 
<sym>BVR</sym> is the degree of exposure of <sym>EV</sym> by <sym>PPPE</sym>.

<note><quote>Degree of exposure</quote> is defined in <specref ref="gql_graph_pattern"/> and
<specref ref="gql_path_pattern_expr"/>.
</note>

</item>

<item>Otherwise, let <symdef>PP</symdef> be the innermost <BNF name="graph pattern"/> or
<BNF name="parenthesized path pattern expression"/> that contains <sym>PPPWC</sym> and that
declares <sym>EV</sym>. 
The degree of reference of <sym>BVR</sym> is the degree of exposure of <sym>EV</sym> by 
<sym>PP</sym>. 
The degree of reference of <sym>BVR</sym> shall be singleton.

<note><quote>Degree of exposure</quote> is defined in <specref ref="gql_graph_pattern"/> and
<specref ref="gql_path_pattern_expr"/>.
</note>

</item>

</olist>

</item>

</olist>

</item>

<comment>Editorial: Stephen Cannan, 2023-10-13</comment>
<item>If the binding graph pattern <sym>GP</sym> of <sym>BVR</sym> is defined and declares 
a <BNF name="path variable"/> equivalent to <sym>BV</sym>, then the degree of reference of 
<sym>BVR</sym> is unconditional singleton.
</item>

<comment>WG3:UTC-123R2</comment>
<item>Otherwise, the degree of reference of <sym>BVR</sym> is defined as follows.

<para>Case:
</para>

<olist>

<item>If the declared type of <sym>BVR</sym> is a group list value type or a dynamic union type
whose component types are group list value types, then <sym>BVR</sym> has group degree of reference.
</item>

<item>Otherwise, the declared type of <sym>BVR</sym> is not a group list value type and

<para>Case:
</para>

<olist>

<item>If the declared type of <sym>BVR</sym> is material, then
the degree of reference of <sym>BVR</sym> is unconditional singleton.
</item>

<item>Otherwise, the declared type of <sym>BVR</sym> is nullable and
the degree of reference of <sym>BVR</sym> is conditional singleton.
</item>

</olist>

</item>

</olist>
<comment>WG3:UTC-123R2 Deleted 1 (one) note</comment>

</item>

</olist>

</item>

<comment>WG3:UTC-123R2</comment>
<item>Let <symdef>DEG</symdef> be the degree of reference of <sym>BVR</sym>. 
If <sym>DEG</sym> is not singleton, then <sym>DEG</sym> shall be effectively bounded group and 
the declared type of <sym>BVR</sym> shall be a group list value type.
</item>

<item id="gql_var_refs_SR_pft">If the binding graph pattern <symdef>GP</symdef> of <sym>BVR</sym>
is defined, then the projected field type <symdef>PFT</symdef> of <sym>BVR</sym> is
the field type whose name is <sym>BVN</sym> and whose value type is determined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>GP</sym> declares an <BNF name="element variable"/> equivalent to <sym>BVN</sym>, 
then

<para>Case:
</para>

<olist>

<item>If <sym>DEG</sym> is unconditional singleton, then the value type of <sym>PFT</sym> is 
a value type that is determined using an <impDef code="IW011"/> mechanism such that it contains 
every reference value of a graph element to which <sym>BV</sym> can be bound by the evaluation of 
<sym>GP</sym>.
</item>

<item>If <sym>DEG</sym> is conditional singleton, then the value type of <sym>PFT</sym> is 
a value type that is determined using an <impDef code="IW011"/> mechanism such that it contains 
every reference value of a graph element to which <sym>BV</sym> can be bound by the evaluation of
<sym>GP</sym> and the null value.
</item>

<comment>WG3:UTC-123R2</comment>
<item>Otherwise, <sym>DEG</sym> is group and the value type of <sym>PFT</sym> is determined using
an <impDef code="IW011"/> mechanism such that:

<olist>

<comment>WG3:UTC-123R2</comment>
<item>The value type of <sym>PFT</sym> is either a group list value type or
a dynamic union type whose component types are group list value types.
</item>

<comment>WG3:UTC-123R2</comment>
<item>The value type of <sym>PFT</sym> contains every list of reference values to
a graph element to which <sym>BV</sym> can be bound by the evaluation of <sym>GP</sym>.
</item>

</olist>

</item>

</olist>

</item>

<item>Otherwise, <sym>GP</sym> declares a <BNF name="path variable"/> equivalent to <sym>BVN</sym>
 and the value type of <sym>PFT</sym> is the path value type.
</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>Editorial: Stefan Plantikow, 2020-07-25 WG3:MMX-055</comment>
<comment>WG3:W12-019</comment>
<comment>Editorial: Stephen Cannan, 2022-03-07 WG3:RKE-010 P00-USA-479</comment>
<comment>WG3:W22-053R2</comment>
<comment>WG3:OHD-017</comment>
<comment>WG3:UTC-087R2</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>Let <symdef>F</symdef> be the field of the current working record whose name is
<sym>BVN</sym>.
</item>

<comment>Editorial: Stefan Plantikow 2023-03-09 </comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>Let <symdef>FV</symdef> be the value of <sym>F</sym>.
</item>

<comment>WG3:UTC-087R2</comment>
<item>If the degree of reference of <sym>BVR</sym> is group and <sym>FV</sym> is not either 
a list value or the null value, then an exception condition is raised: 
<raise class="22" subclass="G13"/>.
</item>

<comment>WG3:UTC-087R2</comment>
<item>The result of <sym>BVR</sym> is <sym>FV</sym>.

<note>Every <BNF name="binding variable reference"/> is evaluated by looking it up in the current
working record. 
The referenced binding variable of a <BNF name="binding variable reference"/> declared by 
a <BNF name="graph pattern"/> is bound in the <specref ref="gql_app_bind_eval_expr"/>.
</note>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-039R1</comment>
<comment>WG3:CMN-057R1</comment>
<comment>WG3:CMN-049</comment>
<item>Without <feature code="GP11"/>, in conforming GQL language,
the declared type of a <BNF name="binding variable reference"/> shall not be a supertype of
a graph reference value type.
</item>

<comment>WG3:UTC-039R1</comment>
<comment>WG3:CMN-057R1</comment>
<comment>WG3:CMN-049</comment>
<item>Without <feature code="GP08"/>, in conforming GQL language,
the declared type of a <BNF name="binding variable reference"/> shall not be a supertype of
a binding table reference value type.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W24-035R1</comment>
<subClause id="gql_path_val_expr" newpage="true">
<clauseHeading><BNF name="path value expression"/></clauseHeading>

<bodyMatter>

<Function>

<para>Specify a path value.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="path value expression">
<rhs>
<alt> <BNF name="path value concatenation"/> </alt>
<alt> <BNF name="path value primary"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="path value concatenation">
<rhs>
<BNF name="path value expression 1"/> <BNF name="concatenation operator"/> 
<BNF name="path value primary"/>
</rhs>
</BNFdef>

<BNFdef name="path value expression 1">
<rhs>
<BNF name="path value expression"/>
</rhs>
</BNFdef>

<BNFdef name="path value primary">
<rhs>
<BNF name="value expression primary"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>Editorial: Correction to W24-035R1</comment>
<item>The declared type of a <BNF name="path value concatenation"/> is the path value type.
</item>

<item>The declared type of a <BNF name="path value primary"/> shall be a path value type.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<item>If <BNF name="path value concatenation"/> is specified, then 
let <symdef>PV1</symdef> be the result of <BNF name="path value expression 1"/> and
let <symdef>PV2</symdef> be the result of <BNF name="path value primary"/>.

<para>Case:
</para>

<olist>

<item>If either <sym>PV1</sym> or <sym>PV2</sym> is the null value, then the result of the 
<BNF name="path value concatenation"/> is the null value.
</item>

<item>Otherwise:

<olist>

<item>Let <symdef>PEL1</symdef> and <symdef>PEL2</symdef> be the path element lists of 
<sym>PV1</sym> and <sym>PV2</sym>, respectively.
</item>

<comment>WG3:UTC-080</comment>
<item>If the last element of <sym>PEL1</sym> and the first element of <sym>PEL2</sym> are not 
node reference values whose referent is the same node, then an exception condition is raised: 
<raise class="22" subclass="G0Z"/>.
</item>

<comment>WG3:UTC-080</comment>
<item>Let <symdef>PELF</symdef> be <sym>PEL1</sym> without its last element.

<note>If <sym>PEL1</sym> is a single-node path value, then <sym>PELF</sym> is the empty sequence.
</note>
</item>

<item>Let <symdef>IDMC</symdef> be the <impDef code="IL015"/> maximum cardinality of path element
lists of path value types.
If the sum of the cardinality of <sym>PELF</sym> and the cardinality of <sym>PEL2</sym> is 
greater than <sym>IDMC</sym>, then an exception condition is raised: 
<raise class="22" subclass="G10"/>.
</item>

<comment>WG3:CMN-019 P00-USA-147 1 (one) GR removed</comment>

<comment>WG3:CMN-019 P00-USA-147</comment>
<item>The result of the <BNF name="path value concatenation"/> is the path value whose path element
list comprises every element of <sym>PELF</sym> followed by every element of <sym>PEL2</sym>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</GeneralRules>

<ConformanceRules>

<olist>

<item>Without <feature code="GV55"/>, conforming GQL language shall not contain 
a <BNF name="path value expression"/>.
</item>

<item>Without <feature code="GE06"/>, conforming GQL language shall not contain 
a <BNF name="path value concatenation"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W24-035R1</comment>
<subClause id="gql_path_val_const" newpage="true">
<clauseHeading><BNF name="path value constructor"/></clauseHeading>

<bodyMatter>

<Function>

<para>Specify construction of a path value.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="path value constructor">
<rhs>
<BNF name="path value constructor by enumeration"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-080</comment>
<BNFdef name="path value constructor by enumeration">
<rhs>
<kw>PATH</kw>
<BNF name="left bracket"/> <BNF name="path element list"/> <BNF name="right bracket"/> 
</rhs>
</BNFdef>

<BNFdef name="path element list">
<rhs>
<BNF name="path element list start"/> <opt> <BNF name="path element list step"/><repeat/> </opt> 
</rhs>
</BNFdef>

<BNFdef name="path element list start">
<rhs>
<BNF name="node reference value expression"/>
</rhs>
</BNFdef>

<BNFdef name="path element list step">
<rhs>
<BNF name="comma"/> <BNF name="edge reference value expression"/>
<BNF name="comma"/> <BNF name="node reference value expression"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>Editorial: Correction to W24-035R1</comment>
<item>The declared type of the <BNF name="path value constructor by enumeration"/> is the 
path value type.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<item>If the <BNF name="path value constructor by enumeration"/> <symdef>PVCBE</symdef> is 
specified, then:

<olist>

<item>Let <symdef>PEL</symdef> be the list of results of all 
<BNF name="node reference value expression"/>s and <BNF name="edge reference value expression"/>s 
simply contained in <sym>PVCBE</sym>.
</item>

<item>If <sym>PEL</sym> contains the null value or does not identify a path, then an exception
condition is raised: <raise class="22" subclass="G0Z"/>
</item>

<item>The result of <sym>PVCBE</sym> is the path value whose path element list is <sym>PEL</sym>.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<item>Without <feature code="GE06"/>, conforming GQL language shall not contain 
a <BNF name="path value constructor"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_listvalexp" newpage="true">
<clauseHeading><BNF name="list value expression"/></clauseHeading>

<bodyMatter>

<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<para>Specify a list value.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="list value expression">
<rhs>
<alt> <BNF name="list concatenation"/> </alt>
<alt> <BNF name="list primary"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="list concatenation">
<rhs>
<BNF name="list value expression 1"/> <BNF name="concatenation operator"/>
<BNF name="list primary"/>
</rhs>
</BNFdef>

<BNFdef name="list value expression 1">
<rhs>
<BNF name="list value expression"/>
</rhs>
</BNFdef>

<BNFdef name="list primary">
<rhs>
<alt>
<BNF name="list value function"/>
</alt>
<alt>
<BNF name="value expression primary"/>
</alt>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:BER-094R1</comment>
<item>The declared type of a <BNF name="list primary"/> shall be a list type.
</item>

<comment>WG3:BER-094R1</comment>
<item>If <BNF name="list concatenation"/> is specified, then:

<olist>

<comment>WG3:OHD-044R1</comment>
<comment>WG3:UTC-015</comment>
<item>The <applySC ref="gql_gen_combo_vts" rules="SR">
<symarg param="DTSET">the declared types of <BNF name="list value expression 1"/> and
 <BNF name="list primary"/>
</symarg>
<symresult param="RESTYPE"><symdef>DT</symdef></symresult>
</applySC>.
</item>

<item>Let <symdef>IDMC</symdef> be the <impDef code="IL015"/> maximum cardinality of a list type.
</item>

<comment>WG3:UTC-123R2</comment>
<comment>WG3:UTC-096R1</comment>
<item>The declared type of <BNF name="list concatenation"/> is the regular variant of <sym>DT</sym>.
</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:BER-094R1</comment>
<item>If <BNF name="list concatenation"/> is specified, then let <symdef>LV1</symdef> be 
the result of <BNF name="list value expression 1"/> and let <symdef>LV2</symdef> be the value 
of <BNF name="list primary"/>.

<para>Case:
</para>

<olist>

<item>If at least one of <sym>LV1</sym> and <sym>LV2</sym> is the null value, then 
the result of the <BNF name="list concatenation"/> is the null value.
</item>

<comment>WG3:W28-014</comment>
<item>If the sum of the cardinality of <sym>LV1</sym> and the cardinality of <sym>LV2</sym> is 
greater than <sym>IDMC</sym>, then an exception condition is raised: 
<raise class="22" subclass="02F"/>.
</item>

<item>Otherwise, the result is the list comprising every element of <sym>LV1</sym> followed
by every element of <sym>LV2</sym>.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W24-026R2</comment>
<item>Without <feature code="GV50"/>, conforming GQL language shall not contain 
a <BNF name="list value expression"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_listvalfunc" newpage="true">
<clauseHeading><BNF name="list value function"/></clauseHeading>

<bodyMatter>

<Function>

<para>Specify a function yielding a value of a list type.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:BER-094R1</comment>
<comment>WG3:UTC-015</comment>
<BNFdef name="list value function">
<rhs>
<alt> <BNF name="trim list function"/> </alt>
<alt> <BNF name="elements function"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="trim list function">
<rhs>
<kw>TRIM</kw> <BNF name="left paren"/> <BNF name="list value expression"/>
<BNF name="comma"/> <BNF name="numeric value expression"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<BNFdef name="elements function">
<rhs>
<kw>ELEMENTS</kw> 
<BNF name="left paren"/> <BNF name="path value expression"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:BER-094R1</comment>
<item>If <BNF name="trim list function"/> is specified, then:

<olist>

<item>The declared type of the <BNF name="numeric value expression"/> shall be 
an exact numeric type with scale 0 (zero).
</item>

<comment>WG3:UTC-123R2</comment>
<item>The declared type of the <BNF name="trim list function"/> is the regular variant of
the declared type of the immediately contained <BNF name="list value expression"/>.
</item>

</olist>

</item>

<item>If <BNF name="elements function"/> is specified, then the declared type of 
<BNF name="elements function"/> is an <impDef code="ID005"/> list value type that includes all node
and edge reference values.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<item>The result of <BNF name="trim list function"/> is defined as follows:

<olist>

<item>Let <symdef>NV</symdef> be the result of the <BNF name="numeric value expression"/>.
</item>

<item>If <sym>NV</sym> is the null value, then the result is the null value and no further General
Rules of this Subclause are applied.
</item>

<comment>WG3:POS-018</comment>
<item>If <sym>NV</sym> is less than 0 (zero), then an exception condition is raised:
<raise class="22" subclass="02E"/>.
</item>

<item>Let <symdef>AV</symdef> be the result of the <BNF name="list value expression"/>.
</item>

<item>If <sym>AV</sym> is the null value, then the result is the null value and no further General
Rules of this Subclause are applied.
</item>

<item>Let <symdef>AC</symdef> be the cardinality of <sym>AV</sym>.
</item>

<comment>WG3:POS-018</comment>
<item>If <sym>NV</sym> is greater than <sym>AC</sym>, then an exception condition is raised:
<raise class="22" subclass="02E"/>.
</item>

<item>Let <symdef>N</symdef> be <sym>AC</sym> &minus; <sym>NV</sym>.
</item>

<item>Case:

<olist>

<item>If <sym>N</sym> = 0 (zero), then the result is a list whose cardinality is 0 (zero).
</item>

<comment>WG3:CMN-019 P00-NLD-050</comment>
<item>Otherwise, the result is a list of <sym>N</sym> elements such that, 
for <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>, the value of the 
<sym>i</sym>-th element of the result is the value of the <sym>i</sym>-th element of <sym>AV</sym>.
</item>

</olist>

</item>

</olist>

</item>

<item>The result of <BNF name="elements function"/> <symdef>EF</symdef> is defined as follows.

<olist>

<item>Let <symdef>PV</symdef> be the result of the <BNF name="path value expression"/>.
</item>

<item>If <sym>PV</sym> is the null value, then the result of <sym>EF</sym> is the null value; 
otherwise, the result of <sym>EF</sym> is the path element list of <sym>PV</sym>.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<comment>WG3:BGI-035 Removed 1 (one) editor's note</comment>

<olist>

<comment>WG3:BGI-035 Removed 1 (one) CR</comment>

<item>Without <feature code="GF04"/>, conforming GQL language shall not contain 
an <BNF name="elements function"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_listvalconst" newpage="true">
<clauseHeading><BNF name="list value constructor"/></clauseHeading>

<bodyMatter>

<Function>

<para>Specify construction of a list.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="list value constructor">
<rhs>
<BNF name="list value constructor by enumeration"/> 
</rhs>
</BNFdef>

<comment>WG3:W24-026R2</comment>
<BNFdef name="list value constructor by enumeration">
<rhs>
<opt> <BNF name="list value type name"/> </opt>
<BNF name="left bracket"/> <opt> <BNF name="list element list"/> </opt> <BNF name="right bracket"/>
</rhs>
</BNFdef>

<BNFdef name="list element list">
<rhs>
<BNF name="list element"/>
<opt> <group> <BNF name="comma"/> <BNF name="list element"/> </group><repeat/> </opt>
</rhs>
</BNFdef>

<BNFdef name="list element">
<rhs>
<BNF name="value expression"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:BER-094R1</comment>
<item>The declared type of <BNF name="list value constructor"/> is the declared type of the
immediately contained <BNF name="list value constructor by enumeration"/>.
</item>

<comment>WG3:W24-026R2</comment>
<item>Let <symdef>LVCE</symdef> be the <BNF name="list value constructor by enumeration"/>. 
Let <symdef>C</symdef> be the number of <BNF name="list element"/>s simply contained in 
<sym>LVCE</sym>.

<note>If <BNF name="list value constructor by enumeration"/> does not simply contain 
a <BNF name="list element list"/>, then <sym>C</sym> is equal to 0 (zero).
</note>

</item>

<comment>WG3:BER-094R1</comment>
<comment>WG3:OHD-044R1</comment>
<comment>WG3:W24-026R2</comment>
<comment>WG3:W26-026R2</comment>
<item>Case:

<olist>

<item>If <sym>C</sym> is greater than 0 (zero), then the 
<applySC ref="gql_gen_combo_vts" rules="SR">
<symarg param="DTSET">the declared types of the <BNF name="list element"/>s immediately contained 
in the <BNF name="list element list"/> of <sym>LVCE</sym>
</symarg>
<symresult param="RESTYPE"><symdef>DT</symdef></symresult>
</applySC>.
The declared type of <sym>LVCE</sym> is the regular list value type with element type <sym>DT</sym>
and a maximum cardinality <sym>C</sym>. 
</item>

<item>Otherwise, <sym>C</sym> is equal to 0 (zero) and 

<olist>

<item>If the GQL-implementation supports <feature code="GV72"/>, then the declared type of 
<sym>LVCE</sym> is the list value type whose list element type is the empty type.
</item>

<item>Otherwise, the declared type of <sym>LVCE</sym> is  a list value type with 
an <impDef code="ID004"/> list element type and a maximum cardinality of <sym>C</sym>.
</item>

</olist>

</item>

<comment>WG3:BER-094R1</comment>
<comment>WG3:W24-026R2</comment>
<item><sym>C</sym> shall be less or equal than the <impDef code="IL015"/> maximum cardinality for 
list value types whose list element type is <sym>DT</sym>.
</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:W24-026R2</comment>
<item>The result of <BNF name="list value constructor by enumeration"/> is a list value whose
<symdef>i</symdef>-th element is the value of the <sym>i</sym>-th <BNF name="list element"/> simply
contained in the <BNF name="list value constructor by enumeration"/>, cast as the value type of 
<sym>DT</sym>.

<note>If <BNF name="list value constructor by enumeration"/> does not simply contain 
a <BNF name="list element list"/>, then the result is a list value that is an empty list value.
</note>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W24-026R2</comment>
<item>Without <feature code="GV50"/>, conforming GQL language shall not contain 
a <BNF name="list value constructor"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_recordtvalconst" newpage="true">
<clauseHeading><BNF name="record constructor"/></clauseHeading>

<comment>Editorial: Stefan Plantikow, 2020-10-09 Added record constructor</comment>
<bodyMatter>

<Function>

<para>Specify construction of a record.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:BER-040R3</comment>
<comment>WG3:W24-026R2</comment>
<BNFdef name="record constructor">
<rhs>
<opt> <kw>RECORD</kw> </opt> <BNF name="fields specification"/>
</rhs>
</BNFdef>

<comment>WG3:W24-026R2</comment>
<BNFdef name="fields specification">
<rhs>
<BNF name="left brace"/> <opt> <BNF name="field list"/> </opt> <BNF name="right brace"/>
</rhs>
</BNFdef>

<BNFdef name="field list">
<rhs>
<BNF name="field"/> <opt> <group> <BNF name="comma"/> <BNF name="field"/> </group><repeat/> </opt>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<item>Let <symdef>RVC</symdef> be the <BNF name="record constructor"/>.
</item>

<comment>WG3:W24-026R2</comment>
<item>Every <BNF name="fields specification"/> specifies the fields specified by the immediately 
contained <BNF name="field list"/>.
</item>

<item>Every <BNF name="field list"/> <symdef>FL</symdef> specifies the fields defined by the 
<BNF name="field"/>s simply contained in <sym>FL</sym>.
</item>

<comment>WG3:W23-009R1 P00-USA-435</comment>
<comment>WG3:W24-026R2</comment>
<comment>WG3:CMN-019 P00-NLD-050</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>Let <symdef>FS</symdef> be the <BNF name="fields specification"/> immediately contained in 
<sym>RVC</sym>.
Let <symdef>N</symdef> be the number of fields specified by <sym>FS</sym>.
<sym>N</sym> shall be less or equal than the <impDef code="IL015"/> maximum number of 
record fields.
For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>,
let <symdef>F</symdef><sub><sym>i</sym></sub> be the <sym>i</sym>-th field specified by 
<sym>FS</sym>, and let <symdef>FT</symdef><sub><sym>i</sym></sub> be the field type of 
<sym>F</sym><sub><sym>i</sym></sub>.
</item>

<item>Let <symdef>RT</symdef> be defined as follows:

<olist>

<item>Let <symdef>RT</symdef><sub>0</sub> be defined as follows:

<olist>

<comment>WG3:CMN-019 P00-USA-207</comment>
<item>If <sym>N</sym> is 0 (zero), then <sym>RT</sym><sub>0</sub> is:
<code>
<kw>RECORD</kw> {}
</code>
</item>

<comment>WG3:CMN-019 P00-USA-207</comment>
<item>Otherwise, <sym>RT</sym><sub>0</sub> is:
<code>
<kw>RECORD</kw> { <sym>FT</sym><sub>1</sub>, <ellipsis/>, <sym>FT</sym><sub><sym>N</sym></sub> }
</code>
</item>

</olist>

</item>

<item><sym>RT</sym> is the <BNF name="record type"/> obtained by the application of Syntax Rules 
for <BNF name="record type"/> to <sym>RT</sym><sub>0</sub>.
</item>

</olist>

</item>

<item>The declared type of <sym>RVC</sym> is the record type specified by <sym>RT</sym>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:BER-040R3</comment>
<item>The General Rules of <BNF name="record type"/> are applied to <sym>RT</sym>.
</item>

<comment>WG3:BER-040R3</comment>
<item>The value of <sym>RVC</sym> is the record whose set of fields are the fields defined by the 
<BNF name="field"/>s specified by <sym>FS</sym>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W24-026R2</comment>
<item>Without <feature code="GV45"/>, conforming GQL language shall not contain 
a <BNF name="record constructor"/>.
</item>

<comment>WG3:CMN-019 P00-USA-077</comment>
<item>Without <feature code="GV46"/>, in conforming GQL language, the declared type of the 
<BNF name="record constructor"/> is the open record type.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:BER-040R3</comment>
<subClause id="gql_field" newpage="true">
<clauseHeading><BNF name="field"/></clauseHeading>

<bodyMatter>

<Function>

<para>Specify a field.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="field">
<rhs>
<BNF name="field name"/> <BNF name="colon"/> <BNF name="value expression"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<item>Let <symdef>FL</symdef> be the <BNF name="field list"/> that simply contains 
a <BNF name="field"/> <symdef>F</symdef>.
</item>

<item>The <BNF name="field name"/> shall not be equivalent to the <BNF name="field name"/> of 
any other <BNF name="field"/> simply contained in <sym>FL</sym>.
</item>

<item>The <BNF name="field name"/> specifies the <newterm>field name</newterm> of the field 
defined by <sym>F</sym>.
</item>

<item>The <BNF name="value expression"/> specifies the <newterm>field value expression</newterm> 
of <sym>F</sym>.
</item>

<item>The field type of <sym>F</sym> is the pair comprising the field name of the field defined by 
<sym>F</sym> and the declared type of the field value expression of <sym>F</sym>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<item>The <newterm>field value</newterm> of the field defined by <sym>F</sym> is the value of the 
field value expression of <sym>F</sym>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<item>Without <feature code="GV48"/>, conforming GQL language shall not contain 
a <BNF name="field"/> that simply contains a <BNF name="record constructor"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_Boolean_value" newpage="true">
<clauseHeading><BNF name="boolean value expression"/></clauseHeading>

<bodyMatter>


<Function>

<comment>Editorial: Stephen Cannan, 2021-04-02 See WG3:W09-024</comment>
<comment>Editorial: Stefan Plantikow, 2021-06-19 Lower-case Boolean value</comment>
<para>Specify a Boolean value.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="boolean value expression">
<rhs>
<alt> <BNF name="boolean term"/> </alt>
<alt> <BNF name="boolean value expression"/> <kw>OR</kw> <BNF name="boolean term"/> </alt>
<alt> <BNF name="boolean value expression"/> <kw>XOR</kw> <BNF name="boolean term"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="boolean term">
<rhs>
<alt> <BNF name="boolean factor"/> </alt>
<alt> <BNF name="boolean term"/> <kw>AND</kw> <BNF name="boolean factor"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="boolean factor">
<rhs>
<opt> <kw>NOT</kw> </opt> <BNF name="boolean test"/>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2021-04-28 Fix grammar bug</comment>
<comment>WG3:JCJ-010R1</comment>
<comment>WG3:UTC-092</comment>
<BNFdef name="boolean test">
<rhs>
<BNF name="boolean primary"/>
<opt> <kw>IS</kw> <opt> <kw>NOT</kw> </opt> <BNF name="truth value"/> </opt>
</rhs>
</BNFdef>

<comment>WG3:JCJ-010R1</comment>
<comment>WG3:BER-094R1</comment>
<BNFdef name="truth value">
<rhs>
<alt> <kw>TRUE</kw> </alt>
<alt> <kw>FALSE</kw> </alt>
<alt> <kw>UNKNOWN</kw> </alt>
</rhs>
</BNFdef>

<BNFdef name="boolean primary">
<rhs>
<alt> <BNF name="predicate"/> </alt>
<alt> <BNF name="boolean predicand"/> </alt>
</rhs>
</BNFdef>

<comment>Email from: Keith Hare, 2022-06-23 1615 Correct spelling of boolean in NT name</comment>
<BNFdef name="boolean predicand">
<rhs>
<alt> <BNF name="parenthesized boolean value expression"/> </alt>
<alt> <BNF name="non-parenthesized value expression primary"/> </alt>
</rhs>
</BNFdef>

<comment>Email from: Keith Hare, 2022-06-23 1615 Correct spelling of boolean in NT name</comment>
<BNFdef name="parenthesized boolean value expression">
<rhs>
<BNF name="left paren"/> <BNF name="boolean value expression"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<ednote id="gql_PP011_3">Rules regarding known-not null and determinism are ignored for the moment.
See <PPref ref="PPgql011"/>.
</ednote>

<comment>WG3:BER-094R1</comment>
<item>The declared type of a <BNF name="boolean value expression"/> is a Boolean type.
</item>

<comment>WG3:BER-094R1</comment>
<item>The declared type of a <BNF name="parenthesized boolean value expression"/> is the declared
type of the simply contained <BNF name="boolean value expression"/>.
</item>

<comment>WG3:BER-094R1</comment>
<item>The declared type of a <BNF name="boolean predicand"/> that is 
a <BNF name="non-parenthesized value expression primary"/> shall be a Boolean type.
</item>

<item><symdef>X</symdef> <kw>XOR</kw> <symdef>Y</symdef> is equivalent to the following
<BNF name="boolean value expression"/>:

<code>
( <sym>X</sym> <kw>OR</kw> <sym>Y</sym> ) <kw>AND</kw> <kw>NOT</kw> ( <sym>X</sym> <kw>AND</kw> <sym>Y</sym> )
</code>

</item>

<item>If <kw>NOT</kw> is specified in a <BNF name="boolean test"/>, then 
let <symdef>BP</symdef> be the contained <BNF name="boolean primary"/> and 
let <symdef>TV</symdef> be the contained <BNF name="truth value"/>.
The <BNF name="boolean test"/> is equivalent to:

<code>
( <kw>NOT</kw> ( <sym>BP</sym> <kw>IS</kw> <sym>TV</sym> ) )
</code>

</item>
</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<item>The result is derived by the application of the specified Boolean operators
(<quote><kw>AND</kw></quote>,
<quote><kw>OR</kw></quote>, <quote><kw>NOT</kw></quote>, and <quote><kw>IS</kw></quote>) to the
results derived from each <BNF name="boolean primary"/>.
If Boolean operators are not specified, then the result of the
<BNF name="boolean value expression"/> is the result of
the specified <BNF name="boolean primary"/>.
</item>

<item><kw>NOT</kw> (<bool>True</bool>) is <bool>False</bool>,
<kw>NOT</kw> (<bool>False</bool>) is <bool>True</bool>, and
<kw>NOT</kw> (<bool>Unknown</bool>) is <bool>Unknown</bool>.
</item>

<item><specref ref="gql_and_truth"/>, <specref ref="gql_or_truth"/>, and
<specref ref="gql_is_truth"/>, specify the semantics of <kw>AND</kw>, <kw>OR</kw>, and <kw>IS</kw>,
respectively.

<comment>Editorial: Stephen Cannan, 2021-04-02 See WG3:W09-024</comment>
<table id="gql_and_truth">
<tableTitle>Truth table for the <kw>AND</kw> Boolean operator</tableTitle>

<table-common>

<table-setup numcols="4">
<table-coldef colnum="1" colwidth="0.8in"/>
<table-coldef colnum="2" colwidth="0.8in"/>
<table-coldef colnum="3" colwidth="0.8in"/>
<table-coldef colnum="4" colwidth="4.1in"/>
</table-setup>

<table-heads>
<table-head> <kw>AND</kw> </table-head>
<table-head> <bool>True</bool> </table-head>
<table-head> <bool>False</bool> </table-head>
<table-head> <bool>Unknown</bool> </table-head>
</table-heads>

</table-common>

<table-body>

<table-row>
<table-cell> <bold><bool>True</bool></bold> </table-cell>
<table-cell> <bool>True</bool> </table-cell>
<table-cell> <bool>False</bool> </table-cell>
<table-cell> <bool>Unknown</bool> </table-cell>
</table-row>

<table-row>
<table-cell> <bold><bool>False</bool></bold> </table-cell>
<table-cell> <bool>False</bool> </table-cell>
<table-cell> <bool>False</bool> </table-cell>
<table-cell> <bool>False</bool> </table-cell>
</table-row>

<table-row>
<table-cell> <bold><bool>Unknown</bool></bold> </table-cell>
<table-cell> <bool>Unknown</bool> </table-cell>
<table-cell> <bool>False</bool> </table-cell>
<table-cell> <bool>Unknown</bool> </table-cell>
</table-row>

</table-body>

</table>

<comment>Editorial: Stephen Cannan, 2021-04-02 See WG3:W09-024</comment>
<table id="gql_or_truth">
<tableTitle>Truth table for the <kw>OR</kw> Boolean operator</tableTitle>

<table-common>

<table-setup numcols="4">
<table-coldef colnum="1" colwidth="0.8in"/>
<table-coldef colnum="2" colwidth="0.8in"/>
<table-coldef colnum="3" colwidth="0.8in"/>
<table-coldef colnum="4" colwidth="4.1in"/>
</table-setup>

<table-heads>
<table-head> <kw>OR</kw> </table-head>
<table-head> <bool>True</bool> </table-head>
<table-head> <bool>False</bool> </table-head>
<table-head> <bool>Unknown</bool> </table-head>
</table-heads>

</table-common>

<table-body>

<table-row>
<table-cell> <bold><bool>True</bool></bold> </table-cell>
<table-cell> <bool>True</bool> </table-cell>
<table-cell> <bool>True</bool> </table-cell>
<table-cell> <bool>True</bool> </table-cell>
</table-row>

<table-row>
<table-cell> <bold><bool>False</bool></bold> </table-cell>
<table-cell> <bool>True</bool> </table-cell>
<table-cell> <bool>False</bool> </table-cell>
<table-cell> <bool>Unknown</bool> </table-cell>
</table-row>

<table-row>
<table-cell> <bold><bool>Unknown</bool></bold> </table-cell>
<table-cell> <bool>True</bool> </table-cell>
<table-cell> <bool>Unknown</bool> </table-cell>
<table-cell> <bool>Unknown</bool> </table-cell>
</table-row>

</table-body>

</table>

<comment>Editorial: Stephen Cannan, 2021-04-02 See WG3:W09-024</comment>
<table id="gql_is_truth">
<tableTitle>Truth table for the <kw>IS</kw> Boolean operator</tableTitle>

<table-common>

<table-setup numcols="4">
<table-coldef colnum="1" colwidth="0.8in"/>
<table-coldef colnum="2" colwidth="0.8in"/>
<table-coldef colnum="3" colwidth="0.8in"/>
<table-coldef colnum="4" colwidth="4.1in"/>
</table-setup>

<table-heads>
<table-head> <kw>IS</kw> </table-head>
<table-head> <kw>TRUE</kw> </table-head>
<table-head> <kw>FALSE</kw> </table-head>
<table-head> <kw>UNKNOWN</kw> </table-head>
</table-heads>

</table-common>

<table-body>

<table-row>
<table-cell> <bold><bool>True</bool></bold> </table-cell>
<table-cell> <bool>True</bool> </table-cell>
<table-cell> <bool>False</bool> </table-cell>
<table-cell> <bool>False</bool> </table-cell>
</table-row>

<table-row>
<table-cell> <bold><bool>False</bool></bold> </table-cell>
<table-cell> <bool>False</bool> </table-cell>
<table-cell> <bool>True</bool> </table-cell>
<table-cell> <bool>False</bool> </table-cell>
</table-row>

<table-row>
<table-cell> <bold><bool>Unknown</bool></bold> </table-cell>
<table-cell> <bool>False</bool> </table-cell>
<table-cell> <bool>False</bool> </table-cell>
<table-cell> <bool>True</bool> </table-cell>
</table-row>

</table-body>

</table>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:CMN-019 P00-USA-135</comment>
<item>Without <feature code="GE07"/>, conforming GQL language shall not contain
a <BNF name="boolean value expression"/> that immediately contains <kw>XOR</kw>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_numexp" newpage="true">
<clauseHeading><BNF name="numeric value expression"/></clauseHeading>

<bodyMatter>


<Function>

<para>Specify a numeric value.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="numeric value expression">
<rhs>
<alt> <BNF name="term"/> </alt>
<alt> <BNF name="numeric value expression"/> <BNF name="plus sign"/> <BNF name="term"/> </alt>
<alt> <BNF name="numeric value expression"/> <BNF name="minus sign"/> <BNF name="term"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="term">
<rhs>
<alt> <BNF name="factor"/> </alt>
<alt> <BNF name="term"/> <BNF name="asterisk"/> <BNF name="factor"/> </alt>
<alt> <BNF name="term"/> <BNF name="solidus"/> <BNF name="factor"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="factor">
<rhs>
<opt> <BNF name="sign"/> </opt> <BNF name="numeric primary"/>
</rhs>
</BNFdef>

<BNFdef name="numeric primary">
<rhs>
<alt> <BNF name="value expression primary"/> </alt>
<alt> <BNF name="numeric value function"/> </alt>
</rhs>

</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:W22-056</comment>
<item>Case:

<olist>

<comment>WG3:UTC-015</comment>
<item>If the declared type of either operand of a dyadic arithmetic operator is approximate
numeric, then the declared type of the result is an <impDef code="ID063"/> approximate numeric 
type.
</item>

<item>Otherwise, the declared type of both operands of a dyadic arithmetic operator is exact
numeric and the declared type of the result is an <impDef code="ID064"/> exact numeric type,
with precision and scale defined as follows:

<olist>

<item>Let <symdef>S1</symdef> and <symdef>S2</symdef> be the scale of the first and second
operands respectively.
</item>

<item>The precision of the result of addition and subtraction is <impDef code="ID065"/>, and the
scale is the maximum of <sym>S1</sym> and <sym>S2</sym>.
</item>

<item>The precision of the result of multiplication is <impDef code="ID066"/>, and the scale is
<sym>S1</sym> + <sym>S2</sym>.
</item>

<item>The precision and scale of the result of division are <impDef code="ID067"/>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W22-056</comment>
<item>The declared type of a <BNF name="factor"/> is that of the immediately contained
<BNF name="numeric primary"/>.
</item>

<comment>WG3:W22-056</comment>
<item>The declared type of a <BNF name="numeric primary"/> shall be numeric.
</item>

<item>If a <BNF name="numeric value expression"/> immediately contains a <BNF name="minus sign"/>
<symdef>NMS</symdef> and immediately contains a <BNF name="term"/> that is a <BNF name="factor"/>
that immediately contains a <BNF name="sign"/> that is a <BNF name="minus sign"/>
<symdef>FMS</symdef>, then there shall be a <BNF name="separator"/> between <sym>NMS</sym> and
<sym>FMS</sym>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<item>If the result of any <BNF name="numeric primary"/> simply contained in 
a <BNF name="numeric value expression"/> is the null value, then the result of the
<BNF name="numeric value expression"/> is the null value.
</item>

<item>If the <BNF name="numeric value expression"/> contains only a <BNF name="numeric primary"/>,
then the result of the <BNF name="numeric value expression"/> is the result of the specified
<BNF name="numeric primary"/>.
</item>

<item>The monadic arithmetic operators <BNF name="plus sign"/> and <BNF name="minus sign"/>
(+ and &minus;, respectively) specify monadic plus and monadic minus, respectively.
Monadic plus does not change its operand.
Monadic minus reverses the sign of its operand.
</item>

<comment>WG3:UTC-063</comment>
<item>The dyadic arithmetic operators <BNF name="plus sign"/>, <BNF name="minus sign"/>,
<BNF name="asterisk"/>, and <BNF name="solidus"/> (+, &minus;, *, and /, respectively) specify
addition, subtraction, multiplication, and division, respectively.
If the value of a divisor is zero, then

<para>Case:
</para>

<olist>

<comment>WG3:CMN-019 P00-ISO-003</comment>
<item>If a GQL-implementation supports <feature code="GA01"/>, then the result shall be a value as 
defined by <docref ref="IEEE754"/>.
</item>

<item>Otherwise, an exception condition is raised: <raise class="22" subclass="012"/>.
</item>

</olist>

</item>

<comment>WG3:UTC-015</comment>
<item>If the result of an arithmetic operation is an exact number, then

<para>Case:
</para>

<olist>

<item>If the operator is not division and the mathematical result of the operation is not exactly
representable with the precision and scale of the declared type of the result, then an exception 
condition is raised: <raise class="22" subclass="003"/>.
</item>

<item>If the operator is division and the approximate mathematical result of the operation
represented with the precision and scale of the declared type of the result loses one or more 
leading significant digits after rounding or truncating if necessary, then an exception condition 
is raised: <raise class="22" subclass="003"/>.
The choice of whether to round or truncate is <impDef code="IA011"/>.
</item>

</olist>

</item>

<comment>WG3:UTC-063</comment>
<comment>WG3:UTC-015</comment>
<item>If the result of an arithmetic operation is an approximate number and the exponent of the 
approximate mathematical result of the operation is not within the <impDef code="IL023"/> exponent 
range for the declared type of the result, then

<para>Case:
</para>

<olist>

<comment>WG3:CMN-019 P00-ISO-003</comment>
<item>If a GQL-implementation supports <feature code="GA01"/>, then the result shall be a value as 
defined by <docref ref="IEEE754"/>.
</item>

<item>Otherwise, an exception condition is raised: <raise class="22" subclass="003"/>.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_numvalfunc" newpage="true">
<clauseHeading><BNF name="numeric value function"/></clauseHeading>

<bodyMatter>


<Function>

<comment>Editorial: Stefan Plantikow, 2023-06-02 Improve wording</comment>
<para>Specify a function yielding a value of a numeric type.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:CMN-068</comment>
<BNFdef name="numeric value function">
<rhs>
<alt> <BNF name="length expression"/> </alt>
<alt> <BNF name="cardinality expression"/> </alt>
<alt> <BNF name="absolute value expression"/> </alt>
<alt> <BNF name="modulus expression"/> </alt>
<alt> <BNF name="trigonometric function"/> </alt>
<alt> <BNF name="general logarithm function"/> </alt>
<alt> <BNF name="common logarithm"/> </alt>
<alt> <BNF name="natural logarithm"/> </alt>
<alt> <BNF name="exponential function"/> </alt>
<alt> <BNF name="power function"/> </alt>
<alt> <BNF name="square root"/> </alt>
<alt> <BNF name="floor function"/> </alt>
<alt> <BNF name="ceiling function"/> </alt>
<comment>WG3:POS-011R1</comment>
<alt> <BNF name="vector dimension count"/> </alt>
<comment>WG3:POS-011R1</comment>
<alt> <BNF name="vector distance function"/> </alt>
<comment>WG3:POS-011R1</comment>
<alt> <BNF name="vector norm function"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19</comment>
<BNFdef name="length expression">
<rhs>
<alt> <BNF name="char length expression"/> </alt>
<alt> <BNF name="byte length expression"/> </alt>
<alt> <BNF name="path length expression"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W26-037R3</comment>
<ednote id="gql_PP379">Support for a generic <BNF name="length expression"/> LENGTH(<ellipsis/>), 
in the same spirit as the <BNF name="cardinality expression"/>, should be considered.
See <PPref ref="PPgql379"/>.
</ednote>

<comment>WG3:CMN-068</comment>
<BNFdef name="cardinality expression">
<rhs>
<alt> 
<kw>CARDINALITY</kw> <BNF name="left paren"/> <BNF name="cardinality expression argument"/> 
<BNF name="right paren"/>
</alt> 
<alt> 
<kw>SIZE</kw> <BNF name="left paren"/> <BNF name="list value expression"/> <BNF name="right paren"/>
</alt>
</rhs>
</BNFdef>

<comment>WG3:CMN-068</comment>
<comment>WG3:W26-037R3</comment>
<BNFdef name="cardinality expression argument">
<rhs>
<alt> <BNF name="binding table reference value expression"/> </alt>
<alt> <BNF name="path value expression"/> </alt>
<alt> <BNF name="list value expression"/> </alt>
<alt> <BNF name="record expression"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W26-037R3</comment>
<ednote id="gql_PP380">Support for determining the cardinalities of element, node, and edge sets of
graphs referenced by graph reference values should be added (possibly by expanding the
<BNF name="cardinality expression"/>).
See <PPref ref="PPgql380"/>.
</ednote>

<comment>consistent use of "character string": Stefan Plantikow, 2021-06-23</comment>
<BNFdef name="char length expression">
<rhs>
<group> 
<alt br="no"> <kw>CHAR_LENGTH</kw> </alt> <alt br="no"> <kw>CHARACTER_LENGTH</kw> </alt> 
</group> 
<breakindent/>
<BNF name="left paren"/> <BNF name="character string value expression"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19</comment>
<comment>WG3:W24-035R1</comment>
<BNFdef name="byte length expression">
<rhs>
<group> 
<alt br="no"> <kw>BYTE_LENGTH</kw> </alt> <alt br="no"> <kw>OCTET_LENGTH</kw> </alt> 
</group>
<breakindent/>
<BNF name="left paren"/> <BNF name="byte string value expression"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<comment>WG3:W22-053R2</comment>
<comment>WG3:W24-035R1</comment>
<BNFdef name="path length expression">
<rhs>
<kw>PATH_LENGTH</kw> 
<BNF name="left paren"/> <BNF name="path value expression"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<BNFdef name="absolute value expression">
<rhs>
<kw>ABS</kw>
<BNF name="left paren"/> <BNF name="numeric value expression"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<comment>WG3:JCJ-010R1</comment>
<BNFdef name="modulus expression">
<rhs>
<kw>MOD</kw>
<BNF name="left paren"/> <BNF name="numeric value expression dividend"/> <BNF name="comma"/>
<breakindent/>
<BNF name="numeric value expression divisor"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<BNFdef name="numeric value expression dividend">
<rhs>
<BNF name="numeric value expression"/>
</rhs>
</BNFdef>

<BNFdef name="numeric value expression divisor">
<rhs>
<BNF name="numeric value expression"/>
</rhs>
</BNFdef>

<BNFdef name="trigonometric function">
<rhs>
<BNF name="trigonometric function name"/>
<BNF name="left paren"/> <BNF name="numeric value expression"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<comment>WG3:JCJ-010R1</comment>
<BNFdef name="trigonometric function name">
<rhs>
<alt br="no"> <kw>SIN</kw> </alt>
<alt br="no"> <kw>COS</kw> </alt>
<alt br="no"> <kw>TAN</kw> </alt>
<alt br="no"> <kw>COT</kw> </alt>
<alt br="no"> <kw>SINH</kw> </alt>
<alt br="no"> <kw>COSH</kw> </alt>
<alt br="no"> <kw>TANH</kw> </alt>
<alt br="no"> <kw>ASIN</kw> </alt>
<alt br="no"> <kw>ACOS</kw> </alt>
<alt br="no"> <kw>ATAN</kw> </alt>
<alt br="no"> <kw>DEGREES</kw> </alt>
<alt br="no"> <kw>RADIANS</kw> </alt>
</rhs>
</BNFdef>

<BNFdef name="general logarithm function">
<rhs>
<kw>LOG</kw> <BNF name="left paren"/> <BNF name="general logarithm base"/> <BNF name="comma"/>
<breakindent/>
<BNF name="general logarithm argument"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<BNFdef name="general logarithm base">
<rhs>
<BNF name="numeric value expression"/>
</rhs>
</BNFdef>

<BNFdef name="general logarithm argument">
<rhs>
<BNF name="numeric value expression"/>
</rhs>
</BNFdef>

<BNFdef name="common logarithm">
<rhs>
<kw>LOG10</kw>
<BNF name="left paren"/> <BNF name="numeric value expression"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<comment>WG3:JCJ-010R1</comment>
<BNFdef name="natural logarithm">
<rhs>
<kw>LN</kw>
<BNF name="left paren"/> <BNF name="numeric value expression"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<BNFdef name="exponential function">
<rhs>
<kw>EXP</kw>
<BNF name="left paren"/> <BNF name="numeric value expression"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<BNFdef name="power function">
<rhs>
<kw>POWER</kw> <BNF name="left paren"/> <BNF name="numeric value expression base"/>
<BNF name="comma"/>
<breakindent/>
<BNF name="numeric value expression exponent"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<BNFdef name="numeric value expression base">
<rhs>
<BNF name="numeric value expression"/>
</rhs>
</BNFdef>

<BNFdef name="numeric value expression exponent">
<rhs>
<BNF name="numeric value expression"/>
</rhs>
</BNFdef>

<BNFdef name="square root">
<rhs>
<kw>SQRT</kw>
<BNF name="left paren"/> <BNF name="numeric value expression"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<BNFdef name="floor function">
<rhs>
<kw>FLOOR</kw>
<BNF name="left paren"/> <BNF name="numeric value expression"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<BNFdef name="ceiling function">
<rhs>
<group>
<alt br="no"> <kw>CEIL</kw> </alt> <alt br="no"> <kw>CEILING</kw> </alt>
</group>
<BNF name="left paren"/> <BNF name="numeric value expression"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<comment>WG3:POS-011R1</comment>
<BNFdef name="vector dimension count">
<rhs>
<kw>VECTOR_DIMENSION_COUNT</kw> 
<BNF name="left paren"/> 
<BNF name="vector value expression"/>
<BNF name="right paren"/> 
</rhs>
</BNFdef>


<ednote id="gql_PP176_1">SQL contains other possibly relevant numeric value functions such as:

<olist>

<comment>Editorial: Stefan Plantikow, 2021-06-23 consistent use of string types</comment>
<item>POSITION for character strings and byte strings.
</item>

<item>EXTRACT for datetimes and durations.
Cypher has a range of functions with similar functionality.
</item>

<item>CARDINALITY for collections.
See also Cypher function size().
</item>

</olist>

<para>See <PPref ref="PPgql176"/>.
</para>

</ednote>

<ednote id="gql_PP176_2">SQL contains other numeric value functions that are probably not relevant
such as:

<olist>

<item>WIDTH_BUCKET.
</item>

<item>MATCH_NUMER
</item>

<item>ARRAY_MAX_CARDINALITY.
</item>

</olist>

<para>See <PPref ref="PPgql176"/>.
</para>

</ednote>

<ednote id="gql_PP176_3">Cypher contains other possibly relevant numeric value functions such as:

<olist>

<item>size() - returns the cardinality of a list, the length of a character string, 
or the number of subgraphs matching the pattern expression.
See also the SQL function CARDINALITY and the current GQL function CHARACTER_LENGTH.
</item>

<item>round() - returns the value of a number rounded to the nearest integer.
</item>

<item>rand() - returns a random floating point number in the range from 0 (inclusive) to 
1 (exclusive); <ie/> [0,1).
The numbers returned follow an approximate uniform distribution.
</item>

<item>e() - returns the base of the natural logarithm, e.
</item>

<item>sign() - returns an indication of the sign of a number: 0 if the number is 0, -1 for any 
negative number, and 1 for any positive number.
</item>

<item>pi() - returns the mathematical constant pi.
</item>

<item>haversin() - returns half the versed sine of a number.
</item>

<item>atan2() - returns the arctangent2 of a set of coordinates in radians.
</item>

<item>reduce() - returns the value resulting from the application of an expression on each 
successive element of a list in conjunction with the result of the computation thus far.
This function iterates through each element e in the given list, run the expression on e 
- taking into account the current partial result -
and store the new partial result in the accumulator.
This function is analogous to the fold or reduce method in functional languages such as Lisp and 
Scala.
</item>

</olist>

<para>See <PPref ref="PPgql176"/>.
</para>

</ednote>

<ednote id="gql_PP176_4">Cypher contains other numeric value functions that may not be relevant such
as:

<olist>

<item>id() - returns the id of a relationship or node.
</item>

</olist>

<para>See <PPref ref="PPgql176"/>.
</para>

</ednote>

<ednote id="gql_PP176_5">Discussion is required as to whether any of the functions named above 
should be incorporated into GQL.
See <PPref ref="PPgql176"/>.
</ednote>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:W24-035R1</comment>
<comment>WG3:UTC-090R1</comment>
<item>The declared type of the result of <BNF name="length expression"/> is the 
<impDef code="ID068"/> nullable exact numeric type with scale 0 (zero).
</item>

<comment>WG3:CMN-068</comment>
<item>If a <BNF name="cardinality expression"/> <symdef>CE</symdef> is specified that 
immediately contains <kw>SIZE</kw> and the <BNF name="list value expression"/> <symdef>LVE</symdef>,
then <sym>CE</sym> is effectively replaced by:
<code>
<kw>CARDINALITY</kw>(<sym>LVE</sym>)
</code>
</item>

<item>The declared type <symdef>DT</symdef> of the result of a <BNF name="cardinality expression"/>
<symdef>CE</symdef> that immediately contains a <BNF name="cardinality expression argument"/> 
<symdef>CEA</symdef> is defined as follows:

<olist>

<item>Let <symdef>DTA</symdef> be the declared type of <sym>CEA</sym>.
</item>

<item><sym>DT</sym> is the <impDef code="ID070"/> exact numeric type with scale 0 (zero)
to whose nullability the nullability of <sym>DTA</sym> is assignment-aligned.
</item>

</olist>

</item>

<item>The declared type of the result of <BNF name="absolute value expression"/> the 
declared type of the immediately contained <BNF name="numeric value expression"/>.
</item>

<item>The declared type of the result of <BNF name="modulus expression"/> is the declared type 
of the immediately contained <BNF name="numeric value expression divisor"/>.
</item>

<item>The declared type of the result of <BNF name="trigonometric function"/> is 
an <impDef code="ID069"/> approximate numeric type.
</item>

<item>The declared type of the result of <BNF name="general logarithm function"/> is 
an <impDef code="ID069"/> approximate numeric type.
</item>

<item>The declared type of the result of <BNF name="natural logarithm"/> is 
an <impDef code="ID069"/> approximate numeric type.
</item>

<item>The declared type of the result of <BNF name="exponential function"/> is 
an <impDef code="ID069"/> approximate numeric type.
</item>

<item>The declared type of the result of <BNF name="power function"/> is 
an <impDef code="ID069"/> approximate numeric type.
</item>

<item>If <BNF name="floor function"/> or <BNF name="ceiling function"/> is specified, then

<para>Case:
</para>

<olist>

<comment>Remark Karl Schendel regarding simply contains (see SXM001 item 13.2)</comment>
<item>If the declared type of the immediately contained <BNF name="numeric value expression"/>
<symdef>NVE</symdef> is exact numeric, then the declared type of the result is exact numeric with
<impDef code="ID074"/> precision, with the radix of <sym>NVE</sym>, and with scale 0 (zero).
</item>

<item>Otherwise, an approximate numeric with <impDef code="ID075"/> precision.
</item>

</olist>

</item>

<item>If <BNF name="common logarithm"/> is specified, then let <symdef>NVE</symdef> be the simply
contained <BNF name="numeric value expression"/>.
The <BNF name="common logarithm"/> is equivalent to:

<code>
<kw>LOG</kw> (10, <sym>NVE</sym>)
</code>

</item>

<item>If <BNF name="square root"/> is specified, then let <symdef>NVE</symdef> be the simply
contained <BNF name="numeric value expression"/>.
The <BNF name="square root"/> is equivalent to:

<code>
<kw>POWER</kw> (<sym>NVE</sym>, 0.5)
</code>

</item>

<item>The declared type of the result of <BNF name="vector dimension count"/> is
an <impDef code="IV251"/> exact numeric type with scale 0 (zero).
</item>
</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:W24-035R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-01-04 Added note on character string length</comment>
<item>If the <BNF name="char length expression"/> <symdef>CLX</symdef> is specified, then 
let the character string <symdef>CSV</symdef> be the result of
the <BNF name="character string value expression"/> immediately contained in <sym>CLX</sym>.

<para>Case:
</para>

<olist>

<comment>Editorial: Stefan Plantikow, 2023-01-04 Added note on character string length</comment>
<item>If <sym>CSV</sym> is material, then the result of <sym>CLX</sym> is the (character string)
length of <sym>CSV</sym>.

<note>The (character string) length of <sym>CSV</sym> is defined in
<specref ref="gql_conc_char_string"/> as the number of characters in the sequence of characters
comprising <sym>CSV</sym>.
</note>

</item>

<item>Otherwise, the result of <sym>CLX</sym> is the null value.
</item>

</olist>

</item>

<comment>WG3:W24-035R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-01-04 Added note on byte string length</comment>
<item>If the <BNF name="byte length expression"/> <symdef>BLX</symdef> is specified, then 
let the byte string <symdef>BSV</symdef> be the result of
the <BNF name="byte string value expression"/> immediately contained in <sym>BLX</sym>.

<para>Case:
</para>

<olist>

<item>If <sym>BSV</sym> is material, then the result of <sym>BLX</sym> is the (byte string) length
of <sym>BSV</sym>.

<comment>Editorial: Stefan Plantikow, 2023-01-04 Added note on byte string length</comment>
<note>The (byte string) length of <sym>BSV</sym> is defined in <specref ref="gql_conc_byte_string"/>
as the number of bytes in the sequence of bytes comprising <sym>BSV</sym>.
</note>

</item>

<item>Otherwise, the result of <sym>BLX</sym> is the null value.
</item>

</olist>

</item>

<comment>WG3:W24-035R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-01-04 Added note on path value length</comment>
<item>If the <BNF name="path length expression"/> <symdef>PLX</symdef> is specified, then 
let the path value <symdef>PSV</symdef> be the result of
the <BNF name="path value expression"/> immediately contained in <sym>PLX</sym>.

<para>Case:
</para>

<olist>

<item>If <sym>PSV</sym> is material, then the result of <sym>PLX</sym> is the (path value) length
of <sym>PSV</sym>.

<comment>Editorial: Stefan Plantikow, 2023-01-04 Added note of path value length</comment>
<note>The (path value) length of <sym>PSV</sym> is defined in <specref ref="gql_conc_path"/> as
the number of edge reference values in the path element list <symdef>PEL</symdef> of <sym>PSV</sym>,
if <sym>PEL</sym> contains at least one node reference value; otherwise, the null value.
</note>

</item>

<item>Otherwise, the result of <sym>PLX</sym> is the null value.
</item>

</olist>

</item>

<comment>WG3:CMN-068</comment>
<item>If the <BNF name="cardinality expression"/> <symdef>CE</symdef> is specified, then 
let <symdef>CER</symdef> be the result of the <BNF name="cardinality expression argument"/> 
immediately contained in <sym>CE</sym> and the result of <sym>CE</sym> is defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>CER</sym> is a binding table reference value whose referent is <symdef>BT</symdef>, 
then the result of <sym>CE</sym> is the cardinality of <sym>BT</sym>.
</item>

<comment>WG3:W26-037R3</comment>
<item>If <sym>CER</sym> is a path value <symdef>PV</symdef>, then the result of <sym>CE</sym> is 
the cardinality of <sym>PV</sym>.
</item>

<item>If <sym>CER</sym> is a list value <symdef>LV</symdef>, then the result of <sym>CE</sym> is 
the cardinality of <sym>LV</sym>.
</item>

<comment>WG3:W26-037R3</comment>
<item>If <sym>CER</sym> is a record <symdef>REC</symdef>, then the result of <sym>CE</sym> is 
the cardinality of <sym>REC</sym>.
</item>

<comment>WG3:W26-037R3</comment>
<item>Otherwise, <sym>CER</sym> is the null value and the result of <sym>CE</sym> is 
the null value.
</item>

</olist>

</item>

<item>If <BNF name="absolute value expression"/> is specified, then let <symdef>N</symdef>
be the result of the immediately contained <BNF name="numeric value expression"/>.

<para>Case:
</para>

<olist>

<item>If <sym>N</sym> is the null value, then the result is the null value.
</item>

<item>If <sym>N</sym> <geq/> 0, then the result is <sym>N</sym>.
</item>

<item>Otherwise, the result is &minus;1 * <sym>N</sym>.
If &minus;1 * <sym>N</sym> is not representable by the declared type of the result, then 
an exception condition is raised: <raise class="22" subclass="003"/>.
</item>

</olist>

</item>

<comment>Editorial: Stefan Plantikow, 2023-06-02 Use result of</comment>
<item>If <BNF name="modulus expression"/> is specified, then let <symdef>N</symdef> be the 
result of the immediately contained <BNF name="numeric value expression dividend"/> and 
let <symdef>M</symdef> be the result of the immediately contained 
<BNF name="numeric value expression divisor"/>.

<para>Case:
</para>

<olist>

<item>If at least one of <sym>N</sym> and <sym>M</sym> is the null value, then the result is the
null value.
</item>

<item>If <sym>M</sym> is zero, then an exception condition is raised:
<raise class="22" subclass="012"/>.
</item>

<item>Otherwise, the result is the unique exact numeric value <symdef>R</symdef> 
with scale 0 (zero) such that all of the following are true:

<olist>

<item><sym>R</sym> has the same sign as <sym>N</sym>.
</item>

<item>The absolute value of <symdef>R</symdef> is less than the absolute value of <sym>M</sym>.
</item>

<comment>Editorial: Stephen Cannan, 2023-06-20, Correct symdef</comment>
<item>For some exact numeric value <symdef>K</symdef> with scale 0 (zero), 
<sym>N</sym> = <sym>M</sym> * <sym>K</sym> + <sym>R</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>Remark Karl Schendel regarding simply contains (see SXM001 item 13.2)</comment>
<item>If <BNF name="trigonometric function"/> is specified, then let <symdef>V</symdef> be the
result of the immediately contained <BNF name="numeric value expression"/> that represents 
an angle expressed in radians.

<para>Case:
</para>

<olist>

<item>If <sym>V</sym> is the null value, then the result is the null value.
</item>

<item>Otherwise, let <symdef>OP</symdef> be the <BNF name="trigonometric function name"/>.

<para>Case:
</para>

<olist>

<item>If <sym>OP</sym> is <kw>ACOS</kw>, then

<para>Case:
</para>

<olist>

<comment>WG3:POS-017R1</comment>
<item>If <sym>V</sym> is less than &minus;1 (negative one) or <sym>V</sym> is greater than 1 (one),
then an exception condition is raised: <raise class="22" subclass="02M"/>.
</item>

<item>Otherwise, the result of the <BNF name="trigonometric function"/> is the inverse cosine of
<sym>V</sym>.
</item>

</olist>

</item>

<item>If <sym>OP</sym> is <kw>ASIN</kw>, then

<para>Case:
</para>

<olist>

<comment>WG3:POS-017R1</comment>
<item>If <sym>V</sym> is less than &minus;1 (negative one) or <sym>V</sym> is greater than 1 (one),
then an exception condition is raised: <raise class="22" subclass="02M"/>.
</item>

<item>Otherwise, the result of the <BNF name="trigonometric function"/> is the inverse sine of
<sym>V</sym>.
</item>

</olist>

</item>

<item>If <sym>OP</sym> is <kw>ATAN</kw>, then the result is the inverse tangent of <sym>V</sym>.
</item>

<item>If <sym>OP</sym> is <kw>COS</kw>, then the result is the cosine of <sym>V</sym>.
</item>

<item>If <sym>OP</sym> is <kw>COSH</kw>, then the result is the hyperbolic cosine of <sym>V</sym>.
</item>

<item>If <sym>OP</sym> is <kw>SIN</kw>, then the result is the sine of <sym>V</sym>.
</item>

<item>If <sym>OP</sym> is <kw>SINH</kw>, then the result is the hyperbolic sine of <sym>V</sym>.
</item>

<item>If <sym>OP</sym> is <kw>TAN</kw>, then the result is the tangent of <sym>V</sym>.
</item>

<item>If <sym>OP</sym> is <kw>TANH</kw>, then the result is the hyperbolic tangent of <sym>V</sym>.
</item>

<item>If <sym>OP</sym> is <kw>COT</kw>, then the result is the cotangent of <sym>V</sym>.
</item>

<item>If <sym>OP</sym> is <kw>DEGREES</kw>, then the result is the value of <sym>V</sym>, taken to
be in radians, expressed as degrees.
</item>

<item>If <sym>OP</sym> is <kw>RADIANS</kw>, then the result is the value of <sym>V</sym>, taken to
be in degrees, expressed as radians.
</item>

</olist>

</item>

</olist>

</item>

<comment>Editorial: Stefan Plantikow, 2023-06-02 Use result of</comment>
<item>If <BNF name="general logarithm function"/> is specified, then let <symdef>VB</symdef> be
the result of the <BNF name="general logarithm base"/> and let <symdef>VA</symdef> be the result of
the <BNF name="general logarithm argument"/>.

<para>Case:
</para>

<olist>

<item>If at least one of <sym>VA</sym> and <sym>VB</sym> is the null value, then the result is the
null value.
</item>

<comment>WG3:POS-017R1</comment>
<item>If <sym>VA</sym> is negative or 0 (zero), then an exception condition is raised:
<raise class="22" subclass="01Z"/>.
</item>

<comment>WG3:POS-017R1</comment>
<item>If <sym>VB</sym> is negative, 0 (zero), or 1 (one), then an exception condition is raised:
<raise class="22" subclass="01Z"/>.
</item>

<item>Otherwise, the result is the logarithm with base <sym>VB</sym> of <sym>VA</sym>.
</item>

</olist>

</item>

<comment>Remark Karl Schendel regarding simply contains (see SXM001 item 13.2)</comment>
<comment>Editorial: Stefan Plantikow, 2023-06-02 Use result of</comment>
<item>If <BNF name="natural logarithm"/> is specified, then let <symdef>V</symdef> be the result of
the immediately contained <BNF name="numeric value expression"/>.

<para>Case:
</para>

<olist>

<item>If <sym>V</sym> is the null value, then the result is the null value.
</item>

<item>If <sym>V</sym> is 0 (zero) or negative, then an exception condition is raised:
<raise class="22" subclass="01E"/>.
</item>

<item>Otherwise, the result is the natural logarithm of <sym>V</sym>.
</item>

</olist>

</item>

<comment>Remark Karl Schendel regarding simply contains (see SXM001 item 13.2)</comment>
<item>If <BNF name="exponential function"/> is specified, then let <symdef>V</symdef> be the 
result of the immediately contained <BNF name="numeric value expression"/>.

<para>Case:
</para>

<olist>

<item>If <sym>V</sym> is the null value, then the result is the null value.
</item>

<item>Otherwise, the result is <symdef>e</symdef> (the base of natural logarithms) raised to the 
power <sym>V</sym>.
If the result is not representable in the declared type of the result, then an exception condition
is raised: <raise class="22" subclass="003"/>.
</item>

</olist>

</item>

<comment>Editorial: Stefan Plantikow, 2023-06-02 Use result of</comment>
<item>If <BNF name="power function"/> is specified, then let <symdef>NVEB</symdef> be the
<BNF name="numeric value expression base"/>, then let <symdef>VB</symdef> be the result of
<sym>NVEB</sym>, let <symdef>NVEE</symdef> be the <BNF name="numeric value expression exponent"/>,
and let <symdef>VE</symdef> be the result of <sym>NVEE</sym>.

<para>Case:
</para>

<olist>

<item>If at least one of <sym>VB</sym> and <sym>VE</sym> is the null value, then the result is the
null value.
</item>

<item>If <sym>VB</sym> is 0 (zero) and <sym>VE</sym> is negative, then an exception condition is
raised: <raise class="22" subclass="01F"/>.
</item>

<item>If <sym>VB</sym> is 0 (zero) and <sym>VE</sym> is 0 (zero), then the result is 1 (one).
</item>

<item>If <sym>VB</sym> is 0 (zero) and <sym>VE</sym> is positive, then the result is 0 (zero).
</item>

<item>If <sym>VB</sym> is negative and <sym>VE</sym> is not equal to an exact numeric value with
scale 0 (zero), then an exception condition is raised: <raise class="22" subclass="01F"/>.
</item>

<item>If <sym>VB</sym> is negative and <sym>VE</sym> is equal to an exact numeric value with scale
0 (zero) that is an even number, then the result is the result of:

<code>
<kw>EXP</kw>(<sym>NVEE</sym>*<kw>LN</kw>(&minus;<sym>NVEB</sym>))
</code>

</item>

<item>If <sym>VB</sym> is negative and <sym>VE</sym> is equal to an exact numeric value with scale
0 (zero) that is an odd number, then the result is the result of:

<code>
&minus;<kw>EXP</kw>(<sym>NVEE</sym>*<kw>LN</kw>(&minus;<sym>NVEB</sym>))
</code>

</item>

<item>Otherwise, the result is the result of:

<code>
<kw>EXP</kw>(<sym>NVEE</sym>*<kw>LN</kw>(<sym>NVEB</sym>))
</code>

</item>

</olist>

</item>

<comment>Remark Karl Schendel regarding simply contains (see SXM001 item 13.2)</comment>
<item>If <BNF name="floor function"/> is specified, then let <symdef>V</symdef> be the result of the
immediately contained <BNF name="numeric value expression"/> <sym>NVE</sym>.

<para>Case:
</para>

<olist>

<item>If <sym>V</sym> is the null value, then the result is the null value.
</item>

<item>Otherwise,

<para>Case:
</para>

<olist>

<comment>WG3:UTC-015</comment>
<item>If the declared type of <sym>NVE</sym> is exact numeric, then the result is the
greatest exact numeric value with scale 0 (zero) that is less than or equal to <sym>V</sym>.
If this result is not representable by the declared type of the result, then an exception
condition is raised: <raise class="22" subclass="003"/>.
</item>

<item>Otherwise, the result is the greatest whole number that is less than or equal to 
<sym>V</sym>.
If this result is not representable by the declared type of the result, then an exception
condition is raised: <raise class="22" subclass="003"/>.
</item>

</olist>

</item>

</olist>

</item>

<comment>Remark Karl Schendel regarding simply contains (see SXM001 item 13.2)</comment>
<item>If <BNF name="ceiling function"/> is specified, then let <symdef>V</symdef> be the 
result of the immediately contained <BNF name="numeric value expression"/> <sym>NVE</sym>.

<para>Case:
</para>

<olist>

<item>If <sym>V</sym> is the null value, then the result is the null value.
</item>

<item>Otherwise,

<para>Case:
</para>

<olist>

<comment>WG3:UTC-015</comment>
<item>If the declared type of <sym>NVE</sym> is exact numeric, then the result is the least
exact numeric value with scale 0 (zero) that is greater than or equal to <sym>V</sym>.
If this result is not representable by the declared type of the result, then an exception
condition is raised: <raise class="22" subclass="003"/>.
</item>

<item>Otherwise, the result is the least whole number that is greater than or equal to 
<sym>V</sym>.
If this result is not representable by the declared type of the result, then an exception
condition is raised: <raise class="22" subclass="003"/>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:POS-011R1</comment>
<item>If <BNF name="vector dimension count"/> <symdef>VDC</symdef> is specified, then

<para>Case:
</para>

<olist>

<comment>WG3:POS-011R1</comment>
<item>If the <BNF name="vector value expression"/> simply contained in <sym>VDC</sym> is
the null value, then the result of <sym>VDC</sym> is the null value.
</item>

<comment>WG3:POS-011R1</comment>
<item>Otherwise, the result of <sym>VDC</sym> is the dimension of
the declared type of the <BNF name="vector value expression"/> simply contained in <sym>VDC</sym>.
</item>

</olist>

</item>


</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W24-030</comment>
<item>Without <feature code="GF01"/>, conforming GQL language shall not contain 
an <BNF name="absolute value expression"/>, a <BNF name="modulus expression"/>, 
a <BNF name="floor function"/>, a <BNF name="ceiling function"/>, or a <BNF name="square root"/>.
</item>

<comment>WG3:W24-030</comment>
<item>Without <feature code="GF02"/>, conforming GQL language shall not contain 
a <BNF name="trigonometric function"/>.
</item>

<comment>WG3:W24-030</comment>
<item>Without <feature code="GF03"/>, conforming GQL language shall not contain 
a <BNF name="general logarithm function"/>, a <BNF name="common logarithm"/>, 
a <BNF name="natural logarithm"/>, an <BNF name="exponential function"/>, or 
a <BNF name="power function"/>.
</item>

<comment>WG3:CMN-019 P00-USA-136</comment>
<item>Without <feature code="GV35"/>, conforming GQL language shall not contain
a <BNF name="byte length expression"/>.
</item>

<comment>WG3:W24-030</comment>
<comment>WG3:W24-035R1</comment>
<item>Without <feature code="GF04"/>, conforming GQL language shall not contain 
a <BNF name="path length expression"/>.
</item>

<comment>WG3:CMN-068</comment>
<item>Without <feature code="GF12"/>, conforming GQL language shall not contain 
a <BNF name="cardinality expression"/> that immediately contains <kw>CARDINALITY</kw>.
</item>

<comment>WG3:CMN-068</comment>
<item>Without <feature code="GF13"/>, conforming GQL language shall not contain 
a <BNF name="cardinality expression"/> that immediately contains <kw>SIZE</kw>.
</item>

<comment>WG3:POS-011R1</comment>
<item>Without <feature code="GV42"/>, conforming GQL language shall not contain
a <BNF name="vector dimension count"/>.
</item>


</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_vecdistfunc" newpage="true">
<clauseHeading><BNF name="vector distance function"/></clauseHeading>

<bodyMatter>

<comment>WG3:POS-011R1</comment>
<Function>

<comment>WG3:POS-011R1</comment>
<para>Determine the distance between two vectors.
</para>

</Function>

<Format>

<grammar>

<comment>WG3:POS-011R1</comment>
<BNFdef name="vector distance function">
<rhs>
<kw>VECTOR_DISTANCE</kw>
<breakindent/>
<BNF name="left paren"/>
<BNF name="vector 1"/>
<BNF name="comma"/>
<BNF name="vector 2"/>
<BNF name="vector distance metric"/>
<BNF name="right paren"/>
</rhs>
</BNFdef>

<comment>WG3:POS-011R1</comment>
<BNFdef name="vector 1">
<rhs>
<BNF name="vector value expression"/>
</rhs>
</BNFdef>

<comment>WG3:POS-011R1</comment>
<BNFdef name="vector 2">
<rhs>
<BNF name="vector value expression"/>
</rhs>
</BNFdef>

<comment>WG3:POS-011R1</comment>
<BNFdef name="vector distance metric">
<rhs>
<alt><kw>EUCLIDEAN</kw></alt>
<alt><kw>EUCLIDEAN_SQUARED</kw></alt>
<alt><kw>MANHATTAN</kw></alt>
<alt><kw>COSINE</kw></alt>
<alt><kw>DOT</kw></alt>
<alt><kw>HAMMING</kw></alt>
</rhs>
</BNFdef>

</grammar>

<comment>WG3:POS-011R1</comment>
<ednote id="PPgql433_1">Support for additional <BNF name="vector distance function"/> metrics,
like Jaccard, could be added.
See <PPref ref="PPgql433"/>.
</ednote>

</Format>

<SyntaxRules>

<olist>

<comment>WG3:POS-011R1</comment>
<item>Let <symdef>VDF</symdef> be the <BNF name="vector distance function"/>.
The declared type of <sym>VDF</sym> is an <impDef code="IV250"/> approximate numeric type.
Let <symdef>RDT</symdef> be that declared type.
</item>

<comment>WG3:POS-011R1</comment>
<item>The declared type of the <BNF name="vector value expression"/> immediately contained in
<BNF name="vector 1"/> of <sym>VDF</sym> shall be the same as the declared type of
the <BNF name="vector value expression"/> immediately contained in
<BNF name="vector 2"/> of <sym>VDF</sym>.
</item>

</olist>

</SyntaxRules>

<GeneralRules>

<olist>

<comment>WG3:POS-011R1</comment>
<item>Let <symdef>V1</symdef> and <symdef>V2</symdef> be the results of <BNF name="vector 1"/> and
<BNF name="vector 2"/>, respectively, that are immediately contained in <sym>VDF</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>If, during the computation of the result of <sym>VDF</sym>, an intermediate result is not
representable in the declared type of the site that contains that intermediate result, then
an exception condition is raised: <raise class="22" subclass="003"/>.
</item>

<comment>WG3:POS-011R1</comment>
<item>The result of <sym>VDF</sym> is determined as follows.

<olist>

<comment>WG3:POS-011R1</comment>
<item>If <sym>V1</sym> or <sym>V2</sym> is the null value, then the result is the null value and
no further General Rules of this Subclause are applied.
</item>

<comment>WG3:POS-011R1</comment>
<item>Let <symdef>D</symdef> be the dimension of <sym>V1</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>Let <symdef>A</symdef><sub><sym>i</sym></sub>, 1 (one) <leq/> <symdef>i</symdef> <leq/> D,
be the <sym>i</sym>-th coordinate of <sym>V1</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>Let <symdef>B</symdef><sub><sym>i</sym></sub>, 1 (one) <leq/> <symdef>i</symdef> <leq/> D,
be the <sym>i</sym>-th coordinate of <sym>V2</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>Let <symdef>DM</symdef> be the <BNF name="vector distance metric"/> immediately contained in
<sym>VDF</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>Let <symdef>R</symdef> be determined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:POS-011R1</comment>
<item>If <sym>DM</sym> is <kw>EUCLIDEAN</kw>, then <sym>R</sym> is

<inlineEquation>
<asciimath>sqrt (sum_(i=1)^D (A_i &minus; B_i)^2)</asciimath>
</inlineEquation>.

</item>

<comment>WG3:POS-011R1</comment>
<item>If <sym>DM</sym> is <kw>EUCLIDEAN_SQUARED</kw>, then <sym>R</sym> is

<inlineEquation>
<asciimath>sum_(i=1)^D (A_i &minus; B_i)^2</asciimath>
</inlineEquation>.

</item>

<comment>WG3:POS-011R1</comment>
<item>If <sym>DM</sym> is <kw>MANHATTAN</kw>, then <sym>R</sym> is

<inlineEquation>
<asciimath>sum_(i=1)^D abs (A_i &minus; B_i)</asciimath>
</inlineEquation>.

</item>

<comment>WG3:POS-011R1</comment>
<item>If <sym>DM</sym> is <kw>COSINE</kw>, then <sym>R</sym> is

<inlineEquation>
<asciimath>1 - (sum_(i=1)^D (A_i * B_i)) /
(sqrt (sum_(i=1)^D (A_i^2)) * sqrt (sum_(i=1)^D (B_i^2)))
</asciimath>
</inlineEquation>.

</item>

<comment>WG3:POS-011R1</comment>
<item>If <sym>DM</sym> is <kw>DOT</kw>, then <sym>R</sym> is

<bar note="Email from: Keith Hare, 21-05-2025 1340"/>
<comment>Keith Hare, 21-05-2025 1341</comment>
<inlineEquation>
<asciimath>&minus; sum_(i=1)^D (A_i * B_i)</asciimath>
</inlineEquation>

</item>
<endbar/>

<comment>WG3:POS-011R1</comment>
<item>Otherwise, <sym>DM</sym> is <kw>HAMMING</kw> and <sym>R</sym> is
the number of coordinates in which <sym>V1</sym> and <sym>V2</sym> differ.
</item>

</olist>

</item>

<comment>WG3:POS-011R1</comment>
<item>The result of <sym>VDF</sym> is the result of
<kw>CAST</kw> ( <sym>R</sym> <kw>AS</kw> <sym>RDT</sym> ).
</item>

</olist>

</item>

</olist>

</GeneralRules>

<ConformanceRules>

<olist>

<comment>WG3:POS-011R1</comment>
<item>Without <feature code="GV42"/>, conforming GQL language shall not contain
a <BNF name="vector distance function"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_vecnormfunc" newpage="true">
<clauseHeading><BNF name="vector norm function"/></clauseHeading>

<bodyMatter>

<comment>WG3:POS-011R1</comment>
<Function>

<comment>WG3:POS-011R1</comment>
<para>Determine the distance between a vector and the zero vector.
</para>

</Function>

<Format>

<grammar>

<comment>WG3:POS-011R1</comment>
<BNFdef name="vector norm function">
<rhs>
<kw>VECTOR_NORM</kw>
<breakindent/>
<BNF name="left paren"/>
<BNF name="vector value expression"/>
<BNF name="comma"/>
<BNF name="vector norm metric"/>
<BNF name="right paren"/>
</rhs>
</BNFdef>

<comment>WG3:POS-011R1</comment>
<BNFdef name="vector norm metric">
<rhs>
<alt><kw>EUCLIDEAN</kw></alt>
<alt><kw>MANHATTAN</kw></alt>
</rhs>
</BNFdef>

</grammar>

</Format>

<SyntaxRules>

<olist>

<comment>WG3:POS-011R1</comment>
<item>Let <symdef>VNF</symdef> be the <BNF name="vector norm function"/>.
The declared type of <sym>VNF</sym> is an <impDef code="IV250"/> approximate numeric type.
Let <symdef>RDT</symdef> be that declared type.
</item>

</olist>

</SyntaxRules>

<GeneralRules>

<olist>

<comment>WG3:POS-011R1</comment>
<item>Let <symdef>V</symdef> be the result of the <BNF name="vector value expression"/>
immediately contained in <sym>VNF</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>If, during the computation of the result of <sym>VNF</sym>, an intermediate result is not
representable in the declared type of the site that contains that intermediate result, then
an exception condition is raised: <raise class="22" subclass="003"/>.
</item>

<comment>WG3:POS-011R1</comment>
<item>The result of <sym>VNF</sym> is determined as follows.

<olist>

<comment>WG3:POS-011R1</comment>
<item>If <sym>V</sym> is the null value, then the result is the null value and
no further General Rules of this Subclause are applied.
</item>

<comment>WG3:POS-011R1</comment>
<item>Let <symdef>D</symdef> be the dimension of <sym>V</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>Let <symdef>C</symdef><sub><sym>i</sym></sub>, 1 (one) <leq/> <symdef>i</symdef> <leq/> D,
be the <sym>i</sym>-th coordinate of <sym>V</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>Let <symdef>NM</symdef> be the <BNF name="vector norm metric"/> immediately contained in
<sym>VNF</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>Let <symdef>R</symdef> be determined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:POS-011R1</comment>
<item>If <sym>NM</sym> is <kw>EUCLIDEAN</kw>, then <sym>R</sym> is

<inlineEquation>
<asciimath>sqrt (sum_(i=1)^D (A_i)^2)</asciimath>
</inlineEquation>.

</item>

<comment>WG3:POS-011R1</comment>
<item>Otherwise, <sym>NM</sym> is <kw>MANHATTAN</kw> and <sym>R</sym> is

<inlineEquation>
<asciimath>sum_(i=1)^D abs (A_i)</asciimath>
</inlineEquation>.

</item>

</olist>

</item>

<comment>WG3:POS-011R1</comment>
<item>The result of <sym>VNF</sym> is the result of
<kw>CAST</kw> ( <sym>R</sym> <kw>AS</kw> <sym>RDT</sym> ).
</item>

</olist>

</item>

</olist>

</GeneralRules>

<ConformanceRules>

<olist>

<comment>WG3:POS-011R1</comment>
<item>Without <feature code="GV42"/>, conforming GQL language shall not contain
a <BNF name="vector norm function"/>.
</item>

</olist>

</ConformanceRules>


</bodyMatter>

</subClause>


<subClause id="gql_string" newpage="true">
<clauseHeading><BNF name="string value expression"/></clauseHeading>

<bodyMatter>


<Function>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19 consistent use of "byte string"</comment>
<para>Specify a character string value or a byte string value.
</para>

</Function>


<Format>

<grammar>

<comment>consistent use of "* string": Stefan Plantikow, 2021-06-23</comment>
<BNFdef name="string value expression">
<rhs>
<alt> <BNF name="character string value expression"/> </alt>
<alt> <BNF name="byte string value expression"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:CMN-048</comment>
<BNFdef name="character string value expression">
<rhs>
<alt> <BNF name="character string concatenation"/> </alt>
<alt> <BNF name="character string primary"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:JCJ-010R1</comment>
<comment>WG3:CMN-048</comment>
<BNFdef name="character string concatenation">
<rhs>
<BNF name="character string value expression"/> <BNF name="concatenation operator"/>
<BNF name="character string primary"/>
</rhs>
</BNFdef>

<comment>WG3:CMN-048 Removed 1 (one) production</comment>

<comment>WG3:CMN-053</comment>
<BNFdef name="character string primary">
<rhs>
<alt> <BNF name="value expression primary"/> </alt>
<alt> <BNF name="character string function"/> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2021-06-23 consistent use of "byte string"</comment>
<comment>WG3:CMN-048</comment>
<BNFdef name="byte string value expression">
<rhs>
<alt> <BNF name="byte string concatenation"/> </alt>
<alt> <BNF name="byte string primary"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:CMN-048 Removed 1 (one) production</comment>

<comment>WG3:CMN-053</comment>
<BNFdef name="byte string primary">
<rhs>
<alt> <BNF name="value expression primary"/> </alt>
<alt> <BNF name="byte string function"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:CMN-048</comment>
<BNFdef name="byte string concatenation">
<rhs>
<BNF name="byte string value expression"/>
<BNF name="concatenation operator"/> <BNF name="byte string primary"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:BER-094R1</comment>
<comment>WG3:OHD-021</comment>
<comment>Editorial: Stefan Plantikow, 2023-01-05 Correct use of equivalent</comment>
<comment>WG3:UTC-009 P00-USA-169</comment>
<comment>WG3:CMN-048</comment>
<comment>WG3:W26-026R2</comment>
<item>If a <BNF name="character string concatenation"/> <symdef>CSC</symdef> is specified, then
let <symdef>CSVE</symdef> be the <BNF name="character string value expression"/> immediately 
contained in <sym>CSC</sym> and let <symdef>CSF</symdef> be the 
<BNF name="character string primary"/> immediately contained in <sym>CSC</sym>. 
Let <symdef>C1</symdef> be the declared type of <sym>CSVE</sym> and let <symdef>C2</symdef> be 
the declared type of <sym>CSF</sym>. 
Let <symdef>M</symdef> be the length in characters of <sym>C1</sym> plus the length in characters 
of <sym>C2</sym>. 
Let <symdef>VL</symdef> be the <impDef code="IL013"/> maximum length of character strings.

<para>Case:
</para>

<olist>

<item>If either <sym>C1</sym> or <sym>C2</sym> is a variable-length character string type, then 
the declared type <symdef>DTCSC</symdef> of <sym>CSC</sym> is a variable-length character string. 
The minimum length of <sym>DTCSC</sym> is an <impDef code="IL009"/> non-negative exact number that 
is less than or equal to the sum of the minimum lengths of <sym>C1</sym> and <sym>C2</sym>, and 
the maximum length of <sym>DTCSC</sym> is equal to the lesser of <sym>M</sym> and <sym>VL</sym>.
</item>

<item>If both <sym>C1</sym> and <sym>C2</sym> are fixed-length character string types, then 
declared type <symdef>DTCSC</symdef> of <sym>CSC</sym> is a fixed-length character string type. 
The minimum and maximum lengths of <sym>DTCSC</sym> are equal to <sym>M</sym> and 
<sym>M</sym> shall not be greater than <sym>VL</sym>.
</item>

</olist>

</item>

<comment>WG3:BER-094R1</comment>
<item>The declared type of a <BNF name="character string primary"/> shall be 
a character string type.
</item>

<comment>WG3:BER-094R1</comment>
<comment>WG3:OHD-021</comment>
<comment>WG3:CMN-048</comment>
<comment>WG3:W26-026R2</comment>
<item>The declared type <symdef>DTBSC</symdef> of a <BNF name="byte string concatenation"/> 
<symdef>BSC</symdef> is a byte string type.
Let <symdef>BSVE</symdef> be the <BNF name="byte string value expression"/> immediately contained 
in <sym>BSC</sym> and 
let <symdef>BSF</symdef> be the <BNF name="byte string primary"/> immediately contained in 
<sym>BSC</sym>. 
Let <symdef>B1</symdef> be the declared type of <sym>BSVE</sym> and let <symdef>B2</symdef> be 
the declared type of <sym>BSF</sym>. 
Let <symdef>M</symdef> be the length in bytes of <sym>B1</sym> plus the length in bytes of 
<sym>B2</sym>. 
Let <symdef>VL</symdef> be the <impDef code="IL013"/> maximum length of byte strings.

<para>Case:
</para>

<olist>

<comment>WG3:W26-026R2</comment>
<item>If either <sym>B1</sym> or <sym>B2</sym> is a variable-length byte string type, then 
<sym>DTBSC</sym> is a variable-length byte string type. 
The minimum length of <sym>DTBSC</sym> is an <impDef code="IL009"/> non-negative exact number that 
is less than or equal to the sum of the minimum lengths of <sym>B1</sym> and <sym>B2</sym>, and 
the maximum length of <sym>DTBSC</sym> is equal to the lesser of <sym>M</sym> and <sym>VL</sym>.
</item>

<comment>WG3:UTC-009 P00-USA-169</comment>
<item>If both <sym>B1</sym> and <sym>B2</sym> are fixed-length byte string types, then 
<sym>DTBSC</sym> is a fixed-length byte string type.
The minimum and maximum lengths of <sym>DTBSC</sym> are equal to <sym>M</sym> and <sym>M</sym> 
shall not be greater than <sym>VL</sym>.
</item>

</olist>

</item>

<comment>WG3:BER-094R1</comment>
<item>The declared type of a <BNF name="byte string primary"/> shall be a byte string type.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>Editorial: Stefan Plantikow, 2021-06-23 Consistent use of "* string"</comment>
<comment>WG3:OHD-021</comment>
<comment>WG3:CMN-019 P00-USA-137</comment>
<item>If the result of any <BNF name="character string primary"/> or 
<BNF name="byte string primary"/> simply contained in a <BNF name="string value expression"/> is 
the null value, then the result of the <BNF name="string value expression"/> is the null value.
</item>

<comment>Editorial: Stefan Plantikow, 2021-06-23 Consistent use of "* string"</comment>
<item>If <BNF name="character string concatenation"/> is specified, then:

<olist>

<comment>Editorial: Stefan Plantikow, 2023-10-12 Removed 1 (one) Subrule</comment>

<comment>consistent use of "* string": Stefan Plantikow, 2021-06-23</comment>
<comment>WG3:CMN-048</comment>
<item>Let <symdef>S1</symdef> and <symdef>S2</symdef> be the result of the
<BNF name="character string value expression"/> and <BNF name="character string primary"/>,
respectively.

<para>Case:
</para>

<olist>

<comment>consistent use of "* string": Stefan Plantikow, 2021-06-23</comment>
<item>If at least one of <sym>S1</sym> and <sym>S2</sym> is the null value, then the result of the
<BNF name="character string concatenation"/> is the null value.
</item>

<item>Otherwise:

<olist>

<comment>Editorial: Stefan Plantikow, 2021-04-29 Editorial</comment>
<item>Let <symdef>S</symdef> be the character string comprising <sym>S1</sym> followed
by <sym>S2</sym> and let <symdef>M</symdef> be the length of <sym>S</sym>.
</item>

<item><sym>S</sym> is effectively replaced by

<para>Case:
</para>

<olist>

<item>If the <BNF name="search condition"/> <mono><sym>S1</sym> <kw>IS</kw>
<kw>NORMALIZED</kw> <kw>AND</kw> <sym>S2</sym> <kw>IS</kw>
<kw>NORMALIZED</kw></mono> evaluates to <bool>True</bool>, then:

<code>
<kw>NORMALIZE</kw> (<sym>S</sym>)
</code>
</item>

<item>Otherwise, an <impDef code="IW017"/> character string.
</item>

</olist>

</item>

<comment>Editorial: Stephen Cannan, 2022-03-07 WG3:RKE-010 P00-USA-479</comment>
<item>Let <symdef>VL</symdef> be the <impDef code="IL013"/> maximum length of character strings.

<para>Case:
</para>

<olist>

<comment>consistent use of "* string": Stefan Plantikow, 2021-06-23</comment>
<item>If <sym>M</sym> is less than or equal to <sym>VL</sym>, then the result of the
<BNF name="character string concatenation"/> is <sym>S</sym> with length <sym>M</sym>.
</item>

<comment>consistent use of "* string": Stefan Plantikow, 2021-06-23</comment>
<item>If <sym>M</sym> is greater than <sym>VL</sym> and the right-most
<sym>M</sym>&minus;<sym>VL</sym> characters of <sym>S</sym> are all 
<BNF name="truncating whitespace"/> characters, then the result of the 
<BNF name="character string concatenation"/> is the first <sym>VL</sym> characters of <sym>S</sym> 
with length <sym>VL</sym>.
</item>

<item>Otherwise, an exception condition is raised: <raise class="22" subclass="001"/>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<comment>Editorial: Stefan Plantikow, 2021-06-23 Consistent use of "* string"</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-048</comment>
<item>If <BNF name="byte string concatenation"/> is specified, then let <symdef>S1</symdef> and
<sym>S2</sym> be the result of the <BNF name="byte string value expression"/> <symdef>SE1</symdef>
and <BNF name="byte string primary"/> <symdef>SE2</symdef>, respectively.

<para>Case:
</para>

<olist>

<comment>Editorial: Stefan Plantikow, 2021-06-23 Consistent use of "* string"</comment>
<item>If at least one of <sym>S1</sym> and <sym>S2</sym> is the null value, then the result of the
<BNF name="byte string concatenation"/> is the null value.
</item>

<comment>Editorial: Stefan Plantikow, 2021-04-29 Editorial</comment>
<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19</comment>
<comment>Editorial: Stephen Cannan, 2022-03-07 WG3:RKE-010 P00-USA-479</comment>
<comment>WG3:OHD-021</comment>
<item>Otherwise, let <symdef>S</symdef> be the byte string comprising <sym>S1</sym> followed by
<sym>S2</sym>; and let <symdef>M</symdef> be the length in bytes of <sym>S</sym>.

<para>Case:
</para>

<olist>

<comment>WG3:OHD-021</comment>
<comment>WG3:UTC-015</comment>
<item>If the declared type of at least one of <sym>SE1</sym> and <sym>SE2</sym> is 
a variable-length byte string type, then let <symdef>VL</symdef> be the <impDef code="IL013"/>
maximum length of byte strings.

<para>Case:
</para>

<olist>

<comment>Editorial: Stefan Plantikow, 2021-06-23 Consistent use of "* string"</comment>
<item>If <sym>M</sym> is less than or equal to <sym>VL</sym>, then the result of the
<BNF name="byte string concatenation"/> is <sym>S</sym> with length <sym>M</sym>.
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19</comment>
<item>If <sym>M</sym> is greater than <sym>VL</sym> and the right-most
<sym>M</sym>&minus;<sym>VL</sym> bytes of <sym>S</sym> are all X<string>00</string>, then the 
result of the <BNF name="byte string concatenation"/> is the first <sym>VL</sym> bytes of
<sym>S</sym> with length <sym>VL</sym>.
</item>

<item>Otherwise, an exception condition is raised: <raise class="22" subclass="001"/>.
</item>

</olist>

</item>

<comment>WG3:OHD-021</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:UTC-015</comment>
<item>Otherwise, the declared types of both <sym>SE1</sym> and <sym>SE2</sym> are fixed-length byte 
string types, and the result of the <BNF name="byte string concatenation"/> is <sym>S</sym>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_charstrfunc" newpage="true">
<comment>WG3:CMN-053</comment>
<clauseHeading><BNF name="character string function"/></clauseHeading>

<bodyMatter>


<Function>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19</comment>
<comment>WG3:CMN-053</comment>
<para>Specify a function yielding a character string value.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:CMN-053 Removed 1 (one) production</comment>

<comment>WG3:W25-009</comment>
<BNFdef name="character string function">
<rhs>
<alt> <BNF name="substring function"/> </alt>
<alt> <BNF name="fold"/> </alt>
<alt> <BNF name="trim function"/> </alt>
<alt> <BNF name="normalize function"/> </alt>
<comment>WG3:POS-011R1</comment>
<alt> <BNF name="vector serialize"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W25-009</comment>
<BNFdef name="substring function">
<rhs>
<group> <alt br="no"> <kw>LEFT</kw></alt> <alt br="no"><kw>RIGHT</kw></alt> </group>
<linebreak/>
<BNF name="left paren"/>
<BNF name="character string value expression"/> <BNF name="comma"/> <BNF name="string length"/> 
<BNF name="right paren"/> 
</rhs>
</BNFdef>

<comment>Consequence of WG3:W23-014</comment>
<comment>WG3:UTC-043</comment>
<BNFdef name="fold">
<rhs>
<group> <alt br="no"> <kw>UPPER</kw> </alt> <alt br="no"> <kw>LOWER</kw> </alt> </group>
<BNF name="left paren"/> <BNF name="character string value expression"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2021-06-23 consistent use of "* string"</comment>
<comment>Consequence of WG3:W23-014</comment>
<comment>WG3:UTC-090R1</comment>
<BNFdef name="trim function">
<rhs>
<alt> <BNF name="single-character trim function"/> </alt>
<alt> <BNF name="multi-character trim function"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-090R1</comment>
<BNFdef name="single-character trim function">
<rhs>
<kw>TRIM</kw> <BNF name="left paren"/> <BNF name="trim operands"/> <BNF name="right paren"/> 
</rhs>
</BNFdef>

<comment>WG3:UTC-090R1</comment>
<BNFdef name="multi-character trim function">
<rhs>
<group> 
<alt br="no"> <kw>BTRIM</kw> </alt> 
<alt br="no"> <kw>LTRIM</kw> </alt> 
<alt br="no"> <kw>RTRIM</kw> </alt> 
</group>
<linebreak/>
<BNF name="left paren"/> 
<BNF name="trim source"/> <opt> <BNF name="comma"/> <BNF name="trim character string"/> </opt>
<BNF name="right paren"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-090R1</comment>
<BNFdef name="trim operands">
<rhs>
<opt> 
<opt> <BNF name="trim specification"/> </opt> <opt> <BNF name="trim character string"/> </opt> 
<kw>FROM</kw> 
</opt> 
<BNF name="trim source"/>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2021-06-23 consistent use of "* string"</comment>
<BNFdef name="trim source">
<rhs>
<BNF name="character string value expression"/>
</rhs>
</BNFdef>

<BNFdef name="trim specification">
<rhs>
<alt> <kw>LEADING</kw> </alt>
<alt> <kw>TRAILING</kw> </alt>
<alt> <kw>BOTH</kw> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2021-06-23 consistent use of "* string"</comment>
<BNFdef name="trim character string">
<rhs>
<BNF name="character string value expression"/>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2021-06-23 consistent use of "* string"</comment>
<BNFdef name="normalize function">
<rhs>
<kw>NORMALIZE</kw> <BNF name="left paren"/> <BNF name="character string value expression"/>
<breakindent/>
<opt> <BNF name="comma"/> <BNF name="normal form"/> </opt> <BNF name="right paren"/>
</rhs>
</BNFdef>

<BNFdef name="normal form">
<rhs>
<alt> <kw>NFC</kw> </alt>
<alt> <kw>NFD</kw> </alt>
<alt> <kw>NFKC</kw> </alt>
<alt> <kw>NFKD</kw> </alt>
</rhs>
</BNFdef>

<comment>WG3:CMN-053 Removed 7 (seven) productions</comment>

<comment>WG3:UTC-015 Deleted 1 (one) production</comment>
<BNFdef name="string length">
<rhs>
<BNF name="numeric value expression"/>
</rhs>
</BNFdef>

<comment>WG3:POS-011R1</comment>
<BNFdef name="vector serialize">
<rhs>
<kw>VECTOR_SERIALIZE</kw> 
<BNF name="left paren"/> <BNF name="vector value expression"/> <BNF name="right paren"/>
<breakindent/>
<opt><kw>RETURNING</kw> <BNF name="character string type"/></opt>
</rhs>
</BNFdef>

<ednote id="gql_PP032_sql">SQL contains other possibly relevant string value functions such as:

<olist>

<item>OVERLAY for character strings.
</item>

</olist>

See <PPref ref="PPgql032"/>.
</ednote>

<ednote id="gql_PP032_exclude">SQL contains other string value functions that are probably not
relevant such as:

<olist>

<item>CONVERT.
</item>

<item>TRANSLITERATE.
</item>

<item>CLASSIFIER.
</item>

</olist>

<para>Discussion is requires as to whether any of the functions named above should be 
incorporated into GQL.
</para>

<para>See <PPref ref="PPgql032"/>.
</para>
</ednote>

<ednote id="gql_PP032_cypher">Cypher contains other possibly relevant string value functions such
as:

<olist>

<item>replace() - returns a string in which every occurrence of a specified string in the original 
string has been replaced by another (specified) string.
</item>

<item>reverse() - returns a string in which the order of every character in the original string 
have been reversed.
</item>

<item>type() - returns the string representation of the edge label.
Note: that this would need modification for GQL that allows multiple labels on an edge that 
Cypher does not.
</item>

<item>randomUUID() - returns a string value corresponding to a randomly generated UUID.
</item>

</olist>

<para>Discussion is requires as to whether any of the functions named above should be 
incorporated into GQL.
</para>
See <PPref ref="PPgql032"/>.
</ednote>

<comment>WG3:CMN-024</comment>
<ednote id="gql_PP366">Support for better handling of whitespace in trim functions should be
considered.

See <PPref ref="PPgql366"/>.
</ednote>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:W25-009</comment>
<item>If <BNF name="substring function"/> is specified, then the declared type of the result is 
the declared type of the immediately contained <BNF name="character string value expression"/>.
</item>

<comment>WG3:UTC-090R1</comment>
<item>If <BNF name="fold"/> is specified, then the declared type of the result is the 
declared type of the immediately contained <BNF name="character string value expression"/>.
</item>

<comment>WG3:UTC-090R1</comment>
<item>If the <BNF name="single-character trim function"/> <symdef>SCTF</symdef> is specified, then:

<olist>

<item>The declared type of the result is the declared type of the <BNF name="trim source"/>
simply contained in <sym>SCTF</sym>.
</item>

<item>Case:

<olist>

<item>If <kw>FROM</kw> is specified, then:

<olist>

<item>At least one of <BNF name="trim specification"/> and <BNF name="trim character string"/>
shall be specified.
</item>

<comment>WG3:W26-024</comment>
<item>If a <BNF name="trim character string"/> is specified, then 
the declared type of <BNF name="trim character string"/> and 
the declared type of <BNF name="trim source"/> shall be comparable value types.
</item>

<item>If <BNF name="trim specification"/> is not specified, then <kw>BOTH</kw> is implicit.
</item>

<item>If <BNF name="trim character string"/> is not specified, then <BNF name="space"/> is
implicit.
</item>

</olist>

</item>

<item>Otherwise, let <symdef>SRC</symdef> be <BNF name="trim source"/>. 
<kw>TRIM</kw> ( <sym>SRC</sym> ) is equivalent to:

<code>
<kw>TRIM</kw> ( <kw>BOTH</kw> <string> </string> <kw>FROM</kw> <sym>SRC</sym> )
</code>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:UTC-090R1</comment>
<item>If the <BNF name="multi-character trim function"/> <symdef>MCTF</symdef> is specified, then:

<olist>

<item>The declared type of the result is the declared type of the <BNF name="trim source"/> 
<symdef>TS</symdef> immediately contained in <sym>MCTF</sym>.
</item>

<item>Case:

<olist>

<comment>WG3:W26-024</comment>
<item>If a <BNF name="trim character string"/> <symdef>TC</symdef> is specified, then 
the declared type of <sym>TS</sym> and the declared type of <sym>TC</sym> shall be comparable
value types.
</item>

<item>Otherwise, let <symdef>TC</symdef> be <BNF name="space"/>.
</item>

</olist>

</item>

<item>If <kw>BTRIM</kw> is specified, then <kw>BTRIM</kw> ( <sym>TS</sym> ) is equivalent to:

<code>
<kw>RTRIM</kw> ( <kw>LTRIM</kw> ( <sym>TS</sym> ) )
</code>

</item>

</olist>

</item>

<comment>WG3:UTC-090R1</comment>
<item>If <BNF name="normalize function"/> is specified, then

<olist>

<comment>WG3:W26-026R2</comment>
<item>The declared type of the result is the declared type of the 
<BNF name="character string value expression"/> simply contained in the 
<BNF name="normalize function"/>.
</item>

<item>Case:

<olist>

<item>If <BNF name="normal form"/> is specified, then let <symdef>NF</symdef> be
<BNF name="normal form"/>.
</item>

<item>Otherwise, let <symdef>NF</symdef> be <kw>NFC</kw>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:CMN-053 Removed 2 (two) Syntax Rules</comment>

<bar note="Email from: Keith Hare, 2025-04-01 2054"/>
<comment>Email from: Keith Hare, 2025-04-01 2054</comment>
<comment>WG3:POS-011R1</comment>
<item>If <BNF name="vector serialize"/> is specified, then

<para>Case:
</para>

<olist>

<comment>WG3:POS-011R1</comment>
<item>If <kw>RETURNING</kw> is not specified, then the declared type of
<BNF name="vector serialize"/> is a variable-length character string with
<impDef code="IL073"/> maximum length.
</item>

<comment>WG3:POS-011R1</comment>
<item>Otherwise, the declared type of <BNF name="vector serialize"/> is
the <BNF name="character string type"/> immediately contained in <BNF name="vector serialize"/>.
</item>

</olist>

</item>
<endbar/>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:W25-009</comment>
<item>If <BNF name="substring function"/> <symdef>SF</symdef> is specified, then:

<olist>

<comment>Editorial: Stefan Plantikow, 2023-06-02 Use result of</comment>
<item>Let <symdef>CSVE</symdef> be the result of the immediately contained 
<BNF name="character string value expression"/>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-06-02 Use result of</comment>
<item>Let <symdef>SL</symdef> be the result of the immediately contained 
<BNF name="string length"/>.
</item>

<item>If at least one of <sym>CSVE</sym> and <sym>SL</sym> is the null value, then 
the result of <sym>SF</sym> is the null value and no further General Rules of this Subclause 
are applied.
</item>

<item>If <sym>SL</sym> is less than 0 (zero), then an exception condition is raised: 
<raise class="22" subclass="011"/>.
</item>

<item>Let <symdef>LC</symdef> be the length in characters of <sym>CSVE</sym>. 
If <sym>SL</sym> is greater than <sym>LC</sym>, then let <symdef>NC</symdef> be <sym>LC</sym>; 
otherwise, let <symdef>NC</symdef> be <sym>SL</sym>.
</item>

<item>Case:

<olist>

<item>If <sym>NC</sym> is 0 (zero), then the result of <sym>SF</sym> is the 
zero-length character string.
</item>

<item>If <kw>LEFT</kw> is specified, then the result of <sym>SF</sym> is the character string 
containing the first <sym>NC</sym> characters of <sym>CSVE</sym>.
</item>

<item>If <kw>RIGHT</kw> is specified, then the result of <sym>SF</sym> is the character string 
containing the last <sym>NC</sym> characters of <sym>CSVE</sym>.
</item>

</olist>

</item>

</olist>

</item>

<item>If <BNF name="normalize function"/> is specified, then:

<olist>

<comment>Editorial: Stefan Plantikow, 2021-06-23 consistent use of "character string"</comment>
<item>Let <symdef>S</symdef> be the result of <BNF name="character string value expression"/>.
</item>

<item>If <sym>S</sym> is the null value, then the result of the <BNF name="normalize function"/>
is the null value.
</item>

<comment>WG3:CMN-032</comment>
<item>Let <symdef>NR</symdef> be <sym>S</sym> in the normalization form specified by <sym>NF</sym> 
in accordance with <docref ref="Unicode15"/>.
</item>

<comment>Editorial: Stefan Plantikow, 2022-05-03 Fuse rules</comment>
<comment>WG3:W23-009R1 P00-USA-421</comment>
<item>If the length in characters of <sym>NR</sym> is less than or equal to the 
<impDef code="IL013"/> maximum length of a character string, then the result of the 
<BNF name="normalize function"/> is <sym>NR</sym>; otherwise, an exception condition is raised: 
<raise class="22" subclass="001"/>.
</item>

</olist>

</item>

<item>If <BNF name="fold"/> is specified, then:

<olist>

<comment>Editorial: Stefan Plantikow, 2021-06-23 consistent use of "character string"</comment>
<item>Let <symdef>S</symdef> be the result of the <BNF name="character string value expression"/>.
</item>

<item>If <sym>S</sym> is the null value, then the result of the <BNF name="fold"/> is the null
value.
</item>

<item>Case:

<olist>

<item>If <kw>UPPER</kw> is specified, then let <symdef>FR</symdef> be a copy of <sym>S</sym> in
which every lower-case character that has a corresponding upper-case character or characters and
every title case character that has a corresponding upper-case character or characters is replaced
by that upper-case character or characters.
</item>

<item>If <kw>LOWER</kw> is specified, then let <symdef>FR</symdef> be a copy of <sym>S</sym> 
in which every upper-case character that has a corresponding lower-case character or characters 
and every title case character that has a corresponding lower-case character or characters is 
replaced by that lower-case character or characters.
</item>

</olist>

</item>

<item><sym>FR</sym> is effectively replaced by

<para>Case:
</para>

<olist>

<item>If the <BNF name="search condition"/>
<mono><sym>S</sym> <kw>IS</kw> <kw>NORMALIZED</kw></mono> evaluated to <bool>True</bool>, then:

<code>
<kw>NORMALIZE</kw> (<sym>FR</sym>)
</code>

</item>

<item>Otherwise, <sym>FR</sym>.
</item>

</olist>

</item>

<item>Let <symdef>FRL</symdef> be the length in characters of <sym>FR</sym> and 
let <symdef>FRML</symdef> be the <impDef code="IL013"/> maximum length of a character string.
</item>

<item>Case:

<olist>

<item>If <sym>FRL</sym> is less than or equal to <sym>FRML</sym>, then the result of the
<BNF name="fold"/> is <sym>FR</sym>.
</item>

<comment>WG3:CMN-019 P00-USA-141</comment>
<item>Otherwise, the result of the <BNF name="fold"/> is the first <sym>FRML</sym> characters of
<sym>FR</sym>.
If any of the right-most (<sym>FRL</sym> &minus; <sym>FRML</sym>) characters of <sym>FR</sym> are
not <BNF name="truncating whitespace"/> characters, then an exception condition is raised:
<raise class="22" subclass="001"/>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:UTC-090R1</comment>
<comment>WG3:CMN-024</comment>
<item>If the <BNF name="single-character trim function"/> <sym>SCTF</sym> is specified, then:

<olist>

<item>Let <symdef>S</symdef> be the result of the <BNF name="trim source"/>.
</item>

<comment>Editorial: Stephen Cannan, 2021-05-27 Standardize terms</comment>
<comment>Editorial: Stefan Plantikow, 2021-06-23 consistent use of "character string"</comment>
<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10 Standardize terms</comment>
<comment>Editorial: Stefan Plantikow, 2023-06-02 Use result of</comment>
<item>Let <symdef>SC</symdef> be the result of the <BNF name="trim character string"/>.
</item>

<item>If at least one of <sym>S</sym> and <sym>SC</sym> is the null value, then the
result of <sym>SCTF</sym> is the null value and no further General Rules of this Subclause 
are applied.
</item>

<item>If the length in characters of <sym>SC</sym> is not 1 (one), then an exception condition is 
raised: <raise class="22" subclass="027"/>.
</item>

<comment>W26-024</comment>
<item>If <kw>FROM</kw> is specified and <sym>SC</sym> and <sym>S</sym> are not comparable values,
then an exception condition is raised: <raise class="22" subclass="G04"/>.
</item>

<item>Case:

<olist>

<item>If <kw>BOTH</kw> is specified or if no <BNF name="trim specification"/> is specified, then
the result of <sym>SCTF</sym> is the value of <sym>S</sym> with every leading or trailing
character equal to <sym>SC</sym> removed.
</item>

<item>If <kw>TRAILING</kw> is specified, then the result of <sym>SCTF</sym> is the value of 
<sym>S</sym> with every trailing character equal to <sym>SC</sym> removed.
</item>

<item>If <kw>LEADING</kw> is specified, then the result of <sym>SCTF</sym> is the value of 
<sym>S</sym> with every leading character equal to <sym>SC</sym> removed.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:UTC-090R1</comment>
<comment>WG3:CMN-024</comment>
<item>If the <BNF name="multi-character trim function"/> <sym>MCTF</sym> is specified, then:

<olist>

<item>Let <symdef>S</symdef> be the result of the <BNF name="trim source"/>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-06-02 Use result of</comment>
<item>Let <symdef>SC</symdef> be the result of the <BNF name="trim character string"/>.
</item>

<item>If at least one of <sym>S</sym> and <sym>SC</sym> is the null value, then the result of 
<sym>MCTF</sym> is the null value and no further General Rules of this Subclause are applied.
</item>

<item>If <sym>S</sym> is the zero-length character string or <sym>SC</sym> is the zero-length 
character string, then the result of <sym>MCTF</sym> is <sym>S</sym> and no further General Rules 
of this Subclause are applied.
</item>

<comment>W26-024</comment>
<item>If <sym>SC</sym> and <sym>S</sym> are not comparable values, then an exception condition is 
raised: <raise class="22" subclass="G04"/>.
</item>

<item>Case:

<olist>

<item>If <kw>RTRIM</kw> is specified:

<olist>

<item>Let <symdef>P</symdef> be the length in characters of <sym>S</sym>.
</item>

<item>Let <symdef>C</symdef> be the <sym>P</sym>-th character of <sym>S</sym>.
</item>

<item>While <sym>C</sym> is contained in <sym>SC</sym>, do:

<olist>

<item>Let <symdef>P</symdef> be <sym>P</sym> − 1 (one).
</item>

<item>Let <symdef>C</symdef> be the <sym>P</sym>-th character of <sym>S</sym>.
</item>

</olist>

</item>

<item>The result of <sym>MCTF</sym> is a character string containing the first <sym>P</sym>
characters of <sym>S</sym>.
</item>

</olist>

</item>

<item>If <kw>LTRIM</kw> is specified:

<olist>

<item>Let <symdef>P</symdef> be 1 (one).
</item>

<item>Let <symdef>C</symdef> be the <sym>P</sym>-th character of <sym>S</sym>.
</item>

<item>While <sym>C</sym> is contained in <sym>SC</sym>, do:

<olist>

<item>Let <symdef>P</symdef> be <sym>P</sym> + 1 (one).
</item>

<item>Let <symdef>C</symdef> be the <sym>P</sym>-th character of <sym>S</sym>.
</item>

</olist>

</item>

<item>The result of <sym>MCTF</sym> is a character string containing the last <sym>P</sym>
characters of <sym>S</sym>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:CMN-053 Removed 2 (two) General Rules</comment>

<bar note="Email from: Keith Hare, 2025-04-01 2054"/>
<comment>Email from: Keith Hare, 2025-04-01 2054</comment>
<comment>WG3:POS-011R1</comment>
<item>If <BNF name="vector serialize"/> <symdef>VS</symdef> is specified, then:

<olist>

<comment>WG3:POS-011R1</comment>
<item>Let <symdef>VE</symdef> be the <BNF name="vector value expression"/> 
immediately contained in <sym>VS</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>Let <symdef>VV</symdef> be the result of <sym>VE</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>If <sym>VV</sym> is the null value, then the result of <sym>VS</sym> is the null value.
</item>

<comment>WG3:POS-011R1</comment>
<item>Let <symdef>DV</symdef> be the dimension of the declared type of <sym>VE</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>Let <symdef>CT</symdef> be the coordinate type of the declared type of <sym>VE</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>DV</sym>,
let <symdef>C</symdef><sub><sym>i</sym></sub> be
an <impDef code="IV252"/> character string representation of
the <sym>i</sym>-th coordinate of <sym>VV</sym>.
</item>

<comment>WG3:POS-011R1</comment>
<item>Let <symdef>VC</symdef> be a character string of the format
<!-- LINE LENGTH CHECK OFF -->
<squote>[<sym>C</sym><sub>1</sub>,&hairspace;<sym>C</sym><sub>2</sub>,&hairspace;<ellipsis/>,&hairspace;<sym>C</sym><sub><sym>DV</sym></sub>]</squote>.
<!-- LINE LENGTH CHECK ON -->

<comment>WG3:POS-011R1</comment>
<note><sym>VC</sym> does not contain any <BNF name="whitespace"/> characters.
</note>
</item>

<comment>WG3:POS-011R1</comment>
<comment>Email from: Keith Hare, 2025-03-27 1502</comment>
<item>Let <symdef>DT</symdef> be the declared type of <sym>VS</sym>.
</item>

<item>Case:

<olist>

<comment>WG3:POS-011R1</comment>
<item>If the maximum length in characters of <sym>DT</sym> is greater than or equal to the length
in characters of <sym>VC</sym> and the result of
<kw>VECTOR</kw>(<sym>VC</sym>,<sym>DV</sym>,<sym>CT</sym>) is equal to <sym>VV</sym>,
then the result of <sym>VS</sym> is:
<code>
<kw>CAST</kw> ( <sym>VC</sym> <kw>AS</kw> <sym>DT</sym> )
</code>
</item>

<comment>WG3:POS-011R1</comment>
<item>Otherwise, an exception condition is raised: <raise class="22" subclass="001"/>.
</item>

</olist>

</item>

</olist>

</item>
<endbar/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-090R1</comment>
<item>Without <feature code="GF05"/>, conforming GQL language shall not contain 
a <BNF name="multi-character trim function"/>.
</item>

<comment>WG3:UTC-090R1</comment>
<item>Without <feature code="GF06"/>, conforming GQL language shall not contain 
a <BNF name="single-character trim function"/> that simply contains <kw>FROM</kw>.
</item>
<comment>WG3:CMN-053 Removed 1 (one) Conformance Rule</comment>

<bar note="Email from: Keith Hare, 2025-04-01 2054"/>
<comment>Email from: Keith Hare, 2025-04-01 2054</comment>
<comment>WG3:POS-011R1</comment>
<item>Without <feature code="GV42"/>, conforming GQL language shall not contain
a <BNF name="vector serialize"/>.
</item>
<endbar/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:CMN-053</comment>
<subClause id="gql_bytestrfunc" newpage="true">
<clauseHeading><BNF name="byte string function"/></clauseHeading>

<bodyMatter>


<Function>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19</comment>
<comment>WG3:CMN-053</comment>
<para>Specify a function yielding a byte string value.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:W25-009</comment>
<BNFdef name="byte string function">
<rhs>
<alt> <BNF name="byte string substring function"/> </alt>
<alt> <BNF name="byte string trim function"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W25-009</comment>
<BNFdef name="byte string substring function">
<rhs>
<group> <alt br="no"> <kw>LEFT</kw></alt> <alt br="no"><kw>RIGHT</kw></alt> </group>
<linebreak/>
<BNF name="left paren"/> 
<BNF name="byte string value expression"/> <BNF name="comma"/> <BNF name="string length"/>
<BNF name="right paren"/> 
</rhs>
</BNFdef>

<comment>Consequence of WG3:W23-014</comment>
<comment>WG3:UTC-090R1</comment>
<BNFdef name="byte string trim function">
<rhs>
<kw>TRIM</kw> 
<BNF name="left paren"/> <BNF name="byte string trim operands"/> <BNF name="right paren"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-090R1</comment>
<BNFdef name="byte string trim operands">
<rhs>
<opt> 
<opt> <BNF name="trim specification"/> </opt> <opt> <BNF name="trim byte string"/> </opt> 
<kw>FROM</kw> 
</opt> 
<BNF name="byte string trim source"/>
</rhs>
</BNFdef>

<BNFdef name="byte string trim source">
<rhs>
<BNF name="byte string value expression"/>
</rhs>
</BNFdef>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19 octet -> byte</comment>
<BNFdef name="trim byte string">
<rhs>
<BNF name="byte string value expression"/>
</rhs>
</BNFdef>

<ednote id="gql_PP032_bs">Please see the editor notes at the end of the Format of
<specref ref="gql_charstrfunc"/> for additional considerations.

See <PPref ref="PPgql032"/>.
</ednote>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:W25-009</comment>
<item>If <BNF name="byte string substring function"/> is specified, then the declared type of the 
result is a byte string type with maximum length equal to the maximum length of the declared type 
of the immediately contained <BNF name="byte string value expression"/>.
</item>

<comment>WG3:W25-009</comment>
<item>If <BNF name="byte string trim function"/> is specified, then the declared type of the 
result is a byte string type with maximum length equal to the maximum length of the declared type 
of the immediately contained <BNF name="byte string value expression"/>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>


<comment>WG3:W25-009</comment>
<item>If <BNF name="byte string substring function"/> <symdef>BSSF</symdef> is specified, then:

<olist>

<comment>Editorial: Stefan Plantikow, 2023-06-02 result of</comment>
<item>Let <symdef>BSVE</symdef> be the result of the immediately contained 
<BNF name="byte string value expression"/>.
</item>

<item>Let <symdef>BSL</symdef> be the result of the immediately contained 
<BNF name="string length"/>.
</item>

<item>If at least one of <sym>BSVE</sym> and <sym>BSL</sym> is the null value, then 
the result of <sym>BSSF</sym> is the null value and no further General Rules of this Subclause 
are applied.
</item>

<item>If <sym>BSL</sym> is less than 0 (zero), then an exception condition is raised: 
<raise class="22" subclass="011"/>.
</item>

<item>Let <symdef>BSLB</symdef> be the length in bytes of <sym>BSVE</sym>. 
If <sym>BSL</sym> is greater than <sym>BSLB</sym>, then let <symdef>NB</symdef> be <sym>BSLB</sym>; 
otherwise, let <symdef>NB</symdef> be <sym>BSL</sym>.
</item>

<item>Case:

<olist>

<item>If <sym>NB</sym> is 0 (zero), then the result of <sym>BSSF</sym> is the 
zero-length byte string.
</item>

<item>If <kw>LEFT</kw> is specified, then the result of <sym>BSSF</sym> is the byte string 
containing the first <sym>NB</sym> characters of <sym>BSVE</sym>.
</item>

<item>If <kw>RIGHT</kw> is specified, then the result of <sym>BSSF</sym> is the byte string 
containing the last <sym>NB</sym> characters of <sym>BSVE</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>Editorial: Stefan Plantikow, 2021-06-23 consistent use of "byte string"</comment>
<comment>WG3:UTC-090R1</comment>
<item>If <BNF name="byte string trim function"/> <symdef>BSTF</symdef> is specified, then:

<olist>

<item>Let <symdef>S</symdef> be the result of the <BNF name="byte string trim source"/>.
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19 octet -> byte</comment>
<comment>Editorial: Stefan Plantikow, 2023-06-02 Use result of</comment>
<item>Let <symdef>SO</symdef> be the result of <BNF name="trim byte string"/>.
</item>

<item>If at least one of <sym>S</sym> and <sym>SO</sym> is the null value, then the result of
<sym>BSTF</sym> is the null value.
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19 octet -> byte</comment>
<item>If the length in bytes of <sym>SO</sym> is not 1 (one), then an exception condition is
raised: <raise class="22" subclass="027"/>.
</item>

<item>Case:

<olist>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19 octet -> byte</comment>
<item>If <kw>BOTH</kw> is specified or if no <BNF name="trim specification"/> is specified,
then the result of <sym>BSTF</sym> is the value of <sym>S</sym> with any leading or trailing bytes 
equal to <sym>SO</sym> removed.
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19 octet -> byte</comment>
<item>If <kw>TRAILING</kw> is specified, then the result of <sym>BSTF</sym> is the value of 
<sym>S</sym> with any trailing bytes equal to <sym>SO</sym> removed.
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19 octet -> byte</comment>
<item>If <kw>LEADING</kw> is specified, then the result of <sym>BSTF</sym> is the value of 
<sym>S</sym> with any leading bytes equal to <sym>SO</sym> removed.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-090R1</comment>
<item>Without <feature code="GF07"/>, conforming GQL language shall not contain 
a <BNF name="byte string trim function"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_datevalexp" newpage="true">
<clauseHeading><BNF name="datetime value expression"/></clauseHeading>

<bodyMatter>


<Function>

<para>Specify a datetime value.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:CMN-048</comment>
<BNFdef name="datetime value expression">
<rhs>
<alt> <BNF name="datetime primary"/> </alt>
<alt> <BNF name="duration value expression"/> <BNF name="plus sign"/> <BNF name="datetime primary"/>
</alt>
<alt> <BNF name="datetime value expression"/> <BNF name="plus sign"/> <BNF name="duration term"/>
</alt>
<alt> <BNF name="datetime value expression"/> <BNF name="minus sign"/> <BNF name="duration term"/>
</alt>
</rhs>
</BNFdef>

<comment>WG3:CMN-048 Removed 2 (two) productions</comment>

<BNFdef name="datetime primary">
<rhs>
<alt> <BNF name="value expression primary"/> </alt>
<alt> <BNF name="datetime value function"/> </alt>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<comment>WG3:UTC-117 Deleted 1 (one) editor's note</comment>

<olist>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-048</comment>
<item>If the declared type of the simply contained <BNF name="datetime primary"/> is 
a zoned datetime type, then the declared type of <BNF name="datetime value expression"/> is
the zoned datetime type; otherwise, the declared type of <BNF name="datetime value expression"/> is
the local datetime type.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>Email from: Keith Hare, 2021-10-25 2128</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-048</comment>
<item>If the result of a <BNF name="datetime primary"/> is not a temporal instant, then 
an exception condition is raised: <raise class="22" subclass="G03"/>.
</item>

<item>If the result of any <BNF name="datetime primary"/>, <BNF name="duration value expression"/>,
<BNF name="datetime value expression"/>, or <BNF name="duration term"/> simply contained in 
a <BNF name="datetime value expression"/> is the null value, then the result of the
<BNF name="datetime value expression"/> is the null value.
</item>

<item>The result of a <BNF name="datetime primary"/> is the result of the immediately
contained <BNF name="value expression primary"/> or <BNF name="datetime value function"/>.
</item>

<comment>WG3:CMN-019 P00-ISO-033</comment>
<item>If a <BNF name="datetime value expression"/> immediately contains the operator
<BNF name="plus sign"/> or <BNF name="minus sign"/>, then the result is evaluated as specified in
<docref ref="ISO8601-2_2019"/>, 14, <quote>Date and time arithmetic</quote>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:CMN-052R1</comment>
<comment>WG3:POS-020R1</comment>
<item>Without <feature code="GV39"/>, conforming GQL language shall not contain
a <BNF name="datetime value expression"/>.
</item>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-052R1</comment>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_datevalfunc" newpage="true">
<clauseHeading><BNF name="datetime value function"/></clauseHeading>

<bodyMatter>


<Function>

<comment>Editorial: Stefan Plantikow, 2023-06-02 Improve wording</comment>
<para>Specify a function yielding a value of a temporal instant type.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="datetime value function">
<rhs>
<alt> <BNF name="date function"/> </alt>
<alt> <BNF name="time function"/> </alt>
<alt> <BNF name="datetime function"/> </alt>
<alt> <BNF name="localtime function"/> </alt>
<alt> <BNF name="localdatetime function"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="date function">
<rhs>
<alt> <kw>CURRENT_DATE</kw> </alt>
<alt>
<kw>DATE</kw><BNF name="left paren"/> <opt> <BNF name="date function parameters"/> </opt>
<BNF name="right paren"/>
</alt>
</rhs>
</BNFdef>

<BNFdef name="time function">
<rhs>
<alt> <kw>CURRENT_TIME</kw> </alt>
<alt>
<kw>ZONED_TIME</kw><BNF name="left paren"/>
<opt> <BNF name="time function parameters"/> </opt>
<BNF name="right paren"/>
</alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-117</comment>
<BNFdef name="localtime function">
<rhs>
<kw>LOCAL_TIME</kw> 
<opt>
<BNF name="left paren"/> 
<opt> <BNF name="time function parameters"/> </opt>
<BNF name="right paren"/>
</opt>
</rhs>
</BNFdef>

<comment>WG3:UTC-117</comment>
<BNFdef name="datetime function">
<rhs>
<alt> <kw>CURRENT_TIMESTAMP</kw> </alt>
<alt>
<kw>ZONED_DATETIME</kw><BNF name="left paren"/>
<opt> <BNF name="datetime function parameters"/> </opt>
<BNF name="right paren"/>
</alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-117</comment>
<BNFdef name="localdatetime function">
<rhs>
<alt> <kw>LOCAL_TIMESTAMP</kw> </alt>
<alt>
<kw>LOCAL_DATETIME</kw><BNF name="left paren"/> 
<opt> <BNF name="datetime function parameters"/> </opt>
<BNF name="right paren"/>
</alt>
</rhs>
</BNFdef>

<comment>WG3:W22-036</comment>
<BNFdef name="date function parameters">
<rhs>
<alt> <BNF name="date string"/> </alt>
<alt> <BNF name="record constructor"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W22-036</comment>
<BNFdef name="time function parameters">
<rhs>
<alt> <BNF name="time string"/> </alt>
<alt> <BNF name="record constructor"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W22-036</comment>
<BNFdef name="datetime function parameters">
<rhs>
<alt> <BNF name="datetime string"/> </alt>
<alt> <BNF name="record constructor"/> </alt>
</rhs>
</BNFdef>

<ednote id="gql_PP196">Cypher has a raft of datetime functions, some of which may not be already
incorporated into GQL.
These should be checked for suitability of inclusion.
See <PPref ref="PPgql196"/>.
</ednote>

</grammar>

</Format>


<SyntaxRules>

<comment>WG3:UTC-117 Deleted 1 (one) editor's note</comment>

<olist>

<comment>WG3:UTC-117</comment>
<item><kw>CURRENT_DATE</kw> is equivalent to:
<code>
<kw>DATE</kw>()
</code>
</item>

<comment>WG3:UTC-117</comment>
<item><kw>CURRENT_TIME</kw> is equivalent to:
<code>
<kw>ZONED_TIME</kw>()
</code>
</item>

<comment>WG3:UTC-117</comment>
<item><kw>LOCAL_TIME</kw> is equivalent to:
<code>
<kw>LOCAL_TIME</kw>()
</code>
</item>

<comment>WG3:UTC-117</comment>
<item><kw>CURRENT_TIMESTAMP</kw> is equivalent to:
<code>
<kw>ZONED_DATETIME</kw>()
</code>
</item>

<comment>WG3:UTC-117</comment>
<item><kw>LOCAL_TIMESTAMP</kw> is equivalent to:
<code>
<kw>LOCAL_DATETIME</kw>()
</code>
</item>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-048</comment>
<item>The declared type of a <BNF name="date function"/> is the date type.
</item>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-048</comment>
<item>The declared type of a <BNF name="time function"/> is the zoned time type.
</item>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-048</comment>
<item>The declared type of a <BNF name="datetime function"/> is the zoned datetime type.
</item>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-048</comment>
<item>The declared type of a <BNF name="localtime function"/> is the local time type.
</item>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-048</comment>
<item>The declared type of a <BNF name="localdatetime function"/> is the local datetime type.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:UTC-117 Deleted 1 (one) GR</comment>

<comment>WG3:UTC-132</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<comment>WG3:CMN-019 P00-NLD-056</comment>
<item>If the current request timestamp is <quote>not set</quote>, then the current request 
timestamp is set to the current date and time at an <unDef code="US009"/> point in time before 
the evaluation of a <BNF name="datetime value function"/>.

<note>This can happen at any <unDef code="US009"/> point in time after the setting of
the request timestamp to <quote>not set</quote>; the determination of the request timestamp need
not wait for evaluation of a <BNF name="datetime value function"/>.
</note>
</item>

<comment>WG3:W22-036</comment>
<item>If the set of <BNF name="field name"/>s simply contained in
a <BNF name="date function parameters"/> is not one of:

<olist>

<item><string>year</string>
</item>

<item><string>year</string> and <string>month</string>
</item>

<item><string>year</string>, <string>month</string>, and <string>day</string>
</item>

<comment>WG3:CMN-048 Removed 3 (three) items</comment>

</olist>

<para>then an exception is raised: <raise class="22" subclass="G05"/>.
</para>

</item>

<comment>WG3:W22-036</comment>
<item>If the set of <BNF name="field name"/>s simply contained in
a <BNF name="time function parameters"/> is not one of:

<olist>

<item><string>hour</string>
</item>

<item><string>hour</string> and <string>minute</string>
</item>

<item><string>hour</string>, <string>minute</string>, and <string>second</string>
</item>

<comment>WG3:UTC-117 Deleted 2 duplicate items</comment>

<comment>WG3:CMN-048</comment>
<item><string>hour</string>, <string>minute</string>, <string>second</string> and one of
<string>millisecond</string>, <string>microsecond</string>, and <string>nanosecond</string>.
</item>

<comment>WG3:CMN-048 Removed 1 (one) item</comment>

<comment>WG3:CMN-048</comment>
<item><string>timezone</string>, if <BNF name="time function parameters"/> is simply contained in
a <BNF name="time function"/>.
</item>

</olist>

<para>then an exception is raised: <raise class="22" subclass="G05"/>.
</para>

</item>

<comment>WG3:W22-036</comment>
<item>If the set of <BNF name="field name"/>s contained in 
a <BNF name="datetime function parameters"/> is not one of:

<olist>

<comment>WG3:W22-036</comment>
<item><string>year</string>, <string>month</string>, <string>day</string>, and any of the set of
<BNF name="field name"/>s permitted in a <BNF name="time function parameters"/>.
</item>

<comment>WG3:CMN-048 Removed 3 (three) items</comment>

<comment>WG3:CMN-048</comment>
<item><string>timezone</string>, if <BNF name="datetime function parameters"/> is simply contained
in a <BNF name="datetime function"/>.
</item>

</olist>

<para>then an exception is raised: <raise class="22" subclass="G05"/>.
</para>

</item>

<comment>Editorial: Stefan Plantikow, 2023-02-21 Deleted GR WG3:UTC-117 made obsolete</comment>

<comment>WG3:W22-036</comment>
<comment>WG3:UTC-117</comment>
<comment>Editorial: Stefan Plantikow, 2023-06-02 Use result of</comment>
<comment>WG3:CMN-048</comment>
<item>If the result of each <BNF name="value expression"/> associated with
the <BNF name="field name"/> <string>millisecond</string> is not between 0 (zero) and 999, or
the value associated with <string>microsecond</string>, not between 0 (zero) and 999999 and
the value for <string>nanosecond</string> not between 0 (zero) and 999999999, or, if more than
one of <string>millisecond</string>, <string>microsecond</string>, and <string>nanosecond</string>
is specified, any value exceeds 999, then an exception is raised:
<raise class="22" subclass="G06"/>.
</item>

<comment>WG3:W22-036</comment>
<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-019 P00-ISO-033</comment>
<comment>WG3:CMN-048</comment>
<item>If the values associated with other <BNF name="field name"/>s do not conform to
the range of values specified in <docref ref="ISO8601-1_2019"/>, 4.3, 
<quote>Time scale components and units</quote>, then an exception is raised: 
<raise class="22" subclass="G06"/>.
</item>

<comment>WG3:UTC-117 Deleted 1 (one) editor's note</comment>

<comment>WG3:CMN-048 Removed 1 (one) General Rule</comment>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>DS</symdef> be the character string defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:CMN-048</comment>
<item>If <BNF name="date function parameters"/> is specified using a <BNF name="date string"/>, then
<sym>DS</sym> is that <BNF name="date string"/>.
</item>

<comment>WG3:CMN-048</comment>
<item>If <BNF name="date function parameters"/> or <BNF name="datetime function parameters"/> are
specified using a <BNF name="record constructor"/>, then:

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>RVS</symdef> be the <BNF name="record constructor"/> immediately contained
in the <BNF name="date function parameters"/> or the <BNF name="datetime function parameters"/>.
</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>YYS</symdef> be defined as follows.

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>YY</symdef> be the result of the <BNF name="value expression"/> in
the <string>year</string> field of <sym>RVS</sym>.
</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>YYC</symdef> be the result of:

<code>
<kw>CAST</kw>(<sym>YY</sym> AS <kw>STRING</kw>)
</code>
</item>

<comment>WG3:CMN-048</comment>
<item>If <kw>CHAR_LENGTH</kw>(<sym>YYC</sym>) &lt; 4, then <sym>YYS</sym> is <sym>YYC</sym>
prepended with 0’s (zeroes) to a length of 4; otherwise, <sym>YYS</sym> is <sym>YYC</sym>.
</item>

</olist>
</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>DDS</symdef> be defined as follows.

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>DD</symdef> be defined as follows. 
If <sym>RVS</sym> does not specify the <string>day</string> field, then <sym>DD</sym> is 1 (one); 
otherwise, <sym>DD</sym> is the result of the <BNF name="value expression"/> in
the <string>day</string> field of <sym>RVS</sym>.
</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>DDC</symdef> be the result of:

<code>
<kw>CAST</kw>(<sym>DD</sym> AS <kw>STRING</kw>)
</code>
</item>

<comment>WG3:CMN-048</comment>
<item>If <kw>CHAR_LENGTH</kw>(<sym>DDC</sym>) &lt; 2, then <sym>DDS</sym> is <sym>DDC</sym>
prepended with 0’s (zeroes) to a length of 2; otherwise, <sym>DDS</sym> is <sym>DDC</sym>.
</item>

</olist>
</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>MMS</symdef> be defined as follows.

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>MM</symdef> be defined as follows. 
If <sym>RVS</sym> does not specify the <string>month</string> field, then <sym>MM</sym> is 1 (one);
 otherwise, <sym>MM</sym> is the result of the <BNF name="value expression"/> in
the <string>month</string> field of <sym>RVS</sym>.
</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>MMC</symdef> be the result of:

<code>
<kw>CAST</kw>(<sym>MM</sym> AS <kw>STRING</kw>)
</code>
</item>

<comment>WG3:CMN-048</comment>
<item>If <kw>CHAR_LENGTH</kw>(<sym>MMC</sym>) &lt; 2, then <sym>MMS</sym> is <sym>MMC</sym>
prepended with 0’s (zeroes) to a length of 2; otherwise, <sym>MMS</sym> is <sym>MMC</sym>.
</item>

</olist>
</item>

<comment>WG3:CMN-048</comment>
<item><symdef>DS</symdef> is the result of:

<code>
<sym>YYS</sym> || <string>-</string> || <sym>MMS</sym> || <string>-</string> || <sym>DDS</sym>
</code>

<para>without intervening whitespace.
</para>

</item>

</olist>

</item>

<item>Otherwise, <sym>DS</sym> is the zero-length character string.
</item>

</olist>

</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>TS</symdef> be the character string defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:CMN-048</comment>
<item>If <BNF name="time function parameters"/> is specified using a <BNF name="time string"/>,
then <sym>TS</sym> is that <BNF name="time string"/>.
</item>

<comment>WG3:CMN-048</comment>
<item>If <BNF name="time function parameters"/> or <BNF name="datetime function parameters"/> are
specified using a <BNF name="record constructor"/>, then:

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>RVS</symdef> be the <BNF name="record constructor"/> immediately contained
in the <BNF name="time function parameters"/> or the <BNF name="datetime function parameters"/>.
</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>HRS</symdef> be defined as follows.

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>HR</symdef> be the result of the <BNF name="value expression"/> in
the <string>hour</string> field of <sym>RVS</sym>.
</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>HRC</symdef> be the result of:

<code>
<kw>CAST</kw>(<sym>HR</sym> AS <kw>STRING</kw>)
</code>
</item>

<comment>WG3:CMN-048</comment>
<item>If <kw>CHAR_LENGTH</kw>(<sym>HRC</sym>) &lt; 2, then <sym>HRS</sym> is <sym>HRC</sym>
prepended with 0’s (zeroes) to a length of 2; otherwise, <sym>HRS</sym> is <sym>HRC</sym>.
</item>

</olist>
</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>MINS</symdef> be defined as follows.

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>MIN</symdef> be defined as follows. 
If <sym>RVS</sym> does not specify the <string>minute</string> field, then <sym>MIN</sym> is 
0 (zero); otherwise, <sym>MIN</sym> is the result of the <BNF name="value expression"/> in
the <string>minute</string> field of <sym>RVS</sym>.
</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>MINC</symdef> be the result of:

<code>
<kw>CAST</kw>(<sym>MIN</sym> AS <kw>STRING</kw>)
</code>
</item>

<comment>WG3:CMN-048</comment>
<item>If <kw>CHAR_LENGTH</kw>(<sym>MINC</sym>) &lt; 2, then <sym>MINS</sym> is <sym>MINC</sym>
prepended with 0’s (zeroes) to a length of 2; otherwise, <sym>MINS</sym> is <sym>MINC</sym>.
</item>

</olist>
</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>SECS</symdef> be defined as follows.

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>SEC</symdef> be defined as follows. 
If <sym>RVS</sym> does not specify the <string>second</string> field, then <sym>SEC</sym> is 
0 (zero); otherwise, <sym>SEC</sym> is the result of the <BNF name="value expression"/> in
the <string>seconds</string> field of <sym>RVS</sym>.
</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>SECC</symdef> be the result of:

<code>
<kw>CAST</kw>(<sym>SEC</sym> AS <kw>STRING</kw>)
</code>
</item>

<comment>WG3:CMN-048</comment>
<item>If <kw>CHAR_LENGTH</kw>(<sym>MINC</sym>) &lt; 2, then <sym>SECS</sym> is <sym>SECC</sym>
prepended with 0’s (zeroes) to a length of 2; otherwise, <sym>SECS</sym> is <sym>SECC</sym>.
</item>

</olist>
</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>SUBSECS</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:CMN-048</comment>
<item>If <sym>RVS</sym> specifies the <string>millisecond</string> field, then:

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>MISEC</symdef> be the result of the <BNF name="value expression"/> in
the <string>millisecond</string> field of <sym>RVS</sym>.
</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>MISECC</symdef> be the result of:

<code>
<kw>CAST</kw>(<sym>MISEC</sym> AS <kw>STRING</kw>)
</code>
</item>

<comment>WG3:CMN-048</comment>
<item>If <kw>CHAR_LENGTH</kw>(<sym>MISECC</sym>) &lt; 3, then <sym>SUBSECS</sym> is
<sym>MISECC</sym> prepended with 0’s (zeroes) to a length of 3; otherwise, <sym>SUBSECS</sym> is
<sym>MISECC</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-048</comment>
<item>If <sym>RVS</sym> specifies the <string>microsecond</string> field, then:

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>MYSEC</symdef> be the result of the <BNF name="value expression"/> in
the <string>microsecond</string> field of <sym>RVS</sym>.
</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>MYSECC</symdef> be the result of:

<code>
<kw>CAST</kw>(<sym>MYSEC</sym> AS <kw>STRING</kw>)
</code>
</item>

<comment>WG3:CMN-048</comment>
<item>If <kw>CHAR_LENGTH</kw>(<sym>MYSECC</sym>) &lt; 6, then <sym>SUBSECS</sym> is
<sym>MYSECC</sym> prepended with 0’s (zeroes) to a length of 6; otherwise, <sym>SUBSECS</sym> is
<sym>MYSECC</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-048</comment>
<item>If <sym>RVS</sym> specifies the <string>nanosecond</string> field, then:

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>NASEC</symdef> be the result of the <BNF name="value expression"/> in
the <string>nanosecond</string> field of <sym>RVS</sym>.
</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>NASECC</symdef> be the result of:

<code>
<kw>CAST</kw>(<sym>NASEC</sym> AS <kw>STRING</kw>)
</code>
</item>

<comment>WG3:CMN-048</comment>
<item>If <kw>CHAR_LENGTH</kw>(<sym>NASECC</sym>) &lt; 9, then <sym>SUBSECS</sym> is
<sym>NASECC</sym> prepended with 0’s (zeroes) to a length of 9; otherwise, <sym>SUBSECS</sym> is
<sym>NASECC</sym>.
</item>

</olist>

</item>

<comment>Editorial: Stefan Plantikow, 2023-10-11 Avoid trailing dot</comment>
<item>Otherwise, <sym>SUBSECS</sym> is <string>000</string>.
</item>

</olist>

</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>TZ</symdef> be defined as follows. 
If <sym>RVS</sym> contains the <string>timezone</string> field, then <sym>TZ</sym> is the result of
the <BNF name="value expression"/> in the <string>timezone</string> field of <sym>RVS</sym>;
otherwise, <sym>TZ</sym> is the zero-length character string.
</item>

<comment>WG3:CMN-048</comment>
<item><sym>TS</sym> is the result of:

<code>
<sym>HRS</sym> || <string>:</string> || <sym>MINS</sym> || <string>:</string> || <sym>SECS</sym> || <string>.</string> || <sym>SUBSECS</sym> || <sym>TZ</sym>
</code>

<para>without intervening whitespace.
</para>
</item>

</olist>

</item>

<item>Otherwise, <sym>TS</sym> is the zero-length character string.
</item>

</olist>

</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>DTS</symdef> be the character string defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:CMN-048</comment>
<item>If <BNF name="datetime function parameters"/> is specified using
a <BNF name="datetime string"/>, then <sym>DTS</sym> is that <BNF name="datetime string"/>.
</item>

<comment>WG3:CMN-048</comment>
<item>If <BNF name="datetime function parameters"/> is specified using
a <BNF name="record constructor"/>, then:

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>RVS</symdef> be the <BNF name="record constructor"/> immediately contained
in the <BNF name="datetime function parameters"/>.
</item>

<item><sym>DTS</sym> is the result of:

<code>
<sym>DS</sym> || <string>T</string> || <sym>TS</sym>
</code>

<para>without intervening whitespace.
</para>
</item>

</olist>

</item>

<item>Otherwise, <sym>DTS</sym> is the zero-length character string.
</item>

</olist>

</item>

<item>If the <BNF name="datetime value function"/> <symdef>DTVF</symdef> is specified, then

<para>Case:

</para>

<olist>

<comment>Editorial: Stephen Cannan, 2020-05-18 GQL- prefix reduction</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-06 Change to time zone identifier</comment>
<comment>WG3:UTC-132</comment>
<comment>WG3:CMN-048</comment>
<item>If <sym>DTVF</sym> is <kw>DATE</kw>(), <kw>ZONED_TIME</kw>(), <kw>ZONED_DATETIME</kw>(),
<kw>TIME</kw>(), or <kw>DATETIME</kw>(), then the result of <sym>DTVF</sym> respectively is
the current date, zoned time, zoned datetime, local time, or local datetime from
the current request timestamp.

<comment>WG3:UTC-117 Implied the deletion of 1 (one) paragraph</comment>

<comment>WG3:UTC-117</comment>
<para>For <kw>ZONED_TIME</kw>() and <kw>ZONED_DATETIME</kw>(),
the result of <sym>DTVF</sym> has a time zone displacement that is equal to
the current time zone displacement.
</para>
</item>

<comment>WG3:CMN-048</comment>
<item>Otherwise, <sym>DTVF</sym> is a <BNF name="date function"/>, <BNF name="time function"/>,
<BNF name="datetime function"/>, <BNF name="localtime function"/>, or
<BNF name="localdatetime function"/> that specifies parameters and respectively the result of
<sym>DTVF</sym> is the date, zoned time, zoned datetime, local time, or local datetime value
associated with the respective representation of the parameters provided by
<sym>DS</sym>, <sym>TS</sym>, <sym>DTS</sym>, <sym>TS</sym>, or <sym>DTS</sym>, as defined by
<docref ref="ISO8601-1_2019"/> and <docref ref="ISO8601-2_2019"/>.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:CMN-052R1</comment>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-052R1</comment>
<item>Without <feature code="GV40"/>, conforming GQL language shall not contain
a <BNF name="datetime value function"/> that is a <BNF name="datetime function"/> or
a <BNF name="time function"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_durvalexp" newpage="true">
<clauseHeading><BNF name="duration value expression"/></clauseHeading>

<bodyMatter>


<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<para>Specify a duration value.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-048</comment>
<BNFdef name="duration value expression">
<rhs>
<alt> <BNF name="duration term"/> </alt>
<alt> <BNF name="duration addition and subtraction"/> </alt>
<alt> <BNF name="datetime subtraction"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:CMN-048</comment>
<BNFdef name="duration addition and subtraction">
<rhs>
<alt>
<BNF name="duration value expression 1"/>
<BNF name="plus sign"/> <BNF name="duration term 1"/>
</alt>
<alt>
<BNF name="duration value expression 1"/>
<BNF name="minus sign"/> <BNF name="duration term 1"/>
</alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-048</comment>
<BNFdef name="datetime subtraction">
<rhs>
<kw>DURATION_BETWEEN</kw>
<BNF name="left paren"/>
<BNF name="datetime subtraction parameters"/>
<BNF name="right paren"/>
<breakindent/>
<opt> <BNF name="temporal duration qualifier"/> </opt>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2023-02-21 Extracted parameters</comment>
<BNFdef name="datetime subtraction parameters">
<rhs>
<BNF name="datetime value expression 1"/>
<BNF name="comma"/>
<BNF name="datetime value expression 2"/>
</rhs>
</BNFdef>

<BNFdef name="duration term">
<rhs>
<alt> <BNF name="duration factor"/> </alt>
<alt> <BNF name="duration term 2"/> <BNF name="asterisk"/> <BNF name="factor"/> </alt>
<alt> <BNF name="duration term 2"/> <BNF name="solidus"/> <BNF name="factor"/> </alt>
<alt> <BNF name="term"/> <BNF name="asterisk"/> <BNF name="duration factor"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="duration factor">
<rhs>
<opt> <BNF name="sign"/> </opt> <BNF name="duration primary"/>
</rhs>
</BNFdef>

<BNFdef name="duration primary">
<rhs>
<alt> <BNF name="value expression primary"/> </alt>
<alt> <BNF name="duration value function"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="duration value expression 1">
<rhs>
<BNF name="duration value expression"/>
</rhs>
</BNFdef>

<BNFdef name="duration term 1">
<rhs>
<BNF name="duration term"/>
</rhs>
</BNFdef>

<BNFdef name="duration term 2">
<rhs>
<BNF name="duration term"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-117</comment>
<BNFdef name="datetime value expression 1">
<rhs>
<BNF name="datetime value expression"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-117</comment>
<BNFdef name="datetime value expression 2">
<rhs>
<BNF name="datetime value expression"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<comment>WG3:UTC-117 Deleted 1 (one) editor's note</comment>

<olist>

<comment>WG3:CMN-048</comment>
<item>If the <BNF name="duration value expression"/> immediately contains
<BNF name="duration addition and subtraction"/>, then:

<olist>

<comment>WG3:CMN-048</comment>
<comment>WG3:W26-024</comment>
<item>The declared type of <BNF name="duration value expression 1"/> and
<BNF name="duration term 1"/> shall be of the same duration unit group.
</item>

<comment>WG3:CMN-048</comment>
<item>The declared type of the <BNF name="duration value expression"/> is the declared type of
the <BNF name="duration value expression 1"/>.
</item>

</olist>

</item>

<comment>WG3:CMN-048</comment>
<comment>WG3:W26-040R1</comment>
<item>If the <BNF name="duration value expression"/> immediately contains
a <BNF name="duration term"/>, then

<para>Case:
</para>


<olist>

<comment>WG3:CMN-048</comment>
<item>If the <BNF name="duration term"/> immediately contains a <BNF name="duration factor"/>, then
the declared type of the <BNF name="duration value expression"/> is the declared type of
the <BNF name="duration factor"/>.
</item>

<comment>WG3:CMN-048</comment>
<item>Otherwise, the declared type of the <BNF name="duration value expression"/> is
the declared type of the <BNF name="duration term 2"/>.
</item>

</olist>

</item>

<comment>WG3:CMN-048</comment>
<item>If the <BNF name="duration value expression"/> <symdef>DVE</symdef> immediately contains
a <BNF name="datetime subtraction"/> <symdef>DS</symdef>, then:

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>DVE1</symdef> and <symdef>DVE2</symdef> be 
the <BNF name="datetime value expression 1"/> and the <BNF name="datetime value expression 2"/>,
respectively, that are simply contained in <sym>DS</sym>.
</item>

<comment>WG3:CMN-048</comment>
<comment>WG3:W26-024</comment>
<item>The declared type of <sym>DVE1</sym> and the declared type of <sym>DVE2</sym> shall be
essentially comparable value types.
</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>TDQ</symdef> be defined as follows. 
If <sym>DS</sym> simply contains a <BNF name="temporal duration qualifier"/>, then <sym>TDQ</sym> 
is that <BNF name="temporal duration qualifier"/>; otherwise, <sym>TDQ</sym> is
<kw>DAY</kw> <kw>TO</kw> <kw>SECOND</kw>.
</item>

<comment>WG3:CMN-048</comment>
<item>If <sym>DVE1</sym> is a zoned time type or a local time type and <sym>DVE2</sym> is
a zoned time type or a local time type, then <sym>TDQ</sym> shall be
<kw>DAY</kw> <kw>TO</kw> <kw>SECOND</kw>.
</item>

<comment>WG3:CMN-048</comment>
<item>If <sym>TDQ</sym> is <kw>DAY</kw> <kw>TO</kw> <kw>SECOND</kw>, then the declared type of
<sym>DVE</sym> shall be the day and time-based duration type; otherwise,
the declared type of <sym>DVE</sym> shall be the year and month-based duration type.
</item>

</olist>

</item>

<item>If <BNF name="duration term"/>, <symdef>DT</symdef> immediately contains
<BNF name="solidus"/>, then let <symdef>DT2</symdef> be the <BNF name="duration term 2"/>
immediately contained in <sym>DT</sym> and <symdef>F</symdef> be the <BNF name="factor"/>
immediately contained in <sym>DT</sym>.
<sym>DT</sym> is effectively replaced by:
<code>
<sym>DT2</sym> * ( 1 / <sym>F</sym> )
</code>
</item>

<comment>WG3:CMN-048 Removed 1 (one) Syntax Rule</comment>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:UTC-117 Deleted 1 (one) GR</comment>

<comment>WG3:UTC-015</comment>
<comment>WG3:W26-040R1</comment>
<item>If the result of a <BNF name="value expression primary"/> simply contained
in a <BNF name="duration primary"/> is not a duration, then an exception condition is raised:
<raise class="22" subclass="G03"/>.
</item>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-048</comment>
<item>If the most specific types of <BNF name="datetime value expression 1"/> and
<BNF name="datetime value expression 2"/> are not temporal instant types, then
an exception condition is raised: <raise class="22" subclass="G03"/>.
</item>

<comment>WG3:CMN-048</comment>
<item>If <BNF name="datetime value expression"/> is specified, then if
the results of <BNF name="datetime value expression"/> and <BNF name="datetime primary"/>
are not essentially comparable values, then an exception condition is raised: 
<raise class="22" subclass="G04"/>.
</item>

<comment>WG3:CMN-019 P00-ISO-033</comment>
<comment>WG3:CMN-048</comment>
<item>If <BNF name="duration term"/> immediately contains <BNF name="asterisk"/>, then 
let <symdef>V</symdef> be the result of the immediately contained <BNF name="term"/> or
<BNF name="factor"/>.
The result of the <BNF name="duration term"/> is the duration specified by 
<docref ref="ISO8601-2_2019"/>, 14.3, <quote>Multiplication</quote>, with <sym>V</sym> as the
coefficient, and <BNF name="duration term 2"/> or <BNF name="duration factor"/> as
<string>durationA</string>, where <string>duration</string>, <string>coefficient</string>,
and <string>durationA</string> are the terms used in <docref ref="ISO8601-2_2019"/>.
</item>

<item>The result of a <BNF name="duration value expression"/> <symdef>DVE</symdef> is defined as
follows.

<para>Case:
</para>

<olist>

<comment>WG3:UTC-117</comment>
<comment>WG3:W26-040R1</comment>
<item>If the result of a <BNF name="datetime value expression"/>,
<BNF name="duration value expression"/>, or <BNF name="duration term"/> simply contained in 
<sym>DVE</sym> is the null value, then the result of <sym>DVE</sym> is the null value.
</item>

<item>If <sym>DVE</sym> immediately contains <BNF name="duration term"/>, then the result of
<sym>DVE</sym> is the result of <BNF name="duration term"/>.
</item>

<comment>WG3:W26-040R1</comment>
<item>If <sym>DVE</sym> immediately contains <BNF name="duration addition and subtraction"/>, then

<para>Case:
</para>

<comment>WG3:UTC-117 as minuted</comment>
<olist>

<comment>WG3:UTC-117 as minuted</comment>
<comment>WG3:CMN-019 P00-ISO-033</comment>
<item>If the two operands of <sym>DVE</sym> are of the same unit group, then
the result of <sym>DVE</sym> is as specified by <docref ref="ISO8601-2_2019"/>, 14, 
<quote>Date and time arithmetic</quote>.
</item>

<comment>WG3:UTC-117 as minuted</comment>
<item>Otherwise, the two operands of <sym>DVE</sym> are not of the same unit group and
an exception condition is raised: <raise class="22" subclass="G14"/>.
</item>

</olist>

</item>

<comment>WG3:UTC-117</comment>
<item>If <sym>DVE</sym> immediately contains
a <BNF name="datetime subtraction"/> <symdef>DS</symdef>, then:

<olist>

<comment>WG3:UTC-117</comment>
<item>Let <symdef>DVE1</symdef> be the <BNF name="datetime value expression 1"/> simply contained
in <sym>DS</sym>.
</item>

<comment>WG3:UTC-117</comment>
<item>Let <symdef>DVE2</symdef> be the <BNF name="datetime value expression 2"/> simply contained
in <sym>DS</sym>.
</item>

<comment>WG3:UTC-117</comment>
<item>Let <symdef>MSP</symdef> be the <impDef code="IL024"/> maximum value of fractional seconds
precision for a temporal duration.
</item>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-048</comment>
<item>Let the units <symdef>Y</symdef> be defined as follows.
If <sym>DVE1</sym> and <sym>DVE2</sym> are datetimes or dates, then <sym>Y</sym> is Days;
otherwise, <sym>Y</sym> is Seconds with a precision of <sym>MSP</sym>.
</item>

<comment>WG3:UTC-117</comment>
<item><sym>DVE1</sym> and <sym>DVE2</sym> are converted to integer scalars <symdef>DVE1IS</symdef>
and <symdef>DVE2IS</symdef>, respectively, in units <sym>Y</sym> as displacements from some
<unDef code="UV014"/> start datetime.
</item>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-025</comment>
<comment>WG3:CMN-048</comment>
<item>The result of <sym>DVE</sym> is determined by:

<olist>

<item>Effectively computing <symdef>RESULT</symdef> as
<sym>DVE2IS</sym> minus <sym>DVE1IS</sym>, rounding or truncating if necessary.
</item>

<item>The result of <sym>DVE</sym> is <sym>RESULT</sym> converted to a duration of
the temporal duration unit group specified by the <BNF name="temporal duration qualifier"/>,
rounding or truncating if necessary.
</item>

<item>The choice of whether to round or truncate is <impDef code="IA005"/>.
</item>

</olist>

<comment>WG3:UTC-117</comment>
<comment>WG3:POS-016</comment>
<para>If the required number of significant digits of the resulting duration exceeds <sym>MSP</sym>,
then an exception condition is raised: <raise class="22" subclass="015"/>.
</para>

<comment>WG3:UTC-117</comment>
<comment>Editorial: Stefan Plantikow 2023-02-21 </comment>
<para>It is <impDef code="IA026"/> whether the resulting duration reflects leap seconds.
</para>

</item>

</olist>

</item>

<comment>WG3:W26-040R1 Removed 1 (one) Subrule</comment>
</olist>

</item>

<comment>WG3:CMN-048</comment>
<item>The result of <sym>DVE</sym> is normalized, carrying over to the next most significant
datetime field as needed, such that:

<olist>

<comment>WG3:CMN-048</comment>
<item>If the result of <sym>DVE</sym> is a day and time-based duration, then:

<olist>

<comment>WG3:CMN-048</comment>
<item>The absolute value of Seconds of is normalized to be &lt; 60.
</item>

<comment>WG3:CMN-048</comment>
<item>The absolute value of Minutes is normalized to be &lt; 60.
</item>

<comment>WG3:CMN-048</comment>
<item>The absolute value of Hours is normalized to be &lt; 24.
</item>

</olist>

</item>

<comment>WG3:CMN-048</comment>
<item>Otherwise, the result of <sym>DVE</sym> is a year and month-based duration and
the absolute value of Months is normalized to be &lt; 12.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:UTC-117</comment>
<item>Without <feature code="GV41"/>, conforming GQL language shall not contain
a <BNF name="duration value expression"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_durvalfunc" newpage="true">
<clauseHeading><BNF name="duration value function"/></clauseHeading>

<bodyMatter>


<Function>

<comment>Editorial: Stefan Plantikow, 2023-06-02 Improve wording</comment>
<para>Specify a function yielding a value of a temporal duration type.
</para>

</Function>


<Format>

<grammar>

<comment>Email from: Keith Hare, 2021-10-25 2233</comment>
<BNFdef name="duration value function">
<rhs>
<alt> <BNF name="duration function"/> </alt>
<alt> <BNF name="duration absolute value function"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="duration function">
<rhs>
<kw>DURATION</kw><BNF name="left paren"/> <BNF name="duration function parameters"/>
<BNF name="right paren"/>
</rhs>
</BNFdef>

<comment>WG3:W22-036</comment>
<BNFdef name="duration function parameters">
<rhs>
<alt> <BNF name="duration string"/> </alt>
<alt> <BNF name="record constructor"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="duration absolute value function">
<rhs>
<kw>ABS</kw><BNF name="left paren"/> <BNF name="duration value expression"/> 
<BNF name="right paren"/>
</rhs>
</BNFdef>

<ednote id="gql_PP197">Cypher has a raft of duration functions, some of which may not be already
incorporated into GQL.
These should be checked for suitability of inclusion.
See <PPref ref="PPgql197"/>.
</ednote>

</grammar>

</Format>


<SyntaxRules>

<comment>WG3:UTC-117 Deleted 1 (one) editor's note by implication</comment>

<olist>

<None/>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:CMN-048 Removed 2 (two) General Rules</comment>

<comment>WG3:CMN-048</comment>
<item>If <BNF name="duration function parameters"/> immediately contains
a <BNF name="duration string"/> <symdef>DS</symdef>, then

<para>Case:
</para>

<olist>

<comment>WG3:CMN-048</comment>
<item>If <sym>DS</sym> conforms to the Format of <BNF name="iso8601 years and months"/>
without a <BNF name="separator"/> between the fields, then the declared type of
the <BNF name="duration function"/> is the year and month-based duration type.
</item>

<comment>WG3:CMN-048</comment>
<item>If <sym>DS</sym> conforms to the Format of <BNF name="iso8601 days and time"/>
without a <BNF name="separator"/> between the fields, then the declared type of
the <BNF name="duration function"/> is the day and time-based duration type.
</item>

<comment>WG3:CMN-048</comment>
<item>Otherwise, an exception condition is raised: <raise class="22" subclass="G0H"/>.
</item>

</olist>

</item>

<comment>WG3:CMN-048</comment>
<item>If <BNF name="duration function parameters"/> immediately contains
a <BNF name="record constructor"/> <symdef>RVS</symdef>, then

<para>Case:
</para>

<olist>

<comment>WG3:CMN-048</comment>
<item>If the declared type of <sym>RVS</sym> specifies the fields <string>years</string> or
<string>months</string>, then the declared type of the <BNF name="duration function"/> is
the year and month-based duration type.
</item>

<comment>WG3:CMN-048</comment>
<item>If the declared type of <sym>RVS</sym> specifies the fields <string>days</string>,
<string>hours</string>, <string>minutes</string>, <string>seconds</string>, 
<string>milliseconds</string>, <string>microseconds</string>, or <string>nanoseconds</string>, then
the declared type of the <BNF name="duration function"/> is the day and time-based duration type.
</item>

<comment>WG3:CMN-048</comment>
<item>Otherwise, an exception condition is raised: <raise class="22" subclass="G07"/>.
</item>

</olist>

</item>


<comment>WG3:W22-036</comment>
<comment>WG3:UTC-009 P00-USA-169</comment>
<comment>WG3:CMN-048</comment>
<item>If <BNF name="duration function parameters"/> immediately contains
a <BNF name="record constructor"/>, then the record is transformed 
into an equivalent <BNF name="duration string"/> as follows:

<olist>

<comment>WG3:CMN-048</comment>
<item>If <sym>RVS</sym> specifies the fields <string>years</string> or <string>months</string>,
then:

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>YYS</symdef> be defined as follows:

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>YY</symdef> be defined as follows. 
If <sym>RVS</sym> does not specify the <string>years</string> field, then <sym>YY</sym> is 
0 (zero); otherwise, <sym>YY</sym> is the result of the <BNF name="value expression"/> in
the <string>years</string> field of <sym>RVS</sym>.
</item>

<comment>WG3:CMN-048</comment>
<item><symdef>YYS</symdef> is the result of:

<code>
<kw>CAST</kw>(<sym>YY</sym> <kw>AS</kw> <kw>STRING</kw>)
</code>

</item>

</olist>

</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>MMS</symdef> be defined as follows:

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>MM</symdef> be defined as follows. 
If <sym>RVS</sym> does not specify the <string>month</string> field, then <sym>MM</sym> is 
0 (zero); otherwise, <sym>MM</sym> is the result of the <BNF name="value expression"/> in
the <string>months</string> field of <sym>RVS</sym>.
</item>

<comment>WG3:CMN-048</comment>
<item><symdef>MMS</symdef> is the result of:

<code>
<kw>CAST</kw>(<sym>MM</sym> <kw>AS</kw> <kw>STRING</kw>)
</code>

</item>

</olist>

</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>DS</symdef> be the result of:

<code>
<string>P</string> || <sym>YYS</sym> || <string>Y</string> || <sym>MMS</sym> || <string>M</string>
</code>

</item>

</olist>

</item>

<comment>WG3:CMN-048</comment>
<item>Otherwise,

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>DDS</symdef> be defined as follows:

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>DD</symdef> be defined as follows. 
If <sym>RVS</sym> does not specify the <string>days</string> field, then <sym>DD</sym> is 0 (zero); 
otherwise, <sym>DD</sym> is the result of the <BNF name="value expression"/> in
the <string>days</string> field of <sym>RVS</sym>.
</item>

<comment>WG3:CMN-048</comment>
<item><symdef>DDS</symdef> is the result of:

<code>
<kw>CAST</kw>(<sym>DD</sym> <kw>AS</kw> <kw>STRING</kw>)
</code>

</item>

</olist>

</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>HRS</symdef> be defined as follows:

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>HR</symdef> be defined as follows. 
If <sym>RVS</sym> does not specify the <string>hours</string> field, then <sym>HR</sym> is 
0 (zero); otherwise, <sym>HR</sym> is the result of the <BNF name="value expression"/> in
the <string>hours</string> field of <sym>RVS</sym>.
</item>

<comment>WG3:CMN-048</comment>
<item><symdef>HRS</symdef> is the result of:

<code>
<kw>CAST</kw>(<sym>HR</sym> <kw>AS</kw> <kw>STRING</kw>)
</code>

</item>

</olist>

</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>MINS</symdef> be defined as follows:

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>MIN</symdef> be defined as follows. 
If <sym>RVS</sym> does not specify the <string>minutes</string> field, then <sym>MIN</sym> is 
0 (zero); otherwise, <sym>MIN</sym> is the result of the <BNF name="value expression"/> in
the <string>minutes</string> field of <sym>RVS</sym>.
</item>

<comment>WG3:CMN-048</comment>
<item><symdef>MINS</symdef> is the result of:

<code>
<kw>CAST</kw>(<sym>MIN</sym> <kw>AS</kw> <kw>STRING</kw>)
</code>

</item>

</olist>

</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>SECS</symdef> be defined as follows:

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>SEC</symdef> be defined as follows. 
If <sym>RVS</sym> does not specify the <string>seconds</string> field, then <sym>SEC</sym> is 
0 (zero); otherwise, <sym>SEC</sym> is the result of the <BNF name="value expression"/> in
the <string>seconds</string> field of <sym>RVS</sym>.
</item>

<comment>WG3:CMN-048</comment>
<item><symdef>SECS</symdef> is the result of:

<code>
<kw>CAST</kw>(<sym>SEC</sym> <kw>AS</kw> <kw>STRING</kw>)
</code>

</item>

</olist>

</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>SUBSECS</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:CMN-048</comment>
<item>If <sym>RVS</sym> specifies the <string>milliseconds</string> field, then:

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>MISEC</symdef> be the result of the <BNF name="value expression"/> in
the <string>milliseconds</string> field of <sym>RVS</sym>.
</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>MISECC</symdef> be the result of:

<code>
<kw>CAST</kw>(<sym>MISEC</sym> AS <kw>STRING</kw>)
</code>
</item>

<comment>WG3:CMN-048</comment>
<item>If <kw>CHAR_LENGTH</kw>(<sym>MISECC</sym>) &lt; 3, then <sym>SUBSECS</sym> is
<sym>MISECC</sym> prepended with 0’s (zeroes) to a length of 3; otherwise, <sym>SUBSECS</sym> is
<sym>MISECC</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-048</comment>
<item>If <sym>RVS</sym> specifies the <string>microseconds</string> field, then:

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>MYSEC</symdef> be the result of the <BNF name="value expression"/> in
the <string>microseconds</string> field of <sym>RVS</sym>.
</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>MYSECC</symdef> be the result of:

<code>
<kw>CAST</kw>(<sym>MYSEC</sym> AS <kw>STRING</kw>)
</code>
</item>

<comment>WG3:CMN-048</comment>
<item>If <kw>CHAR_LENGTH</kw>(<sym>MYSECC</sym>) &lt; 6, then <sym>SUBSECS</sym> is
<sym>MYSECC</sym> prepended with 0’s (zeroes) to a length of 6; otherwise, <sym>SUBSECS</sym> is
<sym>MYSECC</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-048</comment>
<item>If <sym>RVS</sym> specifies the <string>nanoseconds</string> field, then:

<olist>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>NASEC</symdef> be the result of the <BNF name="value expression"/> in
the <string>nanoseconds</string> field of <sym>RVS</sym>.
</item>

<comment>WG3:CMN-048</comment>
<item>Let <symdef>NASECC</symdef> be the result of:

<code>
<kw>CAST</kw>(<sym>NASEC</sym> AS <kw>STRING</kw>)
</code>
</item>

<comment>WG3:CMN-048</comment>
<item>If <kw>CHAR_LENGTH</kw>(<sym>NASECC</sym>) &lt; 9, then <sym>SUBSECS</sym> is
<sym>NASECC</sym> prepended with 0’s (zeroes) to a length of 9; otherwise, <sym>SUBSECS</sym> is
<sym>NASECC</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-048</comment>
<comment>Editorial: Stefan Plantikow, 2023-10-11 Avoid trailing dot</comment>
<item>Otherwise, <sym>SUBSECS</sym> is <string>000</string>.
</item>

</olist>

</item>

<comment>Editorial: Stefan Plantikow, 2023-10-11 Break out to avoid line-break below</comment>
<item>Let <symdef>SECSNSUBSECS</symdef> be the result of:

<code>
<sym>SECS</sym> || <string>.</string> || <sym>SUBSECS</sym> || <string>S</string>
</code>

without intervening whitespace.
</item>

<item><sym>DS</sym> is the result of:

<code>
<string>P</string> || <sym>DDS</sym> || <string>DT</string> || <sym>HRS</sym> || <string>H</string> || <sym>MINS</sym> || <string>M</string> || <sym>SECSNSUBSECS</sym>
</code>

without intervening whitespace.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-ISO-033</comment>
<comment>WG3:CMN-048</comment>
<item>The result of the <BNF name="duration function"/> is the duration represented by
the immediately contained <BNF name="duration string"/>, as defined in
<docref ref="ISO8601-1_2019"/>, 5.5.2, <quote>Duration</quote> as extended by
<docref ref="ISO8601-2_2019"/>, 4.3, <quote>Additional explicit forms</quote> and
<docref ref="ISO8601-2_2019"/>, 4.4, <quote>Numerical extensions</quote>.
</item>

<item>If <BNF name="duration absolute value function"/> is specified, then let <symdef>N</symdef>
be the result of the <BNF name="duration value expression"/>.

<para>Case:
</para>

<olist>

<item>If <sym>N</sym> is the null value, then the result is the null value.
</item>

<item>If <sym>N</sym> <geq/> 0 (zero), then the result is <sym>N</sym>.
</item>

<item>Otherwise, the result is &minus;1 * <sym>N</sym>.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_vecvalexp" newpage="true">
<clauseHeading><BNF name="vector value expression"/></clauseHeading>

<bodyMatter>

<comment>WG3:POS-011R1</comment>
<Function>

<comment>WG3:POS-011R1</comment>
<para>Specify a vector value.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:POS-011R1</comment>
<BNFdef name="vector value expression">
<rhs>
<BNF name="vector primary"/>
</rhs>
</BNFdef>

<comment>WG3:POS-011R1</comment>
<BNFdef name="vector primary">
<rhs>
<BNF name="value expression primary"/>
<BNF name="vector value function"/>
</rhs>
</BNFdef>

</grammar>

<comment>WG3:POS-011R1</comment>
<ednote id="PPgql434_1">Support for additional vector operations, like coordinate-wise
addition, subtraction, multiplication, <etc/>, could be added.
See <PPref ref="PPgql434"/>.
</ednote>

</Format>

<SyntaxRules>

<olist>

<comment>WG3:POS-011R1</comment>
<item>The declared type of the <BNF name="vector value expression"/> is the declared type of
the simply contained <BNF name="value expression primary"/> or <BNF name="vector value function"/>.
</item>

<comment>WG3:POS-011R1</comment>
<item>The declared type of a <BNF name="value expression primary"/> immediately contained in
a <BNF name="vector primary"/> shall be a vector type.
</item>

</olist>

</SyntaxRules>

<GeneralRules>

<olist>

<comment>WG3:POS-011R1</comment>
<item>The result of the <BNF name="vector value expression"/> is the result of
the simply contained <BNF name="value expression primary"/> or <BNF name="vector value function"/>.
</item>

</olist>

</GeneralRules>

<ConformanceRules>

<olist>

<comment>WG3:POS-011R1</comment>
<item>Without <feature code="GV42"/>, conforming GQL language shall not contain
a <BNF name="vector value expression"/>.
</item>

</olist>

</ConformanceRules>


</bodyMatter>

</subClause>

<subClause id="gql_vecvalfunc" newpage="true">
<clauseHeading><BNF name="vector value function"/></clauseHeading>

<bodyMatter>

<comment>WG3:POS-011R1</comment>
<Function>

<comment>WG3:POS-011R1</comment>
<para>Specify a function yielding a value of type vector.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:POS-011R1</comment>
<BNFdef name="vector value function">
<rhs>
<BNF name="vector value constructor"/>
</rhs>
</BNFdef>

<comment>WG3:POS-011R1</comment>
<BNFdef name="vector value constructor">
<rhs>
<kw>VECTOR</kw>
<BNF name="left paren"/>
<BNF name="character string value expression"/>
<BNF name="comma"/>
<breakindent/>
<BNF name="dimension"/>
<BNF name="comma"/>
<BNF name="coordinate type"/>
<BNF name="right paren"/>
</rhs>
</BNFdef>

</grammar>

<ednote id="PPgql432_1">The <BNF name="dimension"/> and <BNF name="coordinate type"/> parameters in
the <kw>VECTOR</kw> function could be optional.
See <PPref ref="PPgql432"/>.
</ednote>

<comment>WG3:POS-011R1</comment>
<ednote id="PPgql436_1">It would be useful to support session variables in
the vector value constructor. 
See <PPref ref="PPgql436"/>.
</ednote>

</Format>

<SyntaxRules>

<olist>

<comment>WG3:POS-011R1</comment>
<item>The declared type of a <BNF name="vector value function"/> is the declared type of
the immediately contained <BNF name="vector value constructor"/>.
</item>

<comment>WG3:POS-011R1</comment>
<item>Let <symdef>DV</symdef> be the <BNF name="dimension"/> and <symdef>CT</symdef> be 
the <BNF name="coordinate type"/> immediately contained in
the specified <BNF name="vector value constructor"/>.
</item>

<comment>WG3:POS-011R1</comment>
<item>The declared type of the specified <BNF name="vector value constructor"/> is
the value type specified by:
<code>
<kw>VECTOR</kw> ( <sym>DV</sym>, <sym>CT</sym> )
</code>
</item>

</olist>

</SyntaxRules>

<GeneralRules>

<olist>

<item>The result of the <BNF name="vector value function"/> is
the result of the immediately contained <BNF name="vector value constructor"/>.
</item>

<item>The result of the specified <BNF name="vector value constructor"/> is determined as follows.

<olist>

<item>Let <symdef>CVEV</symdef> be the result of
the <BNF name="character string value expression"/>.
</item>

<item>If <sym>CVEV</sym> is the null value, then the result is the null value and
no further General Rules of this Subclause are applied.
</item>

<item>Let <symdef>C</symdef><sub><sym>i</sym></sub>, 1 (one) <leq/> i <leq/> <sym>DV</sym>, 
be determined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>CVEV</sym> is not of the format
<!-- LINE LENGTH CHECK OFF -->
<squote>[<symdef>N</symdef><sub>1</sub>,&hairspace;<symdef>N</symdef><sub>2</sub>,&hairspace;<ellipsis/>,&hairspace;<symdef>N</symdef><sub><sym>DV</sym></sub>]</squote>,
<!-- LINE LENGTH CHECK ON -->
such that for <symdef>i</symdef> ranging from 1 (one) to <sym>DV</sym>,
all of the following are true:

<olist>

<item><symdef>N</symdef><sub><sym>i</sym></sub> satisfies the Format and Syntax Rules of
<BNF name="signed numeric literal"/> or some <impDef code="IA238"/> Format and Syntax Rules for
a literal of a <BNF name="vector-only numeric coordinate type"/>.
</item>

<item><BNF name="truncating whitespace"/> outside of <sym>N</sym><sub><sym>i</sym></sub> is ignored.
</item>

</olist>

<para>then an exception condition is raised: <raise class="22" subclass="02B"/>.
</para>

</item>

<item>If any <symdef>N</symdef><sub><sym>i</sym></sub>, 
for 1 (one) <leq/> <sym>i</sym> <leq/> <sym>DV</sym>, is the null value, then
an exception condition is raised: <raise class="22" subclass="02C"/>.
</item>

<item>If <sym>CT</sym> is a <BNF name="numeric type"/> and for all <symdef>i</symdef>,
1 (one) <leq/> i <leq/> <sym>DV</sym>, a hypothetical execution of
the <BNF name="cast specification"/>
<code>
<kw>CAST</kw> ( <sym>N</sym><sub><sym>i</sym></sub> <kw>AS</kw> <sym>CT</sym> )
</code>
would succeed without raising an exception condition, then
<sym>C</sym><sub><sym>i</sym></sub> is the result of
<code>
<kw>CAST</kw> ( <sym>N</sym><sub><sym>i</sym></sub> <kw>AS</kw> <sym>CT</sym> )
</code>
</item>

<item>If <sym>CT</sym> is
a <BNF name="vector-only numeric coordinate type"/> <symdef>VNCT</symdef>
and for all <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>DV</sym>,
it holds that <sym>N</sym><sub><sym>i</sym></sub> satisfies
the <impDef code="IA238"/> constraints for values of <sym>VNCT</sym>, then
for all <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>DV</sym>,
<sym>C</sym><sub><sym>i</sym></sub> is <sym>N</sym><sub><sym>i</sym></sub>
converted to <sym>VNCT</sym> according to <impDef code="IA237"/> rules.
</item>

<item>Otherwise, an exception condition is raised: <raise class="22" subclass="02B"/>.
</item>

</olist>

</item>

<item>The result of the specified <BNF name="vector value constructor"/> is
a <sym>DV</sym>-dimensional vector with coordinates <sym>C</sym><sub><sym>i</sym></sub>,
1 (one) <leq/> <sym>i</sym> <leq/> <sym>DV</sym>.
</item>

</olist>

</item>

</olist>

</GeneralRules>

<ConformanceRules>

<olist>

<comment>WG3:POS-011R1</comment>
<item>Without <feature code="GV42"/>, conforming GQL language shall not contain
a <BNF name="vector value constructor"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>

</clause>


<clause id="gql_lexical">
<clauseHeading>Lexical elements</clauseHeading>
<comment>In consequence of WG3:UTC-069 Deleted 1 (one) editor's note</comment>

<comment>Editorial: Stefan Plantikow, 2020-02-06</comment>
<comment>WG3:W22-053R2</comment>
<comment>WG3:W23-014</comment>
<comment>Email from: Stefan Plantikow, 2023-11-21 1054</comment>
<subClause id="gql_names">
<clauseHeading>Names and variables</clauseHeading>

<bodyMatter>


<Function>

<para>Specify names and variables.
</para>

</Function>


<Format>

<grammar>

<comment>WG3:CMN-060</comment>
<BNFdef name="authorization identifier">
<rhs>
<BNF name="identifier"/>
</rhs>
</BNFdef>

<BNFdef name="object name">
<rhs>
<BNF name="identifier"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-039R1</comment>
<BNFdef name="object name or binding variable">
<rhs>
<BNF name="regular identifier"/>
</rhs>
</BNFdef>

<comment>WG3:W22-051</comment>
<BNFdef name="directory name">
<rhs>
<BNF name="identifier"/>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-10-01 directory name</comment>
<BNFdef name="schema name">
<rhs>
<BNF name="identifier"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-039R1</comment>
<BNFdef name="graph name">
<rhs>
<alt> <BNF name="regular identifier"/> </alt>
<alt> <BNF name="delimited graph name"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-039R1</comment>
<BNFdef name="delimited graph name">
<rhs>
<BNF name="delimited identifier"/>
</rhs>
</BNFdef>

<comment>WG3:MMX-028R2</comment>
<BNFdef name="graph type name">
<rhs>
<BNF name="identifier"/>
</rhs>
</BNFdef>
<comment>WG3:W26-022R1 Removed 1 (one) production</comment>

<comment>WG3:W26-022R2</comment>
<BNFdef name="node type name">
<rhs>
<BNF name="identifier"/>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="edge type name">
<rhs>
<BNF name="identifier"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-039R1</comment>
<BNFdef name="binding table name">
<rhs>
<alt> <BNF name="regular identifier"/> </alt>
<alt> <BNF name="delimited binding table name"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-039R1</comment>
<BNFdef name="delimited binding table name">
<rhs>
<BNF name="delimited identifier"/>
</rhs>
</BNFdef>

<BNFdef name="procedure name">
<rhs>
<BNF name="identifier"/>
</rhs>
</BNFdef>
<comment>WG3:UTC-039R1 Deleted 1 (one) production</comment>

<BNFdef name="label name">
<rhs><BNF name="identifier"/> </rhs>
</BNFdef>

<BNFdef name="property name">
<rhs><BNF name="identifier"/>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-10-09 Added field name</comment>
<BNFdef name="field name">
<rhs>
<BNF name="identifier"/>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-04-24 Moved dollar sign out</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-15 Added dollar sign to parameter name</comment>
<comment>WG3:W17-027</comment>
<comment>WG3:CMN-061R1</comment>
<BNFdef name="parameter name">
<rhs>
<BNF name="separated identifier"/>
</rhs>
</BNFdef>
<comment>WG3:CMN-019 426. P00-USA-185 Removed 1 (one) unused production</comment>

<comment>WG3:RKE-031</comment>
<BNFdef name="graph pattern variable">
<rhs>
<alt> <BNF name="element variable"/> </alt>
<alt> <BNF name="path or subpath variable"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:RKE-031</comment>
<BNFdef name="path or subpath variable">
<rhs>
<alt> <BNF name="path variable"/> </alt>
<alt> <BNF name="subpath variable"/> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-09-24 Moved</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W17-027</comment>
<comment>WG3:W22-053R2</comment>
<BNFdef name="element variable">
<rhs>
<BNF name="binding variable"/>
</rhs>
</BNFdef>

<comment>WG3:SXM-052</comment>
<comment>WG3:W17-027</comment>
<comment>WG3:W22-053R2</comment>
<BNFdef name="path variable">
<rhs>
<BNF name="binding variable"/>
</rhs>
</BNFdef>

<comment>WG3:SXM-052</comment>
<comment>WG3:W17-027</comment>
<comment>WG3:W22-053R2</comment>
<comment>WG3:UTC-080</comment>
<BNFdef name="subpath variable">
<rhs>
<BNF name="regular identifier"/>
</rhs>
</BNFdef>
<comment>Editorial: Stefan Plantikow, 2023-02-24 Deleted 1 (one) editor's note</comment>

<comment>WG3:W17-027</comment>
<comment>WG3:W22-053R2</comment>
<BNFdef name="binding variable">
<rhs>
<BNF name="regular identifier"/>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:CMN-060</comment>
<item>The <BNF name="identifier"/>s that are valid <BNF name="authorization identifier"/>s are 
<impDef code="IV015"/>.
</item>

<comment>WG3:W23-014</comment>
<comment>WG3:UTC-095</comment>
<comment>WG3:W26-037R3</comment>
<item>The <newterm>name</newterm> specified by a <BNF name="delimited identifier"/> or 
a <BNF name="non-delimited identifier"/> <symdef>DIONDI</symdef> is the canonical name form of 
<sym>DIONDI</sym>.

<note>See <itemref ref="gql_canonical_name" type="SR"/> of <specref ref="gql_token"/> for the 
definition of canonical name form.
</note>

</item>

<comment>WG3:UTC-095</comment>
<item>A <newterm>system-generated name</newterm> is the canonical name form of 
a system-generated identifier.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:CMN-060</comment>
<item>An <BNF name="authorization identifier"/> identifies a principal and a set of privileges for
that principal.
</item>

<comment>Editorial: Stefan Plantikow, 2022-08-17 Correct to use GQL-object</comment>
<item>An <BNF name="object name"/> identifies a GQL-object.
</item>

<comment>WG3:UTC-039R1</comment>
<item>An <BNF name="object name or binding variable"/> identifies a GQL-object or
a binding variable.
</item>

<comment>WG3:W22-051</comment>
<item>A <BNF name="directory name"/> identifies a GQL-directory.
</item>

<comment>WG3:W22-053R2</comment>
<item>A <BNF name="schema name"/> identifies a GQL-schema.
</item>

<comment>Editorial: Stefan Plantikow, 2020-10-01 Removed directory</comment>
<item>A <BNF name="graph name"/> identifies a graph.
</item>

<comment>WG3:UTC-039R1</comment>
<item>A <BNF name="delimited graph name"/> identifies a graph.
</item>

<comment>WG3:W22-053R2</comment>
<item>A <BNF name="graph type name"/> identifies a graph type.
</item>
<comment>WG3:W26-022R2 Removed 1 (one) General Rule</comment>

<comment>WG3:W26-022R2</comment>
<item>A <BNF name="node type name"/> identifies a node type.
</item>

<comment>WG3:W26-022R2</comment>
<item>An <BNF name="edge type name"/> identifies an edge type.
</item>

<item>A <BNF name="binding table name"/> identifies a binding table.
</item>

<comment>WG3:UTC-039R1</comment>
<item>A <BNF name="delimited binding table name"/> identifies a binding table.
</item>

<item>A <BNF name="procedure name"/> identifies a procedure.
</item>
<comment>WG3:UTC-039R1 Deleted 1 (one) GR</comment>

<item>A <BNF name="label name"/> identifies a label.
</item>

<comment>WG3:W22-053R2</comment>
<item>A <BNF name="property name"/> identifies a property of a GQL-object.
</item>

<comment>WG3:W22-053R2</comment>
<item>A <BNF name="field name"/> identifies a field of a record, a field type of a record, or 
a column of a binding table.
</item>

<item>A <BNF name="parameter name"/> identifies a parameter.
</item>

<comment>WG3:W22-053R2</comment>
<comment>WG3:UTC-039R1</comment>
<comment>WG3:CMN-019 426. P00-USA-185</comment>
<item> A variable is a graph variable, a graph pattern variable, a binding table variable, 
a value variable, or a binding variable.
</item>

<comment>WG3:W22-053R2</comment>
<comment>WG3:UTC-080</comment>
<item>A <BNF name="graph pattern variable"/> identifies a graph pattern variable. 
A graph pattern variable is an element variable, a path variable, or a subpath variable.
</item>

<comment>WG3:W22-053R2</comment>
<item>A <BNF name="path or subpath variable"/> identifies a path variable or a subpath variable.
</item>

<comment>WG3:SXM-052</comment>
<comment>WG3:W12-033: Stefan Plantikow</comment>
<comment>WG3:W20-022</comment>
<comment>WG3:W22-053R2</comment>
<item>An <BNF name="element variable"/> identifies an element variable.
</item>

<comment>WG3:SXM-052</comment>
<comment>WG3:BER-031</comment>
<comment>WG3:W22-053R2</comment>
<item>A <BNF name="path variable"/> identifies a path variable.
Path variables are binding variables.
</item>

<comment>WG3:SXM-052</comment>
<comment>WG3:BER-031</comment>
<comment>WG3:RKE-031</comment>
<comment>WG3:W22-053R2</comment>
<comment>WG3:UTC-080</comment>
<item>A <BNF name="subpath variable"/> identifies a subpath variable.
</item>

<comment>WG3:W22-053R2</comment>
<comment>WG3:UTC-039R1</comment>
<item>A <BNF name="binding variable"/> identifies a binding variable. 
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_literals" newpage="true">
<clauseHeading><BNF name="literal"/></clauseHeading>

<bodyMatter>

<ednote id="gql_W26_026_1">This Subclause is very long and would benefit from factoring out 
larger groups of types.
See <PPref ref="PPgql375"/>
</ednote>

<Function>

<para>Specify a value.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="literal">
<rhs>
<alt> <BNF name="signed numeric literal"/> </alt>
<alt> <BNF name="general literal"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:CMN-019 P00-USA-176</comment>
<BNFdef name="unsigned literal">
<rhs>
<alt> <BNF name="unsigned numeric literal"/> </alt>
<alt> <BNF name="general literal"/> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow 2020-10-09 Added ordered set</comment>
<comment>Editorial: Stefan Plantikow 2020-10-09 Added record</comment>
<comment>WG3:BER-038R1</comment>
<comment>WG3:BER-094R1</comment>
<comment>WG3:W22-036</comment>
<comment>Editorial: Stefan Plantikow 2020-10-09 Added null literal</comment>
<comment>consistent use of "byte string": Stefan Plantikow 2021-06-23</comment>
<comment>WG3:CMN-019 P00-USA-175</comment>
<BNFdef name="general literal">
<rhs>
<alt> <BNF name="boolean literal"/> </alt>
<alt> <BNF name="character string literal"/> </alt>
<alt> <BNF name="byte string literal"/> </alt>
<alt> <BNF name="temporal literal"/> </alt>
<alt> <BNF name="duration literal"/> </alt>
<alt> <BNF name="null literal"/> </alt>
<alt> <BNF name="list literal"/> </alt>
<alt> <BNF name="record literal"/> </alt>
</rhs>
</BNFdef>
<comment>WG3:CMN-019 P00-USA-175 1 (One) production removed</comment>
<comment>WG3:CMN-019 P00-USA-176 moved one production</comment>

<comment>WG3:JCJ-010R1</comment>
<BNFdef name="boolean literal">
<rhs>
<alt br="no"> <kw>TRUE</kw> </alt>
<alt br="no"> <kw>FALSE</kw> </alt>
<alt br="no"> <kw>UNKNOWN</kw> </alt>
</rhs>
</BNFdef>

<comment>WG3:W17-027</comment>
<BNFdef name="character string literal">
<rhs>
<alt> <BNF name="single quoted character sequence"/> </alt>
<alt> <BNF name="double quoted character sequence"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W17-027</comment>
<comment>WG3:UTC-044</comment>
<comment>WG3:W25-015</comment>
<BNFdef name="single quoted character sequence">
<rhs>
<opt> <BNF name="no escape"/> </opt> <BNF name="unbroken single quoted character sequence"/>
</rhs>
</BNFdef>

<comment>WG3:W17-027</comment>
<comment>WG3:UTC-044</comment>
<comment>WG3:W25-015</comment>
<BNFdef name="double quoted character sequence">
<rhs>
<opt> <BNF name="no escape"/> </opt> <BNF name="unbroken double quoted character sequence"/>
</rhs>
</BNFdef>

<comment>WG3:W23-014</comment>
<comment>WG3:UTC-044</comment>
<comment>WG3:W25-015</comment>
<BNFdef name="accent quoted character sequence">
<rhs>
<opt> <BNF name="no escape"/> </opt> <BNF name="unbroken accent quoted character sequence"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-044</comment>
<BNFdef name="no escape">
<rhs>
<BNF name="commercial at"/>
</rhs>
</BNFdef>

<comment>WG3:W17-027</comment>
<BNFdef name="unbroken single quoted character sequence">
<rhs>
<BNF name="quote"/>
<opt> <BNF name="single quoted character representation"/><repeat/> </opt>
<BNF name="quote"/>
</rhs>
</BNFdef>

<comment>WG3:W17-027</comment>
<BNFdef name="unbroken double quoted character sequence">
<rhs>
<BNF name="double quote"/>
<opt> <BNF name="double quoted character representation"/><repeat/> </opt>
<BNF name="double quote"/>
</rhs>
</BNFdef>

<comment>WG3:W17-027</comment>
<BNFdef name="unbroken accent quoted character sequence">
<rhs>
<BNF name="grave accent"/>
<opt> <BNF name="accent quoted character representation"/><repeat/> </opt>
<BNF name="grave accent"/>
</rhs>
</BNFdef>

<comment>WG3:W17-027</comment>
<comment>WG3:W25-015</comment>
<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<bar note="Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references"/>
<BNFdef name="single quoted character representation">
<rhs>
<alt><BNF name="character representation"/></alt>
<alt><BNF name="double single quote"/></alt>
<linebreak/>
<seeTheRules><itemref ref="gql_lit_sqcr" type="SR"/></seeTheRules>
</rhs>
</BNFdef>

<comment>WG3:W17-027</comment>
<comment>WG3:W25-015</comment>
<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<BNFdef name="double quoted character representation">
<rhs>
<alt><BNF name="character representation"/></alt>
<alt><BNF name="double double quote"/></alt>
<linebreak/>
<seeTheRules><itemref ref="gql_lit_dqcr" type="SR"/></seeTheRules>
</rhs>
</BNFdef>

<comment>WG3:W17-027</comment>
<comment>WG3:W25-015</comment>
<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<BNFdef name="accent quoted character representation">
<rhs>
<alt><BNF name="character representation"/></alt>
<alt><BNF name="double grave accent"/></alt>
<linebreak/>
<seeTheRules><itemref ref="gql_lit_aqcr" type="SR"/></seeTheRules>
</rhs>
</BNFdef>

<comment>WG3:UTC-044</comment>
<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<BNFdef name="character representation">
<rhs>
<seeTheRules><itemref ref="gql_lit_cr" type="SR"/></seeTheRules>
</rhs>
</BNFdef>

<comment>WG3:W25-015</comment>
<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<BNFdef name="double single quote">
<rhs>
<BNF name="quote"/> <BNF name="quote"/>
<linebreak/>
<seeTheRules><itemref ref="gql_lit_dsq" type="SR"/></seeTheRules>
</rhs>
</BNFdef>

<comment>WG3:W25-015</comment>
<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<BNFdef name="double double quote">
<rhs>
<BNF name="double quote"/> <BNF name="double quote"/> 
<linebreak/>
<seeTheRules><itemref ref="gql_lit_ddq" type="SR"/></seeTheRules>
</rhs>
</BNFdef>

<comment>WG3:W25-015</comment>
<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<BNFdef name="double grave accent">
<rhs>
<BNF name="grave accent"/> <BNF name="grave accent"/> 
<linebreak/>
<seeTheRules><itemref ref="gql_lit_dga" type="SR"/></seeTheRules>
</rhs>
</BNFdef>

<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<BNFdef name="string literal character">
<rhs>
<seeTheRules><itemref ref="gql_lit_slc" type="SR"/></seeTheRules>
</rhs>
</BNFdef>
<endbar/>

<comment>WG3:W21-059</comment>
<BNFdef name="escaped character">
<rhs>
<alt> <BNF name="escaped reverse solidus"/> </alt>
<alt> <BNF name="escaped quote"/> </alt>
<alt> <BNF name="escaped double quote"/> </alt>
<alt> <BNF name="escaped grave accent"/> </alt>
<alt> <BNF name="escaped tab"/> </alt>
<alt> <BNF name="escaped backspace"/> </alt>
<alt> <BNF name="escaped newline"/> </alt>
<alt> <BNF name="escaped carriage return"/> </alt>
<alt> <BNF name="escaped form feed"/> </alt>
<alt> <BNF name="unicode escape value"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="escaped reverse solidus">
<rhs>
<BNF name="reverse solidus"/> <BNF name="reverse solidus"/>
</rhs>
</BNFdef>

<BNFdef name="escaped quote">
<rhs>
<BNF name="reverse solidus"/> <BNF name="quote"/>
</rhs>
</BNFdef>

<comment>Editorial: Stephen Cannan 2020-05-14 Remove SQL_MODE</comment>
<BNFdef name="escaped double quote">
<rhs>
<BNF name="reverse solidus"/> <BNF name="double quote"/>
</rhs>
</BNFdef>

<comment>WG3:W21-059</comment>
<comment>WG3:UTC-074</comment>
<BNFdef name="escaped grave accent">
<rhs>
<BNF name="reverse solidus"/> <BNF name="grave accent"/>
</rhs>
</BNFdef>

<BNFdef name="escaped tab">
<rhs>
<BNF name="reverse solidus"/> <terminalsymbol>t</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="escaped backspace">
<rhs>
<BNF name="reverse solidus"/> <terminalsymbol>b</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="escaped newline">
<rhs>
<BNF name="reverse solidus"/> <terminalsymbol>n</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="escaped carriage return">
<rhs>
<BNF name="reverse solidus"/> <terminalsymbol>r</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="escaped form feed">
<rhs>
<BNF name="reverse solidus"/> <terminalsymbol>f</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="unicode escape value">
<rhs>
<alt> <BNF name="unicode 4 digit escape value"/> </alt>
<alt> <BNF name="unicode 6 digit escape value"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="unicode 4 digit escape value">
<rhs>
<BNF name="reverse solidus"/> <terminalsymbol>u</terminalsymbol> <BNF name="hex digit"/>
<BNF name="hex digit"/> <BNF name="hex digit"/> <BNF name="hex digit"/>
</rhs>
</BNFdef>

<BNFdef name="unicode 6 digit escape value">
<rhs>
<BNF name="reverse solidus"/> <terminalsymbol>U</terminalsymbol>
<BNF name="hex digit"/> <BNF name="hex digit"/> <BNF name="hex digit"/> <BNF name="hex digit"/> 
<breakindent/> 
<BNF name="hex digit"/> <BNF name="hex digit"/>
</rhs>
</BNFdef>

<comment>consistent use of "byte string": Stefan Plantikow 2021-06-23</comment>
<bar note="WG3:XRH-037"/>
<comment>WG3:XRH-037</comment>
<BNFdef name="byte string literal">
<rhs>
<BNF name="byte string introducer"/> <BNF name="quote"/> 
<opt> <BNF name="space"/><repeat/> </opt>
<linebreak/>
<opt> 
<group> 
<BNF name="hex digit"/> <opt> <BNF name="space"/><repeat/> </opt>
<BNF name="hex digit"/> <opt> <BNF name="space"/><repeat/> </opt> 
</group><repeat/>
</opt>
<BNF name="quote"/>
<linebreak/>
<opt>
<group> <BNF name="separator"/> <BNF name="quote"/> <opt> <BNF name="space"/><repeat/>
</opt>
<opt> <group> <BNF name="hex digit"/> <opt> <BNF name="space"/><repeat/> </opt>
<breakindent/>
<BNF name="hex digit"/> <opt> <BNF name="space"/><repeat/> </opt> </group><repeat/> </opt>
<BNF name="quote"/> </group><repeat/> </opt>
</rhs>
</BNFdef>

<comment>WG3:XRH-037</comment>
<BNFdef name="byte string introducer">
<rhs>
<alt br="no"><terminalsymbol>X</terminalsymbol></alt>
<alt br="no"><terminalsymbol>x</terminalsymbol></alt>
</rhs>
</BNFdef>

<endbar/>

<BNFdef name="signed numeric literal">
<rhs>
<opt> <BNF name="sign"/> </opt> <BNF name="unsigned numeric literal"/>
</rhs>
</BNFdef>

<BNFdef name="sign">
<rhs>
<alt> <BNF name="plus sign"/> </alt>
<alt> <BNF name="minus sign"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="unsigned numeric literal">
<rhs>
<alt> <BNF name="exact numeric literal"/> </alt>
<alt> <BNF name="approximate numeric literal"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:MMX-011R1 2020-06-14</comment>
<comment>WG3:UTC-074</comment>
<comment>Editorial: Stefan Plantikow, 2023-02-28 WG3:UTC-074</comment>
<comment>WG3:W26-023</comment>
<BNFdef name="exact numeric literal">
<rhs>
<alt> 
<BNF name="unsigned decimal in scientific notation"/> <BNF name="exact number suffix"/>
</alt>
<alt> 
<BNF name="unsigned decimal in common notation"/> <opt> <BNF name="exact number suffix"/> </opt> 
</alt>
<alt> <BNF name="unsigned decimal integer"/> <BNF name="exact number suffix"/> </alt>
<alt> <BNF name="unsigned integer"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-074</comment>
<bar note="WG3:XRH-037"/>
<comment>WG3:XRH-037</comment>
<BNFdef name="exact number suffix">
<rhs>
<alt br="no"><terminalsymbol>M</terminalsymbol></alt>
<alt br="no"><terminalsymbol>m</terminalsymbol></alt>
</rhs>
</BNFdef>
<endbar/>

<comment>Editorial: Stefan Plantikow, 2023-02-08 Resolve 944. P00-USA-443</comment>
<comment>WG3:UTC-074</comment>
<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<bar note="WG3:XRH-037" colour="cyan"/>
<comment>WG3:XRH-037</comment>
<bar note="Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references"/>
<BNFdef name="unsigned decimal in scientific notation">
<rhs>
<BNF name="mantissa"/><BNF name="exponent introducer"/><BNF name="exponent"/>
</rhs>
</BNFdef>
<endbar/>

<comment>WG3:XRH-037</comment>
<BNFdef name="exponent introducer">
<rhs>
<alt br="no"><terminalsymbol>E</terminalsymbol></alt>
<alt br="no"><terminalsymbol>e</terminalsymbol></alt>
</rhs>
</BNFdef>
<endbar/>

<comment>WG3:W26-023</comment>
<BNFdef name="mantissa">
<rhs>
<alt> <BNF name="unsigned decimal in common notation"/> </alt>
<alt> <BNF name="unsigned decimal integer"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:MMX-011R1, 2020-06-14</comment>
<BNFdef name="exponent">
<rhs>
<BNF name="signed decimal integer"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-074</comment>
<comment>WG3:W26-023</comment>
<comment>Editorial: Stephen Cannan, 2024-05-06 Correct error in WG3:UTC-074</comment>
<BNFdef name="unsigned decimal in common notation">
<rhs>
<alt> <BNF name="unsigned decimal integer"/> <BNF name="period"/> 
<opt> <BNF name="unsigned decimal integer"/> </opt> 
</alt>
<alt> <BNF name="period"/> <BNF name="unsigned decimal integer"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:MMX-011R1 2020-06-14</comment>
<BNFdef name="unsigned integer">
<rhs>
<alt> <BNF name="unsigned decimal integer"/> </alt>
<alt> <BNF name="unsigned hexadecimal integer"/> </alt>
<alt> <BNF name="unsigned octal integer"/> </alt>
<alt> <BNF name="unsigned binary integer"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:MMX-011R1, 2020-06-14</comment>
<comment>WG3:W26-023</comment>
<BNFdef name="signed decimal integer">
<rhs>
<opt> <BNF name="sign"/> </opt> <BNF name="unsigned decimal integer"/>
</rhs>
</BNFdef>

<comment>WG3:MMX-011R1, 2020-06-14</comment>
<BNFdef name="unsigned decimal integer">
<rhs>
<BNF name="digit"/>
<opt> <group> <opt> <BNF name="underscore"/> </opt> <BNF name="digit"/> </group><repeat/> </opt>
</rhs>
</BNFdef>

<comment>WG3:MMX-011R1, 2020-06-14</comment>
<comment>WG3:W12-028r1: Stefan Plantikow, 2021-06-16 Aligning unsigned integer with SQL</comment>
<BNFdef name="unsigned hexadecimal integer">
<rhs>
<terminalsymbol>0x</terminalsymbol>
<group> <opt> <BNF name="underscore"/> </opt> <BNF name="hex digit"/> </group><repeat/>
</rhs>
</BNFdef>

<comment>WG3:MMX-011R1, 2020-06-14</comment>
<comment>WG3:W12-028r1: Stefan Plantikow, 2021-06-16 Aligning unsigned integer with SQL</comment>
<BNFdef name="unsigned octal integer">
<rhs>
<terminalsymbol>0o</terminalsymbol>
<group> <opt> <BNF name="underscore"/> </opt> <BNF name="octal digit"/> </group><repeat/>
</rhs>
</BNFdef>

<comment>WG3:MMX-011R1, 2020-06-14</comment>
<comment>WG3:W12-028r1: Stefan Plantikow, 2021-06-16 Aligning unsigned integer with SQL</comment>
<BNFdef name="unsigned binary integer">
<rhs>
<terminalsymbol>0b</terminalsymbol>
<group> <opt> <BNF name="underscore"/> </opt> <BNF name="binary digit"/> </group><repeat/>
</rhs>
</BNFdef>

<comment>WG3:UTC-074</comment>
<comment>WG3:W26-023</comment>
<BNFdef name="approximate numeric literal">
<rhs>
<alt> 
<BNF name="unsigned decimal in scientific notation"/> 
<opt> <BNF name="approximate number suffix"/> </opt>
</alt>
<alt> 
<BNF name="unsigned decimal in common notation"/> <BNF name="approximate number suffix"/>
</alt>
<alt> <BNF name="unsigned decimal integer"/> <BNF name="approximate number suffix"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-074</comment>
<bar note="WG3:XRH-037"/>
<comment>WG3:XRH-037</comment>
<BNFdef name="approximate number suffix">
<rhs>
<alt br="no"> <terminalsymbol>F</terminalsymbol> </alt> 
<alt br="no"> <terminalsymbol>d</terminalsymbol> </alt> 
<alt br="no"> <terminalsymbol>D</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>d</terminalsymbol> </alt> 
</rhs>
</BNFdef>

<endbar/>

<comment>WG3:UTC-117</comment>
<BNFdef name="temporal literal">
<rhs>
<alt> <BNF name="date literal"/> </alt>
<alt> <BNF name="time literal"/> </alt>
<alt> <BNF name="datetime literal"/> </alt>
<alt> <BNF name="SQL-datetime literal"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="date literal">
<rhs>
<kw>DATE</kw> <BNF name="date string"/>
</rhs>
</BNFdef>

<BNFdef name="time literal">
<rhs>
<kw>TIME</kw> <BNF name="time string"/>
</rhs>
</BNFdef>

<BNFdef name="datetime literal">
<rhs>
<group> <alt br="no"> <kw>DATETIME</kw> </alt> <alt br="no"> <kw>TIMESTAMP</kw> </alt> </group>
<BNF name="datetime string"/>
</rhs>
</BNFdef>

<comment>WG3:W26-023</comment>
<BNFdef name="date string">
<rhs>
<BNF name="character string literal"/>
</rhs>
</BNFdef>

<comment>WG3:W26-023</comment>
<BNFdef name="time string">
<rhs>
<BNF name="character string literal"/>
</rhs>
</BNFdef>

<comment>WG3:W26-023</comment>
<BNFdef name="datetime string">
<rhs>
<BNF name="character string literal"/>
</rhs>
</BNFdef>

<comment>WG3:CMN-061R1</comment>
<comment>WG3:W26-023</comment>
<BNFdef name="time zone string">
<rhs>
<BNF name="character string literal"/>
</rhs>
</BNFdef>

<comment>WG3:UTC-117</comment>
<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<bar note="Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references"/>
<BNFdef name="SQL-datetime literal">
<rhs>
<seeTheRules><itemref ref="gql_lit_sql_dt" type="SR"/></seeTheRules>
</rhs>
</BNFdef>
<endbar/>

<BNFdef name="duration literal">
<rhs>
<alt> <kw>DURATION</kw> <BNF name="duration string"/> </alt>
<alt> <BNF name="SQL-interval literal"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W26-023</comment>
<BNFdef name="duration string">
<rhs>
<BNF name="character string literal"/>
</rhs>
</BNFdef>

<comment>WG3:CMN-048</comment>
<BNFdef name="iso8601 years and months">
<rhs>
<terminalsymbol>P</terminalsymbol>
<opt><BNF name="iso8601 years"/></opt>
<opt><BNF name="iso8601 months"/></opt>
</rhs>
</BNFdef>

<comment>WG3:CMN-048</comment>
<BNFdef name="iso8601 years">
<rhs>
<BNF name="iso8601 sint"/>
<terminalsymbol>Y</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:CMN-048</comment>
<BNFdef name="iso8601 months">
<rhs>
<BNF name="iso8601 sint"/>
<terminalsymbol>M</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:CMN-048</comment>
<BNFdef name="iso8601 days">
<rhs>
<BNF name="iso8601 sint"/>
<terminalsymbol>D</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:CMN-048</comment>
<BNFdef name="iso8601 days and time">
<rhs>
<terminalsymbol>P</terminalsymbol>
<opt><BNF name="iso8601 days"/></opt>
<terminalsymbol>T</terminalsymbol>
<opt><BNF name="iso8601 hours"/></opt>
<opt><BNF name="iso8601 minutes"/></opt>
<opt><BNF name="iso8601 seconds"/></opt>
</rhs>
</BNFdef>

<comment>WG3:CMN-048</comment>
<BNFdef name="iso8601 hours">
<rhs>
<BNF name="iso8601 sint"/>
<terminalsymbol>H</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:CMN-048</comment>
<BNFdef name="iso8601 minutes">
<rhs>
<BNF name="iso8601 sint"/>
<terminalsymbol>M</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:CMN-048</comment>
<BNFdef name="iso8601 seconds">
<rhs>
<BNF name="iso8601 sint"/>
<opt><BNF name="period"/> <BNF name="iso8601 uint"/></opt>
<terminalsymbol>S</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:CMN-048</comment>
<BNFdef name="iso8601 sint">
<rhs>
<opt><BNF name="minus sign"/></opt> <BNF name="unsigned decimal integer"/>
</rhs>
</BNFdef>

<comment>WG3:CMN-048</comment>
<BNFdef name="iso8601 uint">
<rhs>
<BNF name="unsigned decimal integer"/>
</rhs>
</BNFdef>

<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<bar note="Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references"/>
<BNFdef name="SQL-interval literal">
<rhs>
<seeTheRules><itemref ref="gql_lit_sql_il" type="SR"/></seeTheRules>
</rhs>
</BNFdef>
<endbar/>

<comment>Editorial: Stefan Plantikow, 2020-10-09 Added null literal</comment>
<BNFdef name="null literal">
<rhs>
<kw>NULL</kw>
</rhs>
</BNFdef>

<BNFdef name="list literal">
<rhs>
<BNF name="list value constructor by enumeration"/>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-10-09 Added record literal</comment>
<comment>WG3:BER-040R3</comment>
<BNFdef name="record literal">
<rhs>
<BNF name="record constructor"/>
</rhs>
</BNFdef>

</grammar>

<ednote id="gql_LO373"><PPref ref="PPgql373"/> questions the naming of some BNF terms.
See <PPref ref="PPgql373"/>.
</ednote>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:UTC-074</comment>
<item>In an <BNF name="unsigned hexadecimal integer"/>, <BNF name="unsigned octal integer"/>, or 
<BNF name="unsigned binary integer"/>, there shall be no <BNF name="separator"/> between the 
radix indicators <quote>0x</quote>, <quote>0o</quote>, <quote>0b</quote> and the first 
<BNF name="hex digit"/>, <BNF name="octal digit"/>, <BNF name="binary digit"/>, or 
<BNF name="underscore"/>.
</item>

<comment>WG3:MMX-011R1, 2020-06-14</comment>
<item>An <BNF name="unsigned decimal integer"/> that immediately contains
<BNF name="underscore"/>s is equivalent to the same <BNF name="unsigned decimal integer"/> 
with every <BNF name="underscore"/> removed.
</item>

<comment>WG3:MMX-011R1, 2020-06-14</comment>
<item>An <BNF name="unsigned hexadecimal integer"/> that immediately contains 
<BNF name="underscore"/>s is equivalent to the same <BNF name="unsigned hexadecimal integer"/>
with every <BNF name="underscore"/> removed.
</item>

<comment>WG3:MMX-011R1, 2020-06-14</comment>
<item>An <BNF name="unsigned octal integer"/> that immediately contains <BNF name="underscore"/>s
is equivalent to the same <BNF name="unsigned octal integer"/> with every
<BNF name="underscore"/> removed.
</item>

<comment>WG3:MMX-011R1, 2020-06-14</comment>
<item>An <BNF name="unsigned binary integer"/> that immediately contains <BNF name="underscore"/>s 
is equivalent to the same <BNF name="unsigned binary integer"/> with every
<BNF name="underscore"/> removed.
</item>

<comment>WG3:MMX-011R1, 2020-06-14</comment>
<comment>Editorial: Stefan Plantikow, 2022-11-21 WG3:W23-009 945. P00-USA-444</comment>
<item>An <BNF name="unsigned hexadecimal integer"/> is equivalent to 
an <BNF name="unsigned decimal integer"/> containing a series of <BNF name="digit"/>s that 
represent the same integer number as the series of <BNF name="hex digit"/>s.
</item>

<comment>WG3:MMX-011R1, 2020-06-14</comment>
<comment>Editorial: Stefan Plantikow, 2022-11-21 WG3:W23-009 945. P00-USA-444</comment>
<item>An <BNF name="unsigned octal integer"/> is equivalent to 
an <BNF name="unsigned decimal integer"/> containing a series of <BNF name="digit"/>s that 
represent the same integer number as the series of <BNF name="octal digit"/>s.
</item>

<comment>WG3:MMX-011R1, 2020-06-14</comment>
<comment>Editorial: Stefan Plantikow, 2022-11-21 WG3:W23-009 945. P00-USA-444</comment>
<item>An <BNF name="unsigned binary integer"/> is equivalent to 
an <BNF name="unsigned decimal integer"/> containing a series of <BNF name="digit"/>s that 
represent the same integer number as the series of <BNF name="binary digit"/>s.
</item>

<comment>WG3:XRH-037 Removed 2 (two) SRs</comment>
<delbar note="WG3:XRH-037 Removed 2 (two) SRs"/>

<comment>WG3:UTC-074</comment>
<item>There shall be no <BNF name="separator"/> before the <BNF name="approximate number suffix"/> 
in an <BNF name="approximate numeric literal"/>.
</item>

<comment>WG3:W26-023</comment>
<item>If an <BNF name="exact numeric literal"/> <symdef>ENL</symdef> is specified that immediately 
contains an <BNF name="unsigned decimal in scientific notation"/> <symdef>UDSN</symdef> then:

<olist>

<item>Let <symdef>M</symdef> and <symdef>E</symdef> be the specified value of the 
<BNF name="mantissa"/> and the <BNF name="exponent"/>, respectively, that are simply contained 
in <sym>UDSN</sym>.
</item>

<item>Let <symdef>UDCN</symdef> be an <BNF name="unsigned decimal in common notation"/> whose 
specified value is <sym>M</sym> &times; 10<super><sym>E</sym></super>.
</item>

<item><sym>ENL</sym> is effectively replaced by:

<code>
<sym>UDCN</sym>
</code>

</item>

</olist>

</item>

<comment>WG3:W26-023</comment>
<item>If an <BNF name="approximate numeric literal"/> <symdef>ANL</symdef> is specified that does 
not immediately contain an <BNF name="unsigned decimal in scientific notation"/>, then:

<olist>

<item>Let <symdef>DIGITS_BEFORE</symdef> and <symdef>DIGITS_AFTER</symdef> be the sequence of 
all <BNF name="digit"/>s specified by <sym>ANL</sym> before, and, respectively, after the 
decimal point but with all leading and, respectively, trailing zero digits removed.
</item>

<item>Let <symdef>M</symdef> be defined as the concatenation of <sym>DIGITS_BEFORE</sym> and 
<sym>DIGITS_AFTER</sym>.
</item>

<item>Let <symdef>E</symdef> be an <BNF name="unsigned integer"/> whose specified value is 
the negated length of <sym>DIGITS_AFTER</sym>.
</item>

<item><sym>ANL</sym> is effectively replaced by:

<code>
<sym>M</sym> E <sym>E</sym>
</code>

</item>

</olist>

</item>

<item>The maximum number of <BNF name="digit"/>s immediately contained in 
an <BNF name="unsigned integer"/> is <impDef code="IL010"/> but shall not be less than 9.
</item>

<comment>WG3:UTC-074</comment>
<item>An <BNF name="exact numeric literal"/> that is an <BNF name="unsigned decimal integer"/> has 
an implicit <BNF name="period"/> following the last <BNF name="digit"/>.
</item>

<comment>WG3:XRH-037 Removed 1 (one) SR</comment>
<delbar note="WG3:XRH-037 Removed 1 (one) SR"/>

<comment>WG3:UTC-074</comment>
<item>There shall be no <BNF name="separator"/> before the <BNF name="exact number suffix"/> in
an <BNF name="exact numeric literal"/>.
</item>

<item>The declared type of an <BNF name="exact numeric literal"/> <symdef>ENL</symdef> is 
an exact numeric type whose scale is the number of <BNF name="digit"/>s to the right of the
<BNF name="period"/>.
There shall be an exact numeric type capable of representing the value of <sym>ENL</sym> exactly.
</item>

<comment>WG3:UTC-074</comment>
<item>The declared type of an <BNF name="approximate numeric literal"/> <symdef>ANL</symdef> is
defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:CMN-019 424. P00-USA-183</comment>
<item>If <sym>ANL</sym> simply contains the <BNF name="approximate number suffix"/> 
<quote>F</quote> or <quote>f</quote>, then the declared type of <sym>ANL</sym> is the regular 
approximate numeric type.
</item>

<comment>WG3:CMN-019 424. P00-USA-183</comment>
<item>If <sym>ANL</sym> simply contains the <BNF name="approximate number suffix"/>
<quote>D</quote> or <quote>d</quote>, then the declared type of <sym>ANL</sym> is the double 
approximate numeric type.
</item>

<item>Otherwise, the declared type of <sym>ANL</sym> is an <impDef code="ID079"/> 
approximate numeric type.
</item>

</olist>

</item>

<comment>WG3:UTC-074</comment>
<comment>Editorial: Stephen Cannan, 2023-08-10</comment>
<item>The value of an <BNF name="approximate numeric literal"/> <symdef>ANL</symdef> shall not be 
greater than the maximum value or less than the minimum value that can be represented by the 
declared type of <sym>ANL</sym>.
</item>

<comment>Editorial: Stephen Cannan, 2021-04-02 See WG3:W09-024</comment>
<item>The declared type of a <BNF name="boolean literal"/> is the Boolean type.
</item>

<comment>WG3:W17-027</comment>
<comment>WG3:CMN-019 411. P00-USA-387</comment>
<item>The <BNF name="character string literal"/> specifies the character string specified by 
the immediately contained <BNF name="single quoted character sequence"/> or 
the immediately contained <BNF name="double quoted character sequence"/>.
</item>

<comment>WG3:W17-027</comment>
<comment>WG3:W25-015</comment>
<comment>WG3:CMN-019 411. P00-USA-387</comment>
<item>The <BNF name="single quoted character sequence"/> specifies the character string specified by
the immediately contained <BNF name="unbroken single quoted character sequence"/>.
</item>

<comment>WG3:W17-027</comment>
<comment>WG3:W25-015</comment>
<comment>WG3:CMN-019 411. P00-USA-387</comment>
<item>The <BNF name="double quoted character sequence"/> specifies the character string specified by
the immediately contained <BNF name="unbroken double quoted character sequence"/>.
</item>

<comment>WG3:W23-014</comment>
<comment>WG3:W25-015</comment>
<comment>WG3:CMN-019 411. P00-USA-387</comment>
<item>The <BNF name="accent quoted character sequence"/> specifies the character string specified by
the immediately contained <BNF name="unbroken accent quoted character sequence"/>.
</item>

<comment>WG3:W17-027</comment>
<comment>WG3:CMN-019 411. P00-USA-387</comment>
<item>The <BNF name="unbroken single quoted character sequence"/> specifies the character string
comprising the sequence of characters defined by
the immediately contained <BNF name="single quoted character representation"/>s.
</item>

<comment>WG3:W17-027</comment>
<comment>WG3:CMN-019 411. P00-USA-387</comment>
<item>The <BNF name="unbroken double quoted character sequence"/> specifies the character string
comprising the sequence of characters defined by
the immediately contained <BNF name="double quoted character representation"/>s.
</item>

<comment>WG3:W17-027</comment>
<comment>WG3:CMN-019 411. P00-USA-387</comment>
<item>The <BNF name="unbroken accent quoted character sequence"/> specifies the character string
comprising the sequence of characters defined by
the immediately contained <BNF name="accent quoted character representation"/>s.
</item>

<comment>WG3:UTC-044</comment>
<item>There shall be no <BNF name="separator"/> between <BNF name="no escape"/> and 
an <BNF name="unbroken single quoted character sequence"/>,
<BNF name="unbroken double quoted character sequence"/>, or
<BNF name="unbroken accent quoted character sequence"/>.
</item>

<comment>WG3:UTC-044</comment>
<comment>WG3:W26-023</comment>
<item>For every BNF non-terminal instance <symdef>NT</symdef> simply contained in 
a <BNF name="single quoted character sequence"/>, <BNF name="double quoted character sequence"/>, 
or <BNF name="accent quoted character sequence"/> <symdef>CS</symdef>, if <sym>CS</sym>  
immediately contains the <BNF name="no escape"/>, then character escaping is said to be disabled 
in <sym>NT</sym>; otherwise, character escaping is said to be enabled in <sym>NT</sym>.
</item>

<comment>WG3:W17-027</comment>
<comment>WG3:UTC-044</comment>
<item id="gql_lit_sqcr">If <BNF name="single quoted character representation"/> <symdef>CR</symdef>
is specified,
then:

<olist>

<item>If character escaping is enabled in <sym>CR</sym>, then <sym>CR</sym> shall not be 
a <BNF name="quote"/> or a <BNF name="reverse solidus"/> unless either of these occurs 
as part of an <BNF name="escaped character"/>.
</item>

<item>Otherwise, character escaping is disabled in <sym>CR</sym> and <sym>CR</sym> shall not be 
a <BNF name="quote"/>.
</item>

</olist>

</item>

<comment>WG3:W17-027</comment>
<comment>WG3:UTC-044</comment>
<item id="gql_lit_dqcr">If <BNF name="double quoted character representation"/> <symdef>CR</symdef>
is specified, 
then:

<olist>

<item>If character escaping is enabled in <sym>CR</sym>, then <sym>CR</sym> shall not be 
a <BNF name="double quote"/> or a <BNF name="reverse solidus"/> unless either of these occurs 
as part of an <BNF name="escaped character"/>.
</item>

<item>Otherwise, character escaping is disabled in <sym>CR</sym> and <sym>CR</sym> shall not be 
a <BNF name="double quote"/>.
</item>

</olist>

</item>

<comment>WG3:W17-027</comment>
<comment>WG3:UTC-044</comment>
<comment>Editorial: Stefan Plantikow 2023-03-16 Replace The by If</comment>
<item id="gql_lit_aqcr">If <BNF name="accent quoted character representation"/> <symdef>CR</symdef>
is specified, 
then:

<olist>

<item>If character escaping is enabled in <sym>CR</sym>, then <sym>CR</sym> shall not be 
a <BNF name="grave accent"/> or a <BNF name="reverse solidus"/> unless either of these occurs 
as part of an <BNF name="escaped character"/>.
</item>

<item>Otherwise, character escaping is disabled in <sym>CR</sym> and <sym>CR</sym> shall not be 
a <BNF name="grave accent"/>.
</item>

</olist>

</item>

<comment>WG3:W25-015</comment>
<item>In a <BNF name="single quoted character representation"/>,
each <BNF name="double single quote"/> represents a single <BNF name="quote"/> character.
</item>

<comment>WG3:W25-015</comment>
<item>In a <BNF name="double quoted character representation"/>,
each <BNF name="double double quote"/> represents a single <BNF name="double quote"/> character.
</item>

<comment>WG3:W25-015</comment>
<item>In an <BNF name="accent quoted character representation"/>,
each <BNF name="double grave accent"/> represents a single <BNF name="grave accent"/> character.
</item>

<comment>WG3:W25-015</comment>
<item id="gql_lit_dsq">In a <BNF name="double single quote"/>, there shall be no 
<BNF name="separator"/> after the leading <BNF name="quote"/>.
</item>

<comment>WG3:W25-015</comment>
<item id="gql_lit_ddq">In a <BNF name="double double quote"/>, there shall be no 
<BNF name="separator"/> after the leading <BNF name="double quote"/>.
</item>

<comment>WG3:W25-015</comment>
<item id="gql_lit_dga">In a <BNF name="double grave accent"/>, there shall be no 
<BNF name="separator"/> after the leading <BNF name="grave accent"/>.
</item>

<comment>WG3:UTC-044</comment>
<comment>WG3:CMN-019 P00-ISO-001</comment>
<item id="gql_lit_cr">If character escaping is enabled in a <BNF name="character representation"/> 
<symdef>CR</symdef>, then <sym>CR</sym> shall conform to the Format and Syntax Rules of
a <BNF name="string literal character"/> or an <BNF name="escaped character"/>; otherwise, 
character escaping is disabled in <sym>CR</sym> and <sym>CR</sym> shall conform to the
Format and Syntax Rules of <BNF name="string literal character"/> only.
</item>

<comment>Editorial: Stephen Cannan 2021-11-12 Consequence of WG3:W17-027</comment>
<comment>WG3:W23-014</comment>
<comment>WG3:UTC-044</comment>
<item>If the <BNF name="character representation"/> <symdef>CR</symdef> is specified, then:

<olist>

<item>Case:

<olist>

<item>If character escaping is enabled in <sym>CR</sym>, then any character in <sym>CR</sym> 
except for those occurring as part of an <BNF name="escaped character"/> is considered 
a <BNF name="string literal character"/>.
</item>

<item>Otherwise, character escaping is disabled in <sym>CR</sym> and any character in <sym>CR</sym>
is considered a <BNF name="string literal character"/>.
</item>

</olist>

</item>

<item id="gql_lit_slc">For every <BNF name="string literal character"/> <symdef>CH</symdef> 
contained in <sym>CR</sym>:

<olist>

<comment>WG3:W25-015</comment>
<comment>WG3:CMN-019 P00-USA-186</comment>
<item>The character <sym>CH</sym> is a character in the GQL source text character repertoire.

<comment>WG3:W25-015</comment>
<note>The character repertoire of GQL source text is specified in
<specref ref="gql_conc_req_gendescr"/>.
</note>
</item>

<item>If <sym>CH</sym> is not <BNF name="whitespace"/>, then it shall not be in
the Unicode General Category Class <quote>Cc</quote>.

<note>In particular, this excludes BACKSPACE (<unicode>0008</unicode>).
</note>

</item>

<item>Whether <sym>CH</sym> shall not be a <BNF name="bidirectional control character"/> is
<impDef code="IA019"/>.

<note>This mitigates <docref ref="CVE-2021-42574"/>.
</note>

</item>

<item><sym>CH</sym> shall not be in the Unicode General Category Class <quote>Cn</quote>.

<comment>Editorial: Stefan Plantikow, 2022-11-16 Remove Cf as its unused here</comment>
<note>The Unicode General Category classes <quote>Cc</quote> and <quote>Cn</quote>,
are assigned to Unicode characters that are, respectively, 
Control codes (other) and Not Assigned codes.
</note>

<note>Despite these restrictions, any character can still be expressed in 
a <BNF name="character representation"/> through the use of a suitable 
<BNF name="escaped character"/>.
</note>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:UTC-074</comment>
<item>In an <BNF name="escaped character"/>, there shall be no <BNF name="separator"/> after the 
leading <BNF name="reverse solidus"/>.
</item>

<comment>Editorial: Stephen Cannan 2021-11-12 Consequence of WG3:W17-027</comment>
<item>In an <BNF name="escaped character"/>, each <BNF name="escaped reverse solidus"/>
represents a <BNF name="reverse solidus"/> character.
</item>

<comment>Editorial: Stephen Cannan 2021-11-12 Consequence of WG3:W17-027</comment>
<item>In an <BNF name="escaped character"/>, each <BNF name="escaped quote"/> represents 
a <BNF name="quote"/> character.
</item>

<comment>Editorial: Stephen Cannan 2021-11-12 Consequence of WG3:W17-027</comment>
<item>In an <BNF name="escaped character"/>, each <BNF name="escaped double quote"/>
represents a <BNF name="double quote"/> character.
</item>

<comment>WG3:W21-059</comment>
<item>In an <BNF name="escaped character"/>, each <BNF name="escaped grave accent"/>
represents a <BNF name="grave accent"/> character.
</item>

<comment>Editorial: Stephen Cannan 2021-11-12 Consequence of WG3:W17-027</comment>
<item>In an <BNF name="escaped character"/>, each <BNF name="escaped tab"/> represents the
Unicode character identified by the code point <unicode>0009</unicode>.
</item>

<comment>Editorial: Stephen Cannan 2021-11-12 Consequence of WG3:W17-027</comment>
<item>In an <BNF name="escaped character"/>, each <BNF name="escaped backspace"/> represents
the Unicode character identified by the code point <unicode>0008</unicode>.
</item>

<comment>Editorial: Stephen Cannan 2021-11-12 Consequence of WG3:W17-027</comment>
<item>In an <BNF name="escaped character"/>, each <BNF name="escaped newline"/> represents
the Unicode character identified by the code point <unicode>000A</unicode>.
</item>

<item>In an <BNF name="escaped character"/>, each <BNF name="escaped carriage return"/>
represents the Unicode character identified by the code point <unicode>000D</unicode>.
</item>

<comment>Editorial: Stephen Cannan 2021-11-12 Consequence of WG3:W17-027</comment>
<item>In an <BNF name="escaped character"/>, each <BNF name="escaped form feed"/> represents
the Unicode character identified by the code point <unicode>000C</unicode>.
</item>

<comment>Editorial: Stephen Cannan 2021-11-12 Consequence of WG3:W17-027</comment>
<item>In an <BNF name="escaped character"/>, each <BNF name="unicode escape value"/>
represents the Unicode character identified by the code point.
</item>

<comment>Editorial: Stefan Plantikow, 2021-06-19 consistent use of "character string"</comment>
<item>The declared type of a <BNF name="character string literal"/> is character string.
</item>

<comment>consistent use of "byte string": Stefan Plantikow, 2021-06-23</comment>
<item>In a <BNF name="byte string literal"/>, the sequence

<code>
<BNF name="quote"/> [ <BNF name="space"/><repeat/> ] { <BNF name="hex digit"/> [ <BNF name="space"/><repeat/> ]
<BNF name="hex digit"/> [ <BNF name="space"/><repeat/> ] }<repeat/> <BNF name="quote"/>
</code>

<para>is equivalent to the sequence
</para>

<code>
<BNF name="quote"/> { <BNF name="hex digit"/> <BNF name="hex digit"/> }<repeat/> <BNF name="quote"/>
</code>

<note>The <BNF name="hex digit"/>s in the equivalent sequence are in the same sequence and
relative sequence as in the original <BNF name="byte string literal"/>.
</note>

</item>

<item>In a <BNF name="byte string literal"/>, the sequence

<code>
<BNF name="quote"/> { <BNF name="hex digit"/> <BNF name="hex digit"/> }<repeat/> <BNF name="quote"/> <BNF name="separator"/>
<BNF name="quote"/> { <BNF name="hex digit"/> <BNF name="hex digit"/> }<repeat/> <BNF name="quote"/>
</code>

<para>is equivalent to the sequence
</para>

<code>
<BNF name="quote"/> { <BNF name="hex digit"/> <BNF name="hex digit"/> }<repeat/> { <BNF name="hex digit"/> <BNF name="hex digit"/> }<repeat/> <BNF name="quote"/>
</code>

<note>The <BNF name="hex digit"/>s in the equivalent sequence are in the same sequence and
relative sequence as in the original <BNF name="byte string literal"/>.
</note>

</item>

<comment>WG3:XRH-037 Removed 1 (one) SR</comment>
<delbar note="WG3:XRH-037 Removed 1 (one) SR"/>

<comment>WG3:W26-023</comment>
<item>In a <BNF name="byte string literal"/>, a <BNF name="separator"/> shall contain 
a <BNF name="newline"/>.
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19</comment>
<item>The declared type of a <BNF name="byte string literal"/> is a byte string type.
Each <BNF name="hex digit"/> appearing in the literal is equivalent to a quartet of bits:
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, and F are interpreted as
0000, 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100, 1101, 1110, and
1111, respectively.
The <BNF name="hex digit"/>s a, b, c, d, e, and f have respectively the same values as the
<BNF name="hex digit"/>s A, B, C, D, E, and F.
</item>

<comment>WG3:W17-027</comment>
<comment>WG3:CMN-019 P00-ISO-033</comment>
<comment>WG3:W26-023</comment>
<item>The character string specified by the <BNF name="character string literal"/> 
immediately contained in <BNF name="date string"/> shall conform to the representation specified in 
<docref ref="ISO8601-1_2019"/>, 5.2, <quote>Date</quote>, as extended by 
<docref ref="ISO8601-2_2019"/>, 4.3, <quote>Additional explicit forms</quote>, and 
<docref ref="ISO8601-2_2019"/>, 4.4, <quote>Numerical extensions</quote>.
</item>

<comment>WG3:CMN-019 424. P00-USA-183</comment>
<item>The declared type of <BNF name="date literal"/> is the date type.
</item>

<comment>WG3:CMN-061R1</comment>
<comment>WG3:W26-023</comment>
<item>The character string specified by the <BNF name="character string literal"/> 
immediately contained in <BNF name="time zone string"/> shall conform to the representation 
specified in <docref ref="ISO8601-1_2019"/>, 4.3.13, <quote>Time shift</quote>, as extended by 
<docref ref="ISO8601-2_2019"/>, 4.3, <quote>Additional explicit forms</quote>, and 
<docref ref="ISO8601-2_2019"/>, 4.4, <quote>Numerical extensions</quote>.
</item>

<comment>WG3:W17-027</comment>
<comment>WG3:CMN-019 P00-ISO-033</comment>
<comment>WG3:W26-023</comment>
<item>The character string specified by the <BNF name="character string literal"/> 
immediately contained in <BNF name="time string"/> shall conform to the representation specified in
<docref ref="ISO8601-1_2019"/>, 5.3, <quote>Time of day</quote>, as extended by 
<docref ref="ISO8601-2_2019"/>, 4.3, <quote>Additional explicit forms</quote>, and 
<docref ref="ISO8601-2_2019"/>, 4.4, <quote>Numerical extensions</quote>.
</item>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-019 424. P00-USA-183</comment>
<item>If the <BNF name="time string"/> does not contain a representation of
a time zone displacement, then the declared type of <BNF name="time literal"/>
is the local time type; otherwise, the declared type of <BNF name="time literal"/>
is the zoned time type.
</item>

<comment>WG3:W17-027</comment>
<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-019 P00-ISO-033</comment>
<comment>WG3:W26-023</comment>
<item>The character string specified by the <BNF name="character string literal"/> 
immediately contained in <BNF name="datetime string"/> shall conform to the representation 
specified in 
<docref ref="ISO8601-1_2019"/>, 5.4, <quote>Date and time of day</quote>, as extended by 
<docref ref="ISO8601-2_2019"/>, 4.3, <quote>Additional explicit forms</quote>, and 
<docref ref="ISO8601-2_2019"/>, 4.4, <quote>Numerical extensions</quote>.
</item>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-019 424. P00-USA-183</comment>
<item>If the <BNF name="datetime string"/> does not contain a representation of
a time zone displacement, then the declared type of <BNF name="datetime literal"/>
is the local datetime type, otherwise, the declared type of <BNF name="datetime literal"/>
is the zoned datetime type.
</item>

<comment>WG3:CMN-019 424. P00-USA-183</comment>
<item>The declared type of <BNF name="duration literal"/> is the duration type.
</item>

<comment>Editorial: Stefan Plantikow, 2020-10-09 Added</comment>
<comment>WG3:RKE-048</comment>
<comment>WG3:W26-026R2</comment>
<item>The nullable declared type <symdef>DT</symdef> of a <BNF name="null literal"/> 
<symdef>NL</symdef> is defined as follows.

<comment>Editorial: Stefan Plantikow, 2022-05-03 Add missing Case</comment>
<para>Case:
</para>

<ednote>The way in which the declared type of <kw>NULL</kw> is determined may require
further adjustment (as per the discussion of RKE-048).
</ednote>

<olist>

<comment>WG3:W26-026R2</comment>
<item>If <sym>DT</sym> can be determined by the context in which <sym>NL</sym> appears, then
<sym>NL</sym> is effectively replaced by <kw>CAST</kw>(<sym>NL</sym> <kw>AS</kw> <sym>DT</sym>).

<note>In every such context, <symdef>NL</symdef> is uniquely associated with some expression or
site of (a nullable) declared type <sym>DT</sym>, which thereby becomes the declared type of 
<sym>NL</sym>.
</note>

</item>

<comment>WG3:W26-026R2</comment>
<item>Otherwise, it is <impDef code="IA014"/> whether an exception condition is raised:
<raise class="42" subclass="001"/>.
If an exception condition is not raised, then <sym>DT</sym> is most specific static value type of 
the null value.

<note>See <specref ref="gql_conc_most_spec_val_type"/>, for the definition of the 
most specific static value type of the null value.
</note>

</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-ISO-033</comment>
<comment>WG3:CMN-048</comment>
<comment>WG3:W26-023</comment>
<item>The character string specified by the <BNF name="character string literal"/> 
immediately contained in <BNF name="duration string"/> shall conform to one of the following:
<olist>

<comment>WG3:CMN-048</comment>
<item>The Format of <BNF name="iso8601 years and months"/>, including one or more of
<BNF name="iso8601 years"/> and <BNF name="iso8601 months"/>,
without a <BNF name="separator"/> between the fields.
</item>

<comment>WG3:CMN-048</comment>
<item>The Format of <BNF name="iso8601 days and time"/>, including one or more of
<BNF name="iso8601 days"/>, <BNF name="iso8601 hours"/>, <BNF name="iso8601 minutes"/>, and
<BNF name="iso8601 seconds"/>, without a <BNF name="separator"/> between the fields.
</item>

<comment>WG3:CMN-048</comment>
<item>The representation specified in
<docref ref="ISO8601-1_2019"/>, 5.5.2, <quote>Duration</quote>, as extended by 
<docref ref="ISO8601-2_2019"/>, 4.3, <quote>Additional explicit forms</quote>, and 
<docref ref="ISO8601-2_2019"/>, 4.4, <quote>Numerical extensions</quote>.
</item>

</olist>

</item>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-019 P00-USA-389</comment>
<item id="gql_lit_sql_dt"><BNF name="SQL-datetime literal"/> shall conform to the Format and 
Syntax Rules of <BNF name="datetime literal" standard="9075" part="02"/> in 
<docref ref="ISO9075-2_2023"/>.
</item>

<comment>WG3:CMN-019 P00-USA-389</comment>
<item id="gql_lit_sql_il"><BNF name="SQL-interval literal"/> shall conform to the Format and 
Syntax Rules of <BNF name="interval literal" standard="9075" part="02"/> in 
<docref ref="ISO9075-2_2023"/>.
</item>

<comment>WG3:CMN-048</comment>
<item>Case:

<olist>

<comment>WG3:CMN-048</comment>
<item>If <BNF name="duration string"/> is an <BNF name="iso8601 years and months"/> or
an <BNF name="SQL-interval literal"/> that is
a <SQL/> <BNF standard="9075" part="02" name="year-month literal"/>, then the declared type of
the <BNF name="duration literal"/> is the year and month-based duration type.
</item>

<comment>WG3:CMN-048</comment>
<item>If <BNF name="duration string"/> is an <BNF name="iso8601 days and time"/> or
an <BNF name="SQL-interval literal"/> that is
a <SQL/> <BNF standard="9075" part="02" name="day-time literal"/>, then the declared type of
the <BNF name="duration literal"/> is the day and time-based duration type.
</item>

<item>Otherwise, an exception condition is raised: <raise class="22" subclass="G0H"/>.
</item>

</olist>

</item>

<item>If <BNF name="SQL-interval literal"/> is specified, then:

<olist>

<comment>Editorial: Stephen Cannan, 2021-05-27 Standardize terms</comment>
<comment>WG3:W14-014: Stefan Plantikow, 2021-08-11 Standardize terms</comment>
<item>If <BNF name="SQL-interval literal"/> contains 
a <BNF name="years value" standard="9075" part="02"/> <symdef>y</symdef>, then 
let <symdef>Y</symdef> be <string>Y<sym>y</sym></string>; otherwise, 
let <symdef>Y</symdef> be the zero-length character string.
</item>

<comment>Editorial: Stephen Cannan, 2021-05-27 Standardize terms</comment>
<comment>WG3:W14-014: Stefan Plantikow, 2021-08-11 Standardize terms</comment>
<item>If <BNF name="SQL-interval literal"/> contains 
a <BNF name="months value" standard="9075" part="02"/> <symdef>m</symdef>, then 
let <symdef>M</symdef> be <string>M<sym>m</sym></string>; otherwise, let <symdef>M</symdef> be 
the zero-length character string.
</item>

<comment>Editorial: Stephen Cannan, 2021-05-27 Standardize terms</comment>
<comment>WG3:W14-014: Stefan Plantikow, 2021-08-11 Standardize terms</comment>
<item>If <BNF name="SQL-interval literal"/> contains 
a <BNF name="days value" standard="9075" part="02"/> <symdef>d</symdef>, then let <symdef>D</symdef>
be <string>D<sym>d</sym></string>; otherwise, let <symdef>D</symdef> be the zero-length character 
string.
</item>

<comment>Editorial: Stephen Cannan, 2021-05-27 Standardize terms</comment>
<comment>WG3:W14-014: Stefan Plantikow, 2021-08-11 Standardize terms</comment>
<item>If <BNF name="SQL-interval literal"/> contains 
an <BNF name="hours value" standard="9075" part="02"/> <symdef>h</symdef>, then 
let <symdef>H</symdef> be <string>H<sym>h</sym></string>; otherwise, let <symdef>H</symdef> be 
the zero-length character string.
</item>

<comment>Editorial: Stephen Cannan, 2021-05-27 Standardize terms</comment>
<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10 Standardize terms</comment>
<item>If <BNF name="SQL-interval literal"/> contains 
a <BNF name="minutes value" standard="9075" part="02"/> <symdef>mn</symdef>, then 
let <symdef>MN</symdef> be <string>M<sym>mn</sym></string>; otherwise, let <symdef>MN</symdef> be 
the zero-length character string.
</item>

<comment>Editorial: Stephen Cannan, 2021-05-27 Standardize terms</comment>
<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10 Standardize terms</comment>
<item>If <BNF name="SQL-interval literal"/> contains 
a <BNF name="seconds value" standard="9075" part="02"/> <symdef>s</symdef>, then 
let <symdef>S</symdef> be <string>S<sym>s</sym></string>; otherwise, let <symdef>S</symdef> be the 
zero-length character string.
</item>

<comment>Editorial: Stephen Cannan, 2021-05-27 Standardize terms</comment>
<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10 Standardize terms</comment>
<item>If <BNF name="SQL-interval literal"/> contains 
an <BNF name="hours value" standard="9075" part="02"/>,
<BNF name="minutes value" standard="9075" part="02"/>, or
<BNF name="seconds value" standard="9075" part="02"/>, then let <symdef>T</symdef> be 
<string>T</string>; otherwise, let <symdef>T</symdef> be the zero-length character string.
</item>

<comment>Editorial: Stephen Cannan, 2021-05-27 Standardize terms</comment>
<comment>WG3:W14-014: Stefan Plantikow, 2021-08-11 Standardize terms</comment>
<comment>WG3:CMN-019 P00-USA-389</comment>
<item>If <BNF name="SQL-interval literal"/> contains at exactly one <BNF name="sign"/> that is 
a <BNF name="minus sign"/>, then let <symdef>SN</symdef> be <string>-</string>; otherwise, 
let <symdef>SN</symdef> be the zero-length character string.
</item>

<comment>WG3:CMN-019 P00-USA-390</comment>
<item><BNF name="SQL-interval literal"/> is equivalent to the <BNF name="duration literal"/>:
<code>
<kw>DURATION</kw> <string><sym>SN</sym>P<sym>Y</sym><sym>M</sym><sym>D</sym><sym>T</sym><sym>H</sym><sym>MN</sym><sym>S</sym></string>
</code>
</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-182</comment>
<comment>WG3:CMN-019 P00-USA-181</comment>
<item>Every <BNF name="value expression"/> contained in a <BNF name="list element"/> 
simply contained in the <BNF name="list value constructor by enumeration"/> contained in 
a <BNF name="list literal"/> shall conform to the Format and Syntax Rules of
<BNF name="literal"/>.
</item>

<item>The declared type of <BNF name="list literal"/> is the declared type of the immediately
contained <BNF name="list value constructor by enumeration"/>.
</item>

<comment>Editorial: Stefan Plantikow, 2020-10-09 Added record</comment>
<comment>WG3:CMN-019 P00-USA-182</comment>
<comment>WG3:CMN-019 P00-USA-181</comment>
<item>Every <BNF name="value expression"/> contained in a <BNF name="field"/> 
simply contained in the <BNF name="record constructor"/> contained in 
a <BNF name="record literal"/> shall conform to the Format and Syntax Rules of 
<BNF name="literal"/>.
</item>
<comment>WG3:UTC-096R1 Deleted 1 (one) SR</comment>

<comment>WG3:W26-023</comment>
<item>The value specified by a <BNF name="literal"/> is the value of that <BNF name="literal"/> 
that is determined by a hypothetical application of its General Rules.

<note>The values of certain <BNF name="literal"/>s are specified by the General Rules of this
Subclause for use in the evaluation of <BNF name="value expression"/>s. 
However, such values are essentially constants and thus can be determined during the application 
of Syntax Rules.
</note>

<ednote id="gql_PP381">The values specified by <BNF name="literal"/>s are currently determined by 
their General Rules. 
Instead, such values should be specified by Syntax Rules and then a corresponding General Rule 
should simply return the specified value of each <BNF name="literal"/> literal>.
See <PPref ref="PPgql381"/>.
</ednote>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:CMN-061R1</comment>
<item>The value specified by a <BNF name="literal"/> is the value represented by that
<BNF name="literal"/>.
</item>

<comment>WG3:W26-023</comment>
<item>Except when it is contained in an <BNF name="exact numeric literal"/>,
the value of an <BNF name="unsigned integer"/> is the exact numeric value determined by 
application of the normal mathematical interpretation of positional decimal notation to the 
series of <BNF name="digit"/>s that constitutes the <BNF name="unsigned integer"/>.
</item>

<comment>WG3:W26-023</comment>
<item>Except when it is contained in an <BNF name="exact numeric literal"/>,
the value of an <BNF name="unsigned decimal integer"/> is the exact numeric value determined by 
application of the normal mathematical interpretation of positional decimal notation to the 
source characters that constitute the <BNF name="unsigned decimal integer"/>.
</item>

<comment>WG3:W26-023</comment>
<item>The value of an <BNF name="exact numeric literal"/> is the exact numeric value determined by
application of the normal mathematical interpretation of positional decimal notation to the
source characters that constitute the <BNF name="exact numeric literal"/>.
</item>

<item>Let <symdef>ANL</symdef> be an <BNF name="approximate numeric literal"/>.
Let <symdef>ANDT</symdef> be the declared type of <sym>ANL</sym>.
Let <symdef>ANV</symdef> be the product of the exact numeric value represented by the
<BNF name="mantissa"/> of <sym>ANL</sym> and the number obtained by raising the number 10 to the
power of the exact numeric value represented by the <BNF name="exponent"/> of <sym>ANL</sym>.
If <sym>ANV</sym> is a value of <sym>ANDT</sym>, then the value of <sym>ANL</sym> is
<sym>ANV</sym>; otherwise, the value of <sym>ANL</sym> is a value of <sym>ANDT</sym> obtained
from <sym>ANV</sym> by rounding or truncation.
The choice of whether to round or truncate is <impDef code="IA005"/>.
</item>

<item>The <BNF name="sign"/> in a <BNF name="signed numeric literal"/> is a monadic arithmetic
operator.
The monadic arithmetic operators + and &minus; specify monadic plus and monadic minus,
respectively.
If neither monadic plus nor monadic minus are specified in a <BNF name="signed numeric literal"/>,
or if monadic plus is specified, then the literal is positive.
If monadic minus is specified in a <BNF name="signed numeric literal"/>, then the literal is
negative.
</item>

<item>The truth value of a <BNF name="boolean literal"/> is <bool>True</bool> if <kw>TRUE</kw> is
specified, is <bool>False</bool> if <kw>FALSE</kw> is specified, and is <bool>Unknown</bool> if
<kw>UNKNOWN</kw> is specified.
</item>

<comment>Editorial: Stefan Plantikow, 2021-04-29 Editorial</comment>
<comment>WG3:W17-027</comment>
<item>The value of a <BNF name="character string literal"/> is the character string that it 
specifies.
</item>

<comment>Editorial: Stefan Plantikow, 2021-04-29 Editorial</comment>
<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19</comment>
<item>The value of a <BNF name="byte string literal"/> is the byte string comprising
sequence of bits defined by the <BNF name="hex digit"/>s that it contains.
Each <BNF name="hex digit"/> appearing in the literal is equivalent to a quartet of bits:
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, and F are interpreted as
0000, 0001, 0010, 0011, 0100, 0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100, 1101, 1110,
and 1111, respectively.
The <BNF name="hex digit"/>s a, b, c, d, e, and f have respectively the same values as the
<BNF name="hex digit"/>s A, B, C, D, E, and F.
</item>

<item>If <BNF name="date string"/> contains a representation with reduced precision, then the
lowest valid value for each of the omitted lower order time scale components is implicit.
</item>

<item>The value of a <BNF name="date literal"/> is a calendar date in the Gregorian calendar.
</item>

<item>If <BNF name="time string"/> contains a representation with reduced precision, then value
for each of the omitted lower order time scale components is 0 (zero).
</item>

<item>The value of a <BNF name="time literal"/> is a time of day.
If the <BNF name="time string"/> contained a representation of a time shift, then the time shift
information is preserved.
</item>

<item>If <BNF name="datetime string"/> contains a representation with reduced precision, then value
for each of the omitted lower order time scale components is 0 (zero).
</item>

<item>The value of a <BNF name="datetime literal"/> is a time.
If the <BNF name="datetime string"/> contained a representation of a time shift, then the time
shift information is preserved.
</item>

<item>The value of a <BNF name="duration literal"/> is a duration or a negative duration.
<note>See <docref ref="ISO8601-2_2019"/>, 4.4.1.9 <quote>Duration</quote>, for the definition of 
a negative duration.
</note>
</item>

<comment>Editorial: Stefan Plantikow 2020-10-09 Added null literal</comment>
<item>The value of a <BNF name="null literal"/> is the null value.
</item>

<item>The value of <BNF name="list literal"/> is 
the value of the immediately contained
<BNF name="list value constructor by enumeration"/>.
</item>

<comment>Editorial: Stefan Plantikow 2020-10-09 Added record literal</comment>
<comment>WG3:BER-040R3</comment>
<item>The value of <BNF name="record literal"/> is the value of the immediately contained
<BNF name="record constructor"/>.
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W22-052R1</comment>
<item>Without <feature code="GL01"/>, conforming GQL language shall not contain 
an <BNF name="unsigned hexadecimal integer"/>.
</item>

<comment>WG3:W22-052R1</comment>
<item>Without <feature code="GL02"/>, conforming GQL language shall not contain 
an <BNF name="unsigned octal integer"/>.
</item>

<comment>WG3:W22-052R1</comment>
<item>Without <feature code="GL03"/>, conforming GQL language shall not contain 
an <BNF name="unsigned binary integer"/>.
</item>

<comment>WG3:UTC-044</comment>
<item>Without <feature code="GL11"/>, conforming GQL language shall not contain 
<BNF name="no escape"/>.
</item>

<comment>WG3:UTC-074</comment>
<item>Without <feature code="GL07"/>, conforming GQL language shall not contain 
an <BNF name="approximate numeric literal"/> that is 
an <BNF name="unsigned decimal in common notation"/> followed by 
an <BNF name="approximate number suffix"/> or an <BNF name="unsigned decimal integer"/> followed 
by an <BNF name="approximate number suffix"/>.
</item>

<comment>WG3:UTC-074</comment>
<item>Without <feature code="GL08"/>, conforming GQL language shall not contain 
an <BNF name="approximate numeric literal"/> that is 
an <BNF name="unsigned decimal in scientific notation"/> followed by 
an <BNF name="approximate number suffix"/>.
</item>

<comment>WG3:UTC-074</comment>
<item>Without <feature code="GL09"/>, conforming GQL language shall not contain 
an <BNF name="approximate numeric literal"/> that is 
an <BNF name="unsigned decimal in scientific notation"/> followed by 
an <BNF name="approximate number suffix"/>.
</item>

<comment>WG3:UTC-074</comment>
<item>Without <feature code="GL10"/>, conforming GQL language shall not contain 
an <BNF name="approximate numeric literal"/> that simply contains 
an <BNF name="approximate number suffix"/> that is <quote>d</quote> or <quote>D</quote>.
</item>

<comment>WG3:UTC-074</comment>
<item>Without <feature code="GL04"/>, conforming GQL language shall not contain 
an <BNF name="exact numeric literal"/> that is 
an <BNF name="unsigned decimal in common notation"/>.
</item>

<comment>WG3:UTC-074</comment>
<item>Without <feature code="GL05"/>, conforming GQL language shall not contain 
an <BNF name="exact numeric literal"/> that is 
an <BNF name="unsigned decimal in common notation"/> followed by 
an <BNF name="exact number suffix"/> or an <BNF name="unsigned decimal integer"/> followed by 
an <BNF name="exact number suffix"/>.
</item>

<comment>WG3:UTC-074</comment>
<item>Without <feature code="GL06"/>, conforming GQL language shall not contain 
an <BNF name="exact numeric literal"/> that is 
an <BNF name="unsigned decimal in scientific notation"/> followed by 
an <BNF name="exact number suffix"/>.
</item>

<comment>WG3:POS-021</comment>
<item>Without <feature code="GV35"/>, conforming GQL language shall not contain 
a <BNF name="byte string literal"/>.
</item>

<comment>WG3:CMN-052R1</comment>
<item>Without <feature code="GV39"/>, conforming GQL language shall not contain
a <BNF name="temporal literal"/>.
</item>

<comment>WG3:UTC-117</comment>
<comment>WG3:CMN-052R1</comment>
<item>Without <feature code="GV40"/>, conforming GQL language shall not contain
a <BNF name="temporal literal"/> that specifies a time zone displacement.
</item>

<comment>WG3:UTC-117</comment>
<item>Without <feature code="GV41"/>, conforming GQL language shall not contain
a <BNF name="duration literal"/>.
</item>

<comment>WG3:UTC-117</comment>
<item>Without <feature code="GL12"/>, conforming GQL language shall not contain
an <BNF name="SQL-datetime literal"/> or an <BNF name="SQL-interval literal"/>.
</item>

<comment>WG3:CMN-019 P00-USA-184</comment>
<item>Without <feature code="GV50"/>, conforming GQL language shall not contain
a <BNF name="list literal"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>
<comment>WG3:UTC-042 3 Subclauses moved</comment>


<comment>WG3:W23-014</comment>
<subClause id="gql_token" newpage="true">
<clauseHeading><BNF name="token"/>, <BNF name="separator"/>, and 
<BNF name="identifier"/></clauseHeading>

<bodyMatter>


<Function>

<para>Specify lexical units (tokens, separators, and identifiers) that participate in the 
GQL language.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="token">
<rhs>
<alt> <BNF name="non-delimiter token"/> </alt>
<alt> <BNF name="delimiter token"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:JCJ-015</comment>
<comment>Editorial: Stefan Plantikow 2020-10-15 Used parameter name directly here</comment>
<comment>Editorial: Stefan Plantikow 2021-06-23 consistent use of "byte string"</comment>
<comment>Editorial: Stephen Cannan, 2023-07-11, Standardize the spelling of keyword</comment>
<comment>WG3:CMN-061R1</comment>
<BNFdef name="non-delimiter token">
<rhs>
<alt> <BNF name="regular identifier"/> </alt>
<alt> <BNF name="substituted parameter reference"/> </alt>
<alt> <BNF name="general parameter reference"/> </alt>
<alt> <BNF name="keyword"/> </alt>
<alt> <BNF name="unsigned numeric literal"/> </alt>
<alt> <BNF name="byte string literal"/> </alt>
<alt> <BNF name="multiset alternation operator"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W23-014</comment>
<comment>WG3:W17-027</comment>
<BNFdef name="identifier">
<rhs>
<alt> <BNF name="regular identifier"/> </alt>
<alt> <BNF name="delimited identifier"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W17-027</comment>
<BNFdef name="separated identifier">
<rhs>
<alt> <BNF name="extended identifier"/> </alt>
<alt> <BNF name="delimited identifier"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W17-027</comment>
<BNFdef name="non-delimited identifier">
<rhs>
<alt> <BNF name="regular identifier"/> </alt>
<alt> <BNF name="extended identifier"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W17-027</comment>
<BNFdef name="regular identifier">
<rhs>
<BNF name="identifier start"/> <opt> <BNF name="identifier extend"/><repeat/> </opt>
</rhs>
</BNFdef>
<ednote id="gql_PP425">The current definition of <BNF name="regular identifier"/> allows 
the use of a single underscore as a valid identifier. 
This should be corrected.
See <PPref ref="PPgql425"/>.
</ednote>

<comment>WG3:W17-027</comment>
<BNFdef name="extended identifier">
<rhs>
<BNF name="identifier extend"/><repeat/>
</rhs>
</BNFdef>

<comment>Editorial: Stephen Cannan, 2020-05-14 Remove SQL_MODE</comment>
<comment>WG3:W17-027</comment>
<comment>WG3:W23-014</comment>
<BNFdef name="delimited identifier">
<rhs>
<alt> <BNF name="double quoted character sequence"/> </alt>
<alt> <BNF name="accent quoted character sequence"/> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<bar note="Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references"/>
<BNFdef name="identifier start">
<rhs>
<seeTheRules><itemref ref="gql_tok_is" type="SR"/></seeTheRules>
</rhs>
</BNFdef>

<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<BNFdef name="identifier extend">
<rhs>
<seeTheRules><itemref ref="gql_tok_ie" type="SR"/></seeTheRules>
</rhs>
</BNFdef>
<endbar/>

<comment>WG3:CMN-061R1</comment>
<BNFdef name="substituted parameter reference">
<rhs>
<BNF name="double dollar sign"/><BNF name="parameter name"/>
</rhs>
</BNFdef>

<comment>WG3:CMN-061R1</comment>
<BNFdef name="general parameter reference">
<rhs>
<BNF name="dollar sign"/><BNF name="parameter name"/>
</rhs>
</BNFdef>

<comment>Editorial: Stephen Cannan, 2023-07-11, Standardize the spelling of keyword</comment>
<BNFdef name="keyword">
<rhs>
<alt> <BNF name="reserved word"/> </alt>
<alt> <BNF name="non-reserved word"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:W08-009 P16-USA-120</comment>
<comment>WG3:W23-014</comment>
<comment>WG3:UTC-071R1 Deleted 1 (one) reserved word</comment>
<comment>WG3:UTC-084</comment>
<comment>Editorial: Stephen Cannan, 2023-02-26 Separate out pre-reserved words</comment>
<BNFdef name="reserved word">
<rhs>
<alt> <BNF name="pre-reserved word"/> </alt>
<blankline/>
<alt br="no"> <kw>ABS</kw> </alt>
<alt br="no"> <kw>ACOS</kw> </alt>
<alt br="no"> <kw>ALL</kw> </alt>
<alt br="no"> <kw>ALL_DIFFERENT</kw> </alt>
<alt br="no"> <kw>AND</kw> </alt>
<alt br="no"> <kw>ANY</kw> </alt>
<alt br="no"> <kw>ARRAY</kw> </alt>
<alt br="no"> <kw>AS</kw> </alt>
<alt br="no"> <kw>ASC</kw> </alt>
<alt br="no"> <kw>ASCENDING</kw> </alt>
<alt br="no"> <kw>ASIN</kw> </alt>
<linebreak/>
<alt br="no"> <kw>AT</kw> </alt>
<alt br="no"> <kw>ATAN</kw> </alt>
<alt br="no"> <kw>AVG</kw> </alt>
<blankline/>
<comment>WG3:BER-085</comment>
<comment>WG3:UTC-090R1</comment>
<alt br="no"> <kw>BIG</kw> </alt>
<alt br="no"> <kw>BIGINT</kw> </alt>
<alt br="no"> <kw>BINARY</kw> </alt>
<alt br="no"> <kw>BOOL</kw> </alt>
<alt br="no"> <kw>BOOLEAN</kw> </alt>
<alt br="no"> <kw>BOTH</kw> </alt>
<alt br="no"> <kw>BTRIM</kw> </alt>
<alt br="no"> <kw>BY</kw> </alt>
<alt br="no"> <kw>BYTE_LENGTH</kw> </alt>
<alt br="no"> <kw>BYTES</kw> </alt>
<blankline/>
<comment>Editorial: Stefan Plantikow 2020-09-16 CURRENT_CATALOG</comment>
<comment>Editorial: Stefan Plantikow 2020-09-26 CURRENT_DIRECTORY</comment>
<comment>Editorial: Stefan Plantikow 2020-10-15 Added</comment>
<comment>Editorial: Stefan Plantikow 2021-04-26 WG3:W10-016</comment>
<comment>Consequence of WG3:W13-012: CAST added</comment>
<comment>WG3:W21-049 deleted COST</comment>
<comment>WG3:UTC-071R1 Deleted 3 reserved words</comment>
<comment>WG3:UTC-045R1</comment>
<comment>WG3:UTC-090R1</comment>
<comment>WG3:W25-028</comment>
<comment>WG3:CMN-068</comment>
<comment>WG3:W26-026R2</comment>
<alt br="no"> <kw>CALL</kw> </alt>
<alt br="no"> <kw>CARDINALITY</kw> </alt>
<alt br="no"> <kw>CASE</kw> </alt>
<alt br="no"> <kw>CAST</kw> </alt>
<alt br="no"> <kw>CEIL</kw> </alt>
<alt br="no"> <kw>CEILING</kw> </alt>
<alt br="no"> <kw>CHAR</kw> </alt>
<alt br="no"> <kw>CHAR_LENGTH</kw> </alt>
<alt br="no"> <kw>CHARACTER_LENGTH</kw> </alt>
<linebreak/>
<alt br="no"> <kw>CHARACTERISTICS</kw> </alt>
<alt br="no"> <kw>CLOSE</kw> </alt>
<alt br="no"> <kw>COALESCE</kw> </alt>
<alt br="no"> <kw>COLLECT_LIST</kw> </alt>
<alt br="no"> <kw>COMMIT</kw> </alt>
<alt br="no"> <kw>COPY</kw> </alt>
<alt br="no"> <kw>COS</kw> </alt>
<alt br="no"> <kw>COSH</kw> </alt>
<alt br="no"> <kw>COT</kw> </alt>
<linebreak/>
<alt br="no"> <kw>COUNT</kw> </alt>
<alt br="no"> <kw>CREATE</kw> </alt>
<alt br="no"> <kw>CURRENT_DATE</kw> </alt>
<alt br="no"> <kw>CURRENT_GRAPH</kw> </alt>
<alt br="no"> <kw>CURRENT_PROPERTY_GRAPH</kw> </alt>
<linebreak/>
<alt br="no"> <kw>CURRENT_SCHEMA</kw> </alt>
<alt br="no"> <kw>CURRENT_TIME</kw> </alt>
<alt br="no"> <kw>CURRENT_TIMESTAMP</kw> </alt>
<blankline/>
<comment>WG3:W12-029: Stefan Plantikow 2021-06-17</comment>
<comment>WG3:W12-029: Stefan Plantikow 2021-06-18</comment>
<comment>WG3:UTC-071R1 Deleted 1 (one) reserved word</comment>
<comment>WG3:W12-029: Stefan Plantikow 2021-06-18</comment>
<comment>WG3:OHD-024</comment>
<comment>WG3:UTC-071R1 Deleted 1 (one) reserved word</comment>
<comment>WG3:UTC-117</comment>
<alt br="no"> <kw>DATE</kw> </alt>
<alt br="no"> <kw>DATETIME</kw> </alt>
<alt br="no"> <kw>DAY</kw> </alt>
<alt br="no"> <kw>DEC</kw> </alt>
<alt br="no"> <kw>DECIMAL</kw> </alt>
<alt br="no"> <kw>DEGREES</kw> </alt>
<alt br="no"> <kw>DELETE</kw> </alt>
<alt br="no"> <kw>DESC</kw> </alt>
<alt br="no"> <kw>DESCENDING</kw> </alt>
<alt br="no"> <kw>DETACH</kw> </alt>
<linebreak/>
<alt br="no"> <kw>DISTINCT</kw> </alt>
<alt br="no"> <kw>DOUBLE</kw> </alt>
<alt br="no"> <kw>DROP</kw> </alt>
<alt br="no"> <kw>DURATION</kw> </alt>
<alt br="no"> <kw>DURATION_BETWEEN</kw> </alt>
<blankline/>
<comment>Editorial: Stefan Plantikow 2020-09-26 EMPTY_DIRECTORY</comment>
<comment>WG3:W15-010</comment>
<comment>WG3:BER-076</comment>
<comment>WG3:UTC-071R1 Deleted 5 reserved words</comment>
<alt br="no"> <kw>ELEMENT_ID</kw> </alt>
<alt br="no"> <kw>ELSE</kw> </alt>
<alt br="no"> <kw>END</kw> </alt>
<alt br="no"> <kw>EXCEPT</kw> </alt>
<alt br="no"> <kw>EXISTS</kw> </alt>
<alt br="no"> <kw>EXP</kw> </alt>
<blankline/>
<comment>WG3:W12-029: Stefan Plantikow, 2021-06-18</comment>
<comment>WG3:UTC-101</comment>
<alt br="no"> <kw>FALSE</kw> </alt>
<alt br="no"> <kw>FILTER</kw> </alt>
<alt br="no"> <kw>FINISH</kw> </alt>
<alt br="no"> <kw>FLOAT</kw> </alt>
<alt br="no"> <kw>FLOAT16</kw> </alt>
<alt br="no"> <kw>FLOAT32</kw> </alt>
<alt br="no"> <kw>FLOAT64</kw> </alt>
<alt br="no"> <kw>FLOAT128</kw> </alt>
<alt br="no"> <kw>FLOAT256</kw> </alt>
<linebreak/>
<comment>WG3:UTC-071R1 Deleted 1 (one) reserved word</comment>
<alt br="no"> <kw>FLOOR</kw> </alt>
<alt br="no"> <kw>FOR</kw> </alt>
<alt br="no"> <kw>FROM</kw> </alt>
<blankline/>
<alt br="no"> <kw>GROUP</kw> </alt>
<blankline/>
<comment>Editorial: Stefan Plantikow, 2020-09-16 HOME_DIRECTORY</comment>
<comment>Editorial: Stefan Plantikow, 2020-07-12 WG3:MMX-055</comment>
<alt br="no"> <kw>HAVING</kw> </alt>
<alt br="no"> <kw>HOME_GRAPH</kw> </alt>
<alt br="no"> <kw>HOME_PROPERTY_GRAPH</kw> </alt>
<alt br="no"> <kw>HOME_SCHEMA</kw> </alt>
<alt br="no"> <kw>HOUR</kw> </alt>
<blankline/>
<comment>WG3:W12-029: Stefan Plantikow, 2021-06-18</comment>
<comment>WG3:W15-010</comment>
<comment>WG3:UTC-071R1 Deleted 1 (one) reserved word</comment>
<comment>WG3:UTC-071R1</comment>
<comment>WG3:W26-022</comment>
<alt br="no"> <kw>IF</kw> </alt>
<alt br="no"> <kw>IMPLIES</kw> </alt>
<alt br="no"> <kw>IN</kw> </alt>
<alt br="no"> <kw>INSERT</kw> </alt>
<alt br="no"> <kw>INT</kw> </alt>
<alt br="no"> <kw>INTEGER</kw> </alt>
<alt br="no"> <kw>INT8</kw> </alt>
<alt br="no"> <kw>INTEGER8</kw> </alt>
<alt br="no"> <kw>INT16</kw> </alt>
<alt br="no"> <kw>INTEGER16</kw> </alt>
<linebreak/>
<alt br="no"> <kw>INT32</kw> </alt>
<alt br="no"> <kw>INTEGER32</kw> </alt>
<alt br="no"> <kw>INT64</kw> </alt>
<alt br="no"> <kw>INTEGER64</kw> </alt>
<alt br="no"> <kw>INT128</kw> </alt>
<alt br="no"> <kw>INTEGER128</kw> </alt>
<alt br="no"> <kw>INT256</kw> </alt>
<alt br="no"> <kw>INTEGER256</kw> </alt>
<linebreak/>
<alt br="no"> <kw>INTERSECT</kw> </alt>
<alt br="no"> <kw>INTERVAL</kw> </alt>
<alt br="no"> <kw>IS</kw> </alt>
<blankline/>
<comment>WG3:W04-009R1</comment>
<comment>WG3:W15-010</comment>
<comment>WG3:BER-052R1</comment>
<comment>WG3:UTC-071R1 Deleted two reserved word</comment>
<comment>WG3:UTC-117</comment>
<comment>Editorial: Stefan Plantikow 2023-03-20 Consequence WG3:W25</comment>
<alt br="no"> <kw>LEADING</kw> </alt>
<alt br="no"> <kw>LEFT</kw> </alt>
<alt br="no"> <kw>LET</kw> </alt>
<alt br="no"> <kw>LIKE</kw> </alt>
<alt br="no"> <kw>LIMIT</kw> </alt>
<alt br="no"> <kw>LIST</kw> </alt>
<alt br="no"> <kw>LN</kw> </alt>
<alt br="no"> <kw>LOCAL</kw> </alt>
<alt br="no"> <kw>LOCAL_DATETIME</kw> </alt>
<alt br="no"> <kw>LOCAL_TIME</kw> </alt>
<linebreak/>
<alt br="no"> <kw>LOCAL_TIMESTAMP</kw> </alt>
<alt br="no"> <kw>LOG</kw> </alt>
<alt br="no"> <kw>LOG10</kw> </alt>
<alt br="no"> <kw>LOWER</kw> </alt>
<alt br="no"> <kw>LTRIM</kw> </alt>
<blankline/>
<comment>WG3:UTC-071R1 Deleted four reserved word</comment>
<alt br="no"> <kw>MATCH</kw> </alt>
<alt br="no"> <kw>MAX</kw> </alt>
<alt br="no"> <kw>MIN</kw> </alt>
<alt br="no"> <kw>MINUTE</kw> </alt>
<alt br="no"> <kw>MOD</kw> </alt>
<alt br="no"> <kw>MONTH</kw> </alt>
<blankline/>
<comment>WG3:W10-016: Stefan Plantikow, 2021-04-26</comment>
<comment>WG3:W12-029: Stefan Plantikow, 2021-06-18</comment>
<comment>WG3:W22-042</comment>
<comment>WG3:OHD-020</comment>
<comment>WG3:UTC-071R1 Deleted 3 reserved words</comment>
<comment>WG3:UTC-101</comment>
<comment>WG3:W26-026R2</comment>
<alt br="no"> <kw>NEXT</kw> </alt>
<alt br="no"> <kw>NODETACH</kw> </alt>
<alt br="no"> <kw>NORMALIZE</kw> </alt>
<alt br="no"> <kw>NOT</kw> </alt>
<alt br="no"> <kw>NOTHING</kw> </alt>
<alt br="no"> <kw>NULL</kw> </alt>
<alt br="no"> <kw>NULLS</kw> </alt>
<alt br="no"> <kw>NULLIF</kw> </alt>
<blankline/>
<comment>WG3:JCJ-010R1</comment>
<comment>Editorial: Stefan Plantikow, 2020-10-09 Added ordered set</comment>
<comment>WG3:W15-010</comment>
<comment>WG3:W23-029R1</comment>
<comment>WG3:UTC-071R1 Deleted three reserved words</comment>
<alt br="no"> <kw>OCTET_LENGTH</kw> </alt>
<alt br="no"> <kw>OF</kw> </alt>
<alt br="no"> <kw>OFFSET</kw> </alt>
<alt br="no"> <kw>OPTIONAL</kw> </alt>
<alt br="no"> <kw>OR</kw> </alt>
<alt br="no"> <kw>ORDER</kw> </alt>
<alt br="no"> <kw>OTHERWISE</kw> </alt>
<blankline/>
<comment>WG3:W12-029: Stefan Plantikow, 2021-06-18</comment>
<comment>WG3:W15-010</comment>
<comment>WG3:BER-076</comment>
<comment>Consequence of WG3:W24-035R1</comment>
<comment>WG3:UTC-045R1</comment>
<comment>WG3:UTC-081</comment>
<comment>WG3:UTC-071R1 Deleted two reserved words</comment>
<comment>WG3:UTC-127R1</comment>
<alt br="no"> <kw>PARAMETER</kw> </alt>
<alt br="no"> <kw>PARAMETERS</kw> </alt>
<alt br="no"> <kw>PATH</kw> </alt>
<alt br="no"> <kw>PATH_LENGTH</kw> </alt>
<alt br="no"> <kw>PATHS</kw> </alt>
<alt br="no"> <kw>PERCENTILE_CONT</kw> </alt>
<alt br="no"> <kw>PERCENTILE_DISC</kw> </alt>
<linebreak/>
<alt br="no"> <kw>POWER</kw> </alt>
<alt br="no"> <kw>PRECISION</kw> </alt>
<alt br="no"> <kw>PROPERTY_EXISTS</kw> </alt>
<blankline/>
<comment>Editorial: Stefan Plantikow, 2020-10-09 Added for record types</comment>
<comment>WG3:W12-029: Stefan Plantikow, 2021-06-18</comment>
<comment>WG3:UTC-045R1</comment>
<comment>WG3:W23-014</comment>
<comment>WG3:UTC-071R1 Deleted 4 reserved words</comment>
<comment>Editorial: Stefan Plantikow 2023-03-20 Consequence WG3:W25</comment>
<alt br="no"> <kw>RADIANS</kw> </alt>
<alt br="no"> <kw>REAL</kw> </alt>
<alt br="no"> <kw>RECORD</kw> </alt>
<alt br="no"> <kw>REMOVE</kw> </alt>
<alt br="no"> <kw>REPLACE</kw> </alt>
<alt br="no"> <kw>RESET</kw> </alt>
<alt br="no"> <kw>RETURN</kw> </alt>
<alt br="no"> <kw>RIGHT</kw> </alt>
<alt br="no"> <kw>ROLLBACK</kw> </alt>
<alt br="no"> <kw>RTRIM</kw> </alt>
<blankline/>
<comment>Editorial: Stefan Plantikow, 2020-09-16 Added plural forms</comment>
<comment>WG3:W12-029: Stefan Plantikow, 2021-06-18</comment>
<comment>WG3:W15-010</comment>
<comment>WG3:BER-085</comment>
<comment>WG3:W23-014</comment>
<comment>WG3:UTC-071R1 Deleted 6 reserved words</comment>
<comment>WG3:UTC-081</comment>
<comment>WG3:CMN-068</comment>
<comment>WG3:CMN-060</comment>
<alt br="no"> <kw>SAME</kw> </alt>
<alt br="no"> <kw>SCHEMA</kw> </alt>
<alt br="no"> <kw>SECOND</kw> </alt>
<alt br="no"> <kw>SELECT</kw> </alt>
<alt br="no"> <kw>SESSION</kw> </alt>
<alt br="no"> <kw>SESSION_USER</kw> </alt>
<alt br="no"> <kw>SET</kw> </alt>
<alt br="no"> <kw>SIGNED</kw> </alt>
<alt br="no"> <kw>SIN</kw> </alt>
<alt br="no"> <kw>SINH</kw> </alt>
<linebreak/>
<alt br="no"> <kw>SIZE</kw> </alt>
<alt br="no"> <kw>SKIP</kw> </alt>
<alt br="no"> <kw>SMALL</kw> </alt>
<alt br="no"> <kw>SMALLINT</kw> </alt>
<alt br="no"> <kw>SQRT</kw> </alt>
<alt br="no"> <kw>START</kw> </alt>
<alt br="no"> <kw>STDDEV_POP</kw> </alt>
<alt br="no"> <kw>STDDEV_SAMP</kw> </alt>
<alt br="no"> <kw>STRING</kw> </alt>
<linebreak/>
<alt br="no"> <kw>SUM</kw> </alt>
<blankline/>
<comment>WG3:W23-014</comment>
<comment>WG3:UTC-071R1 Deleted two reserved word</comment>
<comment>WG3:UTC-015</comment>
<alt br="no"> <kw>TAN</kw> </alt>
<alt br="no"> <kw>TANH</kw> </alt>
<alt br="no"> <kw>THEN</kw> </alt>
<alt br="no"> <kw>TIME</kw> </alt>
<alt br="no"> <kw>TIMESTAMP</kw> </alt>
<alt br="no"> <kw>TRAILING</kw> </alt>
<alt br="no"> <kw>TRIM</kw> </alt>
<alt br="no"> <kw>TRUE</kw> </alt>
<alt br="no"> <kw>TYPED</kw> </alt>
<blankline/>
<comment>WG3:JCJ-010R1</comment>
<comment>WG3:W12-029: Stefan Plantikow, 2021-06-18</comment>
<comment>WG3:BER-085</comment>
<comment>WG3:UTC-071R1 Deleted 4 reserved words</comment>
<alt br="no"> <kw>UBIGINT</kw> </alt>
<alt br="no"> <kw>UINT</kw> </alt>
<alt br="no"> <kw>UINT8</kw> </alt>
<alt br="no"> <kw>UINT16</kw> </alt>
<alt br="no"> <kw>UINT32</kw> </alt>
<alt br="no"> <kw>UINT64</kw> </alt>
<alt br="no"> <kw>UINT128</kw> </alt>
<alt br="no"> <kw>UINT256</kw> </alt>
<alt br="no"> <kw>UNION</kw> </alt>
<alt br="no"> <kw>UNKNOWN</kw> </alt>
<linebreak/>
<alt br="no"> <kw>UNSIGNED</kw> </alt>
<alt br="no"> <kw>UPPER</kw> </alt>
<alt br="no"> <kw>USE</kw> </alt>
<alt br="no"> <kw>USMALLINT</kw> </alt>
<blankline/>
<comment>WG3:W12-029: Stefan Plantikow, 2021-06-18</comment>
<comment>Editorial: Stefan Plantikow, 2022-08-16 Added as consequence of WG3:W22-051</comment>
<comment>WG3:POS-011R1</comment>
<alt br="no"> <kw>VALUE</kw> </alt>
<alt br="no"> <kw>VARBINARY</kw> </alt>
<alt br="no"> <kw>VARCHAR</kw> </alt>
<alt br="no"> <kw>VARIABLE</kw> </alt>
<alt br="no"> <kw>VECTOR</kw> </alt>
<alt br="no"> <kw>VECTOR_DIMENSION_COUNT</kw> </alt>
<linebreak/>
<alt br="no"> <kw>VECTOR_DISTANCE</kw> </alt>
<alt br="no"> <kw>VECTOR_NORM</kw> </alt>
<alt br="no"> <kw>VECTOR_SERIALIZE</kw> </alt>
<blankline/>
<comment>Editorial: Stefan Plantikow, 2020-09-26 WORKING_DIRECTORY</comment>
<comment>Editorial: Stephen Cannan, 2021-04-01 deleted WORKING_GRAPH</comment>
<comment>Consequence of WG3:W13-012: WITHOUT added</comment>
<comment>WG3:UTC-071R1 Deleted 1 (one) reserved word</comment>
<alt br="no"> <kw>WHEN</kw> </alt>
<alt br="no"> <kw>WHERE</kw> </alt>
<alt br="no"> <kw>WITH</kw> </alt>
<blankline/>
<alt br="no"> <kw>XOR</kw> </alt>
<blankline/>
<comment>WG3:UTC-071R1 Deleted 1 (one) reserved word</comment>
<alt br="no"> <kw>YEAR</kw> </alt>
<alt br="no"> <kw>YIELD</kw> </alt>
<blankline/>
<comment>WG3:UTC-117</comment>
<alt br="no"> <kw>ZONED</kw> </alt>
<alt br="no"> <kw>ZONED_DATETIME</kw> </alt>
<alt br="no"> <kw>ZONED_TIME</kw> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stephen Cannan, 2023-02-26 Separate out pre-reserved words</comment>
<BNFdef name="pre-reserved word">
<comment>WG3:W26-026R2</comment>
<rhs>
<alt br="no"> <kw>ABSTRACT</kw> </alt>
<alt br="no"> <kw>AGGREGATE</kw> </alt>
<alt br="no"> <kw>AGGREGATES</kw> </alt>
<alt br="no"> <kw>ALTER</kw> </alt>
<blankline/>
<comment>WG3:CMN-060</comment>
<alt br="no"> <kw>CATALOG</kw> </alt>
<alt br="no"> <kw>CLEAR</kw> </alt>
<alt br="no"> <kw>CLONE</kw> </alt>
<alt br="no"> <kw>CONSTRAINT</kw> </alt>
<alt br="no"> <kw>CURRENT_ROLE</kw> </alt>
<alt br="no"> <kw>CURRENT_USER</kw> </alt>
<blankline/>
<comment>WG3:W26-032R1</comment>
<alt br="no"> <kw>DATA</kw> </alt>
<alt br="no"> <kw>DIRECTORY</kw> </alt>
<alt br="no"> <kw>DRYRUN</kw> </alt>
<blankline/>
<comment>WG3:POS-011R1: Made EXACT non-reserved</comment>
<alt br="no"> <kw>EXISTING</kw> </alt>
<blankline/>
<alt br="no"> <kw>FUNCTION</kw> </alt>
<blankline/>
<alt br="no"> <kw>GQLSTATUS</kw> </alt>
<alt br="no"> <kw>GRANT</kw> </alt>
<blankline/>
<comment>WG3:W26-023</comment>
<alt br="no"> <kw>INSTANT</kw> </alt>
<alt br="no"> <kw>INFINITY</kw> </alt>
<blankline/>
<comment>WG3:W26-026R2</comment>
<alt br="no"> <kw>NUMBER</kw> </alt>
<alt br="no"> <kw>NUMERIC</kw> </alt>
<blankline/>
<comment>WG3:W25-025</comment>
<alt br="no"> <kw>ON</kw> </alt>
<alt br="no"> <kw>OPEN</kw> </alt>
<blankline/>
<alt br="no"> <kw>PARTITION</kw> </alt>
<alt br="no"> <kw>PROCEDURE</kw> </alt>
<alt br="no"> <kw>PRODUCT</kw> </alt>
<alt br="no"> <kw>PROJECT</kw> </alt>
<blankline/>
<alt br="no"> <kw>QUERY</kw> </alt>
<blankline/>
<alt br="no"> <kw>RECORDS</kw> </alt>
<alt br="no"> <kw>REFERENCE</kw> </alt>
<alt br="no"> <kw>RENAME</kw> </alt>
<alt br="no"> <kw>REVOKE</kw> </alt>
<blankline/>
<comment>WG3:CMN-060</comment>
<alt br="no"> <kw>SUBSTRING</kw> </alt>
<alt br="no"> <kw>SYSTEM_USER</kw> </alt>
<blankline/>
<alt br="no"> <kw>TEMPORAL</kw> </alt>
<blankline/>
<alt br="no"> <kw>UNIQUE</kw> </alt>
<alt br="no"> <kw>UNIT</kw> </alt>
<blankline/>
<alt br="no"> <kw>VALUES</kw> </alt>
<blankline/>
<comment>WG3:CMN-024</comment>
<alt br="no"> <kw>WHITESPACE</kw> </alt>
</rhs>
</BNFdef>

<comment>WG3:UTC-015</comment>
<comment>WG3:XRH-021R1</comment>
<BNFdef name="non-reserved word">
<rhs>
<bar note="WG3:XRH-021R1"/>
<alt br="no"> <kw>ACYCLIC</kw> </alt>
<alt br="no"> <kw>APPROX</kw> </alt>
<alt br="no"> <kw>APPROXIMATE</kw> </alt>
<endbar/>
<blankline/>
<alt br="no"> <kw>BINDING</kw> </alt>
<alt br="no"> <kw>BINDINGS</kw> </alt>
<blankline/>
<comment>WG3:UTC-071R1 Deleted 3 non-reserved words</comment>
<alt br="no"> <kw>CONNECTING</kw> </alt>
<comment>WG3:POS-011R1</comment>
<alt br="no"> <kw>COSINE</kw> </alt>

<blankline/>
<alt br="no"> <kw>DESTINATION</kw> </alt>
<alt br="no"> <kw>DIFFERENT</kw> </alt>
<alt br="no"> <kw>DIRECTED</kw> </alt>
<comment>WG3:POS-011R1</comment>
<alt br="no"> <kw>DOT</kw> </alt>
<blankline/>
<comment>WG3:POS-011R1</comment>
<alt br="no"> <kw>EDGE</kw> </alt>
<alt br="no"> <kw>EDGES</kw> </alt>
<alt br="no"> <kw>ELEMENT</kw> </alt>
<alt br="no"> <kw>ELEMENTS</kw> </alt>
<alt br="no"> <kw>EUCLIDEAN</kw> </alt>
<alt br="no"> <kw>EUCLIDEAN_SQUARED</kw> </alt>
<alt br="no"> <kw>EXACT</kw> </alt>
<blankline/>
<comment>WG3:UTC-071R1 Deleted 1 (one) non-reserved word</comment>
<alt br="no"> <kw>FIRST</kw> </alt>
<blankline/>
<alt br="no"> <kw>GRAPH</kw> </alt>
<alt br="no"> <kw>GROUPS</kw> </alt>
<comment>WG3:POS-011R1</comment>
<blankline/>
<alt br="no"> <kw>HAMMING</kw> </alt>
<blankline/>
<comment>WG3:UTC-088 INDEX removed</comment>
<comment>WG3:BER-052R1</comment>
<alt br="no"> <kw>KEEP</kw> </alt>
<blankline/>
<comment>WG3:UTC-071R1 Deleted 3 non-reserved words</comment>
<alt br="no"> <kw>LABEL</kw> </alt>
<alt br="no"> <kw>LABELED</kw> </alt>
<alt br="no"> <kw>LABELS</kw> </alt>
<alt br="no"> <kw>LAST</kw> </alt>
<blankline/>
<comment>WG3:POS-011R1</comment>
<alt br="no"> <kw>MANHATTAN</kw> </alt>
<blankline/>
<comment>WG3:UTC-071R1 Deleted 2 non-reserved words</comment>
<comment>Editorial: Stefan Plantikow, 2023-02-15 Added NO since its used by NO BINDINGS</comment>
<comment>Editorial: Stefan Plantikow, 2023-02-15 Added NUMERIC for base type names</comment>
<alt br="no"> <kw>NFC</kw> </alt>
<alt br="no"> <kw>NFD</kw> </alt>
<alt br="no"> <kw>NFKC</kw> </alt>
<alt br="no"> <kw>NFKD</kw> </alt>
<alt br="no"> <kw>NO</kw> </alt>
<alt br="no"> <kw>NODE</kw> </alt>
<alt br="no"> <kw>NORMALIZED</kw> </alt>
<blankline/>
<comment>Editorial: Stefan Plantikow, 2020-10-11 OVERRIDABLE</comment>
<comment>WG3:UTC-071R1 Deleted 2 non-reserved words</comment>
<alt br="no"> <kw>ONLY</kw> </alt>
<alt br="no"> <kw>ORDINALITY</kw> </alt>
<blankline/>
<alt br="no"> <kw>PROPERTY</kw> </alt>
<blankline/>
<comment>Editorial: Stefan Plantikow, 2020-10-09 RECORDS is now reserved</comment>
<comment>WG3:BER-052R1</comment>
<comment>WG3:UTC-071R1 Deleted 1 (one) non-reserved word</comment>
<alt br="no"> <kw>READ</kw> </alt>
<alt br="no"> <kw>RELATIONSHIP</kw> </alt>
<alt br="no"> <kw>RELATIONSHIPS</kw> </alt>
<alt br="no"> <kw>REPEATABLE</kw> </alt>
<comment>WG3:POS-011R1</comment>
<alt br="no"> <kw>RETURNING</kw> </alt>

<blankline/>
<comment>WG3:UTC-071R1 Deleted 1 (one) non-reserved word</comment>
<alt br="no"> <kw>SHORTEST</kw> </alt>
<alt br="no"> <kw>SIMPLE</kw> </alt>
<alt br="no"> <kw>SOURCE</kw> </alt>
<blankline/>
<comment>WG3:W24-022</comment>
<comment>WG3:UTC-071R1 Deleted 2 non-reserved words</comment>
<comment>WG3:UTC-117</comment>
<comment>Correction of application of WG3:UTC-117 Deleted 1 (one) non-reserved word</comment>
<alt br="no"> <kw>TABLE</kw> </alt>
<alt br="no"> <kw>TEMP</kw> </alt>
<alt br="no"> <kw>TO</kw> </alt>
<alt br="no"> <kw>TRAIL</kw> </alt>
<alt br="no"> <kw>TRANSACTION</kw> </alt>
<alt br="no"> <kw>TYPE</kw> </alt>
<blankline/>
<alt br="no"> <kw>UNDIRECTED</kw> </alt>
<blankline/>
<comment>WG3:UTC-071R1 Deleted 1 (one) non-reserved word</comment>
<alt br="no"> <kw>VERTEX</kw> </alt>
<blankline/>
<comment>WG3:UTC-117</comment>
<alt br="no"> <kw>WALK</kw> </alt>
<alt br="no"> <kw>WITHOUT</kw> </alt>
<alt br="no"> <kw>WRITE</kw> </alt>
<blankline/>
<comment>WG3:W08-014</comment>
<alt br="no"> <kw>ZONE</kw> </alt>
</rhs>
</BNFdef>

<comment>WG3:JCJ-015</comment>
<BNFdef name="multiset alternation operator">
<rhs>
<terminalsymbol unicode="007C,002B,007C">|+|</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:MMX-028R2</comment>
<comment>Editorial: WG3:MMX-060 Email Fred Zemke, 2020-07-21</comment>
<comment>WG3:W08-009 P16-USA-090</comment>
<comment>WG3:W26-022R2</comment>
<BNFdef name="delimiter token">
<rhs>
<alt> <BNF name="GQL special character"/> </alt>
<alt> <BNF name="bracket right arrow"/> </alt>
<alt> <BNF name="bracket tilde right arrow"/> </alt>
<alt> <BNF name="character string literal"/> </alt>
<alt> <BNF name="concatenation operator"/> </alt>
<alt> <BNF name="date string"/> </alt>
<alt> <BNF name="datetime string"/> </alt>
<alt> <BNF name="delimited identifier"/> </alt>
<alt> <BNF name="double colon"/> </alt>
<alt> <BNF name="double period"/> </alt>
<alt> <BNF name="duration string"/> </alt>
<alt> <BNF name="greater than operator"/> </alt>
<alt> <BNF name="greater than or equals operator"/> </alt>
<alt> <BNF name="left arrow"/> </alt>
<alt> <BNF name="left arrow bracket"/> </alt>
<alt> <BNF name="left arrow tilde"/> </alt>
<alt> <BNF name="left arrow tilde bracket"/> </alt>
<alt> <BNF name="left minus right"/> </alt>
<alt> <BNF name="left minus slash"/> </alt>
<alt> <BNF name="left tilde slash"/> </alt>
<alt> <BNF name="less than operator"/> </alt>
<alt> <BNF name="less than or equals operator"/> </alt>
<alt> <BNF name="minus left bracket"/> </alt>
<alt> <BNF name="minus slash"/> </alt>
<alt> <BNF name="not equals operator"/> </alt>
<alt> <BNF name="right arrow"/> </alt>
<alt> <BNF name="right bracket minus"/> </alt>
<alt> <BNF name="right bracket tilde"/> </alt>
<alt> <BNF name="right double arrow"/> </alt>
<alt> <BNF name="slash minus"/> </alt>
<alt> <BNF name="slash minus right"/> </alt>
<alt> <BNF name="slash tilde"/> </alt>
<alt> <BNF name="slash tilde right"/> </alt>
<alt> <BNF name="tilde left bracket"/> </alt>
<alt> <BNF name="tilde right arrow"/> </alt>
<alt> <BNF name="tilde slash"/> </alt>
<alt> <BNF name="time string"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="bracket right arrow">
<rhs>
<terminalsymbol unicode="005D, 002D, 003E">]-></terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:MMX-060</comment>
<BNFdef name="bracket tilde right arrow">
<rhs>
<terminalsymbol unicode="005D, 007E, 003E">]~></terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="concatenation operator">
<rhs>
<terminalsymbol unicode="007C, 007C">||</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="double colon">
<rhs>
<terminalsymbol unicode="003A, 003A">::</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:CMN-061R1</comment>
<BNFdef name="double dollar sign">
<rhs>
<terminalsymbol unicode="0024, 0024">$$</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="double minus sign">
<rhs>
<terminalsymbol unicode="002D, 002D">--</terminalsymbol>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-02-06</comment>
<BNFdef name="double period">
<rhs>
<terminalsymbol unicode="002E, 002E">..</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:MMX-060</comment>
<BNFdef name="greater than operator">
<rhs>
<BNF name="right angle bracket"/>
</rhs>
</BNFdef>

<BNFdef name="greater than or equals operator">
<rhs>
<terminalsymbol unicode="003E, 003D">&gt;=</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="left arrow">
<rhs>
<terminalsymbol unicode="003C, 002D">&lt;-</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:MMX-060</comment>
<BNFdef name="left arrow tilde">
<rhs>
<terminalsymbol unicode="003C, 007E">&lt;~</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="left arrow bracket">
<rhs>
<terminalsymbol unicode="003C, 002D, 005B">&lt;-[</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:MMX-060</comment>
<BNFdef name="left arrow tilde bracket">
<rhs>
<terminalsymbol unicode="003C, 007E, 005B">&lt;~[</terminalsymbol>
</rhs>
</BNFdef>

<comment>Editorial: WG3:MMX-060 Email Fred Zemke, 2020-07-21</comment>
<BNFdef name="left minus right">
<rhs>
<terminalsymbol unicode="003C, 002D, 003E">&lt;-></terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:MMX-060</comment>
<BNFdef name="left minus slash">
<rhs>
<terminalsymbol unicode="003C, 002D, 002F">&lt;-/</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:MMX-060</comment>
<BNFdef name="left tilde slash">
<rhs>
<terminalsymbol unicode="003C, 007E, 002F">&lt;~/</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:MMX-060</comment>
<BNFdef name="less than operator">
<rhs>
<BNF name="left angle bracket"/>
</rhs>
</BNFdef>

<BNFdef name="less than or equals operator">
<rhs>
<terminalsymbol unicode="003C, 003D">&lt;=</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="minus left bracket">
<rhs>
<terminalsymbol unicode="002D, 005B">-[</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:MMX-060</comment>
<BNFdef name="minus slash">
<rhs>
<terminalsymbol unicode="002D, 002F">-/</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="not equals operator">
<rhs>
<terminalsymbol unicode="003C, 003E">&lt;&gt;</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="right arrow">
<rhs>
<terminalsymbol unicode="002D, 003E">-&gt;</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="right bracket minus">
<rhs>
<terminalsymbol unicode="005D, 002D">]-</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:MMX-028R2 and WG3:MMX-060</comment>
<BNFdef name="right bracket tilde">
<rhs>
<terminalsymbol unicode="005D, 007E">]~</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="right double arrow">
<rhs>
<terminalsymbol unicode="003D, 003E">=></terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:MMX-060</comment>
<BNFdef name="slash minus">
<rhs>
<terminalsymbol unicode="002F, 002D">/-</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:MMX-060</comment>
<BNFdef name="slash minus right">
<rhs>
<terminalsymbol unicode="002F, 002D, 003E">/-></terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:MMX-060</comment>
<BNFdef name="slash tilde">
<rhs>
<terminalsymbol unicode="002F, 007E">/~</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:MMX-060</comment>
<BNFdef name="slash tilde right">
<rhs>
<terminalsymbol unicode="002F, 007E, 003E">/~></terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:MMX-028R2 and WG3:MMX-060</comment>
<BNFdef name="tilde left bracket">
<rhs>
<terminalsymbol unicode="007E,005B">~[</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:MMX-060</comment>
<BNFdef name="tilde right arrow">
<rhs>
<terminalsymbol unicode="007E,003E">~></terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:MMX-060</comment>
<BNFdef name="tilde slash">
<rhs>
<terminalsymbol unicode="007E, 002F">~/</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="double solidus">
<rhs>
<terminalsymbol unicode="002F, 002F">//</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="separator">
<rhs>
<group>
<alt br="no"> <BNF name="comment"/> </alt>
<alt br="no"> <BNF name="whitespace"/> </alt>
</group><repeat/>
</rhs>
</BNFdef>

<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<bar note="Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references"/>
<BNFdef name="whitespace">
<rhs>
<seeTheRules><itemref ref="gql_tok_ws" type="SR"/></seeTheRules>
</rhs>
</BNFdef>

<comment>WG3:W26-026R2</comment>
<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<BNFdef name="truncating whitespace">
<rhs>
<seeTheRules><itemref ref="gql_tok_tws" type="SR"/></seeTheRules>
</rhs>
</BNFdef>

<comment>WG3:W23-014</comment>
<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<BNFdef name="bidirectional control character">
<rhs>
<seeTheRules><itemref ref="gql_tok_bdcc" type="SR"/></seeTheRules>
</rhs>
</BNFdef>
<endbar/>

<BNFdef name="comment">
<rhs>
<alt> <BNF name="simple comment"/> </alt>
<alt> <BNF name="bracketed comment"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="simple comment">
<rhs>
<BNF name="simple comment introducer"/>
<opt> <BNF name="simple comment character"/><repeat/> </opt> <BNF name="newline"/>
</rhs>
</BNFdef>

<comment>WG3:JCJ-010R1</comment>
<BNFdef name="simple comment introducer">
<rhs>
<alt> <BNF name="double solidus"/> </alt>
<alt> <BNF name="double minus sign"/> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<bar note="Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references"/>
<BNFdef name="simple comment character">
<rhs>
<seeTheRules><itemref ref="gql_tok_scc" type="SR"/></seeTheRules>
</rhs>
</BNFdef>
<endbar/>

<BNFdef name="bracketed comment">
<rhs>
<BNF name="bracketed comment introducer"/>
<breakindent/>
<BNF name="bracketed comment contents"/>
<breakindent/>
<BNF name="bracketed comment terminator"/>
</rhs>
</BNFdef>

<BNFdef name="bracketed comment introducer">
<rhs>
<terminalsymbol unicode="002F, 002A">/*</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="bracketed comment terminator">
<rhs>
<terminalsymbol unicode="002A, 002F">*/</terminalsymbol>
</rhs>
</BNFdef>

<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<bar note="Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references"/>
<BNFdef name="bracketed comment contents">
<rhs>
<seeTheRules><itemref ref="gql_tok_bcc" type="SR"/></seeTheRules>
</rhs>
</BNFdef>
<comment>WG3:W21-059 Moved grave accent related productions to literals</comment>

<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<BNFdef name="newline">
<rhs>
<seeTheRules><itemref ref="gql_tok_nl" type="SR"/></seeTheRules>
</rhs>
</BNFdef>
<endbar/>

<BNFdef name="edge synonym">
<rhs>
<alt br="no"> <kw>EDGE</kw> </alt>
<alt br="no"> <kw>RELATIONSHIP</kw> </alt>
</rhs>
</BNFdef>

<comment>WG3:BER-032R3</comment>
<BNFdef name="edges synonym">
<rhs>
<alt br="no"> <kw>EDGES</kw> </alt>
<alt br="no"> <kw>RELATIONSHIPS</kw> </alt>
</rhs>
</BNFdef>

<BNFdef name="node synonym">
<rhs>
<alt br="no"> <kw>NODE</kw> </alt>
<alt br="no"> <kw>VERTEX</kw> </alt>
</rhs>
</BNFdef>

<comment>WG3:W26-022R2</comment>
<BNFdef name="implies">
<rhs>
<alt br="no"> <BNF name="right double arrow"/> </alt>
<alt br="no"> <kw>IMPLIES</kw> </alt>
</rhs>
</BNFdef>

</grammar>

</Format>


<SyntaxRules>

<olist>

<comment>WG3:W23-014</comment>
<comment>WG3:CMN-032</comment>
<item id="gql_tok_is">An <BNF name="identifier start"/> shall be <BNF name="underscore"/> or 
any character with the Unicode property XID_Start, optionally modified by 
an <impDef code="IE003"/> profile, in accordance with UAX31-D1 Default Identifier Syntax 
in <docref ref="Unicode31"/>.

<note>The characters in ID_Start are those in the Unicode General Category classes
<quote>Lu</quote>, <quote>Ll</quote>, <quote>Lt</quote>, <quote>Lm</quote>, <quote>Lo</quote>, and
<quote>Nl</quote> together with those with the Unicode property Other_ID_Start but none of which
have the Unicode properties Pattern_Syntax or Pattern_White_Space.
The characters in XID_Start are derived from those in ID_Start to ensure closure under NFKC 
normalization.
</note>

</item>

<comment>WG3:W23-014</comment>
<comment>WG3:CMN-032</comment>
<item id="gql_tok_ie">An <BNF name="identifier extend"/> shall be any character with the Unicode 
property XID_Continue, optionally modified by an <impDef code="IE003"/> profile, in accordance 
with UAX31-D1 Default Identifier Syntax in <docref ref="Unicode31"/>.

<note>The characters in ID_Continue are those in ID_Start together with those in the Unicode
General Category classes <quote>Mn</quote>, <quote>Mc</quote>, <quote>Nd</quote>, and
<quote>Pc</quote> together with those with the Unicode property Other_ID_Continue but none of
which have the Unicode properties Pattern_Syntax or Pattern_White_Space.
The characters in XID_Continue are derived from those in ID_Continue to ensure closure under NFKC 
normalization. 
Every character in XID_Start is also a character in XID_Continue.
</note>

</item>

<comment>WG3:W02-016</comment>
<comment>WG3:W17-027</comment>
<comment>WG3:W23-014</comment>
<item>The <newterm>representative form</newterm> <symdef>RF</symdef> of
a <BNF name="non-delimited identifier"/> <symdef>NDI</symdef> is the character string
comprising the sequence of characters contained in <sym>NDI</sym>. 
<sym>RF</sym> shall not be the zero-length character string.

<note>Provisions regarding the assumed Unicode normalization of character strings apply. 
See <specref ref="gql_conc_char_string"/>.
</note>

</item>

<comment>Editorial: Stephen Cannan, 2020-10-06 Add escaped grave accent</comment>
<comment>WG3:W17-027</comment>
<comment>WG3:W23-014</comment>
<item id="gql_rep_frm_di">The <newterm>representative form</newterm> <symdef>RF</symdef> of 
a <BNF name="delimited identifier"/> <symdef>DI</symdef> is the character string
specified by the <BNF name="double quoted character sequence"/>, or 
the <BNF name="accent quoted character sequence"/> contained in <sym>DI</sym>. 
<sym>RF</sym> shall not be the zero-length character string.

<note>Provisions regarding the assumed Unicode normalization of character strings apply. 
See <specref ref="gql_conc_char_string"/>.
</note>

</item>

<comment>WG3:W02-016</comment>
<comment>WG3:W17-027</comment>
<comment>WG3:W23-014</comment>
<item>For every <BNF name="non-delimited identifier"/> or <BNF name="delimited identifier"/> 
<symdef>NDIODI</symdef>:

<olist>

<item>Let <symdef>RF</symdef> be the representative form of <sym>NDIODI</sym>.
</item>

<item>The maximum length in characters of <sym>RF</sym> shall be 
2<super>14</super> &minus;1 = 16383.

<note>This maximum length is modified by <itemref ref="gql_max_len_del_id" type="CR"/>.
</note>

</item>

<item><sym>RF</sym> shall not contain characters of the Unicode General Category classes 
<quote>Cc</quote>, <quote>Cf</quote>, <quote>Cn</quote>, <quote>Cs</quote>, <quote>Zl</quote>, or
<quote>Zp</quote>.

<note>The Unicode General Category classes <quote>Cc</quote>, <quote>Cf</quote>, <quote>Cn</quote>,
<quote>Cs</quote>, <quote>Zl</quote>, and <quote>Zp</quote> are assigned to Unicode characters that
are, respectively, Control codes (other), Formal Control codes, Not Assigned codes, Surrogates, 
Line Separators, and Paragraph Separators.
</note>

</item>

<item><sym>RF</sym> shall not contain characters of the Unicode General Category class 
<quote>Zs</quote> other than <BNF name="space"/>.

<note>Unicode General Category class <quote>Zs</quote> identifies characters that are Space
Separators (whitespace).
</note>

</item>

<item>Whether characters of the Unicode General Category class <quote>Co</quote> are permitted to
be contained in <sym>RF</sym> is <impDef code="IA020"/>.

<note>The Unicode General Category class <quote>Co</quote> is assigned to private use characters.
</note>

</item>

</olist>

</item>

<item id="gql_tok_ws"><BNF name="whitespace"/> is any consecutive sequence of Unicode characters 
with the property White_Space.
<note>These are the characters the Unicode General Category classes 
<quote>Zs</quote>, <quote>Zl</quote> and <quote>Zp</quote> together with the characters:
<unicode>0009</unicode> (Horizontal Tabulation), <unicode>000A</unicode> (Line Feed),
<unicode>000B</unicode> (Vertical Tabulation), <unicode>000C</unicode> (Form Feed),
<unicode>000D</unicode> (Carriage Return), and <unicode>0085</unicode> (Next Line).
</note>
</item>

<comment>WG3:W26-026R2</comment>
<item id="gql_tok_tws"><BNF name="truncating whitespace"/> is an <impDef code="IV023"/> subset of 
Unicode characters with the property White_Space; the subset shall always include at least 
<BNF name="space"/>.

<note>Since the Unicode definition of White_Space is subject to the addition of new characters,
this definition prevents an existing conforming GQL-implementation from being made non-conforming
by such a change. 
However, GQL-implementations are expected to align themselves with the most recent Unicode 
definition in a timely manner.
</note>

</item>

<comment>WG3:W23-014</comment>
<item id="gql_tok_bdcc">A <BNF name="bidirectional control character"/> is any of the following 
characters of the Unicode General Category class <quote>Cf</quote>: 
LEFT-TO-RIGHT EMBEDDING (<unicode>202A</unicode>), 
RIGHT-TO-LEFT EMBEDDING (<unicode>202B</unicode>), 
POP DIRECTIONAL FORMATTING (<unicode>202C</unicode>), 
LEFT-TO-RIGHT OVERRIDE (<unicode>202D</unicode>), 
RIGHT-TO-LEFT OVERRIDE (<unicode>202E</unicode>), 
LEFT-TO-RIGHT ISOLATE (<unicode>2066</unicode>), 
RIGHT-TO-LEFT ISOLATE (<unicode>2067</unicode>),
FIRST STRONG ISOLATE (<unicode>2068</unicode>), 
POP DIRECTIONAL ISOLATE (<unicode>2069</unicode>).

<comment>Editorial: Stefan Plantikow, 2022-11-16 Explain Cf</comment>
<note>The Unicode General Category class <quote>Cf</quote> is assigned to Unicode characters that
are Formal Control codes.
</note>
</item>

<comment>WG3:W23-014</comment>
<item id="gql_tok_scc"><BNF name="simple comment character"/> is any character in the 
GQL source text character repertoire that is not a <BNF name="newline"/>.
</item>

<comment>Editorial: Stefan Plantikow, 2021-06-19 consistent use of "character string"</comment>
<comment>WG3:W23-014</comment>
<comment>WG3:CMN-019 P00-USA-186</comment>
<item id="gql_tok_bcc"><BNF name="bracketed comment contents"/> is any character string whose 
characters are in the GQL source text character repertoire and that does not contain
<BNF name="bracketed comment terminator"/>.
</item>

<comment>WG3:W23-014</comment>
<item>Whether a <BNF name="simple comment character"/> or <BNF name="bracketed comment contents"/>
shall not be or contain, respectively, a <BNF name="bidirectional control character"/> is 
<impDef code="IA019"/>.

<note>This mitigates <docref ref="CVE-2021-42574"/>.
</note>

</item>

<item id="gql_tok_nl"><BNF name="newline"/> is the <impDef code="IA023"/> end-of-line indicator.
<note><BNF name="newline"/> is typically represented by
<unicode>000A</unicode> (<quote>Line Feed</quote>) and/or
<unicode>000D</unicode> (<quote>Carriage Return</quote>); however, this representation is not
required by this document.
</note>
</item>

<comment>Editorial: Stefan Plantikow, 2021-06-23 consistent use of "byte string"</comment>
<comment>WG3:CMN-019 P00-USA-187</comment>
<item>A <BNF name="token"/>, other than a <BNF name="byte string literal"/> shall not contain
a <BNF name="separator"/>.
</item>

<item>Any <BNF name="token"/> may be followed by a <BNF name="separator"/>.
A <BNF name="non-delimiter token"/> shall be followed by a <BNF name="delimiter token"/> or 
a <BNF name="separator"/>.
<note>If the Format does not allow a <BNF name="non-delimiter token"/> to be followed by 
a <BNF name="delimiter token"/>, then that <BNF name="non-delimiter token"/> will be followed by 
a <BNF name="separator"/>.
</note>
</item>

<comment>WG3:CMN-019 P00-USA-188</comment>
<item>GQL source text containing one or more instances of <BNF name="simple comment"/> is equivalent
to the same GQL source text with each <BNF name="simple comment"/> replaced with
<BNF name="newline"/>.
</item>

<comment>WG3:CMN-019 P00-USA-188</comment>
<item>GQL source text containing one or more instances of <BNF name="bracketed comment"/> is
equivalent to the same GQL source text with each <BNF name="bracketed comment"/> <symdef>BC</symdef>
replaced with,

<para>Case:
</para>

<olist>

<item>If <sym>BC</sym> contains a <BNF name="newline"/>, then <BNF name="newline"/>.
</item>

<item>Otherwise, <BNF name="space"/>.
</item>

</olist>

</item>

<comment>WG3:W17-027</comment>
<item>For every <BNF name="non-delimited identifier"/> <symdef>NDI</symdef>, there is exactly one
corresponding <newterm>case-normal form</newterm> <symdef>CNF</symdef>.
<sym>CNF</sym> is a character string derived from the representative form <sym>RF</sym> of 
<sym>NDI</sym> as follows.

<comment>WG3:CMN-019 P00-USA-207</comment>
<para>Let <symdef>N</symdef> be the number of characters in <sym>RF</sym>.
For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>, the 
<sym>i</sym>-th character <symdef>M</symdef><sub><sym>i</sym></sub> of <sym>RF</sym> is 
transliterated into the corresponding character or characters of <sym>CNF</sym> as follows.
</para>

<para>Case:
</para>

<olist>

<item>If <sym>M</sym><sub><sym>i</sym></sub> is a lower-case character or a title case character 
for which an equivalent upper-case sequence <symdef>U</symdef> is defined by Unicode, then 
let <symdef>j</symdef> be the number of characters in <sym>U</sym>; the next <sym>j</sym> characters
of <sym>CNF</sym> are <sym>U</sym>.
</item>

<item>Otherwise, the next character of <sym>CNF</sym> is <sym>M</sym><sub><sym>i</sym></sub>.
</item>

</olist>

<note>Any lower-case letters for which there are no upper-case equivalents are left in their
lower-case form.
</note>

<comment>WG3:W17-027</comment>
<note>The case-normal form of a <BNF name="non-delimited identifier"/> is used in excluding 
<BNF name="reserved word"/>s.
</note>

</item>

<comment>WG3:W17-027</comment>
<comment>Consequence of WG3:W23-014</comment>
<item>The case-normal form of a <BNF name="non-delimited identifier"/> shall not be equal, 
according to the comparison rules in <specref ref="gql_comp"/>, to any 
<BNF name="reserved word"/> (with every letter that is a lower-case letter replaced by the 
corresponding upper-case letter or letters), treated as a <BNF name="character string literal"/>.

<comment>Editorial: Stephen Cannan, 2023-07-11, Standardize the spelling of keyword</comment>
<note>It is the intention that no keyword specified in this document or revisions thereto will end
with an <BNF name="underscore"/>.
</note>

</item>

<comment>WG3:W17-027</comment>
<item>Two <BNF name="non-delimited identifier"/>s are equivalent if their
representative forms compare equally according to the comparison rules in
<specref ref="gql_comp"/>.
</item>

<comment>Editorial: Stephen Cannan, 2020-10-06 Correct comparison of identifiers</comment>
<comment>WG3:W17-027</comment>
<item>A <BNF name="non-delimited identifier"/> and a <BNF name="delimited identifier"/> are 
equivalent if their representative forms compare equally according to the comparison rules in
<specref ref="gql_comp"/>.
</item>

<comment>Editorial: Stephen Cannan, 2020-10-06 Correct comparison of identifiers</comment>
<comment>WG3:W17-027</comment>
<item>Two <BNF name="delimited identifier"/>s are equivalent if their representative forms 
compare equally according to the comparison rules in <specref ref="gql_comp"/>.
</item>

<comment>WG3:W26-037R3</comment>
<item>A <newterm>new system-generated regular identifier</newterm> is 
a new system-generated identifier that also conforms to the Format and Syntax Rules of 
<BNF name="regular identifier"/>.
</item>

<comment>WG3:W26-037R3</comment>
<item id="gql_token_sys_gen_id">A <newterm>new system-generated identifier</newterm> 
<symdef>IDENT</symdef> that is possibly qualified by additional syntactic requirements is 
a system-generated identifier that is generated at a given point during the application 
<symdef>APP</symdef> of Rules for the GQL-program <symdef>PROGRAM</symdef> of the GQL-request 
such that:

<olist>

<item><sym>IDENT</sym> conforms to the Format and Syntax Rules of <BNF name="identifier"/>.
</item>

<item>Within the context provided by <sym>APP</sym>, it holds that:

<olist>

<item><sym>IDENT</sym> does not identify an existing named object or construct prior to being
explicitly bound.
</item>

<item><sym>IDENT</sym> adheres to all specified qualifying additional syntactic requirements
</item>

</olist>

</item>

<item><sym>IDENT</sym> does not identify a session parameter in the current session context or 
a dynamic parameter in the current request context.
</item>

<item><sym>IDENT</sym> is not equivalent to an <BNF name="identifier"/> or 
a <BNF name="separated identifier"/> contained in <sym>PROGRAM</sym>.
</item>

<item><sym>IDENT</sym> is not equivalent to any other system-generated identifier obtained during
the application of Rules for <sym>PROGRAM</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-095</comment>
<comment>WG3:CMN-019 P00-NLD-037</comment>
<item id="gql_canonical_name">For every <BNF name="delimited identifier"/> or 
<BNF name="non-delimited identifier"/> <symdef>DIONDI</symdef>, there is exactly one
<newterm>canonical name form</newterm> that is a character string derived from
the representative form of <sym>DIONDI</sym> using an <impDef code="IW023"/> mechanism such that
the canonical name forms of equivalent identifiers are always identical.
</item>

<comment>Consequence of WG3:W23-014</comment>
<comment>Editorial: Stephen Cannan, 2023-07-11, Standardize the spelling of keyword</comment>
<item>For the purposes of identifying keywords, any <BNF name="simple Latin lower-case letter"/> 
contained in a candidate <BNF name="keyword"/> shall be effectively treated as the corresponding 
<BNF name="simple Latin upper-case letter"/>.

<comment>WG3:CMN-056</comment>
<note>The equivalence of <BNF name="simple Latin lower-case letter"/>s and
<BNF name="simple Latin upper-case letter"/> is specified in <specref ref="gql_character"/>,
<itemref ref="gql_character_SR_one_to_one" type="SR"/>.
</note>

</item>

<comment>WG3:CMN-061R1</comment>
<item>A <newterm>parameter reference</newterm> is either 
a <BNF name="substituted parameter reference"/> or a <BNF name="general parameter reference"/>.
</item>

<comment>WG3:CMN-061R1</comment>
<item>The <newterm>parameter name</newterm> of parameter reference <symdef>PR</symdef> is the 
parameter name specified by the <BNF name="parameter name"/> simply contained in <sym>PR</sym>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W12-025</comment>
<comment>WG3:W12-025</comment>
<comment>WG3:W23-014</comment>
<item id="gql_max_len_del_id">Without <feature code="GB01"/>, in conforming GQL language, the 
maximum length in characters of the representative form of 
a <BNF name="non-delimited identifier"/> or a <BNF name="delimited identifier"/> shall be 
2<super>7</super> &minus;1 = 127.
</item>

<comment>WG3:W17-025R1</comment>
<comment>WG3:CMN-019 P00-USA-190</comment>
<item>Without <feature code="GB02"/>, conforming GQL language shall not contain
a <BNF name="simple comment introducer"/> that is a <BNF name="double minus sign"/>.
</item>

<comment>WG3:CMN-019 P00-USA-188</comment>
<item>Without <feature code="GB03"/>, conforming GQL language shall not contain
a <BNF name="simple comment introducer"/> that is a <BNF name="double solidus"/>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_character" newpage="true">
<clauseHeading><BNF name="GQL terminal character"/></clauseHeading>

<bodyMatter>


<Function>

<comment>Editorial: Stephen Cannan, 2021-02-02</comment>
<para>Define the terminal symbols of the GQL language.
</para>

</Function>


<Format>

<grammar>

<BNFdef name="GQL terminal character">
<rhs>
<alt> <BNF name="GQL language character"/> </alt>
<alt> <BNF name="other language character"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="GQL language character">
<rhs>
<alt> <BNF name="simple Latin letter"/> </alt>
<alt> <BNF name="digit"/> </alt>
<alt> <BNF name="GQL special character"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="simple Latin letter">
<rhs>
<alt> <BNF name="simple Latin lower-case letter"/> </alt>
<alt> <BNF name="simple Latin upper-case letter"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="simple Latin lower-case letter">
<rhs>
<alt br="no"> <terminalsymbol>a</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>b</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>c</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>d</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>e</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>f</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>g</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>h</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>i</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>j</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>k</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>l</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>m</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>n</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>o</terminalsymbol> </alt>
<linebreak/>
<alt br="no"> <terminalsymbol>p</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>q</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>r</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>s</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>t</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>u</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>v</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>w</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>x</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>y</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>z</terminalsymbol> </alt>
</rhs>
</BNFdef>

<BNFdef name="simple Latin upper-case letter">
<rhs>
<alt br="no"> <terminalsymbol>A</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>B</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>C</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>D</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>E</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>F</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>G</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>H</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>I</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>J</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>K</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>L</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>M</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>N</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>O</terminalsymbol> </alt>
<linebreak/>
<alt br="no"> <terminalsymbol>P</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>Q</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>R</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>S</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>T</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>U</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>V</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>W</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>X</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>Y</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>Z</terminalsymbol> </alt>
</rhs>
</BNFdef>

<comment>WG3:MMX-011R1, 2020-06-14</comment>
<BNFdef name="hex digit">
<rhs>
<alt br="no"> <BNF name="standard digit"/> </alt>
<alt br="no"> <terminalsymbol>A</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>B</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>C</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>D</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>E</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>F</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>a</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>b</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>c</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>d</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>e</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>f</terminalsymbol> </alt>
</rhs>
</BNFdef>

<BNFdef name="digit">
<rhs>
<alt> <BNF name="standard digit"/> </alt>
<alt> <BNF name="other digit"/> </alt>
</rhs>
</BNFdef>

<comment>WG3:MMX-011R1, 2020-06-14</comment>
<BNFdef name="standard digit">
<rhs>
<alt br="no"> <BNF name="octal digit"/> </alt>
<alt br="no"> <terminalsymbol>8</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>9</terminalsymbol> </alt>
</rhs>
</BNFdef>

<comment>WG3:MMX-011R1, 2020-06-14</comment>
<BNFdef name="octal digit">
<rhs>
<alt br="no"> <BNF name="binary digit"/> </alt>
<alt br="no"> <terminalsymbol>2</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>3</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>4</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>5</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>6</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>7</terminalsymbol> </alt>
</rhs>
</BNFdef>

<comment>WG3:MMX-011R1, 2020-06-14</comment>
<BNFdef name="binary digit">
<rhs>
<alt br="no"> <terminalsymbol>0</terminalsymbol> </alt>
<alt br="no"> <terminalsymbol>1</terminalsymbol> </alt>
</rhs>
</BNFdef>

<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<bar note="Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references"/>
<BNFdef name="other digit">
<rhs>
<seeTheRules><itemref ref="gql_GQLc_od" type="SR"/></seeTheRules>
</rhs>
</BNFdef>
<endbar/>

<comment>Editorial: Stefan Plantikow, 2020-07-27 WG3:MMX-055</comment>
<comment>Editorial: Stefan Plantikow, 2020-09-16 commercial at</comment>
<comment>WG3:UTC-044</comment>
<comment>WG3:CMN-019 P00-DEU-023</comment>
<BNFdef name="GQL special character">
<rhs>
<alt> <BNF name="space"/> </alt>
<alt> <BNF name="ampersand"/> </alt>
<alt> <BNF name="asterisk"/> </alt>
<alt> <BNF name="colon"/> </alt>
<alt> <BNF name="equals operator"/> </alt>
<alt> <BNF name="comma"/> </alt>
<alt> <BNF name="commercial at"/> </alt>
<alt> <BNF name="dollar sign"/> </alt>
<alt> <BNF name="double quote"/> </alt>
<alt> <BNF name="exclamation mark"/> </alt>
<alt> <BNF name="grave accent"/> </alt>
<alt> <BNF name="right angle bracket"/> </alt>
<alt> <BNF name="left brace"/> </alt>
<alt> <BNF name="left bracket"/> </alt>
<alt> <BNF name="left paren"/> </alt>
<alt> <BNF name="left angle bracket"/> </alt>
<alt> <BNF name="minus sign"/> </alt>
<alt> <BNF name="period"/> </alt>
<alt> <BNF name="plus sign"/> </alt>
<alt> <BNF name="question mark"/> </alt>
<alt> <BNF name="quote"/> </alt>
<alt> <BNF name="reverse solidus"/> </alt>
<alt> <BNF name="right brace"/> </alt>
<alt> <BNF name="right bracket"/> </alt>
<alt> <BNF name="right paren"/> </alt>
<alt> <BNF name="solidus"/> </alt>
<alt> <BNF name="underscore"/> </alt>
<alt> <BNF name="vertical bar"/> </alt>
<alt> <BNF name="percent"/> </alt>
<alt> <BNF name="tilde"/> </alt>
</rhs>
</BNFdef>

<BNFdef name="space">
<rhs>
<!-- Needed to get correct indentation; relies on a hack in VerifySourceCode.xsl -->
<terminalsymbol unicode="0020">&nbsp;</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="ampersand">
<rhs>
<terminalsymbol unicode="0026">&amp;</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="asterisk">
<rhs>
<terminalsymbol unicode="002A">*</terminalsymbol>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-06-14 colon equals</comment>
<BNFdef name="colon">
<rhs>
<terminalsymbol unicode="003A">:</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="comma">
<rhs>
<terminalsymbol unicode="002C">,</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:UTC-044</comment>
<BNFdef name="commercial at">
<rhs>
<terminalsymbol unicode="0040">@</terminalsymbol>
</rhs>
</BNFdef>

<comment>Editorial: Stefan Plantikow, 2020-09-16 commercial at</comment>
<BNFdef name="dollar sign">
<rhs>
<terminalsymbol unicode="0024">$</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="double quote">
<rhs>
<terminalsymbol unicode="0022">&quot;</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="equals operator">
<rhs>
<terminalsymbol unicode="003D">=</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="exclamation mark">
<rhs>
<terminalsymbol unicode="0021">!</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:MMX-060</comment>
<BNFdef name="right angle bracket">
<rhs>
<terminalsymbol unicode="003E">&gt;</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="grave accent">
<rhs>
<terminalsymbol unicode="0060">`</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="left brace">
<rhs>
<terminalsymbol unicode="007B">{</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="left bracket">
<rhs>
<terminalsymbol unicode="005B">[</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="left paren">
<rhs>
<terminalsymbol unicode="0028">(</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:MMX-060</comment>
<BNFdef name="left angle bracket">
<rhs>
<terminalsymbol unicode="003C">&lt;</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="minus sign">
<rhs>
<terminalsymbol unicode="002D">-</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="percent">
<rhs>
<terminalsymbol unicode="0025">%</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="period">
<rhs>
<terminalsymbol unicode="002E">.</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="plus sign">
<rhs>
<terminalsymbol unicode="002B">+</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="question mark">
<rhs>
<terminalsymbol unicode="003F">?</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="quote">
<rhs>
<terminalsymbol unicode="0027">&apos;</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="reverse solidus">
<rhs>
<terminalsymbol unicode="005C">\</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="right brace">
<rhs>
<terminalsymbol unicode="007D">}</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="right bracket">
<rhs>
<terminalsymbol unicode="005D">]</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="right paren">
<rhs>
<terminalsymbol unicode="0029">)</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="solidus">
<rhs>
<terminalsymbol unicode="002F">/</terminalsymbol>
</rhs>
</BNFdef>

<comment>WG3:MMX-028R2 and WG3:MMX-060</comment>
<BNFdef name="tilde">
<rhs>
<terminalsymbol unicode="007E">~</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="underscore">
<rhs>
<terminalsymbol unicode="005F">_</terminalsymbol>
</rhs>
</BNFdef>

<BNFdef name="vertical bar">
<rhs>
<terminalsymbol unicode="007C">|</terminalsymbol>
</rhs>
</BNFdef>

<comment>Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references</comment>
<bar note="Editorial: Stephen Cannan, 2025-06-02 SeeTheRules references"/>
<BNFdef name="other language character">
<rhs>
<seeTheRules><itemref ref="gql_GQLc_olc" type="SR"/></seeTheRules>
</rhs>
</BNFdef>
<endbar/>

</grammar>

</Format>


<SyntaxRules>

<olist>

<item id="gql_GQLc_olc"><BNF name="other language character"/> is any Unicode character not 
contained in <BNF name="GQL language character"/>.
</item>

<item id="gql_GQLc_od"><BNF name="other digit"/> is any Unicode character in the Unicode General 
Category class <quote>Nd</quote> not contained in <BNF name="standard digit"/>.
</item>

<comment>WG3:CMN-056</comment>
<item id="gql_character_SR_one_to_one">There is a one-to-one correspondence between
the symbols contained in <BNF name="simple Latin upper-case letter"/> and
the symbols contained in <BNF name="simple Latin lower-case letter"/> such that,
for every <symdef>i</symdef>, the symbol defined as
the <sym>i</sym>-th alternative for <BNF name="simple Latin upper-case letter"/>
corresponds to the symbol defined as
the <sym>i</sym>-th alternative for <BNF name="simple Latin lower-case letter"/>.
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:CMN-056 Removed 1 (one) General Rule</comment>
<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>

</clause>


<clause id="gql_common_rules">
<clauseHeading>Additional common rules</clauseHeading>

<comment>WG3:W04-009R1</comment>
<ednote id="gql_PP011_2">SQL has
<extref standard="9075" part="02" ref="fnd_potential_non_determinism"/> in SQL/Foundation, which is
modified by <extref standard="9075" part="16" ref="pgq_potential_non_determinism"/> in SQL/PGQ 
as a result of WG3:W04-009R1.
GQL currently has no equivalent Subclause.
See <PPref ref="PPgql011"/>.
</ednote>

<comment>WG3:CMN-061R1</comment>
<subClause id="gql_annot_gql_program">
<clauseHeading>Annotation of a <BNF name="GQL-program"/></clauseHeading>

<bodyMatter>

<Function>

<para>Annotate a <BNF name="GQL-program"/> with contextually provided metadata.
</para>

<note>See <specref ref="gql_conc_req_exe"/>.
</note>

</Function>


<SyntaxRules>

<olist>

<item><SCsignature>
<symparam name="GQL_PROGRAM"><symdef>PROG</symdef></symparam>
<symparam name="INI_SCHEMA"><symdef>IS</symdef></symparam>
<symparam name="INI_GRAPH"><symdef>IG</symdef></symparam>
<symparam name="SES_PARAMS"><symdef>SESP</symdef></symparam>
<symparam name="DYN_PARAMS"><symdef>DYNP</symdef></symparam>
<documentation>
<slist>
<item>GQL_PROGRAM — a <BNF name="GQL-program"/>.
</item>
<item>INI_SCHEMA — either <quote>not set</quote>, or 
an <BNF name="absolute catalog schema reference"/>.
</item>
<item>INI_GRAPH — either <quote>not set</quote> or a material graph reference value.
</item>
<item>SES_PARAMS — a dictionary of general parameters.
</item>
<item>DYN_PARAMS — a dictionary of general parameters.
</item>
</slist>
</documentation>
</SCsignature>.
</item>

<item><sym>PROG</sym> is annotated with an initial schema and an initial graph as follows:

<olist>

<item>The initial schema of <sym>PROG</sym> is <sym>IS</sym>.
</item>

<item>The initial graph of <sym>PROG</sym> is <sym>IG</sym>.
</item>

</olist>

</item>

<item>For every <BNF name="substituted parameter reference"/> <symdef>SPR</symdef> simply contained
in <sym>PROG</sym>:

<olist>

<item>Let <symdef>PN</symdef> be the parameter name of <sym>SPR</sym>.
</item>

<item><sym>PN</sym> shall be the parameter name of a general parameter in <sym>DYNP</sym>.
</item>

<item>Let <symdef>PV</symdef> be the parameter value of the general parameter in <sym>DYNP</sym> 
whose parameter name is <sym>PN</sym>.
</item>

<item><sym>PV</sym> shall be GQL source text.

<note>All comments are implicitly removed from GQL source text, as detailed by
the Syntax Rules of <specref ref="gql_token"/>. 
This enables later Syntax Rules to simply verify the Format of parameter substitutions
without having to cater for comments.
</note>

</item>

<item><sym>SPR</sym> is annotated with a parameter name and a parameter substitution as follows:

<olist>

<item>The parameter name of <sym>SPR</sym> is <sym>PN</sym>.
</item>

<item>The parameter substitution of <sym>SPR</sym> is <sym>PV</sym>.

<comment>WG3:CMN-035</comment>
<note>Parameter substitutions are substituted for certain BNF non-terminal instances and
are required to conform to the Format of the corresponding BNF non-terminal symbols only. 
Consequently, GQL-implementations are required to ensure that parameter substitutions do not 
contain additional characters (such as unclosed <BNF name="bracketed comment"/>s) to avoid 
potential security issues.
</note>

</item>

</olist>

</item>

</olist>

</item>

<item>For every <BNF name="session parameter specification"/> <symdef>SPS</symdef> simply contained 
in <sym>PROG</sym>:

<olist>

<item>Let <symdef>GPR</symdef> be the <BNF name="general parameter reference"/> simply contained 
in <sym>SPS</sym>.
</item>

<item>Let <symdef>PN</symdef> be the parameter name of <sym>GPR</sym>.
</item>

<item><sym>SPS</sym> is annotated with a parameter name and a parameter value type as follows.

<para>Case:
</para>

<olist>

<item>If <sym>PN</sym> is the parameter name of a general parameter <symdef>SP</symdef> in 
<sym>SESP</sym>, then <sym>SPS</sym> is said to reference the defined session parameter 
<sym>SP</sym> and:

<olist>

<item>The parameter name of <sym>SPS</sym> is <sym>PN</sym>.
</item>

<item>The parameter value type of <sym>SPS</sym> is the parameter value type of <sym>SP</sym>.
</item>

</olist>

</item>

<item>Otherwise, <sym>SPS</sym> does not reference a defined session parameter and:

<olist>

<item>The parameter name of <sym>SPS</sym> is <sym>PN</sym>.
</item>

<item>The parameter value type of <sym>SPS</sym> is <quote>not set</quote>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<item>For every <BNF name="dynamic parameter specification"/> <symdef>DPS</symdef> simply contained
in <sym>PROG</sym>:

<olist>

<item>Let <symdef>SSC</symdef> be the <BNF name="session set command"/> that simply contains 
<sym>DPS</sym>.
</item>

<item>Let <symdef>GPR</symdef> be the <BNF name="general parameter reference"/> simply contained 
in <sym>DPS</sym>.
</item>

<item>Let <symdef>PN</symdef> be the parameter name of <sym>GPR</sym>.
</item>

<item><sym>DPS</sym> is annotated with a parameter name and a parameter value type as follows.

<note>This is a recursive definition.
</note>

<para>Case:
</para>

<olist>

<item>If there are other <BNF name="session set command"/>s that are simply contained in
<sym>PROG</sym> that precede <sym>SSC</sym> in <sym>PROG</sym> and that simply contain 
a <BNF name="session parameter specification"/> whose parameter name is <sym>PN</sym>, then:

<olist>

<item>Let <symdef>DT</symdef> be the declared type of the 
<BNF name="session parameter specification"/> simply contained in the rightmost such 
<BNF name="session set command"/>.
</item>

<item>The parameter name of <sym>DPS</sym> is <sym>PN</sym>.
</item>

<item>The parameter value type of <sym>DPS</sym> is <sym>DT</sym>.
</item>

</olist>

</item>

<item>Otherwise:

<olist>

<item><sym>PN</sym> shall be the parameter name of a general parameter in <sym>DYNP</sym>.
</item>

<item>Let <symdef>PVT</symdef> be the parameter value type of the general parameter in
<sym>DYNP</sym> whose parameter name is <sym>PN</sym>.
</item>

<item>If <sym>PN</sym> is the parameter name of a session parameter <symdef>SP</symdef> in 
<sym>SESP</sym>, then <sym>PVT</sym> shall be a subtype of the parameter value type of 
<sym>SP</sym>.
</item>

<item>The parameter name of <sym>DPS</sym> is <sym>PN</sym>.
</item>

<item>The parameter value type of <sym>DPS</sym> is <sym>PVT</sym>.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

</olist>

</SyntaxRules>


<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>

</bodyMatter>

</subClause>


<comment>WG3:W04-009R1</comment>
<subClause id="gql_machinery_graph_pattern_matching" newpage="true">
<clauseHeading>Machinery for graph pattern matching</clauseHeading>

<bodyMatter>


<Function>

<para>Define the infrastructure (alphabet, mappings and related definitions) used in graph
pattern matching.
</para>

</Function>


<SyntaxRules>

<olist>

<None/>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:RKE-038 P16-USA-781</comment>
<comment>WG3:W22-053R2</comment>
<comment>Editorial: Stephen Cannan, 2023-01-03 Add documentation</comment>
<item><SCsignature>
<symparam name="PROPERTY GRAPH"><symdef>PG</symdef></symparam>
<symparam name="PATH PATTERN LIST"><symdef>PPL</symdef></symparam>
<symreturn name="MACHINERY"/>
<documentation>
<slist>
<item>PROPERTY GRAPH &mdash; a property graph.
</item>
<item>PATH PATTERN LIST &mdash; a <BNF name="path pattern list"/>.
</item>
<item>MACHINERY &mdash; the machinery to be used for graph pattern matching.
</item>
</slist>
</documentation>
</SCsignature>
</item>

<comment>WG3:SXM-052</comment>
<comment>WG3:W02-015</comment>
<comment>WG3:BER-031</comment>
<item>Let <symdef>SVV</symdef> be the set of names of node variables declared in <sym>PPL</sym> 
at the same depth of graph pattern matching, and let <symdef>SEV</symdef> be the set of names of 
edge variables declared in <sym>PPL</sym> at the same depth of graph pattern matching.
</item>

<comment>WG3:W02-015</comment>
<comment>WG3:RKE-025 P16-USA-765</comment>
<comment>WG3:BER-031</comment>
<item>For each subpath variable <symdef>SPV</symdef> declared in <sym>PPL</sym> at 
the same depth of graph pattern matching, let <symdef>SPVBEGIN</symdef> and <symdef>SPVEND</symdef>
be two distinct <BNF name="identifier"/>s that are distinct from every
<BNF name="identifier"/> in <sym>SVV</sym> <setunion/> <sym>SEV</sym> and from every 
<BNF name="identifier"/> created by this rule.
<sym>SPVBEGIN</sym> is the <newterm>begin subpath symbol</newterm> and <sym>SPVEND</sym> is the
<newterm>end subpath symbol</newterm> associated with <sym>SPV</sym>.
Let <symdef>SPS</symdef> be the set of every subpath symbol.
</item>

<item>Let <symdef><delimId>()</delimId></symdef> and <symdef><delimId>-</delimId></symdef> be 
mutually distinct <BNF name="identifier"/>s that are distinct from every <BNF name="identifier"/>
in <sym>SVV</sym> <setunion/> <sym>SEV</sym> <setunion/> <sym>SPS</sym>.
These are, respectively, the <newterm>anonymous node symbol</newterm> and the
<newterm>anonymous edge symbol</newterm>.
Let <symdef>SAS</symdef> be the set of anonymous symbols.
</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:W02-015</comment>
<comment>WG3:W04-009R1</comment>
<comment>Editorial: Stephen Cannan 2021-11-28</comment>
<comment>WG3:W20-022</comment>
<item>Let <symdef>NPP</symdef> be the number of 
<BNF name="parenthesized path pattern expression"/>s
contained in <sym>PPL</sym> at the same depth of graph pattern matching.
Let <symdef>PPPE</symdef><sub>1</sub>, <ellipsis/>, 
<symdef>PPPE</symdef><sub><sym>NPP</sym></sub> be 
an enumeration of the <BNF name="parenthesized path pattern expression"/>s contained in 
<sym>PPL</sym> at the same depth of graph pattern matching.
For every <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NPP</sym>,
<sym>i</sym> is the <newterm>bracket index</newterm> of <sym>PPPE</sym><sub><sym>i</sym></sub>.
</item>

<comment>WG3:BNE-034</comment>
<comment>Email from: Fred Zemke, 2019-02-28 2154</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W04-009R1</comment>
<comment>WG3:W12-033: Stefan Plantikow</comment>
<comment>Editorial: Stephen Cannan 2021-11-28</comment>
<comment>WG3:W23-009R1 P00-USA-456</comment>
<item>Let <symdef><delimId>[<sub>1</sub></delimId></symdef>, <ellipsis/>,
<symdef><delimId>[<sub><sym>NPP</sym></sub></delimId></symdef>,
<symdef><delimId>]<sub>1</sub></delimId></symdef>, <ellipsis/>,
<symdef><delimId>]<sub><sym>NPP</sym></sub></delimId></symdef> be 2 * <sym>NPP</sym>
<BNF name="identifier"/>s that are mutually distinct, and distinct from every member of
<sym>SVV</sym> <setunion/> <sym>SEV</sym> <setunion/> <sym>SPS</sym> <setunion/> <sym>SAS</sym>
and from every graph element of <sym>PG</sym>.
These are called <newterm>bracket symbols</newterm>.
For every bracket symbols <delimId>[<sub><sym>j</sym></sub></delimId> or 
<delimId>]<sub><sym>j</sym></sub></delimId>, <symdef>j</symdef> is the 
<newterm>bracket index</newterm> of the bracket symbol.
There are two bracket symbols for each bracket index <sym>j</sym> between 1 (one) and 
<sym>NPP</sym>, corresponding to the <BNF name="parenthesized path pattern expression"/>s 
<sym>PPPE</sym><sub><sym>j</sym></sub>.
Let <symdef>SBS</symdef> be the set of bracket symbols.
</item>

<comment>WG3:W04-009R1</comment>
<comment>WG3:W08-018 deleted one GR</comment>

<comment>WG3:BNE-034</comment>
<comment>Email from: Fred Zemke, 2019-02-28 2154</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W04-009R1</comment>
<comment>WG3:W08-018</comment>
<comment>WG3:W12-033: Stefan Plantikow</comment>
<item>Let <symdef>GX</symdef> be the set whose members are the graph elements of <sym>PG</sym>, 
the subpath symbols, and the bracket symbols.
</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W02-015</comment>
<comment>WG3:W04-009R1</comment>
<comment>WG3:W08-018</comment>
<comment>WG3:BER-096</comment>
<item>Let <symdef>ABC</symdef> be
<sym>SPS</sym> <setunion/> <sym>SBS</sym> <setunion/> <sym>SVV</sym> <setunion/> <sym>SEV</sym>
<setunion/> <sym>SAS</sym>.
<sym>ABC</sym> is the <newterm>alphabet</newterm>.
The members of <sym>ABC</sym> are <newterm>symbols</newterm>.
</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W02-015</comment>
<item>A <newterm>word</newterm> is a string of elements of <sym>ABC</sym>.
</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<item>An <newterm>elementary binding</newterm> is a pair 
(<symdef>LET</symdef>, <symdef>GE</symdef>)
where <sym>LET</sym> is a member of <sym>ABC</sym> and <sym>GE</sym>
is a member of <sym>GX</sym>, such that:

<para>Case:
</para>

<olist>

<comment>WG3:BNE-034</comment>
<comment>WG3:RKE-023 and RKE-010 P16-SWE-009</comment>
<item>If <sym>LET</sym> is a bracket symbol, then <sym>LET</sym> = <sym>GE</sym>.
In this case, the elementary binding is a <newterm>bracket symbol binding</newterm>.
If <sym>LET</sym> is a start bracket symbol, then the elementary binding is 
a <newterm>start bracket symbol binding</newterm>; otherwise, it is 
an <newterm>end bracket symbol binding</newterm>.
The bracket index of <sym>LET</sym> is the bracket index of the bracket symbol binding.
</item>

<comment>WG3:SXM-052</comment>
<comment>WG3:BER-031</comment>
<item>If <sym>LET</sym> is a subpath symbol, then <sym>LET</sym> = <sym>GE</sym>.
In this case, the elementary binding is a <newterm>subpath symbol binding</newterm>.
</item>

<comment>WG3:W04-009R1</comment>
<comment>WG3:W08-018 deleted one subrule</comment>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W02-015</comment>
<comment>WG3:BER-031</comment>
<item>If <sym>LET</sym> is the name of a node variable or the anonymous node symbol, 
then <sym>GE</sym> is a node.
In this case the elementary binding is a <newterm>node symbol binding</newterm>.
</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W02-015</comment>
<comment>WG3:BER-031</comment>
<item>If <sym>LET</sym> is the name of an edge variable or the anonymous edge symbol, 
then <sym>GE</sym> is an edge.
In this case, the elementary binding is an <newterm>edge symbol binding</newterm>.
</item>

</olist>

</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W18-009/P16-USA-769</comment>
<comment>WG3:BER-031</comment>
<comment>Editorial: Stephen Cannan, 2024-04-10 Move unwanted content out of newterm</comment>
<item>If <symdef>EB</symdef> = (<sym>LET</sym>, <sym>GE</sym>) is an elementary binding, then 
<sym>EB</sym> is an <newterm>elementary binding</newterm> of <sym>LET</sym>, and <sym>EB</sym>
<newterm>binds</newterm> <sym>LET</sym> to <sym>GE</sym>.

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>Editorial: Stephen Cannan 2023-01-20 Align with Directives Part 2</comment>
<note>An elementary binding is a mapping of a symbol (an <BNF name="identifier"/>) to
a member of <sym>GX</sym>; it is not the binding of a graph pattern variable. 
In particular, if <sym>LET</sym> is the name of an element variable <symdef>EV</symdef>, 
there can be more than one elementary binding of <sym>LET</sym> in a multi-path binding. 
In a consistent path binding (defined subsequently), two elementary bindings of <sym>LET</sym> 
necessarily bind to the same graph element in contexts in which <sym>LET</sym> is exposed as 
unconditional singleton; otherwise, elementary bindings of <sym>LET</sym> are independent of 
one another, and can bind to more than one graph element. 
Similarly, references to <sym>EV</sym> are context-dependent, and can resolve to a list that is 
a proper subset of all the graph elements bound to <sym>LET</sym> by elementary bindings. 
Resolution of <BNF name="element variable reference"/>s is performed by the General Rules of 
<specref ref="gql_app_bind_eval_expr"/>.
</note>

<comment>WG3:UTC-087R2</comment>
<ednote>The following item from WG3:BER-031 was not included.
A <newterm>compressed binding</newterm> is a pair (<symdef>LOV</symdef>, <symdef>GE</symdef>) 
where <sym>LOV</sym> is a list of names of element variables and <sym>GE</sym> is a graph element.
</ednote>
</item>

<comment>Editorial: Stefan Plantikow, 2020-05-01 Connected with GQL</comment>
<comment>Rule added for GQL.</comment>
<comment>WG3:CMN-019 P00-USA-351</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>When an elementary binding (<sym>LET</sym>, <sym>GE</sym>)
binds <symdef>LET</symdef> to a graph element <symdef>GE</symdef>
during the evaluation of an <BNF name="element pattern where clause"/>, a new field whose 
name is <sym>LET</sym> and whose value is a graph element reference value to 
<sym>GE</sym> is temporarily added to the current working record until the evaluation has finished.
</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W26-025R1</comment>
<item>A <newterm>path binding</newterm> is a sequence of zero or more elementary bindings,
<symdef>B</symdef> = (<sym>LET</sym><sub>1</sub>, <sym>GE</sym><sub>1</sub>),
<ellipsis/> (<sym>LET</sym><sub><sym>N</sym></sub>, <sym>GE</sym><sub><sym>N</sym></sub>).
Given a path binding <sym>B</sym>:

<comment>WG3:W04-009R1</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>WG3:W21-023</comment>
<comment>Editorial: Stephen Cannan 2023-01-20 Align with Directives Part 2</comment>
<comment>WG3:UTC-080</comment>
<note>Unlike the definition of path, the definition of path binding allows a sequence of zero 
elementary bindings.
For example, a quantifier can iterate 0 (zero) times, resulting in an empty path binding.
The result of a <BNF name="path pattern"/>, on the other hand, is unable to be empty 
because of a Syntax Rule that enforces a minimum node count of 1 (one).
</note>

<olist>

<comment>WG3:BNE-034</comment>
<comment>Editorial: Stephen Cannan 2021-11-28</comment>
<item>The <newterm>word</newterm> of <sym>B</sym> is the sequence
<sym>LET</sym><sub>1</sub>, <ellipsis/>, <sym>LET</sym><sub><sym>N</sym></sub>.
</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:W26-025R1</comment>
<item>The <newterm>annotated path</newterm> of <sym>B</sym> is the sequence
<sym>GE</sym><sub>1</sub>, <ellipsis/>, <sym>GE</sym><sub><sym>N</sym></sub>.

<comment>WG3:SXM-052</comment>
<comment>WG3:W04-009R1</comment>
<comment>WG3:W08-018</comment>
<comment>WG3:UTC-009 P00-USA-169</comment>
<note>If the path binding is consistent (defined subsequently), then the annotated path of 
<sym>B</sym> contains within it a path that matches the word of <sym>B</sym>, plus mark-up with 
bracket symbols and subpath symbols indicating how to interpret the path as a match to the word.
</note>

</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:RKE-031</comment>
<comment>WG3:BER-054</comment>
<item>The <newterm>compressed path binding</newterm> <symdef>CPB</symdef> of <sym>B</sym> is 
obtained from <sym>B</sym> as follows:

<olist>

<item>Let <symdef>CPB</symdef> be a copy of <sym>B</sym>.
</item>

<comment>WG3:BER-031</comment>
<item>All subpath symbol bindings and all bracket symbol bindings are deleted from <sym>CPB</sym>.
</item>

<item>Each maximal subsequence <symdef>MS</symdef> of <sym>CPB</sym> comprising one or more
consecutive node bindings is replaced by a single compressed binding, whose components are the 
following:

<olist>

<comment>WG3:BER-031</comment>
<item>The first component is a list of the names of node variables in the first component of 
the node bindings of <sym>MS</sym>.

<note>This list is empty if only the anonymous node symbol is bound in <sym>MS</sym>.
</note>
</item>

<item>The second component is the node that is bound by the first node binding in <sym>MS</sym>.

<note>For consistent path bindings, consecutive node bindings will bind the same node.
</note>
</item>

</olist>

</item>

<comment>WG3:BER-031</comment>
<item>In each edge binding <symdef>EB</symdef> of <sym>CPB</sym>, the first component is replaced 
by a list of zero or one name of an edge variable, retaining the name of the edge variable in 
the first component of <sym>EB</sym>, if any.
</item>

</olist>

</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:RKE-031</comment>
<item>The <newterm>extracted path</newterm> <symdef>XP</symdef> of <sym>B</sym> is obtained from
the compressed path binding of <sym>B</sym> as the sequence of the second components of the
compressed bindings of <sym>CPB</sym>.

<comment>WG3:UTC-080</comment>
<note>The extracted path is a path if the path binding is consistent and non-empty; 
otherwise, the extracted path is not necessarily a path.
</note>
</item>

</olist>

</item>

<comment>WG3:SXM-052</comment>
<comment>WG3:W04-009R1</comment>
<comment>WG3:RKE-025 P16-USA-768</comment>
<comment>WG3:BER-054</comment>
<item id="gql_machinery_graph_pattern_matching_GR_reduce">Let <symdef>REDUCE</symdef> be 
a function that maps path bindings to path bindings, determined as follows.

<olist>

<comment>WG3:W04-009R1</comment>
<item>Let <symdef>PBIN</symdef> be a path binding.
</item>

<comment>WG3:W04-009R1</comment>
<item>Let <symdef>PBOUT</symdef> be a copy of <sym>PBIN</sym>.
</item>

<comment>WG3:SXM-052</comment>
<comment>WG3:W04-009R1</comment>
<item>All bracket bindings are removed from <sym>PBOUT</sym>.
</item>

<comment>WG3:W24-022</comment>
<item>Every element binding to a temporary node variable is replaced by an anonymous node binding 
to the same node in <sym>PBOUT</sym>.
</item>

<comment>WG3:W24-022</comment>
<item>Every element binding to a temporary edge variable is replaced by an anonymous edge binding 
to the same edge in <sym>PBOUT</sym>.
</item>

<comment>WG3:SXM-052</comment>
<item>The following steps are performed on <sym>PBOUT</sym> repeatedly until no more anonymous 
node bindings can be removed:

<olist>

<comment>WG3:SXM-052</comment>
<item>If there are two adjacent anonymous node bindings, then the second is removed.
</item>

<comment>WG3:SXM-052</comment>
<item>If there is a binding of a node variable adjacent to an anonymous node binding,
then the anonymous node binding is removed.
</item>

</olist>

</item>

<comment>WG3:W08-009 P16-USA-250</comment>
<item><sym>REDUCE</sym>(<sym>PBIN</sym>) is <sym>PBOUT</sym>.
</item>

</olist>

</item>

<comment>WG3:W04-009R1</comment>
<comment>WG3:W08-018</comment>
<item>In a path binding, two node bindings are <newterm>separable</newterm> if there is an edge 
binding between them.
</item>

<comment>WG3:BNE-034</comment>
<comment>Editorial: 2019-6-12</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W02-015</comment>
<comment>Email from: Jim Melton 2022-12-08 0219</comment>
<item>A path binding <symdef>B</symdef> is <newterm>consistent</newterm> if all of the following
conditions are true:

<olist>

<comment>WG3:BNE-034</comment>
<comment>Email from: Fred Zemke, 2019-02-28 2154</comment>
<comment>WG3:MMX-077</comment>
<comment>Editorial: Stefan Plantikow, 2021-06-29 Consistent use of "empty string"</comment>
<comment>WG3:W21-023</comment>
<comment>WG3:UTC-080</comment>
<item>The extracted path <symdef>XP</symdef> of <sym>B</sym> is either the empty sequence or 
a path of <sym>PG</sym>.
<note>That is, either <sym>XP</sym> is empty or <sym>XP</sym> begins with a node, alternates 
between nodes and edges, each edge in <sym>XP</sym> connects the node before and after it, and 
<sym>XP</sym> ends with a node.
</note>
</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W04-009R1</comment>
<comment>WG3:W26-025R1</comment>
<item>For every two node bindings (<sym>LET</sym><sub>1</sub>, <symdef>GE</symdef><sub>1</sub>) and
(<sym>LET</sym><sub>2</sub>, <symdef>GE</symdef><sub>2</sub>) that are not separable,
<sym>GE</sym><sub>1</sub> = <sym>GE</sym><sub>2</sub>.

<comment>WG3:W08-018</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>WG3:BER-031</comment>
<comment>WG3:UTC-009 P00-USA-169</comment>
<note>If there are only bracket symbol or subpath symbol bindings between two node bindings, then
the node bindings must bind to the same node.
</note>

</item>

<comment>WG3:BNE-034</comment>
<comment>Email from: Fred Zemke, 2019-02-28 2154</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W02-015</comment>
<comment>WG3:BER-080</comment>
<comment>Editorial: Stephen Cannan, 2023-08-30</comment>
<item>For every edge binding <symdef>EB</symdef> = (<sym>LET</sym>, <sym>GE</sym>),
let (<symdef>LET_LEFT</symdef>, <symdef>GE_LEFT</symdef>) be the 
last node binding to the left of <sym>EB</sym> and 
let (<symdef>LET_RIGHT</symdef>, <symdef>GE_RIGHT</symdef>) be the 
first node binding to the right of <sym>EB</sym>.

<para>Case:
</para>

<comment>WG3:MMX-060</comment>
<olist>

<comment>WG3:W02-015</comment>
<comment>Editorial: Stephen Cannan, 2023-08-30</comment>
<item>If <sym>GE</sym> is an undirected edge, then <sym>GE</sym> is an edge connecting 
<sym>GE_LEFT</sym> and <sym>GE_RIGHT</sym>.
</item>

<comment>WG3:W02-015</comment>
<comment>Editorial: Stephen Cannan, 2023-08-30</comment>
<item>If <sym>GE</sym> is a directed edge, then either <sym>GE_LEFT</sym> 
is the source node and <sym>GE_RIGHT</sym> is the destination node of 
<sym>GE</sym>, or <sym>GE_RIGHT</sym> is the source node and 
<sym>GE_LEFT</sym> is the destination node of <sym>GE</sym>.
<note>The directionality constraint of the edge binding is fully checked during the generation of 
the regular language for <BNF name="path concatenation"/>.
</note>
</item>

</olist>

</item>

<comment>WG3:W04-009R1</comment>
<comment>WG3:RKE-023 and RKE-010 P16-SWE-009</comment>
<comment>Editorial: Stefan Plantikow, 2022-06-14 Align wording with SQL/PGQ</comment>
<item>For every start bracket symbol binding <symdef>SBS</symdef> contained in <sym>B</sym>, 
let <symdef>j</symdef> be the bracket index of <sym>SBS</sym>.
All of the following are true:

<olist>

<comment>WG3:W09-031</comment>
<comment>WG3:RKE-023 and RKE-010 P16-SWE-009</comment>
<item>There is an end bracket symbol binding contained in <sym>B</sym> and following <sym>SBS</sym> 
whose bracket index is <sym>j</sym>.
Let <symdef>EBS</symdef> be the first such end bracket symbol binding.
Let <symdef>PPS</symdef> be the explicit or implicit <BNF name="path mode prefix"/> simply 
contained in the <BNF name="parenthesized path pattern expression"/> whose bracket index is 
<sym>j</sym>.
Let <symdef>PM</symdef> be the <BNF name="path mode"/> contained in <sym>PPS</sym>.
</item>

<item>Case:

<olist>

<comment>WG3:RKE-023 and RKE-010 P16-SWE-009</comment>
<item>If <sym>PM</sym> is <kw>TRAIL</kw>, then there is no pair of edge bindings at two different
positions between <sym>SBS</sym> and <sym>EBS</sym> that bind the same edge.

<comment>WG3:RKE-023 and RKE-010 P16-SWE-009</comment>
<note>This definition does not take note of the symbols that are bound, only the edges. 
It is a violation of the <kw>TRAIL</kw> <BNF name="path mode"/> if the symbols in the pair of 
distinct edge bindings are both anonymous edge symbols, are both edge variables (whether the same 
or different), or one is the anonymous edge symbol and the other is an edge variable.
</note>
</item>


<comment>Email from: Fred Zemke, 2023-08-29 2028</comment>
<item>If <sym>PM</sym> is <kw>SIMPLE</kw>, then no two separable node bindings between 
<sym>SBS</sym> and <sym>EBS</sym> bind the same node, except that the first and last node
binding between <sym>SBS</sym> and <sym>EBS</sym> may bind the same node.

<comment>WG3:RKE-023 and RKE-010 P16-SWE-009</comment>
<comment>Editorial: Stephen Cannan 2023-01-20 Align with Directives Part 2</comment>
<note>This definition does not take note of the symbols that are bound, only the nodes. 
It is a violation of the <kw>SIMPLE</kw> <BNF name="path mode"/> if the symbols in the pair of 
separable node bindings are both anonymous node symbols, are both node variables (whether the
same or different), or one is the anonymous node symbol and the other is a node variable.
However, the first and last node binding between <sym>SBS</sym> and <sym>EBS</sym> can bind the 
same node without violating the <kw>SIMPLE</kw> <BNF name="path mode"/>.
</note>

</item>

<item>If <sym>PM</sym> is <kw>ACYCLIC</kw>, then no two separable node bindings between
<sym>SBS</sym> and <sym>EBS</sym> bind the same node.

<comment>WG3:RKE-023 and RKE-010 P16-SWE-009</comment>
<note>This definition does not take note of the symbols that are bound, only the nodes. 
It is a violation of the <kw>ACYCLIC</kw> <BNF name="path mode"/> if the symbols in the pair of 
separable node bindings are both anonymous node symbols, both are node variables (whether the
same or different), or one is the anonymous node symbol and the other is a node variable.
</note>

</item>

</olist>

<note>The <BNF name="path mode"/> <kw>WALK</kw> imposes no constraints on the extracted path.
</note>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W04-009R1</comment>
<comment>Editorial: Stephen Cannan 2021-11-28</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<comment>Editorial: Jim Melton 2024-09-30</comment>
<item>A <newterm>multi-path binding</newterm> is an n-tuple 
(<symdef>PB</symdef><sub>1</sub>, <ellipsis/>, <symdef>PB</symdef><sub><sym>N</sym></sub>) 
for some positive integer <symdef>N</symdef> such that each <sym>PB</sym><sub><sym>i</sym></sub>,
1 (one) <leq/> <symdef>i</symdef> <leq/> <sym>N</sym>, is a path binding.
</item>

<comment>WG3:BNE-034</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<comment>WG3:UTC-009 P00-USA-169</comment>
<item>If <symdef>S</symdef> and <symdef>T</symdef> are sets of strings, then
let <symdef>S</symdef> <dotOp/> <sym>T</sym> be the set of strings formed by concatenating 
an element of <sym>S</sym> followed by an element of <sym>T</sym>;
that is, <sym>S</sym> <dotOp/> <sym>T</sym> = { <symdef>s</symdef> <symdef>t</symdef> | <sym>s</sym>
is an element of <sym>S</sym>, <sym>t</sym> is an element of <sym>T</sym> }.

<comment>WG3:SXM-052</comment>
<comment>WG3:W02-015</comment>
<note>The <dotOp/> operator will be used to concatenate words (strings of symbols) and path
bindings (strings of elementary bindings).
</note>
</item>

<comment>WG3:BNE-034</comment>
<item>If <symdef>S</symdef> is a set of strings, then let <symdef>S</symdef><super>0</super> be
the set whose only element is the string of length 0 (zero), and for each non-negative integer
<symdef>n</symdef>,
let <symdef>S</symdef><super><sym>n</sym>+1</super> be <sym>S</sym><super><sym>n</sym></super> 
<dotOp/> <sym>S</sym>.
Let <symdef>S</symdef><super>*</super> be the union of <sym>S</sym><super><sym>n</sym></super> 
for every non-negative integer <symdef>n</symdef>.

<comment>WG3:W20-022</comment>
<comment>WG3:W26-025R1</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-12 non-empty</comment>
<note>If <sym>S</sym> is non-empty, then <sym>S</sym><super>*</super> is an infinite set. 
However, a finite result for every <BNF name="graph pattern"/> is assured by the syntactic 
requirement that every <BNF name="quantified path primary"/> is bounded, contained in 
a restrictive <BNF name="parenthesized path pattern expression"/>, contained in a selective 
<BNF name="path pattern"/>, or in the scope of the <BNF name="different edges match mode"/>.
</note>

</item>

<comment>WG3:W04-009R1</comment>
<comment>Editorial: Stephen Cannan 2021-11-28</comment>
<comment>Editorial: Stephen Cannan, 2023-08-30</comment>
<item><sym>REDUCE</sym> is extended to multi-path bindings as follows.
If <symdef>MPB</symdef> = (<sym>PB</sym><sub>1</sub>, <ellipsis/>, 
<sym>PB</sym><sub><sym>n</sym></sub>) is a multi-path binding, then 
<sym>REDUCE</sym>(<sym>MPB</sym>) = (<sym>REDUCE</sym>(<sym>PB</sym><sub>1</sub>), <ellipsis/>,
<sym>REDUCE</sym>(<sym>PB</sym><sub><sym>n</sym></sub>)).
</item>

<comment>WG3:W04-009R1</comment>
<item>Let <symdef>MACH</symdef> be a data structure comprising the following:

<olist>

<item><symdef>ABC</symdef>, the alphabet, formed as the disjoint union of the following:

<olist>

<comment>WG3:BER-031</comment>
<item><symdef>SVV</symdef>, the set of names of node variables.
</item>

<comment>WG3:BER-031</comment>
<item><symdef>SEV</symdef>, the set of names of edge variables.
</item>

<item><symdef>SPS</symdef>, the set of subpath symbols.
</item>

<item><symdef>SAS</symdef>, the set of anonymous symbols.
</item>

<item><symdef>SBS</symdef>, the set of bracket symbols.
</item>

</olist>

</item>

<item><symdef>REDUCE</symdef>, the function mapping path bindings to path bindings, and
multi-path bindings to multi-path bindings.
</item>

</olist>

</item>

<comment>WG3:W04-009R1</comment>
<comment>Insert explicit SCreturn</comment>
<item><SCreturn>
 <SCretval name="MACHINERY"><sym>MACH</sym></SCretval>
</SCreturn>
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W04-009R1</comment>
<subClause id="gql_eval_path_pattern_expr" newpage="true">
<clauseHeading>Evaluation of a <BNF name="path pattern expression"/></clauseHeading>

<bodyMatter>

<Function>

<para>Evaluate a <BNF name="path pattern expression"/>.
</para>

</Function>


<SyntaxRules>

<olist>

<None/>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:W08-018</comment>
<comment>WG3:RKE-038 P16-USA-781</comment>
<comment>WG3:W21-048</comment>
<comment>WG3:W22-053R2</comment>
<comment>Editorial: Stephen Cannan, 2023-01-03 Add documentation</comment>
<item><SCsignature>
<symparam name="PROPERTY GRAPH"><symdef>PG</symdef></symparam>
<symparam name="PATH PATTERN LIST"><symdef>PPL</symdef></symparam>
<symparam name="MACHINERY"><symdef>MACH</symdef></symparam>
<symparam name="SPECIFIC BNF INSTANCE"><symdef>SBI</symdef></symparam>
<symreturn name="SET OF MATCHES"/>
<documentation>
<slist>
<item>PROPERTY GRAPH &mdash; a property graph.
</item>
<item>PATH PATTERN LIST &mdash; a <BNF name="path pattern list"/>.
</item>
<item>MACHINERY &mdash; the machinery for graph pattern matching.
</item>
<item>SPECIFIC BNF INSTANCE &mdash; the specific BNF non-terminal instance to be evaluated.
</item>
<comment>WG3:W25-016</comment>
<item>SET OF MATCHES &mdash; the set of local matches to the SPECIFIC BNF INSTANCE.
</item>
</slist>
</documentation>
</SCsignature>
</item>

<item>The following components of <sym>MACH</sym> are identified:

<olist>

<item><symdef>ABC</symdef>, the alphabet, formed as the disjoint union of the following:

<olist>

<comment>WG3:BER-031</comment>
<item><symdef>SVV</symdef>, the set of names of node variables.
</item>

<comment>WG3:BER-031</comment>
<item><symdef>SEV</symdef>, the set of names of edge variables.
</item>

<item><symdef>SPS</symdef>, the set of subpath symbols.
</item>

<item><symdef>SAS</symdef>, the set of anonymous symbols.
</item>

<item><symdef>SBS</symdef>, the set of bracket symbols.
</item>

</olist>

</item>

<item><symdef>REDUCE</symdef>, the function mapping path bindings to path bindings, and multi-path 
bindings to multi-path bindings.
</item>

</olist>

</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W01-014</comment>
<comment>WG3:W02-015</comment>
<comment>WG3:W04-009R1</comment>
<comment>Editorial: Stephen Cannan, 2024-04-10 Move unwanted content out of newterm</comment>
<item>For every BNF non-terminal instance <symdef>BNT</symdef> that is 
a <BNF name="path pattern expression"/>, <BNF name="path term"/>,
<BNF name="path pattern union"/>, <BNF name="path factor"/>, <BNF name="path concatenation"/>,
<BNF name="path primary"/>, <BNF name="quantified path primary"/>, 
<BNF name="questioned path primary"/>, <BNF name="element pattern"/>,
or <BNF name="parenthesized path pattern expression"/> equal to or contained in <sym>SBI</sym> at 
the same depth of graph pattern matching, the following are defined by simultaneous recursion:
the <newterm>regular language</newterm> of <sym>BNT</sym>, denoted 
<symdef>RL</symdef>(<sym>BNT</sym>), defined as a set of words over <sym>ABC</sym>; and
the <newterm>set of local matches</newterm> to <sym>BNT</sym>, denoted 
<symdef>SLM</symdef>(<sym>BNT</sym>), defined as a set of path bindings.

<note><sym>SLM</sym>(<sym>BNT</sym>) is consistent except when concatenating an edge pattern 
prior to concatenating the following node pattern.
Restrictive path modes are enforced when generating <sym>SLM</sym>(<sym>BNT</sym>) for the 
<BNF name="parenthesized path pattern expression"/> that declares the path mode.
</note>

<comment>WG3:W09-031</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>Editorial: Stephen Cannan 2023-01-20 Align with Directives Part 2</comment>
<comment>WG3:W26-025R1</comment>
<note><sym>RL</sym>(<sym>BNT</sym>) and <sym>SLM</sym>(<sym>BNT</sym>) can be infinite sets 
if <sym>BNT</sym> contains an effectively unbounded quantifier.
Every effectively unbounded quantifier is required to be either contained in a selective 
<BNF name="path pattern"/> or in the scope of the <BNF name="different edges match mode"/>.
For a selective <BNF name="path pattern"/> the potentially infinite set of local matches is 
subsequently reduced to a finite set by the General Rules of 
<specref ref="gql_eval_sel_paren_path_pattern_expr"/>.
For <BNF name="different edges match mode"/>, the matches are reduced to a finite set by the 
General Rules of <specref ref="gql_graph_pattern"/>.
</note>

<comment>WG3:CMN-035</comment>
<note>The BNF non-terminal symbols are listed above in the <quote>top down</quote> order
of appearance in the Format of <specref ref="gql_path_pattern_expr"/>; the definitions in
the following subrules treat instances of the same BNF non-terminal symbols in
<quote>bottom up</quote> order.
</note>

<comment>Email from: Fred Zemke, 2019-02-28 2154</comment>
<para>Case:
</para>

<olist>

<comment>WG3:BNE-034</comment>
<comment>WG3:RKE-039 P16-USA-771</comment>
<item>If <sym>BNT</sym> is a <BNF name="parenthesized path pattern expression"/>, then
let <symdef>PPE</symdef> be the <BNF name="path pattern expression"/> immediately contained in
<sym>BNT</sym> and let <symdef>j</symdef> be the bracket index of <sym>BNT</sym>.

<note><quote>Bracket index</quote> is defined in 
<specref ref="gql_machinery_graph_pattern_matching"/>.
</note>

<olist>

<comment>WG3:SXM-052</comment>
<item>Case:

<olist>

<comment>WG3:SXM-052</comment>
<item>If <sym>BNT</sym> simply contains a <BNF name="subpath variable declaration"/>
<symdef>SVD</symdef>, then let <symdef>SV</symdef> be the subpath variable declared by
<sym>SVD</sym>.
Let <symdef>BSV</symdef> be the begin subpath symbol associated with <sym>SV</sym> and
let <symdef>ESV</symdef> be the end subpath symbol associated with <sym>SV</sym>.
Let <symdef>BSVBINDING</symdef> be (<sym>BSV</sym>, <sym>BSV</sym>) and 
let <symdef>ESVBINDING</symdef> be (<sym>ESV</sym>, <sym>ESV</sym>).
</item>

<comment>WG3:SXM-052</comment>
<comment>Editorial: Stephen Cannan, 2021-05-27 Standardize terms</comment>
<comment>Editorial: Stefan Plantikow, 2021-06-29 Fix wrong use of character string</comment>
<item>Otherwise, let <symdef>BSV</symdef>, <symdef>ESV</symdef>, <symdef>BSVBINDING</symdef> and
<symdef>ESVBINDING</symdef> be the empty string.
</item>

</olist>

</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W04-009R1</comment>
<comment>WG3:W09-031</comment>
<item><sym>RL</sym>(<sym>BNT</sym>) is { <delimId>[<sub><sym>j</sym></sub></delimId> } <dotOp/>
{ <sym>BSV</sym> } <dotOp/> <sym>RL</sym>(<sym>PPE</sym>) <dotOp/> { <sym>ESV</sym> } <dotOp/>
{ <delimId>]<sub><sym>j</sym></sub></delimId> }
</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<item>Let <symdef>STPB</symdef> be <sym>SLM</sym>(<sym>PPE</sym>).

<comment>WG3:W04-009R1</comment>
<para>Let <symdef>SLMMAYBE</symdef> be { (<delimId>[<sub><sym>j</sym></sub></delimId>,
<delimId>[<sub><sym>j</sym></sub></delimId>) } <dotOp/>
{ <sym>BSVBINDING</sym> } <dotOp/> <sym>STPB</sym> <dotOp/> { <sym>ESVBINDING</sym> } <dotOp/>
{ (<delimId>]<sub><sym>j</sym></sub></delimId>, <delimId>]<sub><sym>j</sym></sub></delimId>) }
</para>

<comment>WG3:W04-009R1</comment>
<comment>WG3:W09-031</comment>
<para><sym>SLM</sym>(<sym>BNT</sym>) is the set of every path binding in
<sym>SLMMAYBE</sym> that is consistent.
</para>

<comment>WG3:W02-015</comment>
<comment>WG3:W04-009R1</comment>
<comment>WG3:W09-031</comment>
<comment>WG3:BER-031</comment>
<note>That is, the words in <sym>RL</sym>(<sym>BNT</sym>) are formed by surrounding the
words of <sym>RL</sym>(<sym>PPE</sym>) by the bracket symbols 
<delimId>[<sub><sym>j</sym></sub></delimId> and <delimId>]<sub><sym>j</sym></sub></delimId>.
If <sym>BNT</sym> contains a subpath variable declaration, then the words of 
<sym>RL</sym>(<sym>BNT</sym>) are also surrounded by the begin and end subpath symbol associated 
with that subpath variable.
Similarly, the path bindings in <sym>SLMMAYBE</sym> are formed by surrounding the path bindings
with bracket bindings and, if there is a subpath declaration, with the corresponding begin and
end subpath bindings.
Eliminating inconsistent bindings from <sym>SLMMAYBE</sym> to get <sym>SLM</sym>(<sym>BNT</sym>) 
has the effect of enforcing restrictive path modes.
</note>

</item>

</olist>

</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W02-015</comment>
<item>If <sym>BNT</sym> is an <BNF name="element pattern"/> <symdef>EP</symdef>, then:

<olist>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W02-015</comment>
<item>Case:

<olist>

<comment>WG3:W02-015</comment>
<comment>WG3:BER-031</comment>
<item>If <sym>EP</sym> declares an element variable <symdef>EV</symdef>, 
then let <symdef>EPI</symdef> be the name of <sym>EV</sym>.
</item>

<comment>WG3:W02-015</comment>
<item>If <sym>EP</sym> is a <BNF name="node pattern"/>, then let <symdef>EPI</symdef> be 
<delimId>()</delimId>, the anonymous node symbol.
</item>

<comment>WG3:W02-015</comment>
<item>If <sym>EP</sym> is an <BNF name="edge pattern"/>, then let <symdef>EPI</symdef> be 
<delimId>-</delimId>, the anonymous edge symbol.
</item>

</olist>

</item>

<item><sym>RL</sym>(<sym>BNT</sym>) is { <sym>EPI</sym> }, the set whose sole member is 
<sym>EPI</sym>.
</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W13-018</comment>
<item><sym>SLM</sym>(<sym>BNT</sym>) is the set of every elementary binding 
(<sym>EPI</sym>, <symdef>GE</symdef>) such that:

<olist>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<item>If <sym>EP</sym> is a <BNF name="node pattern"/>, then <sym>GE</sym> is a node.
</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<item>If <sym>EP</sym> is an <BNF name="edge pattern"/>, then <sym>GE</sym> is an edge.
</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W02-015</comment>
<comment>WG3:W13-018</comment>
<comment>Editorial: Stephen Cannan 2021-09-28 Use new applySC asTest option</comment>
<item>If <sym>EP</sym> simply contains a <BNF name="label expression"/> <symdef>LE</symdef>, 
then <bool>True</bool>
<applySC ref="gql_satisf_lbl_expr_by_lbl_set" rules="SR" type="asTest">
<symarg param="LABEL EXPRESSION"><sym>LE</sym></symarg>
<symarg param="LABEL SET">the label set of <sym>GE</sym></symarg>
<symresult param="TRUTH VALUE"><symdef>TV</symdef></symresult>
</applySC>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:BNE-034</comment>
<item>If <sym>BNT</sym> is a <BNF name="quantified path primary"/>, then:

<olist>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W02-015</comment>
<item>Let <symdef>PP</symdef> be the <BNF name="path primary"/> immediately contained in
<sym>BNT</sym>.
As a result of the transformations in the Syntax Rules, <sym>PP</sym> is 
a <BNF name="parenthesized path pattern expression"/>.
Let <symdef>R</symdef> be <sym>RL</sym>(<sym>PP</sym>) and 
let <symdef>S</symdef> be <sym>SLM</sym>(<sym>PP</sym>).
</item>

<comment>WG3:BNE-034</comment>
<item>Let <symdef>GQ</symdef> be the <BNF name="general quantifier"/> immediately contained in
<sym>BNT</sym>.
</item>

<comment>WG3:BNE-034</comment>
<item>Let <symdef>LB</symdef> be the value of the <BNF name="lower bound"/> contained in
<sym>GQ</sym>.
</item>

<comment>WG3:BNE-034</comment>
<item>Case:

<olist>

<comment>WG3:BNE-034</comment>
<comment>WG3:BER-080</comment>
<item>If <sym>GQ</sym> contains an <BNF name="upper bound"/>, then let <symdef>UB</symdef> be
the value of the <BNF name="upper bound"/>.

<olist>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W02-015</comment>
<item><sym>RL</sym>(<sym>BNT</sym>) is <sym>R</sym><super><sym>LB</sym></super> <setunion/>
<sym>R</sym><super><sym>LB</sym>+1</super> <setunion/> <ellipsis/> <setunion/>
<sym>R</sym><super><sym>UB</sym>&minus;1</super> <setunion/> <sym>R</sym><super>UB</super>.
</item>

<comment>WG3:BNE-034</comment>
<item>Let <symdef>TOOMUCH</symdef> be <sym>S</sym><super><sym>LB</sym></super> <setunion/>
<sym>S</sym><super><sym>LB</sym>+1</super> <setunion/> <ellipsis/> <setunion/>
<sym>S</sym><super><sym>UB</sym>&minus;1</super> <setunion/> 
<sym>S</sym><super><sym>UB</sym></super>.
</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:W04-009R1</comment>
<item><sym>SLM</sym>(<sym>BNT</sym>) is the set of those path bindings in <sym>TOOMUCH</sym> 
that are consistent.
</item>

</olist>

</item>

<comment>WG3:BNE-034</comment>
<item>Otherwise,

<olist>

<comment>WG3:BNE-034</comment>
<comment>WG3:MMX-077</comment>
<comment>WG3:W02-015</comment>
<item><sym>RL</sym>(<sym>BNT</sym>) is <sym>R</sym><super><sym>LB</sym></super> <dotOp/> 
<sym>R</sym><super>*</super>.
</item>

<comment>WG3:BNE-034</comment>
<item>Let <symdef>WAYTOOMUCH</symdef> be <sym>S</sym><super><sym>LB</sym></super> <dotOp/>
<sym>S</sym><super>*</super>.
</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:W04-009R1</comment>
<item><sym>SLM</sym>(<sym>BNT</sym>) is the set of those path bindings in <sym>WAYTOOMUCH</sym> 
that are consistent.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W01-014</comment>
<item>If <sym>BNT</sym> is a <BNF name="questioned path primary"/>, then:

<olist>

<comment>WG3:W02-015</comment>
<item>Let <symdef>PP</symdef> be the <BNF name="path primary"/> immediately contained in 
<sym>BNT</sym>.
As a result of the transformations in the Syntax Rules, <sym>PP</sym> is 
a <BNF name="parenthesized path pattern expression"/>.
Let <symdef>R</symdef> be <sym>RL</sym>(<sym>PP</sym>) and 
let <symdef>S</symdef> be <sym>SLM</sym>(<sym>PP</sym>).
</item>

<comment>WG3:W02-015</comment>
<item><sym>RL</sym>(<sym>BNT</sym>) is <sym>R</sym><super>0</super> <setunion/> <sym>R</sym>.
</item>

<item><sym>SLM</sym>(<sym>BNT</sym>) is <sym>S</sym><super>0</super> <setunion/> <sym>S</sym>.
</item>

</olist>

</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:BER-080</comment>
<item>If <sym>BNT</sym> is a <BNF name="path primary"/>, then let <symdef>BNT2</symdef> be the
<BNF name="element pattern"/> or <BNF name="parenthesized path pattern expression"/> that is
immediately contained in <sym>BNT</sym>.

<olist>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W02-015</comment>
<item><sym>RL</sym>(<sym>BNT</sym>) is <sym>RL</sym>(<sym>BNT2</sym>).
</item>

<comment>WG3:BNE-034</comment>
<item><sym>SLM</sym>(<sym>BNT</sym>) is <sym>SLM</sym>(<sym>BNT2</sym>).
</item>

</olist>

</item>

<comment>WG3:BNE-034</comment>
<item>If <sym>BNT</sym> is a <BNF name="path concatenation"/>, then:

<olist>

<comment>WG3:BNE-034</comment>
<item>Let <symdef>PST</symdef> be the <BNF name="path term"/>
and let <symdef>PC</symdef> be the <BNF name="path factor"/> that are immediately contained in
<sym>BNT</sym>.
</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W02-015</comment>
<item><sym>RL</sym>(<sym>BNT</sym>) is <sym>RL</sym>(<sym>PST</sym>) <dotOp/> 
<sym>RL</sym>(<sym>PC</sym>).
</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:MMX-077</comment>
<item>Case:

<olist>

<comment>WG3:MMX-077</comment>
<item>If <sym>PC</sym> is an <BNF name="edge pattern"/>, then <sym>SLM</sym>(<sym>BNT</sym>) is 
<sym>SLM</sym>(<sym>PST</sym>) <dotOp/> <sym>SLM</sym>(<sym>PC</sym>)

<comment>WG3:W02-015</comment>
<note>If <sym>PC</sym> is an <BNF name="edge pattern"/>, then there is 
a <BNF name="node pattern"/> to its right, which will be concatenated in a subsequent
iteration of this recursion; consistency, including the directionality
constraint implied by the <BNF name="edge pattern"/>, will be checked at that point.
</note>
</item>

<comment>WG3:W02-015</comment>
<item>If <sym>PC</sym> is a <BNF name="node pattern"/>, and the last 
<BNF name="element pattern"/> <symdef>EP</symdef> of <sym>PST</sym> is 
an <BNF name="edge pattern"/>, then:

<comment>WG3:W04-009R1</comment>
<note>By transformations in the Syntax Rules of <specref ref="gql_path_pattern_expr"/>, an edge 
binding is always immediately preceded and followed by a node binding.
The current rule handles the situation in which the edge has been bound as the last elementary 
binding of <sym>PST</sym>, and therefore <sym>PC</sym> is the node binding that immediately 
follows the edge binding.
Also note that the Syntax Rules have transformed every <BNF name="abbreviated edge pattern"/> to 
a <BNF name="full edge pattern"/>.
</note>

<olist>

<item>Let <symdef>SLMCONCAT</symdef> be <sym>SLM</sym>(<sym>PST</sym>) <dotOp/> 
<sym>SLM</sym>(<sym>PC</sym>).
</item>

<item>For each path binding <symdef>PB</symdef> contained in <sym>SLMCONCAT</sym>,

<olist>

<comment>Editorial: Stephen Cannan, 2023-08-30</comment>
<item>Let <symdef>GE_RIGHT</symdef> be the node that is bound in the 
last elementary binding of <sym>PB</sym>.
</item>

<item>Let <symdef>GE</symdef> be the edge that is bound in the penultimate elementary
binding of <sym>PB</sym>.
</item>

<comment>Editorial: Stephen Cannan, 2023-08-30</comment>
<item>Let <symdef>GE_LEFT</symdef> be the node that is bound in the 
antepenultimate elementary binding of <sym>PB</sym>.
</item>

</olist>

</item>

<comment>WG3:W02-015</comment>
<item>Let the propositions <symdef>L</symdef>, <symdef>U</symdef>, and <symdef>R</symdef> be 
defined as follows:

<olist>

<comment>WG3:W02-015</comment>
<comment>Editorial: Stephen Cannan, 2023-08-30</comment>
<item>Proposition <sym>L</sym> is true if <sym>GE</sym> is a directed edge, 
<sym>GE_LEFT</sym> is the destination node of <sym>GE</sym> and 
<sym>GE_RIGHT</sym> is the source node of <sym>GE</sym>.
</item>

<comment>WG3:W02-015</comment>
<comment>Editorial: Stephen Cannan, 2023-08-30</comment>
<item>Proposition <sym>U</sym> is true if <sym>GE</sym> is an undirected edge, and 
<sym>GE_LEFT</sym> and <sym>GE_RIGHT</sym> are the 
nodes connected by <sym>GE</sym>.
</item>

<comment>WG3:W02-015</comment>
<comment>Editorial: Stephen Cannan, 2023-08-30</comment>
<item>Proposition <sym>R</sym> is true if <sym>GE</sym> is a directed edge, 
<sym>GE_LEFT</sym> is the source node of <sym>GE</sym> and 
<sym>GE_RIGHT</sym> is the destination node of <sym>GE</sym>.
</item>

</olist>

</item>

<comment>WG3:W02-015</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>The <newterm>directionality constraint</newterm> of <sym>EP</sym> is

<para>Case:
</para>

<olist>

<comment>WG3:W02-015</comment>
<item>If <sym>EP</sym> is a <BNF name="full edge pointing left"/>, then proposition <sym>L</sym> 
is true.
</item>

<comment>WG3:W02-015</comment>
<comment>WG3:W22-051</comment>
<item>If <sym>EP</sym> is a <BNF name="full edge undirected"/>, then proposition <sym>U</sym> 
is true.
</item>

<comment>WG3:W02-015</comment>
<item>If <sym>EP</sym> is a <BNF name="full edge pointing right"/>, then proposition <sym>R</sym> 
is true.
</item>

<comment>WG3:W22-051</comment>
<comment>WG3:W02-015</comment>
<item>If <sym>EP</sym> is a <BNF name="full edge left or undirected"/>, then proposition
<sym>L</sym>, or proposition <sym>U</sym>, is true.
</item>

<comment>WG3:W02-015</comment>
<item>If <sym>EP</sym> is a <BNF name="full edge undirected or right"/>, then proposition 
<sym>U</sym>, or proposition <sym>R</sym>, is true.
</item>

<comment>WG3:W02-015</comment>
<item>If <sym>EP</sym> is a <BNF name="full edge left or right"/>, then proposition <sym>L</sym>,
or proposition <sym>R</sym>, is true.
</item>

<comment>WG3:W02-015</comment>
<item>If <sym>EP</sym> is a <BNF name="full edge any direction"/>, then at least one of proposition 
<sym>L</sym>, proposition <sym>U</sym>, or proposition <sym>R</sym>, is true.
</item>

</olist>

</item>

<item><sym>SLM</sym>(<sym>BNT</sym>) is the set of those path bindings of <sym>SLMCONCAT</sym> that
are consistent and satisfy the directionality constraint of <sym>EP</sym>.
</item>

</olist>

</item>

<comment>WG3:MMX-077</comment>
<item>Otherwise, <sym>SLM</sym>(<sym>BNT</sym>) is the set of those path bindings in
<sym>SLM</sym>(<sym>PST</sym>) <dotOp/> <sym>SLM</sym>(<sym>PC</sym>) that are consistent.

<ednote id="gql_w04009_10">It may be possible to enforce implicit joins of unconditional singletons
exposed by a <BNF name="path concatenation"/> as part of the GRs for 
<BNF name="path concatenation"/>.
This was discussed in an SQL/PGQ ad hoc meeting on September 8, 2020.
It was decided not to attempt that change as part of WG3:W04-009R1, leaving it as a future 
possibility.
See <PPref ref="PPgql044"/>.
</ednote>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:W01-014</comment>
<comment>WG3:BER-080</comment>
<item>If <sym>BNT</sym> is a <BNF name="path factor"/>, then let <symdef>BNT2</symdef> be the
<BNF name="path primary"/>, <BNF name="quantified path primary"/> or 
<BNF name="questioned path primary"/> immediately contained in <sym>BNT</sym>.

<olist>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W02-015</comment>
<item><sym>RL</sym>(<sym>BNT</sym>) is <sym>RL</sym>(<sym>BNT2</sym>).
</item>

<comment>WG3:BNE-034</comment>
<comment>Email from: Fred Zemke, 2019-02-28 2154</comment>
<item><sym>SLM</sym>(<sym>BNT</sym>) is <sym>SLM</sym>(<sym>BNT2</sym>).
</item>

</olist>

</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>Editorial: Stephen Cannan 2021-11-28</comment>
<comment>WG3:BER-080</comment>
<item>If <sym>BNT</sym> is a <BNF name="path pattern union"/>, then let <symdef>NMA</symdef>
be the number of <BNF name="path term"/>s immediately contained in <sym>BNT</sym>.
Let <symdef>PMO</symdef><sub>1</sub>, <ellipsis/>, <symdef>PMO</symdef><sub><sym>NMA</sym></sub> 
be these <BNF name="path term"/>s.

<olist>

<comment>WG3:BNE-034</comment>
<comment>WG3:W02-015</comment>
<item><symdef>RL</symdef>(<sym>BNT</sym>) is <sym>RL</sym>(<sym>PMO</sym><sub>1</sub>) <setunion/> 
<sym>RL</sym>(<sym>PMO</sym><sub>2</sub>) <setunion/> <ellipsis/> <setunion/> 
<sym>RL</sym>(<sym>PMO</sym><sub><sym>NMA</sym></sub>).
</item>

<comment>WG3:BNE-034</comment>
<item><symdef>SLM</symdef>(<sym>BNT</sym>) is <sym>SLM</sym>(<sym>PMO</sym><sub>1</sub>) 
<setunion/> <sym>SLM</sym>(<sym>PMO</sym><sub>2</sub>) <setunion/> <ellipsis/> <setunion/>
<sym>SLM</sym>(<sym>PMO</sym><sub><sym>NMA</sym></sub>).
</item>

</olist>

</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:BER-080</comment>
<item>If <sym>BNT</sym> is <BNF name="path term"/>, then let <symdef>BNT2</symdef> be the
<BNF name="path factor"/> or <BNF name="path concatenation"/> immediately contained in
<sym>BNT</sym>.

<olist>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W02-015</comment>
<item><sym>RL</sym>(<sym>BNT</sym>) is <sym>RL</sym>(<sym>BNT2</sym>).
</item>

<comment>WG3:BNE-034</comment>
<item><sym>SLM</sym>(<sym>BNT</sym>) is <sym>SLM</sym>(<sym>BNT2</sym>).
</item>

</olist>

</item>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:BER-080</comment>
<item>If <sym>BNT</sym> is a <BNF name="path pattern expression"/>, then let <symdef>BNT2</symdef>
be the <BNF name="path term"/> or <BNF name="path pattern union"/> immediately contained in
<sym>BNT</sym>.

<comment>WG3:SXM-052</comment>
<comment>Editorial: Stefan Plantikow, 2022-02-24 WG3:W20-010 P00-USA-374</comment>
<note><BNF name="path multiset alternation"/> is transformed into <BNF name="path pattern union"/>
in the Syntax Rules and therefore it is not considered separately here.
</note>
<olist>

<comment>WG3:BNE-034</comment>
<comment>WG3:SXM-052</comment>
<comment>WG3:W02-015</comment>
<item><sym>RL</sym>(<sym>BNT</sym>) is <sym>RL</sym>(<sym>BNT2</sym>).
</item>

<comment>WG3:BNE-034</comment>
<item><sym>SLM</sym>(<sym>BNT</sym>) is <sym>SLM</sym>(<sym>BNT2</sym>).
</item>

</olist>

</item>

</olist>

</item>

<item>Let <symdef>SM</symdef> be <sym>SLM</sym>(<sym>SBI</sym>).
</item>

<comment>Insert explicit SCreturn</comment>
<item><SCreturn>
 <SCretval name="SET OF MATCHES"><sym>SM</sym></SCretval>
</SCreturn>
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_eval_sel_paren_path_pattern_expr" newpage="true">
<comment>WG3:W09-031</comment>
<clauseHeading>Evaluation of a selective <BNF name="path pattern"/></clauseHeading>

<bodyMatter>

<Function>

<comment>WG3:W09-031</comment>
<para>Evaluate a <BNF name="path pattern"/> with a selective <BNF name="path search prefix"/>.
</para>

</Function>


<SyntaxRules>

<olist>

<None/>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>WG3:W20-022</comment>
<comment>WG3:RKE-038 P16-USA-781</comment>
<comment>WG3:W21-048</comment>
<comment>WG3:W22-053R2</comment>
<comment>Editorial: Stephen Cannan, 2023-01-03 Add documentation</comment>
<item><SCsignature>
<symparam name="PROPERTY GRAPH"><symdef>PG</symdef></symparam>
<symparam name="PATH PATTERN LIST"><symdef>PPL</symdef></symparam>
<symparam name="MACHINERY"><symdef>MACH</symdef></symparam>
<symparam name="SELECTIVE PATH PATTERN"><symdef>SEL</symdef></symparam>
<symparam name="INPUT SET OF LOCAL MATCHES"><symdef>INSLM</symdef></symparam>
<symreturn name="OUTPUT SET OF LOCAL MATCHES"/>
<documentation>
<slist>
<item>PROPERTY GRAPH &mdash; a property graph.
</item>
<item>PATH PATTERN LIST &mdash; a <BNF name="path pattern list"/>.
</item>
<item>MACHINERY &mdash; the machinery for graph pattern matching.
</item>
<item>SELECTIVE PATH PATTERN &mdash; a selective <BNF name="path pattern"/>.
</item>
<comment>WG3:W25-016</comment>
<item>INPUT SET OF LOCAL MATCHES &mdash; a set, possibly infinite, of matches to 
SELECTIVE PATH PATTERN.
</item>
<item>OUTPUT SET OF LOCAL MATCHES &mdash; finite subset of the INPUT SET OF LOCAL MATCHES, 
selected according to the criterion indicated by the selective <BNF name="path search prefix"/> 
of SELECTIVE PATH PATTERN.
</item>
</slist>
</documentation>
</SCsignature>
</item>

<comment>WG3:W13-018</comment>
<comment>WG3:W18-009/P16-USA-773</comment>
<item>It is <impDef code="IA013"/> whether the General Rules of this Subclause are
terminated if an exception condition is raised.
If a GQL-implementation defines that it terminates execution because of an exception condition, 
it is <unDef code="UA006"/> which of the members of <sym>CANDIDATES</sym> (defined subsequently) 
are actually probed to establish whether they might raise an exception.

<comment>WG3:W18-009/P16-USA-773</comment>
<comment>Editorial: Stephen Cannan 2023-01-20 Align with Directives Part 2</comment>
<note id="gql_candidates_infinite"><sym>CANDIDATES</sym> is potentially an infinite set, but 
there are algorithms to enumerate this set so as to satisfy the selection criterion of the 
selective <BNF name="path pattern"/> without testing all candidate solutions.
Even if the GQL-implementation defines that it terminates when an exception condition is 
encountered on a particular candidate solution, the order of enumerating the candidates is
<unDef annex="no" code="None"/>, and it is possible that a candidate solution that would raise 
an exception is never tested.
</note>

</item>

<item>The following components of <sym>MACH</sym> are identified:

<olist>

<item><symdef>ABC</symdef>, the alphabet, formed as the disjoint union of the following:

<olist>

<comment>WG3:BER-031</comment>
<item><symdef>SVV</symdef>, the set of names of node variables.
</item>

<comment>WG3:BER-031</comment>
<item><symdef>SEV</symdef>, the set of names of edge variables.
</item>

<item><symdef>SPS</symdef>, the set of subpath symbols.
</item>

<item><symdef>SAS</symdef>, the set of anonymous symbols.
</item>

<item><symdef>SBS</symdef>, the set of bracket symbols.
</item>

</olist>

</item>

<item><symdef>REDUCE</symdef>, the function mapping path bindings to path bindings, and multi-path 
bindings to multi-path bindings.
</item>

</olist>

</item>

<item>Let <symdef>NP</symdef> be the number of <BNF name="path pattern"/>s in <sym>PPL</sym>.
</item>

<comment>WG3:W09-031</comment>
<item><sym>SEL</sym> is a selective <BNF name="path pattern"/>.
Let <symdef>j</symdef> be the bracket index of the 
<BNF name="parenthesized path pattern expression"/> simply contained in <sym>SEL</sym>.

<comment>WG3:RKE-039 P16-USA-771</comment>
<note><quote>Bracket index</quote> is defined in 
<specref ref="gql_machinery_graph_pattern_matching"/>.
</note>

<note>By a syntactic transformation in <specref ref="gql_graph_pattern"/>, this
<BNF name="parenthesized path pattern expression"/> is the entire content of <sym>SEL</sym> except
possibly the declaration of a path variable.
</note>

</item>

<item>Let <symdef>PSP</symdef> be the <BNF name="path search prefix"/> simply contained in 
<sym>SEL</sym>.
</item>

<comment>WG3:RKE-025 P16-USA-774</comment>
<item>Let <symdef>N</symdef> be the value of the <BNF name="number of paths"/> or the 
<BNF name="number of groups"/> specified in <sym>PSP</sym>.
If <sym>N</sym> is not a positive integer, then an exception condition is raised: 
<raise class="22" subclass="G0F"/> and no further General Rules of this Subclause are applied.
</item>

<comment>WG3:W09-031</comment>
<item>Let <symdef>p</symdef> be such that <sym>SEL</sym> is the <sym>p</sym>-th 
<BNF name="path pattern"/> of <sym>PPL</sym>.
</item>

<comment>Email from: Jim Melton 2022-12-08 0219</comment>
<item>Let <symdef>CANDIDATES</symdef> be the set of every path binding <sym>PBX</sym> in 
<sym>INSLM</sym> such that all of the following conditions are true:

<olist>

<comment>WG3:W08-018</comment>
<comment>WG3:BER-031</comment>
<item>For every unconditional singleton <BNF name="element variable"/> <symdef>EV</symdef> 
exposed by <sym>SEL</sym>, <sym>EV</sym> is bound to a unique graph element by the 
elementary bindings of <sym>EV</sym> contained in <sym>PBX</sym>.

<note>Anonymous symbols are not <BNF name="element variable"/>s; there is no requirement that 
two anonymous symbols bind to the same graph element.
</note>

</item>

<comment>WG3:W08-018</comment>
<item>For every <BNF name="parenthesized path pattern expression"/> <symdef>PPPE</symdef> equal to
or contained in <sym>SEL</sym>, let <symdef>i</symdef> be the bracket index of <sym>PPPE</sym>, 
and let <symdef><delimId>[<sub><sym>i</sym></sub></delimId></symdef> and 
<symdef><delimId>]<sub><sym>i</sym></sub></delimId></symdef> be the bracket symbols associated 
with <sym>PPPE</sym>.
A <newterm>binding</newterm> of <sym>PPPE</sym> is a substring of <sym>PBX</sym> that begins with 
the bracket binding (<delimId>[<sub><sym>i</sym></sub></delimId>, 
<delimId>[<sub><sym>i</sym></sub></delimId>) and ends with the next bracket binding 
(<delimId>]<sub><sym>i</sym></sub></delimId>, <delimId>]<sub><sym>i</sym></sub></delimId>).

<comment>WG3:RKE-039 P16-USA-771</comment>
<note><quote>Bracket index</quote> is defined in 
<specref ref="gql_machinery_graph_pattern_matching"/>.
</note>

<comment>Email from: Jim Melton 2022-12-08 0219</comment>
<para>For every binding <symdef>BPPPE</symdef> of <sym>PPPE</sym> contained in <sym>PBX</sym>, 
all of the following are true:
</para>

<olist>

<comment>WG3:BER-031</comment>
<comment>Editorial: Jim Melton, 2022-12-07</comment>
<item>For every <BNF name="element variable"/> <symdef>EV</symdef> that is exposed as 
an unconditional singleton by <sym>PPPE</sym>, <sym>EV</sym> is bound to a unique graph element 
by the elementary bindings of <sym>EV</sym> contained in <sym>BPPPE</sym>.

<note>Anonymous symbols are not <BNF name="element variable"/>s; there is no requirement that 
two anonymous symbols bind to the same graph element.
</note>

</item>

<comment>WG3:W08-018</comment>
<comment>Email from: Tobias Lindaaker, 2021-03-22</comment>
<comment>WG3:W13-018</comment>
<comment>Editorial: Stephen Cannan 2021-09-28 Use new applySC asTest option</comment>
<item>If <sym>PPPE</sym> contains a <BNF name="parenthesized path pattern where clause"/> 
<symdef>PPPWC</symdef>, then <bool>True</bool> 
<applySC ref="gql_app_bind_eval_expr" rules="GR" type="asTest">
<symarg param="GRAPH PATTERN"><sym>PPL</sym></symarg>
<symarg param="EXPRESSION">the <BNF name="search condition"/> simply contained in 
<sym>PPPWC</sym></symarg>
<symarg param="MACHINERY"><sym>MACH</sym></symarg>
<symarg param="MULTI-PATH BINDING"><sym>PBX</sym></symarg>
<symarg param="REFERENCE TO LOCAL CONTEXT">a reference to <sym>BPPPE</sym> as a subset of 
<sym>PBX</sym></symarg>
<symresult param="VALUE"><symdef>V</symdef></symresult>
</applySC>.

<comment>WG3:W18-009/P16-USA-773</comment>
<comment>Editorial: Stephen Cannan 2023-01-20 Align with Directives Part 2</comment>
<note>This is the juncture at which an exception condition might be raised.
It is <impDef annex="no" code="None"/> whether to terminate if an exception condition is raised.
The order of enumerating the members of <sym>CANDIDATES</sym> is <unDef annex="no" code="None"/>, 
and there is no requirement that a GQL-implementation test all candidate solutions, 
which can be an infinite set in any case.
</note>

</item>

</olist>

</item>

</olist>

</item>

<item>Each path binding <symdef>PBX</symdef> of <sym>CANDIDATES</sym> is replaced by 
<sym>REDUCE</sym>(<sym>PBX</sym>).
</item>

<item>Redundant duplicate path bindings are removed from <sym>CANDIDATES</sym>.
</item>

<item><sym>CANDIDATES</sym> is partitioned as follows.
For every path binding <symdef>PBX</symdef> in <sym>CANDIDATES</sym>, the partition of 
<sym>PBX</sym> is the set of every path binding <symdef>PBY</symdef> in <sym>CANDIDATES</sym> 
such that the first and last node bindings of <sym>PBX</sym> bind the same nodes as the 
first and last node bindings, respectively, of <sym>PBY</sym>.
</item>

<item>Each partition <symdef>PART</symdef> of <sym>CANDIDATES</sym> is modified as follows.

<para>Case:
</para>

<olist>

<item>If <sym>PSP</sym> is an <BNF name="any path search"/>, then

<para>Case:
</para>

<olist>

<item>If the number of path bindings in <sym>PART</sym> is <sym>N</sym> or less, then the entire 
partition <sym>PART</sym> is retained.
</item>

<item>Otherwise, it is <unDef code="UA005" /> which <sym>N</sym> path bindings of <sym>PART</sym>
are retained.
</item>

</olist>

</item>

<item>If <sym>PSP</sym> is a <BNF name="shortest path search"/>, then

<para>Case:
</para>

<olist>

<item>If <sym>PSP</sym> is a <BNF name="counted shortest path search"/>, then

<para>Case:
</para>

<olist>

<item>If the number of path bindings in <sym>PART</sym> is <sym>N</sym> or less, then the entire
partition <sym>PART</sym> is retained.
</item>

<item>Otherwise, the path bindings of <sym>PART</sym> are sorted in increasing order of
number of edges; the order of path bindings that have the same number of edges is 
<unDef code="US005"/>.
The first <sym>N</sym> path bindings in <sym>PART</sym> are retained.
</item>

</olist>

</item>

<item>If <sym>PSP</sym> is <BNF name="counted shortest group search"/>, then the path bindings in 
<sym>PART</sym> are grouped, with each group comprising those path bindings having the same number 
of edges.
The groups are ordered in increasing order by the number of edges.

<para>Case:
</para>

<olist>

<item>If the number of groups in <sym>PART</sym> is <sym>N</sym> or less, then the entire partition
<sym>PART</sym> is retained.
</item>

<item>Otherwise, the path bindings comprising the first <sym>N</sym> groups of <sym>PART</sym> are
retained.
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<item>Let <symdef>OUTSLM</symdef> be the set of path bindings retained in <sym>CANDIDATES</sym> 
after the preceding modifications to its partitions.
</item>

<comment>Insert explicit SCreturn</comment>
<item><SCreturn>
 <SCretval name="OUTPUT SET OF LOCAL MATCHES"><sym>OUTSLM</sym></SCretval>
</SCreturn>
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W13-018</comment>
<subClause id="gql_satisf_lbl_expr_by_lbl_set" newpage="true">
<clauseHeading>Satisfaction of a <BNF name="label expression"/> by a label set</clauseHeading>

<bodyMatter>

<Function>

<para>Determine if a label set satisfies a <BNF name="label expression"/>.
</para>

</Function>


<SyntaxRules>

<olist>

<comment>Editorial: Stephen Cannan, 2023-01-03 Add documentation</comment>
<item><SCsignature>
<symparam name="LABEL EXPRESSION"><symdef>LEXP</symdef></symparam>
<symparam name="LABEL SET"><symdef>LS</symdef></symparam>
<symreturn name="TRUTH VALUE"/>
<documentation>
<slist>
<item>LABEL EXPRESSION &mdash; a <BNF name="label expression"/>.
</item>
<item>LABEL SET &mdash; the label set of a graph element.
</item>
<item>TRUTH VALUE &mdash; <bool>True</bool> if the DEFINED LABEL SET satisfies the 
LABEL EXPRESSION; otherwise, <bool>False</bool>.
</item>
</slist>
</documentation>
</SCsignature>
</item>

<item>A label set <symdef>LS</symdef> <newterm>satisfies</newterm> a <BNF name="label expression"/>
<symdef>LE</symdef> according to the following recursive definition:

<olist>

<comment>WG3:RKE-027 P16-USA-747</comment>
<item>If <sym>LE</sym> is a <BNF name="label name"/> <symdef>L2</symdef>, then <sym>L2</sym> is 
a member of <sym>LS</sym>.
</item>

<item>If <sym>LE</sym> is a <BNF name="wildcard label"/>, then <sym>LS</sym> is non-empty.

<comment>Editorial: Stephen Cannan 2021-12-08 Standardize on GQL-implementation</comment>
<note>This condition is always true; every label set is non-empty.
The rule is written this way in case empty label sets are permitted in the future, or for
guidance to a GQL-implementation that supports graph elements with no labels.
</note>

</item>

<comment>WG3:BER-080</comment>
<item>If <sym>LE</sym> is a <BNF name="parenthesized label expression"/> <symdef>PLE</symdef>,
then let <symdef>LE2</symdef> be the <BNF name="label expression"/> simply contained in
<sym>PLE</sym>; <sym>LS</sym> satisfies <sym>LE2</sym>.
</item>

<comment>WG3:BER-080</comment>
<item>If <sym>LE</sym> is a <BNF name="label negation"/>, then
let <symdef>LP</symdef> be the <BNF name="label primary"/> simply contained in <sym>LE</sym>;
<sym>LS</sym> does not satisfy <sym>LP</sym>.
</item>

<comment>WG3:BER-080</comment>
<item>If <sym>LE</sym> is a <BNF name="label conjunction"/>, then let <symdef>L1</symdef> be the
<BNF name="label term"/> and let <symdef>L2</symdef> be the <BNF name="label factor"/> simply
contained in <sym>LE</sym>; <sym>LS</sym> satisfies <sym>L1</sym> and <sym>LS</sym> satisfies 
<sym>L2</sym>.
</item>

<comment>WG3:BER-080</comment>
<item>If <sym>LE</sym> is a <BNF name="label disjunction"/>, then
let <symdef>L1</symdef> be the <BNF name="label expression"/> and let <symdef>L2</symdef> be
the <BNF name="label term"/> simply contained in <sym>LE</sym>; <sym>LS</sym> satisfies 
<sym>L1</sym> or <sym>LS</sym> satisfies <sym>L2</sym>.
</item>

</olist>

</item>

<comment>WG3:RKE-025 P16-USA-760</comment>
<comment>Editorial: Stephen Cannan, 2023-07-05, define symbol explicitly</comment>
<item>Let <symdef>TV</symdef> be:

<para>Case:
</para>

<olist>

<item>If <sym>LS</sym> satisfies <sym>LEXP</sym>, then <bool>True</bool>.
</item>

<item>Otherwise, <bool>False</bool>.
</item>

</olist>

</item>

<comment>Insert explicit SCreturn</comment>
<item><SCreturn>
 <SCretval name="TRUTH VALUE"><sym>TV</sym></SCretval>
</SCreturn>
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W13-018</comment>
<subClause id="gql_app_bind_eval_expr" newpage="true">
<clauseHeading>Application of bindings to evaluate an expression</clauseHeading>

<bodyMatter>

<Function>

<comment>WG3:BER-031</comment>
<para>Evaluate a <BNF name="value expression"/> or <BNF name="search condition"/> using the 
bindings of graph pattern variables determined by a local context within a multi-path binding.
</para>

</Function>


<SyntaxRules>

<olist>

<None/>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>Editorial: Stephen Cannan, 2023-01-03 Add documentation</comment>
<item><SCsignature>
<symparam name="GRAPH PATTERN"><symdef>GP</symdef></symparam>
<symparam name="EXPRESSION"><symdef>EXP</symdef></symparam>
<symparam name="MACHINERY"><symdef>MACH</symdef></symparam>
<symparam name="MULTI-PATH BINDING"><symdef>MPB</symdef></symparam>
<symparam name="REFERENCE TO LOCAL CONTEXT"><symdef>RTLC</symdef></symparam>
<symreturn name="VALUE"/>
<documentation>
<slist>
<item>GRAPH PATTERN &mdash; a <BNF name="graph pattern"/>.
</item>
<item>EXPRESSION &mdash; a <BNF name="value expression"/> or <BNF name="search condition"/>.
</item>
<item>MACHINERY &mdash; the machinery for graph pattern matching.
</item>
<item>MULTI-PATH BINDING &mdash; multi-path binding to the <BNF name="graph pattern"/> in which
to evaluate the expression.
</item>
<comment>WG3:W25-016</comment>
<item>REFERENCE TO LOCAL CONTEXT &mdash; an indication of a subset of the multi-path
binding, the local context.
Group bindings are confined to the local context; singleton bindings may look outside the local 
context.
</item>
<item>VALUE &mdash; the evaluated value of EXPRESSION.
</item>
</slist>
</documentation>
</SCsignature>
</item>

<item>The following components of <sym>MACH</sym> are identified:

<olist>

<item><symdef>ABC</symdef>, the alphabet, formed as the disjoint union of the following:

<olist>

<comment>WG3:BER-031</comment>
<item><symdef>SVV</symdef>, the set of names of node variables.
</item>

<comment>WG3:BER-031</comment>
<item><symdef>SEV</symdef>, the set of names of edge variables.
</item>

<item><symdef>SPS</symdef>, the set of subpath symbols.
</item>

<item><symdef>SAS</symdef>, the set of anonymous symbols.
</item>

<item><symdef>SBS</symdef>, the set of bracket symbols.
</item>

</olist>

</item>

<item><symdef>REDUCE</symdef>, the function mapping path bindings to path bindings, and multi-path 
bindings to multi-path bindings.
</item>

</olist>

</item>

<item>Let <symdef>LC</symdef> be the subset of <sym>MPB</sym> that is indicated by <sym>RTLC</sym>.

<comment>WG3:W25-016</comment>
<note>The local context is passed <quote>by reference</quote> in order to correctly evaluate 
non-local singletons.
For example, given the pattern:
<code>
( (A) -> ( (B) -> (C) <kw>WHERE</kw> A.X = B.X+C.X ) -> (D)){2}
</code>

<para>then A.X makes a non-local reference to element variable A.
A word of this pattern will repeat the outer <BNF name="parenthesized path pattern expression"/> 
twice, requiring two evaluations of the <kw>WHERE</kw> clause.
Each evaluation of the <kw>WHERE</kw> clause must locate the appropriate non-local reference to A.
The bindings to the inner <BNF name="parenthesized path pattern expression"/>, 
if passed <quote>by value</quote>, might not be enough information to determine the appropriate 
binding to the outer <BNF name="parenthesized path pattern expression"/>.
</para>
</note>

</item>

<comment>WG3:W22-053R2</comment>
<comment>WG3:CMN-019 P00-NLD-050</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>Let <symdef>VREFS</symdef> be the binding variable references that are contained in 
<sym>EXP</sym> whose referenced binding variable is an element variable or a path variable declared
by <sym>GP</sym> that is in the scope of <sym>EXP</sym>.
Let <symdef>N</symdef> be the number elements of <sym>VREFS</sym>.
For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>, 
let <symdef>VR</symdef><sub><sym>i</sym></sub> be the <sym>i</sym>-th element of <sym>VREFS</sym>.
The <newterm>projected field value</newterm> is a value defined for the binding variable references
in <sym>VREFS</sym> according to the following General Rules.
</item>

<comment>Editorial; Stephen Cannan, 2023-10-10; fix sym/symdef problem</comment>
<comment>WG3:W26-025R1</comment>
<item>For each binding variable reference <symdef>BVR</symdef> in <sym>VREFS</sym>, 
the projected field value of <sym>BVR</sym> is defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>BVR</sym> is a binding variable reference whose variable is an element variable, 
then:

<olist>

<item>Let <symdef>DEG</symdef> be the degree of reference of <sym>BVR</sym>.
</item>

<item>Let <symdef>EV</symdef> be the element variable of <sym>BVR</sym>.
</item>

<item>Case:

<olist>

<!-- 5) a) iii) 1)-->
<item>If <sym>LC</sym> is equal to <sym>MPB</sym>, then let <symdef>SPACE</symdef> be 
<sym>MPB</sym>.

<note>That is, the search space is the entire multi-path binding.
This case arises in two circumstances: 
1) the evaluation of a <BNF name="parenthesized path pattern where clause"/> in the outermost 
<BNF name="parenthesized path pattern expression"/> of a selective <BNF name="path pattern"/>; 
2) the evaluation of a <BNF name="graph pattern where clause"/>.
</note>

</item>

<item>Otherwise, let <symdef>LCBI</symdef> be the bracket index of the first bracket symbol in 
<sym>LC</sym>.
Let <symdef>LCPPPE</symdef> be the <BNF name="parenthesized path pattern expression"/> contained in
<sym>GP</sym> whose bracket index is <sym>LCBI</sym>.
Let <symdef>PP</symdef> be the <BNF name="path pattern"/> containing <sym>LCPPPE</sym>.

<comment>WG3:RKE-039 P16-USA-771</comment>
<note><quote>Bracket index</quote> is defined in 
<specref ref="gql_machinery_graph_pattern_matching"/>.
</note>

<para>Case:
</para>

<olist>

<item>If <sym>EV</sym> is not declared by <sym>PP</sym>, then let <symdef>SPACE</symdef> be 
<sym>MPB</sym>.

<comment>WG3:RKE-027 P16-USA-775</comment>
<comment>Editorial; Stephen Cannan, 2023-10-10; fix sym/symdef problem</comment>
<comment>WG3:W26-025R1</comment>
<note>In this case, <sym>EV</sym> is declared in some other <BNF name="path pattern"/>
than the one that contains <sym>BVR</sym>.
<sym>BVR</sym> is a non-local reference, therefore <sym>DEG</sym> is singleton, and <sym>EV</sym> 
is exposed as a singleton by the <BNF name="path pattern"/>(s) that declares it.
</note>

</item>

<item>If <sym>EV</sym> is declared by <sym>LCPPPE</sym>, then let <symdef>SPACE</symdef> be 
<sym>LC</sym>.

<comment>Editorial; Stephen Cannan, 2023-10-10; fix sym/symdef problem</comment>
<comment>WG3:W26-025R1</comment>
<note>In this case, <sym>EV</sym> is declared locally to <sym>LCPPPE</sym> and the
binding(s) to <sym>BVR</sym> can be found by searching the local context <sym>LC</sym>.
</note>

</item>

<item>Otherwise, let <symdef>DEFPPPE</symdef> be the innermost 
<BNF name="parenthesized path pattern expression"/> that declares <sym>EV</sym> and that contains 
<sym>LCPPPE</sym>.
Let <symdef>BI</symdef> be the bracket index of <sym>DEFPPPE</sym>.
Let <symdef><delimId>[<sub><sym>BI</sym></sub></delimId></symdef> and
<symdef><delimId>]<sub><sym>BI</sym></sub></delimId></symdef> 
be the bracket symbols whose bracket index is <sym>BI</sym>.
Let <symdef>SPACE</symdef> be the smallest substring of <sym>MPB</sym> containing <sym>LC</sym> 
and beginning with <delimId>[<sub><sym>BI</sym></sub></delimId> and ending with 
<delimId>]<sub><sym>BI</sym></sub></delimId>.

<comment>WG3:RKE-027 P16-USA-776</comment>
<comment>Editorial; Stephen Cannan, 2023-10-10; fix sym/symdef problem</comment>
<comment>WG3:W26-025R1</comment>
<note>In this case, <sym>EV</sym> is declared in some outer scope containing <sym>LCPPPE</sym>, 
and the binding of <sym>BVR</sym>, if any, is found by searching the innermost scope that declares 
<sym>EV</sym>.
<sym>BVR</sym> is a non-local reference, therefore <sym>DEG</sym> is singleton, and <sym>EV</sym>
is exposed as a singleton by <sym>DEFPPPE</sym>.
</note>

<comment>WG3:RKE-039 P16-USA-771</comment>
<note><quote>Bracket index</quote> is defined in 
<specref ref="gql_machinery_graph_pattern_matching"/>.
</note>

</item>

</olist>

</item>

</olist>

</item>

<item>Case:

<olist>

<item>If <sym>DEG</sym> is singleton, then

<para>Case:
</para>

<olist>

<comment>WG3:BER-031</comment>
<item>If there is an elementary binding <symdef>EB</symdef> of <sym>EV</sym> in <sym>SPACE</sym>, 
then let <symdef>LOE</symdef> be a list with a single graph element, 
the graph element that is bound to <sym>EV</sym> by <sym>EB</sym>.

<note>Even if <sym>EV</sym> is bound multiple times in <sym>SPACE</sym> (expressing 
an equijoin on <sym>EV</sym>), the list has only one graph element.
</note>
 
</item>

<item>Otherwise, let <symdef>LOE</symdef> be the empty list.

<note>This case can only arise if <sym>DEG</sym> is conditional singleton.
</note>

</item>

</olist>

</item>

<item>If <sym>DEG</sym> is group, then

<para>Case:
</para>

<olist>

<item>If <sym>SPACE</sym> does not contain an elementary binding of <sym>EV</sym>, 
then let <symdef>LOE</symdef> be an empty list.
</item>

<comment>WG3:BER-031</comment>
<item>Otherwise, let <symdef>LOE</symdef> be the list of the graph elements that are bound to
<sym>EV</sym> by elementary bindings in the order that they occur in <sym>SPACE</sym>, 
scanning <sym>SPACE</sym> from left to right, and retaining duplicates.

<ednote id="gql_w13018_1">The bindings of a group reference flatten nested lists.
This may be acceptable for SQL aggregates, which have no support for nested groupings, 
but may be inadequate to fully capture the semantics of a group reference in a graph pattern.
WG3:MMX-035r2 section 4.1, <quote>Desynchronized lists</quote> pointed out a problem with reducing 
group variables to lists: two lists may be interleaved, but the reduction to separate lists can 
lose this information.
The example given is

<code>
(   (A:Person) -[:SPOUSE]-> ()
  | (B:Person) -[:FRIEND]-> () ){3}
</code>

<para>A solution may find matches to A and B in any order.
With separate lists of matches of A and B, it will not be easy to reconstruct the precise
sequence of interleaved matches to A and B.
</para>

<para>A similar problem can arise with nested quantifiers.
WG3:MMX-035r2 section 4.2, <quote>Nested quantifiers</quote> gives this example:
</para>

<code>
( (C1:CORP) (-[:TRANSFERS]->(B:BANK))*
  -[:TRANSFERS]-> (C2:CORP) )*
</code>

<comment>Editorial: Jim Melton, 2022-12-07</comment>
<para>With this pattern, there can be 0 (zero) or more bindings to B between any two consecutive 
bindings to C1 and C2.
With just independent lists of matches to C1, B and C2, it will not be easy to determine what
bindings to B lie between what bindings to C1 and C2.
</para>

</ednote>

</item>

</olist>

</item>

</olist>

</item>

<comment>Editorial; Stephen Cannan, 2023-10-10; fix sym/symdef problem</comment>
<comment>WG3:W26-025R1</comment>
<comment>Email from: Finbar Good, 2023-11-15"</comment>
<item><sym>LOE</sym> is the list of graph elements bound to <sym>BVR</sym>.
</item>

<comment>WG3:W22-053R2</comment>
<item>The projected field value of <sym>EV</sym> is defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>DEG</sym> is singleton, then:

<olist>

<comment>WG3:W24-035R1</comment>
<comment>WG3:W26-025R1</comment>
<item>If <sym>EV</sym> is a node variable and <sym>LOE</sym> contains a single node 
<symdef>N</symdef>, then the projected field value of <sym>BVR</sym> is a node reference value 
for <sym>N</sym>.
</item>

<comment>WG3:W24-035R1</comment>
<comment>WG3:W26-025R1</comment>
<item>If <sym>EV</sym> is an edge variable and <sym>LOE</sym> contains a single edge 
<symdef>E</symdef>, then the projected field value of <sym>BVR</sym> is an edge reference value 
for <sym>E</sym>.
</item>

<comment>WG3:W26-025R1</comment>
<item>Otherwise, <sym>DEG</sym> is conditional singleton, <sym>LOE</sym> is empty, and the
projected field value of <sym>BVR</sym> is the null value.
</item>

</olist>

</item>

<item>Otherwise, <sym>DEG</sym> is group.

<para>Case:
</para>

<olist>

<comment>WG3:W24-035R1</comment>
<comment>WG3:W26-025R1</comment>
<item>If <sym>EV</sym> is a node variable, then the projected field value of <sym>BVR</sym> is 
the list value comprising node reference values for the nodes given by <sym>LOE</sym> 
(in the order determined by <sym>LOE</sym>).
</item>

<comment>WG3:W26-025R1</comment>
<item>If <sym>EV</sym> is an edge variable, then the projected field value of <sym>BVR</sym> is 
the list value comprising edge reference values for the edges given by <sym>LOE</sym> 
(in the order determined by <sym>LOE</sym>).
</item>

</olist>

</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W22-053R2</comment>
<comment>Editorial; Stephen Cannan, 2023-10-10; fix sym/symdef problem</comment>
<comment>WG3:W26-025R1</comment>
<item>If <sym>BVR</sym> is a binding variable reference whose variable is a path variable, then:

<olist>

<comment>WG3:W26-025R1</comment>
<item>Let <symdef>PV</symdef> be the path variable of <sym>BVR</sym>.
</item>

<item>Let <symdef>PB</symdef> be the path binding of <sym>MPB</sym> corresponding to the 
<BNF name="path pattern"/> that declares <sym>PV</sym>.
</item>

<comment>WG3:W24-035R1</comment>
<item>Let <symdef>EP</symdef> be the extracted path of <sym>PB</sym> and let <symdef>PEL</symdef>
be the graph element list whose elements are graph reference values for the graph elements given 
by <sym>EP</sym> (in the order determined by <sym>EP</sym>).
</item>

<comment>WG3:W24-035R1</comment>
<comment>WG3:W26-025R1</comment>
<item>The projected field value of <sym>BVR</sym> is the path value whose path element list is 
<sym>PEL</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W22-053R2</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>Let <symdef>R</symdef> be a record with fields <symdef>F</symdef><sub><sym>i</sym></sub>, 
1 (one) <leq/> <symdef>i</symdef> <leq/> <sym>N</sym>, whose name is the variable name of 
<sym>VR</sym><sub><sym>i</sym></sub> and whose value is the projected field value of 
<sym>VR</sym><sub><sym>i</sym></sub>.
</item>

<comment>WG3:W22-053R2</comment>
<item>Let <symdef>V</symdef> be the result of evaluating <sym>EXP</sym> in a new child execution 
context amended with <sym>R</sym>.

<note>The type of the working record of this child execution context is determined by 
<itemref ref="gql_gql_gpbt_SR_wrt" type="SR"/> of <specref ref="gql_gpbt"/>.
</note>
</item>

<comment>Insert explicit SCreturn</comment>
<item><SCreturn>
 <SCretval name="VALUE"><sym>V</sym></SCretval>
</SCreturn>
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_app_eval_expr_on_grpvar" newpage="true">
<clauseHeading>Evaluation of an expression on a group variable</clauseHeading>

<bodyMatter>

<comment>WG3:UTC-123R2</comment>
<Function>

<para>Evaluate a value expression that contains references to exactly one variable whose type is
a group list value type.
</para>

</Function>


<SyntaxRules>

<olist>

<None/>

</olist>

</SyntaxRules>


<GeneralRules>

<olist>

<comment>WG3:UTC-123R2</comment>
<item><SCsignature>
<symparam name="GROUP LIST BINDING VARIABLE"><symdef>GLBV</symdef></symparam>
<symparam name="EXPRESSION"><symdef>EXP</symdef></symparam>
<symreturn name="LIST VALUE"/>
<documentation>
<slist>
<item>GROUP LIST BINDING VARIABLE &mdash; a <BNF name="binding variable"/> with group degree
of reference
</item>
<item>EXPRESSION &mdash; a <BNF name="value expression"/> that references
GROUP LIST BINDING VARIABLE
</item>
</slist>
</documentation>
</SCsignature>
</item>

<comment>WG3:UTC-123R2 Consequence</comment>
<item>Let <symdef>NAME</symdef> be the name of <sym>GLBV</sym>.
</item>

<comment>WG3:UTC-123R2 Consequence</comment>
<item>Let <symdef>CWR</symdef> be the current working record.
</item>

<comment>WG3:UTC-123R2 Consequence</comment>
<item>Let <symdef>ELTS</symdef> be the value of the field of <sym>CWR</sym> whose name is
<sym>NAME</sym> and let <symdef>NELTS</symdef> be the number of elements of <sym>ELTS</sym>.

<comment>WG3:UTC-123R2 Consequence</comment>
<note><sym>ELTS</sym> is always a list of graph element reference values.
</note>

</item>

<comment>WG3:UTC-123R2</comment>
<item>Let <symdef>LV</symdef> be a list value determined as follows. 

<olist>

<item>Initially, <symdef>LV</symdef> is an empty list.
</item>

<comment>WG3:UTC-123R2</comment>
<item>For every <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>NELTS</sym>:

<olist>

<item>Let <symdef>FIELD</symdef> be the field whose name is <sym>NAME</sym> and whose value is
the <sym>i</sym>-th element of <sym>ELTS</sym>. 
</item>

<item>In a new child execution context whose working record is amended with the record comprising 
<sym>FIELD</sym>, the result of <sym>EXP</sym> is appended to <sym>LV</sym>. 
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:UTC-123R2</comment>
<item><SCreturn>
<SCretval name="LIST VALUE"><sym>LV</sym></SCretval>
</SCreturn>
</item>

</olist>

</GeneralRules>

<ConformanceRules>

<comment>WG3:UTC-123R2</comment>
<olist>

<comment>WG3:UTC-123R2</comment>
<comment>WG3:CMN-019 P00-USA-077</comment>
<item>Without <feature code="GQ17"/>, in conforming GQL language, <sym>EXP</sym> shall be
a <BNF name="binding variable reference"/> to <sym>GLBV</sym>.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W22-053R2</comment>
<subClause id="gql_app_bind_gen_rec" newpage="true">
<clauseHeading>Application of bindings to generate a record</clauseHeading>

<bodyMatter>


<Function>

<para>Generate a record of output from a <BNF name="graph pattern binding table"/>.
</para>

</Function>


<SyntaxRules>

<olist>

<None/>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<comment>Editorial: Stephen Cannan, 2023-01-03 Add documentation</comment>
<item><SCsignature>
<symparam name="GRAPH PATTERN"><symdef>GP</symdef></symparam>
<symparam name="YIELD CLAUSE"><symdef>YC</symdef></symparam>
<symparam name="MULTI-PATH BINDING"><symdef>MPB</symdef></symparam>
<symparam name="MACHINERY"><symdef>MACH</symdef></symparam>
<symreturn name="RECORD"/>
<documentation>
<slist>
<item>GRAPH PATTERN &mdash; a <BNF name="graph pattern"/>.
</item>
<item>YIELD CLAUSE &mdash; a <BNF name="graph pattern yield clause"/>.
</item>
<item>MULTI-PATH BINDING &mdash; a multi-path binding.
</item>
<item>MACHINERY &mdash; the machinery for graph pattern matching.
</item>
<item>RECORD &mdash; a record to be output by <BNF name="graph pattern binding table"/>.
</item>
</slist>
</documentation>
</SCsignature>.
</item>

<comment>Editorial: Stephen Cannan, 2023-03-21</comment>
<item>Let <symdef>RTLC</symdef> be reference to <sym>MPB</sym> as a subset of itself.
</item>

<comment>WG3:CMN-019 P00-NLD-050</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>Let <symdef>N</symdef> be the number of <BNF name="graph pattern variable"/>s simply 
contained in <sym>YC</sym>.
For <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>, 
let <symdef>YC</symdef><sub><sym>i</sym></sub> be the 
<sym>i</sym>-th <BNF name="graph pattern variable"/> simply contained in <sym>YC</sym> and 
let <symdef>RECORD</symdef> be a record with <sym>N</sym> fields 
<symdef>F</symdef><sub><sym>i</sym></sub> determined as follows.

<olist>

<item>The name of <sym>F</sym><sub><sym>i</sym></sub> is <sym>YC</sym><sub><sym>i</sym></sub>.
</item>

<item>The value of <sym>F</sym><sub><sym>i</sym></sub> is defined as follows:

<olist>

<comment>Editorial: Stephen Cannan, 2023-03-21</comment>
<item>The <applySC ref="gql_app_bind_eval_expr" rules="GR">
<symarg param="GRAPH PATTERN"><sym>GP</sym></symarg>
<symarg param="EXPRESSION"><sym>YC</sym><sub><sym>i</sym></sub></symarg>
<symarg param="MACHINERY"><sym>MACH</sym></symarg>
<symarg param="MULTI-PATH BINDING"><sym>MPB</sym></symarg>
<symarg param="REFERENCE TO LOCAL CONTEXT"><sym>RTLC</sym></symarg>
<symresult param="VALUE"><symdef>VE</symdef></symresult>
</applySC>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>The value of <sym>F</sym><sub><sym>i</sym></sub> is <sym>VE</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>Insert explicit SCreturn</comment>
<item><SCreturn>
 <SCretval name="RECORD"><sym>RECORD</sym></SCretval>
</SCreturn>
</item>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W23-014</comment>
<subClause id="gql_res_simple_directory_path" newpage="true">
<clauseHeading>Resolution of a <BNF name="simple directory path"/> from a start 
directory</clauseHeading>

<bodyMatter>

<Function>

<para>Determine a GQL-directory by resolving a <BNF name="simple directory path"/> from 
a start directory
</para>

</Function>


<SyntaxRules>

<olist>

<comment>Editorial: Stephen Cannan, 2023-01-03 Add documentation</comment>
<item><SCsignature>
<symparam name="SIMPLE DIRECTORY PATH"><symdef>SDP</symdef></symparam>
<symparam name="START DIRECTORY"><symdef>SD</symdef></symparam>
<symreturn name="RESOLVED DIRECTORY"/>
<documentation>
<slist>
<item>SIMPLE DIRECTORY PATH &mdash; a <BNF name="simple directory path"/>.
</item>
<item>START DIRECTORY &mdash; the GQL-directory from which SIMPLE DIRECTORY PATH is to be resolved.
</item>
<item>RESOLVED DIRECTORY &mdash; the resolved GQL-directory.
</item>
</slist>
</documentation>
</SCsignature>
</item>

<comment>WG3:CMN-019 P00-USA-207</comment>
<item>Let <symdef>DNSEQ</symdef> be the sequence of all <BNF name="directory name"/>s that are 
immediately contained in <sym>SDP</sym>.
Let <symdef>N</symdef> be the number of elements of <sym>DNSEQ</sym>.
</item>

<comment>WG3:CMN-019 P00-NLD-050</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>Let <symdef>D</symdef><sub>0</sub> be <sym>SD</sym> and 
for <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>N</sym>, 
let <symdef>DN</symdef><sub><sym>i</sym></sub> be the <sym>i</sym>-th element of <sym>DNSEQ</sym>.
</item>

<comment>WG3:CMN-019 P00-NLD-050</comment>
<comment>WG3:CMN-019 P00-USA-207</comment>
<item>For <symdef>j</symdef>, 1 (one) <leq/> <sym>j</sym> <leq/> <sym>N</sym>, 
let the GQL-directory <symdef>D</symdef><sub><sym>j</sym></sub>, be defined as follows:

<olist>

<item>GQL-directory <sym>D</sym><sub><sym>j</sym>-1</sub> shall contain a GQL-directory with name 
<sym>DN</sym><sub><sym>j</sym></sub>.
</item>

<item>For every other GQL-directory <symdef>OGD</symdef> contained in 
<sym>D</sym><sub><sym>j</sym>-1</sub>, if the name by which <sym>OGD</sym> is identified in 
<sym>D</sym><sub><sym>j</sym>-1</sub> and <sym>D</sym><sub><sym>j</sym></sub> are visually 
confusable with each other, then an exception condition is raised: 
<raise class="42" subclass="004"/>.
</item>

<item><sym>D</sym><sub><sym>j</sym></sub> is the GQL-directory with name 
<sym>DN</sym><sub><sym>j</sym></sub> contained in GQL-directory 
<sym>D</sym><sub><sym>j</sym>-1</sub>.
</item>

</olist>

</item>

<comment>WG3:CMN-019 P00-USA-207</comment>
<item>Let <symdef>RD</symdef> be the GQL-directory <sym>D</sym><sub><sym>N</sym></sub>.
</item>

<item><SCreturn>
<SCretval name="RESOLVED DIRECTORY"><sym>RD</sym></SCretval>
</SCreturn>
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W24-034R2</comment>
<subClause id="gql_store" newpage="true">
<clauseHeading>Store assignment</clauseHeading>

<bodyMatter>


<Function>

<comment>WG3:CMN-019 436. P00-USA-392</comment>
<para>Specify rules for store assignments.
</para>

<comment>WG3:CMN-019 436. P00-USA-392</comment>
<note>See <specref ref="gql_conc_ass_mut"/>.
</note>

</Function>


<SyntaxRules>

<olist>

<item id="gql_store_SR_signature"><SCsignature>
<symparam name="TARGET"><symdef>T</symdef></symparam>
<symparam name="VALUE"><symdef>V</symdef></symparam>
<documentation>
<slist>
<comment>Editorial: Stefan Plantikow, 2023-10-06 Remove GQL prefix</comment>
<item>TARGET &mdash; a site that is the target of an assignment operation. 
</item>
<comment>WG3:CMN-081</comment>
<item>VALUE &mdash; a <BNF name="value expression"/> that is assigned to TARGET. 
</item>
</slist>
</documentation>
</SCsignature> 
</item>

<item>Let <symdef>SD</symdef> be the declared type of <sym>V</sym>.
</item>

<item>Let <symdef>TD</symdef> be the declared type of <sym>T</sym>.
</item>

<comment>WG3:UTC-124</comment>
<item><sym>SD</sym> shall be assignable to <sym>TD</sym>.
</item>

<comment>WG3:UTC-015</comment>
<item>If at least one of <sym>SD</sym> or <sym>TD</sym> is a dynamic union type, then:

<olist>

<item>Let <symdef>SCTS</symdef> be the set defined as follows. 
If <sym>SD</sym> is a dynamic union type, then <sym>SCTS</sym> is the set of component types of
<sym>SD</sym>; otherwise, <sym>SCTS</sym> is the singleton set comprising <sym>SD</sym>.
</item>

<item>Let <symdef>TCTS</symdef> be the set defined as follows. 
If <sym>TD</sym> is a dynamic union type, then <sym>TCTS</sym> is the set of component types of 
<sym>TD</sym>; otherwise, <sym>TCTS</sym> is the singleton set comprising <sym>TD</sym>.
</item>

<item>For each type <symdef>ST</symdef> in <sym>SCTS</sym>, there shall be one type 
<symdef>TT</symdef> in <sym>TCTS</sym> such that given a temporary site <symdef>TS</symdef> whose 
declared type is <sym>TT</sym> and an arbitrary expression <symdef>AX</symdef> whose declared type 
is <sym>ST</sym>, then the <applySC ref="gql_store" rules="SR">
 <symarg param="TARGET"><sym>TS</sym></symarg>
 <symarg param="VALUE"><sym>AX</sym></symarg>
</applySC>.
</item>

<item><SCreturn/>

<comment>WG3:W25-031R2</comment>
<note>This ensures that every possible source value is assignable to the target using the 
General Rules of this Subclause.
</note>

</item>

</olist>

</item>

<item>If <sym>TD</sym> is a predefined value type, then

<para>Case:
</para>

<olist>

<item>If <sym>TD</sym> is a reference value type, then:

<olist>

<item>The data type descriptors of <sym>SD</sym> and <sym>TD</sym> shall specify the same 
object base type name.
</item>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<item>Either <sym>TD</sym> is an open type or the constraining GQL-object type of <sym>SD</sym>
shall be a subtype of the constraining GQL-object type of <sym>TD</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-124 Consequence</comment>
<item>Otherwise, <sym>TD</sym> is not a reference value type.
</item>

</olist>

</item>

<item>If <sym>TD</sym> is a list value type, then:

<olist>

<item><sym>SD</sym> shall be a list value type.
</item>

<item>Let <symdef>TELT</symdef> be the list element type of <sym>TD</sym> and 
let <symdef>VELT</symdef> be the list element type of <sym>SD</sym>.
</item>

<item>Let <symdef>TS</symdef> be a transient site whose declared type is <sym>TELT</sym>, and 
let <symdef>AX</symdef> be an arbitrary expression whose declared type is <sym>VELT</sym>.
</item>

<item>The <applySC ref="gql_store" rules="SR">
 <symarg param="TARGET"><sym>TS</sym></symarg>
 <symarg param="VALUE"><sym>AX</sym></symarg>
</applySC>.
</item>

</olist>

</item>

<item>If <sym>TD</sym> is a record type, then

<para>Case:
</para>

<olist>

<item>If <sym>TD</sym> is an open record type, then <sym>SD</sym> shall be a record type.
</item>

<comment>WG3:UTC-124</comment>
<item>Otherwise, <sym>TD</sym> is a closed record type.

<para>Case:
</para>

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>If <sym>SD</sym> is a closed record type with the same set of
field type names as <sym>TD</sym>.
For every name <symdef>FTN</symdef> in the set of field type names of <sym>SD</sym>:

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>Let <symdef>FTD</symdef> be the value type of the field type of <sym>TD</sym> whose name is
<sym>FTN</sym>, let <symdef>FSD</symdef> be the value type of the field type of <sym>SD</sym> 
whose name is <sym>FTN</sym>, let <symdef>TS</symdef> be a transient site whose declared type is 
<sym>FTD</sym>, and let <symdef>AX</symdef> be an arbitrary expression whose declared type is 
<sym>FSD</sym>.
</item>

<item>The <applySC ref="gql_store" rules="SR">
<symarg param="TARGET"><sym>TS</sym></symarg>
<symarg param="VALUE"><sym>AX</sym></symarg>
</applySC>.
</item>

</olist>

</item>

<item>Otherwise, <sym>SD</sym> is an open record type.
</item>

</olist>

</item>

</olist>

</item>

<item><SCreturn/>
</item>

</olist>

</SyntaxRules>


<GeneralRules>

<olist>

<item id="gql_store_GR_signature"><SCsignature>
 <symparam name="TARGET"><symdef>T</symdef></symparam>
 <symparam name="VALUE"><symdef>V</symdef></symparam>
<documentation>
<slist>
<item>TARGET &mdash; a GQL site that is the target of an assignment operation. 
</item>
<item>VALUE &mdash; a GQL value that is assigned to TARGET. 
</item>
</slist>
</documentation>
</SCsignature> 
</item>

<comment>WG3:UTC-015</comment>
<item>Let <symdef>VD</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<item>If the declared type of <sym>V</sym> is a dynamic union type, then <sym>VD</sym> is the 
most specific static value type of <sym>V</sym>.
</item>

<item>Otherwise, <sym>VD</sym> is the declared type of <sym>V</sym>.
</item>

</olist>

</item>

<item>Let <symdef>TD</symdef> be the declared type of <sym>T</sym>.
</item>

<item>Case:

<olist>

<item>If <sym>V</sym> is the null value, then <sym>TD</sym> shall be nullable and <sym>T</sym> is 
set to the null value.
</item>

<item>Otherwise, <sym>V</sym> is material.

<para>Case:
</para>

<olist>

<comment>WG3:UTC-015</comment>
<item>If <sym>TD</sym> is a dynamic union type, then:

<olist>

<item>Let <symdef>NTCTS</symdef> be the set of component types of <sym>TD</sym> to which 
<sym>VD</sym> is assignable.
</item>

<item>The <applySC ref="gql_svt_prec" rules="SR">
<symarg param="NDTSET"><sym>NTCTS</sym></symarg>
<symresult param="NDTLIST"><symdef>NTCTL</symdef></symresult>
</applySC>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-11-01 simulated => hypothetical application</comment>
<item>Let <symdef>TST</symdef> be the value type of an element of <sym>NTCTL</sym> for which 
a hypothetical application of the General Rules of this Subclause would succeed without raising
an exception condition, or the first element of <sym>NTCTL</sym> if such a hypothetical application
would fail.
</item>

<item>The <applySC ref="gql_store" rules="GR">
<symarg param="TARGET">a temporary site <sym>TS</sym> whose declared type is <sym>TST</sym></symarg>
<symarg param="VALUE"><sym>V</sym></symarg>
</applySC>.
</item>

</olist>

</item>

<item>If <sym>TD</sym> is a reference value type, then:

<olist>

<item>If the base type of <sym>V</sym> is not the same as the base type of <sym>TD</sym>, then 
an exception condition is raised: <raise class="22" subclass="G0V"/>.
</item>

<item>If the referent of <sym>V</sym> is not an object of <sym>TD</sym>, then 
an exception condition is raised: <raise class="22" subclass="G0W"/>.
</item>

<item>The value of <sym>T</sym> is set to <sym>V</sym>.
</item>

</olist>

</item>

<comment>WG3:W26-026R2</comment>
<item>If <sym>TD</sym> is a fixed-length character string type with length in characters 
<symdef>L</symdef>, then:

<para>Case:
</para>

<olist>

<item>If the length in characters <symdef>M</symdef> of <sym>V</sym> is greater than <sym>L</sym>, 
then

<para>Case:
</para>

<olist>

<item>If the rightmost <sym>M</sym>&minus;<sym>L</sym> characters of <sym>V</sym> are all 
<BNF name="truncating whitespace"/> characters, then the value of <sym>T</sym> is set to the 
first <sym>L</sym> characters of <sym>V</sym>.
</item>

<item>Otherwise, one or more of the rightmost <sym>M</sym>&minus;<sym>L</sym> characters of 
<sym>V</sym> are not <BNF name="truncating whitespace"/> characters and 
an exception condition is raised: <raise class="22" subclass="001"/>.
</item>

</olist>

</item>

<item>If the length in characters <symdef>M</symdef> of <sym>V</sym> is less than <sym>L</sym>, 
then the first <sym>M</sym> characters of <sym>T</sym> are set to <sym>V</sym> and the last
<sym>L</sym>&minus;<sym>M</sym> characters of <sym>T</sym> are set to <BNF name="space"/>.
</item>

<item>Otherwise, the length in characters of <sym>V</sym> is equal to <sym>L</sym> and the value 
of <sym>T</sym> is set to <sym>V</sym>.
</item>

</olist>

</item>

<comment>WG3:W26-026R2</comment>
<item>If <sym>TD</sym> is variable-length character string type with minimum length in characters 
<symdef>MINL</symdef> and maximum length in characters <symdef>MAXL</symdef>, then

<para>Case:
</para>

<olist>

<item>If the length in characters <symdef>M</symdef> of <sym>V</sym> is less than <sym>MINL</sym>, 
then <sym>T</sym> is set to <sym>V</sym> extended on the right by 
<sym>MINL</sym>&minus;<sym>M</sym> <BNF name="space"/>s.
</item>

<item>If the length in characters <symdef>M</symdef> of <sym>V</sym> is greater than 
<sym>MAXL</sym>, then

<para>Case:
</para>

<olist>

<item>If the rightmost <sym>M</sym>&minus;<sym>MAXL</sym> characters of <sym>V</sym> are all 
<BNF name="truncating whitespace"/> characters, then the value of T is set to the first 
<sym>MAXL</sym> characters of <sym>V</sym>.
</item>

<item>Otherwise; one or more of the rightmost <sym>M</sym>&minus;<sym>MAXL</sym> characters of 
<sym>V</sym> are not <BNF name="truncating whitespace"/> characters, then 
an exception condition is raised: <raise class="22" subclass="001"/>.
</item>

</olist>

</item>

<item>Otherwise, the length in characters <symdef>M</symdef> of <sym>V</sym> is both greater than 
or equal to <sym>MINL</sym> and less than or equal to <sym>MAXL</sym> .
The value of <sym>T</sym> is set to <sym>V</sym>.
</item>

</olist>

</item>

<comment>Email from: Jeffrey Lovitz, 2022-12-22</comment>
<comment>WG3:W26-026R2</comment>
<item>If <sym>TD</sym> is a fixed-length byte string type with length in bytes <symdef>L</symdef>,
then

<para>Case:
</para>

<olist>

<item>If the length in bytes <symdef>M</symdef> of <sym>V</sym> is greater than <sym>L</sym>, then

<para>Case:
</para>

<olist>

<comment>Email from: Jeffrey Lovitz, 2022-12-22</comment>
<item>If the rightmost <sym>M</sym>&minus;<sym>L</sym> bytes of <sym>V</sym> are all equal to 
X<string>00</string>, then the value of <sym>T</sym> is set to the first <sym>L</sym> bytes of 
<sym>V</sym>.
</item>

<item>Otherwise, one or more of the rightmost <sym>M</sym>&minus;<sym>L</sym> bytes of <sym>V</sym>
are not equal to X<string>00</string>, and an exception condition is raised:
<raise class="22" subclass="001"/>.
</item>

</olist>

</item>

<comment>Email from: Jeffrey Lovitz, 2022-12-22</comment>
<item>If the length in bytes <symdef>M</symdef> of <sym>V</sym> is less than <sym>L</sym>, then the 
first <sym>M</sym> bytes of <sym>T</sym> are set to <sym>V</sym> and the last 
<sym>L</sym>&minus;<sym>M</sym> bytes of <sym>T</sym> are set to X<string>00</string>s.
</item>

<item>Otherwise, the length in bytes of <sym>V</sym> is equal to <sym>L</sym>.
The value of <sym>T</sym> is set to <sym>V</sym>.
</item>

</olist>

</item>

<comment>Email from: Jeffrey Lovitz, 2022-12-22</comment>
<comment>WG3:W26-026R2</comment>
<item>If <sym>TD</sym> is a variable-length byte string type with minimum length in bytes 
<symdef>MINL</symdef> and maximum length in bytes <symdef>MAXL</symdef>, then

<para>Case:
</para>

<olist>

<item>If the length in bytes <symdef>M</symdef> of <sym>V</sym> is less than <sym>MINL</sym>, 
then <sym>T</sym> is set to <sym>V</sym> extended on the right by 
<sym>MINL</sym>&minus;<sym>M</sym> X<string>00</string>s.
</item>

<item>If the length in bytes <symdef>M</symdef> of <sym>V</sym> is greater than <sym>MAXL</sym>,
then

<para>Case:
</para>

<olist>

<item>If the rightmost <sym>M</sym>&minus;<sym>MAXL</sym> bytes of <sym>V</sym> are all equal to 
X<string>00</string>, then the value of <sym>T</sym> is set to the first <sym>MAXL</sym> bytes of 
<sym>V</sym>.
</item>

<item>Otherwise, one or more of the rightmost <sym>M</sym>&minus;<sym>MAXL</sym> bytes of 
<sym>V</sym> are not equal to X<string>00</string>, and an exception condition is raised:
<raise class="22" subclass="001"/>.
</item>

</olist>

</item>

<item>Otherwise, the length in bytes <symdef>M</symdef> of <sym>V</sym> is both greater than or 
equal to <sym>MINL</sym> and less than or equal to <sym>MAXL</sym>.
The value of <sym>T</sym> is set to <sym>V</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-124</comment>
<item>If <sym>TD</sym> is a numeric type, then

<para>Case:
</para>

<olist>

<item>If <sym>V</sym> is a value of <sym>TD</sym>, then the value of <sym>T</sym> is set to 
<sym>V</sym>.
</item>

<comment>WG3:CMN-025</comment>
<item>If a value of <sym>TD</sym> can be obtained from <sym>V</sym> by rounding or truncation, then
it is <impDef code="IA021"/> which of the following occurs:

<olist>

<item>The value of <sym>T</sym> is set to that value.
If <sym>TD</sym> is exact numeric, then it is <impDef code="IA005"/> whether the approximation is
obtained by rounding or by truncation.
</item>

<item>An exception condition is raised: <raise class="22" subclass="003"/>.
</item>

</olist>

</item>

<item>Otherwise, an exception condition is raised: <raise class="22" subclass="003"/>.
</item>

</olist>

</item>

<comment>WG3:CMN-081</comment>
<item>If <sym>TD</sym> is a datetime type or a time type, then

<olist>

<comment>Editorial: Stefan Plantikow 2023-02-21 Use zoned datetime terminology</comment>
<item>If only one of <sym>TD</sym> and <sym>VD</sym> is a zoned datetime type or a zoned time type,
then <sym>V</sym> is effectively replaced by:

<code>
<kw>CAST</kw> ( <sym>V</sym> <kw>AS</kw> <sym>TD</sym> )
</code>

</item>

<comment>WG3:UTC-124</comment>
<item>Case:

<olist>

<item>If <sym>V</sym> is a value of <sym>TD</sym>, then the value of <sym>T</sym> is set to 
<sym>V</sym>.
</item>

<comment>WG3:CMN-025</comment>
<item>If a value of <sym>TD</sym> can be obtained from <sym>V</sym> by rounding or truncation, then
it is <impDef code="IA021"/> which of the following occurs:

<olist>

<item>The value of <sym>T</sym> is set to that value.
It is <impDef code="IA005"/> whether the approximation is obtained by rounding or truncation.
</item>

<item>An exception condition is raised: <raise class="22" subclass="008"/>.
</item>

</olist>

</item>

<item>Otherwise, an exception condition is raised: <raise class="22" subclass="008"/>.
</item>

</olist>

</item>

</olist>

</item>

<item>If <sym>TD</sym> is a list value type, then

<para>Case:
</para>

<olist>

<item>If the maximum cardinality <symdef>L</symdef> of <sym>T</sym> is equal to the cardinality 
of <sym>V</sym>, then for <symdef>i</symdef> ranging from 1 (one) to <sym>L</sym>,
the <applySC ref="gql_store" rules="GR">
<symarg param="TARGET">the <sym>i</sym>-th element of <sym>T</sym></symarg>
<symarg param="VALUE">the <sym>i</sym>-th element of <sym>V</sym></symarg>
</applySC>.
</item>

<item>If the maximum cardinality <symdef>L</symdef> of <sym>T</sym> is smaller than the cardinality
<symdef>M</symdef> of <sym>V</sym>, then

<para>Case:
</para>

<olist>

<item>If the rightmost <sym>M</sym>&minus;<sym>L</sym> elements of <sym>V</sym> are all null, then 
for <symdef>i</symdef> ranging from 1 (one) to <sym>L</sym>, 
the <applySC ref="gql_store" rules="GR">
<symarg param="TARGET">the <sym>i</sym>-th element of <sym>T</sym></symarg>
<symarg param="VALUE">the <sym>i</sym>-th element of <sym>V</sym></symarg>
</applySC>.
</item>

<comment>WG3:W28-014</comment>
<item>If one or more of the rightmost <sym>M</sym>&minus;<sym>L</sym> elements of <sym>V</sym> are 
not the null value, then an exception condition is raised: <raise class="22" subclass="02F"/>.
</item>

</olist>

</item>

<item>If the maximum cardinality <sym>L</sym> of <sym>T</sym> is greater than the cardinality 
<sym>M</sym> of <sym>V</sym>, then for <symdef>i</symdef> ranging from 1 (one) to <sym>M</sym>,
the <applySC ref="gql_store" rules="GR">
<symarg param="TARGET">the <sym>i</sym>-th element of <sym>T</sym></symarg>
<symarg param="VALUE">the <sym>i</sym>-th element of <sym>V</sym></symarg>
</applySC>.
The cardinality of the value of <sym>T</sym> is set to <sym>M</sym>.

<note>The maximum cardinality <sym>L</sym> of <sym>T</sym> is unchanged.
</note>

</item>

</olist>

</item>

<item>If <sym>TD</sym> is a closed record type, then:

<olist>

<item>If there is a field of <sym>V</sym> whose name is not the name of a field type of 
<sym>TD</sym>, then an exception condition is raised: <raise class="22" subclass="G0X"/>.
</item>

<item>If there is a field type of <sym>TD</sym> whose name is not the name of a field of 
<sym>V</sym>, then an exception condition is raised: <raise class="22" subclass="G0Y"/>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>For every name <sym>FTN</sym> in the set of field type names of <sym>VD</sym>,
the <applySC ref="gql_store" rules="GR">
<symarg param="TARGET">the field with name <sym>FTN</sym> of <sym>T</sym></symarg>
<symarg param="VALUE">the field with name <sym>FTN</sym> of <sym>V</sym></symarg>
</applySC>.
</item>

</olist>

</item>

<item>If <sym>TD</sym> is an open record type, then for every field <symdef>F</symdef> in 
<sym>V</sym>:

<olist>

<item>Let <symdef>FTN</symdef> be the name of <sym>F</sym>, let <symdef>FTD</symdef> be the 
declared type of <sym>F</sym>, and let <symdef>TS</symdef> be a transient site whose declared type
is <sym>FTD</sym>.
</item>

<item>The <applySC ref="gql_store" rules="GR">
<symarg param="TARGET"><sym>TS</sym></symarg>
<symarg param="VALUE"><sym>F</sym></symarg>
</applySC>.
</item>

<item>The field with name <sym>FTN</sym> in <sym>T</sym> is set to the value of <sym>TS</sym>.
</item>

</olist>

</item>

<item>Otherwise, the value of <sym>T</sym> is set to <sym>V</sym>.
</item>

</olist>

</item>

</olist>

</item>

<item><SCreturn/>
</item>

</olist>

</GeneralRules>


<comment>Email from: Keith Hare, 2023-07-20</comment>
<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:RKE-048</comment>
<subClause id="gql_identical_vals" newpage="true">
<clauseHeading>Determination of identical values</clauseHeading>

<bodyMatter>


<Function>

<para>Determine whether two values are identical.
</para>

</Function>


<SyntaxRules>

<olist>

<None/>

</olist>

</SyntaxRules>


<GeneralRules>

<olist>

<comment>Editorial: Stephen Cannan, 2023-01-03 Add documentation</comment>
<item><SCsignature>
<symparam name="FIRST VALUE"><symdef>V1</symdef></symparam>
<symparam name="SECOND VALUE"><symdef>V2</symdef></symparam>
<documentation>
<slist>
<item>FIRST VALUE &mdash; the first of two values for which it is to be determined
whether they are identical values. 
</item>
<item>SECOND VALUE &mdash; the second of two values for which it is to be determined
whether they are identical values. 
</item>
</slist>
</documentation>
</SCsignature>

<comment>WG3:CMN-019 P00-ISO-029</comment>
<note>This Subclause is invoked implicitly wherever the word <quote>identical</quote> is used of
two values.
</note>
</item>

<comment>Editorial: Stefan Plantikow, 2022-05-03 Introduced proper Case</comment>
<item>Whether <sym>V1</sym> is identical to <sym>V2</sym> is determined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>V1</sym> and <sym>V2</sym> are both the null value, then <symdef>V1</symdef> is
identical to <sym>V2</sym>.
</item>

<item>If <sym>V1</sym> is the null value and <sym>V2</sym> is not the null value, or if
<sym>V1</sym> is not the null value and <sym>V2</sym> is the null value, then
<sym>V1</sym> is not identical to <sym>V2</sym>.
</item>
<comment>WG3:UTC-082R1 Deleted 1 (one) GR</comment>

<comment>Email from: Nathalie Charbel, 2023-03-01 1050</comment>
<item>If <sym>V1</sym> and <sym>V2</sym> are character strings, then
let <mono><symdef>L</symdef> be <kw>CHARACTER_LENGTH</kw>(<sym>V1</sym>)</mono> and

<para>Case:
</para>

<olist>

<comment>WG3:UTC-082R1</comment>
<item>If <mono><kw>CHARACTER_LENGTH</kw>(<sym>V2</sym>)</mono> equals <sym>L</sym>, and
if for all <symdef>i</symdef>, 1 (one) <leq/> <sym>i</sym> <leq/> <sym>L</sym>,
the <sym>i</sym>-th character of <sym>V1</sym> corresponds to the same Unicode code point as the 
<sym>i</sym>-th character of <sym>V2</sym>, then <sym>V1</sym> is identical to <sym>V2</sym>.
</item>

<item>Otherwise, <sym>V1</sym> is not identical to <sym>V2</sym>.
</item>

</olist>

</item>

<comment>WG3:W25-031R2</comment>
<item>If <sym>V1</sym> and <sym>V2</sym> are both numbers, then

<para>Case:
</para>

<olist>

<item>If <sym>V1</sym> and <sym>V2</sym> are both exact numbers, then <sym>V1</sym> is identical 
to <sym>V2</sym> if and only if <sym>V1</sym> is not distinct from <sym>V2</sym>.
</item>

<item>If <sym>V1</sym> and <sym>V2</sym> are both approximate numbers, then <sym>V1</sym> is 
identical to <sym>V2</sym> if and only if <sym>V1</sym> is not distinct from <sym>V2</sym>.
</item>

<item>Otherwise, <sym>V1</sym> and <sym>V2</sym> are not identical.
</item>

</olist>

<note>Numbers are always compared by their numeric value, as specified in 
<specref ref="gql_comp"/>, and therefore two numbers with the same numeric value are generally 
indistinguishable unless an explicit <BNF name="value type predicate"/> is used. 
See <specref ref="gql_val_type_pred"/>.
</note>

<comment>WG3:CMN-035</comment>
<note>The distinction between exact numbers and approximate numbers made by this General Rule
only impacts GQL-implementations that support dynamic union types where it enables
the correct functioning of any dynamically generated type tests and casts. 
See <specref ref="gql_dyn_gen_type_cast"/>.
</note>

</item>

<comment>Consequence of WG3:UTC-117</comment>
<item>If <sym>V1</sym> and <sym>V2</sym> are zoned times or zoned datetimes, then:

<para>Case:
</para>

<olist>

<item>If <sym>V1</sym> and <sym>V2</sym> are not distinct and their time zone displacement fields
are not distinct, then <sym>V1</sym> is identical to <sym>V2</sym>.
</item>

<item>Otherwise, <sym>V1</sym> is not identical to <sym>V2</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-082R1</comment>
<item>If <sym>V1</sym> and <sym>V2</sym> are records, then:

<para>Case:
</para>

<olist>

<item>If the sets of field types of <sym>V1</sym> and <sym>V2</sym> have the same cardinality and 
all respective fields of <sym>V1</sym> and <sym>V2</sym> with the same name are identical,
then <sym>V1</sym> is identical to <sym>V2</sym>.
</item>

<item>Otherwise, <sym>V1</sym> is not identical to <sym>V2</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-082R1</comment>
<item>If <sym>V1</sym> and <sym>V2</sym> are lists, then:

<para>Case:
</para>

<olist>

<item>If <sym>V1</sym> and <sym>V2</sym> have the same cardinality and elements in
the same ordinal position in the two lists are identical, then
<sym>V1</sym> is identical to <sym>V2</sym>.
</item>

<item>Otherwise, <sym>V1</sym> is not identical to <sym>V2</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-082R1</comment>
<comment>Email from: Nathalie Charbel, 2023-03-01 1050 combine 2 GRs</comment>
<item>Otherwise,

<para>Case:
</para>

<olist>

<comment>Email from: Nathalie Charbel, 2023-03-01 1050 combine 2 GRs</comment>
<comment>WG3:W26-024</comment>
<item>If <sym>V1</sym> and <sym>V2</sym> are comparable values, then
<symdef>V1</symdef> is identical to <sym>V2</sym> if and only if
<sym>V1</sym> is not distinct from <sym>V2</sym>.
</item>

<comment>Email from: Nathalie Charbel, 2023-03-01 1050 combine 2 GRs</comment>
<item>Otherwise, <sym>V1</sym> and <sym>V2</sym> are not identical.
</item>

</olist>

</item>

<comment>WG3:UTC-082R1 Deleted 1 (one) GR</comment>

</olist>

</item>

</olist>

</GeneralRules>

</bodyMatter>

</subClause>


<comment>WG3:RKE-048</comment>
<subClause id="gql_distinct_vals" newpage="true">
<clauseHeading>Determination of distinct values</clauseHeading>

<bodyMatter>


<Function>

<para>Determine whether two values are distinct.
</para>

</Function>


<SyntaxRules>

<olist>

<None/>

</olist>

</SyntaxRules>


<GeneralRules>

<olist>

<comment>Editorial: Stephen Cannan, 2023-01-03 Add documentation</comment>
<item><SCsignature>
<symparam name="FIRST VALUE"><symdef>V1</symdef></symparam>
<symparam name="SECOND VALUE"><symdef>V2</symdef></symparam>
<documentation>
<slist>
<item>FIRST VALUE &mdash; the first of two values for which it is to be determined
whether they are distinct values. 
</item>
<item>SECOND VALUE &mdash; the second of two values for which it is to be determined
whether they are distinct values. 
</item>
</slist>
</documentation>
</SCsignature>

<comment>WG3:CMN-019 P00-ISO-029</comment>
<note>This Subclause is invoked implicitly wherever the word <quote>distinct</quote> is used of two
values.
</note>

</item>

<comment>Editorial: Stefan Plantikow, 2022-05-03 Introduce proper Case</comment>
<item>Whether <sym>V1</sym> is distinct from <sym>V2</sym> is defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>V1</sym> and <sym>V2</sym> are both the null value, then <symdef>V1</symdef> is
not distinct from <sym>V2</sym>.
</item>

<item>If <sym>V1</sym> is the null value and <sym>V2</sym> is not the null value, or if
<sym>V1</sym> is not the null value and <sym>V2</sym> is the null value, then
<sym>V1</sym> is distinct from <sym>V2</sym>.
</item>
<comment>WG3:UTC-050 Delete Editor's Note</comment>

<comment>WG3:W24-026R2</comment>
<comment>WG3:UTC-015</comment>
<comment>WG3:UTC-050</comment>
<item>If <sym>V1</sym> and <sym>V2</sym> are comparable values of predefined value types but are 
not reference values, then

<para>Case:
</para>

<olist>

<item>If <sym>V1</sym> is not equal to <sym>V2</sym>, then <sym>V1</sym> is distinct from 
<sym>V2</sym>.
</item>

<item>Otherwise, <sym>V1</sym> is not distinct from <sym>V2</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-015</comment>
<comment>WG3:W26-024</comment>
<item>If <sym>V1</sym> and <sym>V2</sym> are comparable reference values, then

<para>Case:
</para>

<olist>

<item>If <sym>V1</sym> and <sym>V2</sym> do not refer to the same referent, then 
<sym>V1</sym> is distinct from <sym>V2</sym>.
</item>

<item>Otherwise, <sym>V1</sym> is not distinct from <sym>V2</sym>.
</item>

</olist>

</item>

<comment>WG3:W24-026R2</comment>
<comment>WG3:W26-024</comment>
<item>If <sym>V1</sym> and <sym>V2</sym> are comparable values of constructed types, then

<para>Case:
</para>

<olist>

<comment>WG3:W24-035R1</comment>
<item>If <sym>V1</sym> and <sym>V2</sym> are path values, then

<para>Case:
</para>

<olist>

<item>If the path element list of <sym>V1</sym> is distinct from the path element list of 
<sym>V2</sym>, then <sym>V1</sym> is distinct from <sym>V2</sym>.
</item>

<item>Otherwise, <sym>V1</sym> is not distinct from <sym>V2</sym>.
</item>

</olist>

</item>

<item>If <sym>V1</sym> and <sym>V2</sym> are list values, then

<para>Case:
</para>

<olist>

<comment>WG3:CMN-057R1</comment>
<item>If <sym>V1</sym> and <sym>V2</sym> have different cardinality or at least one pair of
elements at the same ordinal position in the two lists are distinct, then 
<sym>V1</sym> is distinct from <sym>V2</sym>.
</item>

<item>Otherwise, <sym>V1</sym> is not distinct from <sym>V2</sym>.
</item>

</olist>

</item>

<item>If <sym>V1</sym> and <sym>V2</sym> are records, then

<para>Case:
</para>

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>If <sym>V1</sym> and <sym>V2</sym> have different sets of field names or the values of
at least one of the respective fields of <sym>V1</sym> and <sym>V2</sym>
with the same name are distinct, then 
<sym>V1</sym> is distinct from <sym>V2</sym>.
</item>

<item>Otherwise, <sym>V1</sym> is not distinct from <sym>V2</sym>.
</item>

</olist>

</item>

<item>Otherwise, <sym>V1</sym> is distinct from <sym>V2</sym>.
</item>

</olist>

</item>

<comment>WG3:W24-026R2</comment>
<comment>WG3:UTC-050</comment>
<comment>WG3:W26-024</comment>
<item>Otherwise, an exception condition is raised: <raise class="22" subclass="G04"/>.
</item>

</olist>

</item>

</olist>

</GeneralRules>


<comment>Editorial: Stefan Plantikow, 2023-08-22 Add missing section</comment>
<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_equality_ops" newpage="true">
<clauseHeading>Equality operations</clauseHeading>

<bodyMatter>


<Function>

<para>Specify the prohibitions and restrictions by value type on operations that involve testing
for equality.
</para>

</Function>


<SyntaxRules>

<olist>

<item>An <newterm>equality operation</newterm> is any of the following:

<olist>

<ednote id="SQL_diff18">Consider explicit support for additional collations other than 
UCS_BASIC and UNICODE (<eg/> case insensitive variants, use of alternative collation 
tables).
See <PPref ref="PPgql012"/>.
</ednote>

<item>A <BNF name="comparison predicate"/> that specifies <BNF name="equals operator"/> or
<BNF name="not equals operator"/>.
</item>

<comment>WG3:W24-037</comment>
<item>A <BNF name="same predicate"/>.
</item>

<comment>WG3:W24-037</comment>
<item>An <BNF name="all_different predicate"/>.
</item>

<comment>WG3:W26-024</comment>
<item>A <BNF name="graph pattern binding table"/>.

<comment>WG3:W26-024</comment>
<note>This is implied by the natural join performed by the application of
<itemref ref="gql_gpbt_GR_nat_join" type="GR"/> of <specref ref="gql_gpbt"/>.
</note>

</item>

</olist>

</item>

<comment>WG3:W24-037</comment>
<item>An <newterm>operand of an equality operation</newterm> is any of the following:

<olist>

<item>A <BNF name="comparison predicand"/> simply contained in 
a <BNF name="comparison predicate"/> that specifies <BNF name="equals operator"/> or 
<BNF name="not equals operator"/>.
</item>

<item>An <BNF name="element variable reference"/> simply contained in 
a <BNF name="same predicate"/>.
</item>

<item>An <BNF name="element variable reference"/> simply contained in 
an <BNF name="all_different predicate"/>.
</item>

<comment>WG3:W26-024</comment>
<item>In the context of an application of the Syntax Rules and General Rules of
<specref ref="gql_gpbt"/>: The records bound to <symdef>COMBINED</symdef> by
<itemref ref="gql_gpbt_GR_COMBINED" type="GR"/> whose declared type is the record type bound to 
<symdef>IBRT</symdef> by <itemref ref="gql_gpbt_SR_IBRT" type="SR"/>, and the binding tables bound
to <symdef>INNER_TABLE</symdef> by <itemref ref="gql_gpbt_GR_INNER_TABLE" type="GR"/>
whose declared type is the record type bound to <symdef>GPYCRT</symdef> by
<itemref ref="gql_gpbt_SR_GPYCRT" type="SR"/>.
</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W26-024</comment>
<item>Without <feature code="GA04"/>, in conforming GQL language, the declared types of
the operands of an equality operation shall be comparable value types.
</item>

<comment>WG3:W26-024</comment>
<item>Without <feature code="GA09"/>, in conforming GQL language, the declared types of
the operands of an equality operation shall not contain path types.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_ordering_ops" newpage="true">
<clauseHeading>Ordering operations</clauseHeading>

<bodyMatter>


<Function>

<para>Specify the prohibitions and restrictions by value type on operations that involve ordering
of data.
</para>

</Function>


<SyntaxRules>

<olist>

<item>An <newterm>ordering operation</newterm> is any of the following:

<olist>

<ednote id="SQL_diff19">Consider explicit support for additional collations other than 
UCS_BASIC and UNICODE (<eg/> case insensitive variants, use of alternative collation 
tables).
See <PPref ref="PPgql012"/>.
</ednote>

<item>A <BNF name="comparison predicate"/> that does not specify <BNF name="equals operator"/>
or <BNF name="not equals operator"/>.
</item>

<item>A <BNF name="sort specification list"/>.
</item>

<comment>WG3:CMN-019 446. P00-USA-196</comment>
<item>An <BNF name="aggregate function"/> that specifies <kw>MIN</kw>, <kw>MAX</kw>,
<kw>PERCENTILE_CONT</kw>, or <kw>PERCENTILE_DISC</kw>
</item>

</olist>

</item>

<comment>WG3:W24-037</comment>
<item>An <newterm>operand of an ordering operation</newterm> is any of the following:

<olist>

<item>A <BNF name="comparison predicand"/> simply contained in 
a <BNF name="comparison predicate"/> that does not specify <BNF name="equals operator"/> or 
<BNF name="not equals operator"/>.
</item>

<comment>Email from: Nathalie Charbel, 2022-12-20 1738</comment>
<comment>WG3:UTC-081</comment>
<item>A <BNF name="value expression"/> simply contained in 
an <BNF name="aggregate function"/> that specifies <kw>MIN</kw>, <kw>MAX</kw>, 
<kw>PERCENTILE_CONT</kw>, or <kw>PERCENTILE_DISC</kw>. 
</item>

<item>A <BNF name="value expression"/> simply contained in a <BNF name="sort key"/>.
</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W26-024</comment>
<item>Without <feature code="GA04"/>, in conforming GQL language, the declared types of
the operands of an ordering operation shall be comparable value types.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W24-037</comment>
<subClause id="gql_grouping_ops" newpage="true">
<clauseHeading>Grouping operations</clauseHeading>

<bodyMatter>

<Function>

<para>Specify the prohibitions and restrictions by value type on operations that involve grouping 
of data.
</para>

</Function>


<SyntaxRules>

<olist>

<item>A <newterm>grouping operation</newterm> is any of the following:

<olist>

<item>A <BNF name="group by clause"/>.
</item>

<item>An <BNF name="aggregate function"/> that specifies <kw>DISTINCT</kw>.
</item>

<item>A <BNF name="return statement"/> that simply contains <kw>DISTINCT</kw> without 
an intervening <BNF name="return item"/>.
</item>

<item>A <BNF name="select statement"/> that simply contains <kw>DISTINCT</kw> without 
an intervening <BNF name="select item"/>.
</item>

<item>A <BNF name="composite query expression"/> that simply contains or implies <kw>UNION</kw>
<kw>DISTINCT</kw>.
</item>

<item>A <BNF name="composite query expression"/> that simply contains <kw>EXCEPT</kw>.
</item>

<item>A <BNF name="composite query expression"/> that simply contains <kw>INTERSECT</kw>.
</item>

</olist>

</item>

<item>An <newterm>operand of a grouping operation</newterm> is any of the following:

<olist>

<item>A <BNF name="binding variable reference"/> simply contained in 
a <BNF name="group by clause"/>.
</item>

<item>A <BNF name="value expression"/> simply contained in an <BNF name="aggregate function"/>
that specifies <kw>DISTINCT</kw>.
</item>

<item>A <BNF name="return item"/> simply contained in a <BNF name="return statement"/> 
that simply contains <kw>DISTINCT</kw> without an intervening <BNF name="return item"/>.
</item>

<item>A <BNF name="select item"/> simply contained in a <BNF name="select statement"/>
that simply contains <kw>DISTINCT</kw> without an intervening <BNF name="select item"/>.
</item>

<item>A column of the result of a <BNF name="composite query expression"/> that simply contains 
or implies <kw>UNION</kw> <kw>DISTINCT</kw>.
</item>

<item>A column of the result of a <BNF name="composite query expression"/> that simply contains
<kw>EXCEPT</kw>.
</item>

<item>A column of the result of a <BNF name="composite query expression"/> that simply contains
<kw>INTERSECT</kw>.
</item>

</olist>

</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:W21-058</comment>
<comment>WG3:CMN-057R1</comment>
<subClause id="gql_collationdeterm" newpage="true">
<clauseHeading>Determination of collation</clauseHeading>

<bodyMatter>


<Function id="gql_collationdeterm_0">

<para>Specify rules for determining the collation to be used in the comparison
of character strings.
</para>

</Function>


<SyntaxRules id="gql_collationdeterm_2">

<olist>

<comment>Editorial: Stephen Cannan, 2023-01-03 Add documentation</comment>
<item><SCsignature>
<symreturn name="COLL"/>
<documentation>
<slist>
<item>COLL &mdash; the collation to be used in the comparison of character strings.
</item>
</slist>
</documentation>
</SCsignature> 
</item>

<comment>WG3:CMN-057R1</comment>
<item>Let <symdef>DEFCOLL</symdef> be the default collation which is defined as the 
<impDef code="ID022"/> choice of one of the following:

<comment>WG3:CMN-057R1</comment>
<note>See <specref ref="gql_collation"/>.
</note>

<olist>

<item>UCS_BASIC.
</item>

<item>UNICODE.
</item>

<item>An <impDef code="ID022"/> custom collation.
</item>

</olist>

</item>

<comment>Insert explicit SCreturn</comment>
<item><SCreturn>
 <SCretval name="COLL"><sym>DEFCOLL</sym></SCretval>
</SCreturn>
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<subClause id="gql_gts_combo_vts" newpage="true">
<clauseHeading>Graph-type specific combination of property value types</clauseHeading>

<bodyMatter>

<Function>

<comment>WG3:W26-022R2</comment>
<para>Determine a combined property value type capable of representing all values of
the given argument property value types for use in the verification of graph type consistency.
</para>

</Function>


<SyntaxRules>

<olist>

<comment>WG3:W26-022R2</comment>
<item><SCsignature>
<symparam name="DTSET"><symdef>VTS</symdef></symparam>
<symreturn name="RESTYPE"/>
<documentation>
<slist>
<item>DTSET &mdash; a set of supported property value types. 
</item>

<comment>WG3:W26-022R2</comment>
<item>RESTYPE &mdash; a supported property value type that can be used to represent values of
the value types in <sym>DTSET</sym>. 
</item>
</slist>
</documentation>
</SCsignature>
</item>

<comment>WG3:W26-022R2</comment>
<item>Let <symdef>DTR</symdef> be defined as follows.

<comment>WG3:W26-022R2</comment>
<para>Case:
</para>

<olist>

<comment>WG3:W26-022R2</comment>
<item>If <feature code="GG26"/> is supported and a hypothetical application of
the Syntax Rules of <specref ref="gql_gen_combo_vts"/>,
with <sym>VTS</sym> as <symdef>DTSET</symdef> would succeed and
return <symdef>RESTYPE</symdef> as <symdef>CVT</symdef>, then <sym>DTR</sym> is <sym>CVT</sym>.
</item>

<comment>WG3:W26-022R2</comment>
<item>If <feature code="GG26"/> is not supported and <sym>VTS</sym> is a singleton set
comprising the value type <symdef>SVT</symdef>, then <sym>DTR</sym> is <sym>SVT</sym>.

<comment>WG3:W26-022R2</comment>
<note>The value types in <sym>VTS</sym> are normalized according to the provisions on
the equivalence of value types with the same type normal form.
Hence, equivalent value types are always represented by the same (single) value type
in <sym>VTS</sym>.
</note>

</item>

<comment>WG3:W26-022R2</comment>
<comment>WG3:GYD-017</comment>
<item id="gql_gts_combo_vts_empty">Otherwise, <sym>DTR</sym> is the empty type.
</item>

</olist>

</item>

<item><sym>DTR</sym> shall be a supported property value type.

<note>Consequently, <sym>DTR</sym> cannot be an immaterial value type in a successful evaluation of
this Syntax Rule.
</note>
</item>

<comment>WG3:W26-022R2</comment>
<item><SCreturn>
<SCretval name="RESTYPE"><sym>DTR</sym></SCretval>
</SCreturn>
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-043</comment>
<subClause id="gql_gen_combo_vts" newpage="true">
<clauseHeading>General combination of value types</clauseHeading>

<bodyMatter>

<Function>

<comment>WG3:CMN-043</comment>
<para>Determine a (possibly dynamic) combined value type capable of representing all values of 
the given argument value types.
</para>

</Function>


<SyntaxRules>

<olist>

<comment>WG3:CMN-043</comment>
<item><SCsignature>
<symparam name="DTSET"><symdef>IDTS</symdef></symparam>
<symreturn name="RESTYPE"/>
<documentation>
<slist>
<comment>WG3:W26-026R2</comment>
<item>DTSET &mdash; a set of value types. 
</item>
<item>RESTYPE &mdash; a (possibly dynamic) value type that can be used to represent values of
the value types in DTSET. 
</item>
</slist>
</documentation>
</SCsignature>
</item>

<item>If the conforming GQL-implementation does not support <feature code="GV65"/>, then:

<olist>

<item>The <applySC ref="gql_stat_combo_vts" rules="SR">
<symarg param="DTSET"><sym>IDTS</sym></symarg>
<symresult param="RESTYPE"><symdef>IRESTYPE</symdef></symresult>
</applySC>.
</item>

<item><SCreturn>
<SCretval name="RESTYPE"><sym>IRESTYPE</sym></SCretval>
</SCreturn>
</item>

</olist>

</item>
<comment>WG3:CMN-043 1 (one) Syntax Rule</comment>

<comment>WG3:W26-026R2</comment>
<item>Let <symdef>NDTS</symdef> be the set of all non-immaterial static value types contained 
in <sym>IDTS</sym>.
</item>

<comment>WG3:CMN-043</comment>
<item>For every set of static value types <symdef>SVTSET</symdef>: 
if <sym>SVTSET</sym> is non-empty and the 
<applySC ref="gql_stat_combo_vts" rules="SR" type="asTrial">
<symarg param="DTSET"><sym>SVTSET</sym></symarg>
<symresult param="RESTYPE"><symdef>IRESTYPE</symdef></symresult>
</applySC>, then <sym>SVTSET</sym> is called <newterm>statically combinable</newterm>.

<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-28 Fix typo</comment>
<note>Every singleton set is statically combinable. 
The empty set and sets containing non-numeric types of different primary base types are not 
statically combinable.
</note>

</item>

<comment>WG3:CMN-043</comment>
<item>Let <symdef>PNDTS</symdef> be a partition of <sym>NDTS</sym>, <ie/> a family of disjoint 
subsets (called parts) of <sym>NDTS</sym> such that:

<olist>

<comment>WG3:CMN-043</comment>
<item>Every value type in <sym>NDTS</sym> is contained in exactly one part in <sym>PNDTS</sym>.
</item>

<comment>WG3:CMN-043</comment>
<item>For each part <symdef>SUBPNDTS</symdef> in <sym>PNDTS</sym>.

<para>Case:
</para>

<olist>

<item>If <sym>SUBPNDTS</sym> is statically combinable, then:

<olist>

<item>Every proper non-empty subset of <sym>SUBPNDTS</sym> is statically combinable.
</item>

<item>There is no other part <symdef>SUBPNDTS2</symdef> in <sym>PNDTS</sym> such that the union of
<sym>SUBPNDTS</sym> and <sym>SUBPNDTS2</sym> is statically combinable.
</item>

</olist>

</item>

<item>Otherwise, <sym>SUBPNDTS</sym> is not statically combinable and:

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-12 non-empty</comment>
<item><sym>SUBPNDTS</sym> is non-empty.
</item>

<item><sym>SUBPNDTS</sym> contains no subset of at least two value types that is
statically combinable.
</item>

<item>Every other part in <sym>PNDTS</sym> is statically combinable.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:CMN-043</comment>
<item>The union of all parts in <sym>PNDTS</sym> is <sym>NDTS</sym>.
</item>

</olist>

<comment>WG3:CMN-043</comment>
<note>By these rules, <sym>PNDTS</sym> is a well-defined partition of <sym>NDTS</sym> and 
every part of <sym>PNDTS</sym> is non-empty.
</note>

</item>

<item>Let <symdef>CDTS</symdef> be the set of value types determined as follows.

<olist>

<comment>WG3:CMN-043</comment>
<item>Initially, <sym>CDTS</sym> is empty.
</item>

<comment>WG3:CMN-043</comment>
<item>For each part <symdef>SUBPNDTS</symdef> in <sym>PNDTS</sym>

<para>Case:
</para>

<olist>

<comment>Editorial: Stephen Cannan, 2023-08-31 Use proper mark-up</comment>
<comment>WG3:CMN-043</comment>
<item>If <sym>SUBPNDTS</sym> is statically combinable, then:

<olist>

<item>The <applySC ref="gql_stat_combo_vts" rules="SR">
<symarg param="DTSET"><sym>SUBPNDTS</sym></symarg>
<symresult param="RESTYPE"><symdef>CRESTYPE</symdef></symresult>
</applySC>.
</item>

<item><sym>CRESTYPE</sym> is defined and included in <sym>CDTS</sym>.
</item>

</olist>

</item>

<item>Otherwise, the value type specified by <kw>ANY</kw>&lt;<sym>SUBPNDTS</sym>&gt; is included 
in <sym>CDTS</sym>.

<comment>WG3:CMN-043</comment>
<note><kw>ANY</kw>&lt;<sym>SUBPNDTS</sym>&gt; is subject to type normalization and can
normalize to a dynamic union type or a static value type.
</note>

</item>

</olist>

</item>

<item>No other value types are included in <sym>CDTS</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-043</comment>
<bar note="Editorial: Stefan Plantikow, 2024-04-06 Improve wording"/>
<comment>Editorial: Stefan Plantikow, 2024-04-06 Improve wording</comment>
<item>Let <symdef>YDTS</symdef> be the set of all dynamic union types contained in <sym>IDTS</sym>.
</item>
<endbar/>

<comment>WG3:CMN-043</comment>
<comment>WG3:W26-026R2</comment>
<item>Let <symdef>FDTS</symdef> be the union of <sym>CDTS</sym> and <sym>YDTS</sym>.
</item>

<comment>WG3:CMN-043</comment>
<item>Let <symdef>NDTR</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W26-026R2</comment>
<item>If <sym>FDTS</sym> is empty, then <sym>NDTR</sym> is the null type.
</item>

<item>If <sym>FDTS</sym> comprises a single value type <symdef>FDT</symdef>, then <sym>NDTR</sym> 
is <sym>FDT</sym>.
</item>

<comment>WG3:W26-026R2</comment>
<item>Otherwise, <sym>FDTS</sym> contains at least two value types and

<para>Case:
</para>

<olist>

<item>If the GQL-implementation supports <feature code="GV67"/>, then:

<olist>

<item>Let <symdef>FDTLIST</symdef> be a <BNF name="vertical bar"/>-separated enumeration of 
<BNF name="value type"/>s that specify all value types in <sym>FDTS</sym>.
</item>

<item><sym>NDTR</sym> is the value type specified by <kw>ANY</kw>&lt;<sym>FDTLIST</sym>&gt;.
</item>

</olist>

<note><kw>ANY</kw>&lt;<sym>FDTLIST</sym>&gt; is subject to type normalization and can
normalize to a dynamic union type or a static value type.
</note>

</item>

<item>Otherwise, the GQL-implementation supports <feature code="GV66"/> and <sym>NDTR</sym> is 
the open dynamic union type.
</item>

</olist>

</item>

<item>Let <symdef>DTR</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:CMN-043</comment>
<comment>WG3:W26-026R2</comment>
<item>If <sym>IDTS</sym> is empty or only contains material value types, then <sym>DTR</sym> is 
the material variant of <sym>NDTR</sym>.
</item>

<item>Otherwise, <sym>IDTS</sym> is a non-empty set that contains at least one nullable value type 
and <sym>DTR</sym> is the (nullable) value type <sym>NDTR</sym>.
</item>

</olist>

</item>

</olist>

</item>

<item><SCreturn>
<SCretval name="RESTYPE"><sym>DTR</sym></SCretval>
</SCreturn>
</item>

</olist>

</SyntaxRules>


<comment>Editorial: Stefan Plantikow, 2023-08-22 Add missing section</comment>
<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>


<comment>Editorial: Stefan Plantikow, 2023-08-22 Add missing section</comment>
<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:CMN-043</comment>
<subClause id="gql_stat_combo_vts" newpage="true">
<clauseHeading>Static combination of value types</clauseHeading>

<bodyMatter>
<comment>WG3:W23-013 One editor's note removed</comment>

<Function>

<comment>WG3:UTC-015</comment>
<comment>WG3:CMN-043</comment>
<para>Determine a combined static value type capable of representing all values of the given 
argument value types.
</para>

</Function>


<SyntaxRules>

<ednote id="gql_PPgql415"> Ensure type lattice of each base type can be closed by union types.
See <PPref ref="PPgql415"/>.
</ednote>


<comment>WG3:OHD-044R1</comment>
<olist>

<comment>Editorial: Stephen Cannan, 2023-01-03 Add documentation</comment>
<comment>WG3:CMN-043</comment>
<item><SCsignature>
<symparam name="DTSET"><symdef>IDTS</symdef></symparam>
<symreturn name="RESTYPE"/>
<documentation>
<slist>
<comment>WG3:W26-026R2</comment>
<item>DTSET &mdash; a set of value types. 
</item>

<item>RESTYPE &mdash; a static value type that can be used to represent values of
the value types in DTSET. 
</item>
</slist>
</documentation>
</SCsignature>
</item>

<comment>WG3:UTC-129</comment>
<comment>WG3:CMN-043</comment>
<item><sym>IDTS</sym> shall contain only static value types.
</item>

<comment>WG3:UTC-129</comment>
<comment>WG3:W26-026R2</comment>
<item>Let <symdef>DTS</symdef> be the set of the nullable variants of all non-immaterial value 
types in <sym>IDTS</sym>.
</item>

<comment>WG3:UTC-129</comment>
<comment>WG3:W26-026R2</comment>
<item>Let the nullable value type <symdef>NDTR</symdef> be determined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W26-026R2</comment>
<item>If <sym>DTS</sym> is empty, then <sym>NDTR</sym> is the null type.
</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19</comment>
<comment>WG3:OHD-044R1</comment>
<item>If at least one of the value types in <sym>DTS</sym> is a character string type, then:

<olist>

<item>Every value type in <sym>DTS</sym> shall be a character string type.
</item>

<item>There shall be at least one character string type supported by the GQL-implementation that 
is a supertype of every value type in <sym>DTS</sym>.
</item>

<comment>WG3:UTC-129</comment>
<item><sym>NDTR</sym> is a character string type supported by the GQL-implementation that is 
a supertype of every value type in <sym>DTS</sym>. 
This type is determined using an <impDef code="IW019"/> mechanism.
</item>

</olist>

</item>

<comment>WG3:W12-029: Stefan Plantikow, 2021-06-19</comment>
<comment>WG3:OHD-044R1</comment>
<item>If at least one of the value types in <sym>DTS</sym> is a byte string type, then:

<olist>

<item>Every value type in <sym>DTS</sym> shall be a byte string type.
</item>

<item>There shall be at least one byte string type supported by the GQL-implementation that 
is a supertype of every value type in <sym>DTS</sym>.
</item>

<comment>WG3:UTC-129</comment>
<item><sym>NDTR</sym> is a byte string type supported by the GQL-implementation that is 
a supertype of every value type in <sym>DTS</sym>. 
This type is determined using an <impDef code="IW019"/> mechanism.
</item>

</olist>

</item>

<item>If at least one value type in <sym>DTS</sym> is numeric, then:

<olist>

<comment>WG3:OHD-044R1</comment>
<item>All value types in <sym>DTS</sym> shall be numeric types.
</item>

<comment>WG3:UTC-129</comment>
<item>Case:

<olist>

<comment>WG3:UTC-129</comment>
<item>If at least one value type in <sym>DTS</sym> is approximate numeric, then <sym>NDTR</sym> 
is approximate numeric with <impDef code="ID037"/> precision.
</item>

<comment>WG3:UTC-129</comment>
<item>Otherwise, <sym>NDTR</sym> is exact numeric with <impDef code="IL011"/> precision and with
scale equal to the maximum of the scales of the value types in <sym>DTS</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:W11-013</comment>
<comment>WG3:UTC-129</comment>
<comment>Editorial: Stefan Plantikow, 2023-03-01 Reword for consistency</comment>
<item>If at least one value type in <sym>DTS</sym> is a datetime type, then

<para>Case:
</para>

<olist>

<comment>WG3:OHD-044R1</comment>
<comment>WG3:UTC-117 required adjustments</comment>
<comment>WG3:UTC-129</comment>
<comment>Editorial: Stefan Plantikow, 2023-03-01 Reword for consistency</comment>
<item>All value types in <sym>DTS</sym> shall be datetime types.
</item>

<comment>WG3:UTC-129</comment>
<comment>Editorial: Stefan Plantikow, 2023-03-01 Reword for consistency</comment>
<item>If at least one value type in <sym>DTS</sym> is a zoned datetime type, then <sym>NDTR</sym> is
the zoned datetime type.
</item>

<comment>WG3:UTC-129</comment>
<comment>Editorial: Stefan Plantikow, 2023-03-01 Reword for consistency</comment>
<item>Otherwise, <sym>NDTR</sym> is the local datetime type.
</item>

</olist>

</item>

<comment>WG3:W11-013</comment>
<comment>WG3:UTC-117 required adjustments</comment>
<comment>WG3:UTC-129</comment>
<comment>Editorial: Stefan Plantikow, 2023-03-01 Reword for consistency</comment>
<item>If at least one value type in <sym>DTS</sym> is a time type, then:

<para>Case:
</para>

<olist>

<comment>WG3:OHD-044R1</comment>
<comment>WG3:UTC-129</comment>
<comment>Editorial: Stefan Plantikow, 2023-03-01 Reword for consistency</comment>
<item>All value types in <sym>DTS</sym> shall be time types.
</item>

<comment>WG3:UTC-129</comment>
<comment>Editorial: Stefan Plantikow, 2023-03-01 Reword for consistency</comment>
<item>If at least one value type in <sym>DTS</sym> is a zoned time type, then <sym>NDTR</sym> is 
the zoned time type.
</item>

<comment>WG3:UTC-129</comment>
<comment>Editorial: Stefan Plantikow, 2023-03-01 Reword for consistency</comment>
<item>Otherwise, <sym>NDTR</sym> is the local time type.
</item>

</olist>

</item>

<comment>WG3:UTC-129</comment>
<comment>Editorial: Stefan Plantikow, 2023-03-01 Reword for consistency</comment>
<item>If at least one value type in <sym>DTS</sym> is a date type, then all value types in 
<sym>DTS</sym> shall be date types and <sym>NDTR</sym> is the date type.
</item>

<comment>WG3:W11-013</comment>
<comment>WG3:OHD-044R1</comment>
<comment>WG3:UTC-129</comment>
<comment>Editorial: Stefan Plantikow, 2023-03-01 Reword for consistency</comment>
<comment>WG3:CMN-043</comment>
<item>If at least one value type in <sym>DTS</sym> is a year and month-based duration type, then 
all value types in <sym>DTS</sym> shall be year and month-based duration types and 
<sym>NDTR</sym> is the year and month-based duration type.
</item>

<comment>WG3:CMN-043</comment>
<item>If at least one value type in <sym>DTS</sym> is a day and time-based duration type, then 
all value types in <sym>DTS</sym> shall be day and time-based duration types and 
<sym>NDTR</sym> is the day and time-based duration type.
</item>

<comment>Editorial: Stephen Cannan, 2021-04-02 See WG3:W09-024</comment>
<comment>WG3:W11-013</comment>
<comment>WG3:OHD-044R1</comment>
<comment>WG3:W24-026R2</comment>
<comment>WG3:UTC-129</comment>
<item>If at least one value type in <sym>DTS</sym> is a Boolean type, then all value types in 
<sym>DTS</sym> shall be Boolean types and <sym>NDTR</sym> is the Boolean type.
</item>

<comment>WG3:POS-011R1</comment>
<item>If at least one value type in <sym>DTS</sym> is a vector type, then all value types in
<sym>DTS</sym> shall be vector types with the same dimensions and coordinate types and
<sym>NDTR</sym> is the vector type with that dimension and that coordinate type.
</item>

<comment>WG3:W11-013</comment>
<comment>WG3:OHD-044R1</comment>
<comment>WG3:W24-026R2</comment>
<item>If at least one value type in <sym>DTS</sym> is a list value type, then:

<olist>

<item>All value types in <sym>DTS</sym> shall be list value types.
</item>

<comment>WG3:CMN-043</comment>
<item>The <applySC ref="gql_stat_combo_vts" rules="SR">
<symarg param="DTSET">the set of all list element types of all list value types in 
<sym>DTS</sym></symarg>
<symresult param="RESTYPE"><symdef>ELT</symdef></symresult>
</applySC>.
</item>

<comment>WG3:UTC-123R2</comment>
<item>Case:

<olist>

<item>If all value types in <sym>DTS</sym> are group list value types, then <sym>NDTR</sym> is 
the group list value type with list element type <sym>ELT</sym>.
</item>


<item>Otherwise, <symdef>NDTR</symdef> is the regular list value type
with list element type <sym>ELT</sym>. 
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:UTC-129</comment>
<item>If any value type in <sym>DTS</sym> is a path value type, then all value types
in <sym>DTS</sym> shall be path value types and <sym>NDTR</sym> is the path value type.
</item>

<comment>WG3:W24-026R2</comment>
<item>If at least one value type in <sym>DTS</sym> is a record type, then:

<olist>

<item>All value types in <sym>DTS</sym> shall be a closed record type.
</item>

<comment>Email from: Hannes Voigt, 2022-12-22 1137</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>All record types in <sym>DTS</sym> shall have identical sets of field names.
</item>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Align wording</comment>
<item>Let <symdef>FNS</symdef> be the set of all names of all field types of all record
types in <sym>DTS</sym>.
</item>

<comment>WG3:UTC-129</comment>
<comment>WG3:CMN-043</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Align wording</comment>
<item><sym>NDTR</sym> is the closed record type comprising one field type <symdef>FT</symdef> for
every name <symdef>FN</symdef> in <sym>FNS</sym>, where the value type of <sym>FT</sym>
is determined as follows.

<olist>

<item>Let <symdef>FTSET</symdef> be the set of all value types of field types of record
types in <sym>DTS</sym> whose name is <sym>FN</sym>.
</item>

<item>The <applySC ref="gql_stat_combo_vts" rules="SR">
<symarg param="DTSET"><sym>FTSET</sym></symarg>
<symresult param="RESTYPE"><symdef>FVT</symdef></symresult>
</applySC>.
</item>

<item>The value type of <sym>FT</sym> is <sym>FVT</sym>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:UTC-129</comment>
<comment>WG3:CMN-043</comment>
<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<item>Otherwise:

<olist>

<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<item>At least one value type in <sym>DTS</sym> shall be a reference value type.
</item>

<comment>WG3:CMN-057R1</comment>
<item>All value types in <sym>DTS</sym> shall have the same primary base type.
</item>

<comment>WG3:CMN-057R1</comment>
<item>Let <symdef>BT</symdef> be that primary base type.
</item>

<comment>WG3:CMN-043</comment>
<comment>WG3:CMN-057R1</comment>
<item>There shall be at least one reference value type supported by the GQL-implementation that is 
a supertype of every value type in <sym>DTS</sym> and whose primary base type is <sym>BT</sym>.
</item>

<comment>WG3:CMN-043</comment>
<comment>WG3:CMN-057R1</comment>
<item><sym>NDTR</sym> is a value type supported by the GQL-implementation that is a supertype of 
every value type in <sym>DTS</sym> and whose primary base type is <sym>BT</sym>.
This type is determined using an <impDef code="IW019"/> mechanism.
</item>

</olist>

</item>

</olist>

</item>

<comment>Insert explicit SCreturn</comment>
<item>Let <symdef>DTR</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<comment>WG3:W26-026R2</comment>
<item>If <sym>IDTS</sym> is empty or only contains material value types, then <sym>DTR</sym> is 
the material variant of <sym>NDTR</sym>.
</item>

<comment>WG3:W26-026R2</comment>
<item>Otherwise, <sym>IDTS</sym> is a non-empty set that contains at least one nullable value type
and <sym>DTR</sym> is the (nullable) value type <sym>NDTR</sym>.
</item>

</olist>

</item>

<comment>Insert explicit SCreturn</comment>
<item><SCreturn>
<SCretval name="RESTYPE"><sym>DTR</sym></SCretval>
</SCreturn>
</item>

</olist>

</SyntaxRules>


<!-- Uncomment when Access Control is defined.
<AccessRules>

<olist>

<None/>

</olist>

</AccessRules>
-->


<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>


<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>


<comment>WG3:CMN-043</comment>
<subClause id="gql_svt_prec" newpage="true">
<clauseHeading>Determination of value type precedence</clauseHeading>

<bodyMatter>

<Function>

<comment>WG3:CMN-043</comment>
<para>Order a set of value types by precedence.
</para>

</Function>


<SyntaxRules>

<olist>

<comment>WG3:CMN-043</comment>
<item><SCsignature>
<symparam name="NDTSET"><symdef>IDTSET</symdef></symparam>
<symreturn name="NDTLIST"/>
<documentation>
<slist>
<item>NDTSET &mdash; a set of value types.
</item>
<item>NDTLIST &mdash; a list of the given value types in order of precedence.
</item>
</slist>
</documentation>
</SCsignature>
</item>

<item>The <newterm>effective binary precision</newterm> of a numeric type <symdef>T</symdef> is 
defined as follows.

<para>Case:
</para>

<olist>

<item>If the radix of <sym>T</sym> is decimal, then the effective binary precision is the product 
of log<sub>2</sub>(10) and the precision of <sym>T</sym>.
</item>

<item>Otherwise, the radix of <sym>T</sym> is binary and the effective binary precision is the
precision of <sym>T</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-043</comment>
<item>The notion of the 
<newterm>closed material record type corresponding to a set of property types</newterm> 
is defined as follows:

<olist>

<comment>WG3:CMN-043</comment>
<item>Let <symdef>PTSET</symdef> be a set of property types.
</item>

<comment>WG3:CMN-043</comment>
<item>Let <symdef>R</symdef> be the closed material record type defined as follows:

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>The set of names of field types of <sym>R</sym> is the same as
the set of names of property types in <sym>PTSET</sym>.
</item>

<comment>Editorial: Stefan Plantikow, 2023-11-15 Align wording</comment>
<item>For each field type <symdef>FT</symdef> of <sym>R</sym> whose name is <symdef>FN</symdef>,
the value type of <sym>FT</sym> is the value type of the property type in <sym>PTSET</sym>
whose name is <sym>FN</sym>.
</item>

</olist>

</item>

<comment>WG3:CMN-043</comment>
<item>The closed material record type corresponding to <sym>PTSET</sym> is <sym>R</sym>.
</item>

</olist>

</item>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<item>Let <symdef>REF</symdef>(<symdef>NT</symdef>) denote the closed node reference value type 
whose constraining GQL-object type is the node type <sym>NT</sym>.
</item>

<comment>WG3:CMN-043</comment>
<item>Given a set of value types <symdef>TS</symdef>, let <symdef>NTSEQ</symdef>(<sym>TS</sym>) 
denote the result of applying an <impDef code="IW021"/> mechanism for determining a permutation of 
all value types contained in <sym>TS</sym> such that:

<olist>

<item><sym>NTSEQ</sym>(<sym>TS</sym>) is a sequence of value types such that:

<olist>

<item>Every value type contained in <sym>NTSEQ</sym>(<sym>TS</sym>) is contained in <sym>TS</sym>.
</item>

<item>Every value type contained in <sym>TS</sym> is contained exactly once in 
<sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

</olist>

</item>

<comment>WG3:W26-026R2</comment>
<item>Immaterial value types precede all other value types in <sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

<comment>WG3:CMN-043</comment>
<comment>WG3:CMN-057R1</comment>
<comment>WG3:W26-026R2</comment>
<item>For each base type <symdef>BT</symdef> that is the primary base type of at least one 
material static value type in <sym>TS</sym>, there is exactly one longest subsequence of 
<sym>NTSEQ</sym>(<sym>TS</sym>) that comprises every value type of <sym>BT</sym> that is included 
in <sym>TS</sym>.
</item>


<comment>WG3:CMN-043</comment>
<comment>WG3:CMN-057R1</comment>
<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<item>For each pair of different data types <symdef>T1</symdef> and <symdef>T2</symdef> from 
<sym>TS</sym> with the same primary base type:

<olist>

<comment>WG3:CMN-043</comment>
<item>If <sym>T1</sym> is a closed value type and <sym>T2</sym> is an open value type, then 
<sym>T1</sym> precedes <sym>T2</sym> in <sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

<comment>WG3:CMN-043</comment>
<comment>WG3:W26-026R2</comment>
<item>Otherwise, <sym>T1</sym> and <sym>T2</sym> are either both closed value types, or 
both open value types, or both cannot be distinguished in terms of being open or closed
value types, and then:

<olist>

<item>Let <symdef>M1</symdef> and <symdef>M2</symdef> be the material variants of <sym>T1</sym> and
<sym>T2</sym>, respectively
</item>

<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<item>If <sym>M1</sym> precedes <sym>M2</sym> in <sym>NTSEQ</sym>({<sym>M1</sym>, <sym>M2</sym>}) 
and <sym>T2</sym> is possibly nullable, then <sym>T1</sym> precedes <sym>T2</sym> in 
<sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

</olist>

<comment>WG3:CMN-043</comment>
<comment>WG3:W26-026R2</comment>
<note>This provision fully handles the distinction between material and
nullable value types such that the following Syntax Rules need to consider
material value types only.
In particular, this provision places the null type before the empty type in terms of 
type precedence.
</note>

</item>

</olist>

</item>

<comment>WG3:W26-026R2</comment>
<item>There is exactly one (possibly empty) longest subsequence of <sym>NTSEQ</sym>(<sym>TS</sym>) 
that comprises every numeric type that is included in <sym>TS</sym>.
</item>

<comment>WG3:CMN-043</comment>
<item>For each pair of different material character string types <symdef>T1</symdef> and 
<symdef>T2</symdef> from <sym>TS</sym>, if the maximum length of <sym>T1</sym> is less than 
the maximum length of <sym>T2</sym>, then <sym>T1</sym> precedes <sym>T2</sym> in 
<sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

<comment>WG3:CMN-043</comment>
<item>For each pair of different material byte string types <symdef>T1</symdef> and 
<symdef>T2</symdef> from <sym>TS</sym>:

<olist>

<item>Let <symdef>DIFF1</symdef> be the difference between the maximum length of <sym>T1</sym> and 
the minimum length of <sym>T1</sym>.
</item>

<item>Let <symdef>DIFF2</symdef> be the difference between the maximum length of <sym>T2</sym> and 
the minimum length of <sym>T2</sym>.
</item>

<item>If <sym>DIFF1</sym> is less than <sym>DIFF2</sym>, then <sym>T1</sym> precedes <sym>T2</sym> 
in <sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

</olist>

</item>

<comment>WG3:CMN-043</comment>
<item>For each pair of different material numeric data types <symdef>T1</symdef> and 
<symdef>T2</symdef> from <sym>TS</sym>:

<olist>

<item>If <sym>T1</sym> is exact numeric and <sym>T2</sym> is approximate numeric, then
<sym>T1</sym> precedes <sym>T2</sym> in <sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

<comment>WG3:CMN-043</comment>
<comment>WG3:CMN-057R1</comment>
<item>If <sym>T1</sym> and <sym>T2</sym> have the same primary base type, then:

<olist>

<item>If the effective binary precision of <sym>T1</sym> is less than the effective binary
precision of <sym>T2</sym>, then <sym>T1</sym> precedes <sym>T2</sym> in 
<sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

<item>If the effective binary precision of <sym>T1</sym> is equal to the effective binary
precision of <sym>T2</sym> and the scale of <sym>T1</sym> is less than the scale of <sym>T2</sym>, 
then <sym>T1</sym> precedes <sym>T2</sym> in <sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:CMN-043</comment>
<item>The precedence of different material temporal instant types in <sym>TS</sym> in 
<sym>NTSEQ</sym>(<sym>TS</sym>) adhere to the following provisions:

<olist>

<item>A local temporal instant type precedes its zoned variant in <sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<item>A material date type precedes all material time types in <sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

<item>A material time type precedes all material datetime types in <sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

</olist>

</item>

<comment>WG3:CMN-043</comment>
<item>The material day and time-based duration type precedes the material year and
month-based duration type in <sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

<comment>WG3:POS-011R1</comment>
<item>For each pair of different material vector types <symdef>T1</symdef> and <symdef>T2</symdef>
from <sym>TS</sym>, if the coordinate type <symdef>C1</symdef> of <sym>T1</sym> precedes
the coordinate type <symdef>C2</symdef> of <sym>T2</sym> in
<sym>NTSEQ</sym>({<sym>C1</sym>, <sym>C2</sym>}), then <sym>T1</sym> precedes <sym>T2</sym> in
<sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

<comment>WG3:POS-011R1</comment>
<item>For each pair of different material vector types
<symdef>T1</symdef> and <symdef>T2</symdef> from <sym>TS</sym>,
if <sym>T1</sym> and <sym>T2</sym> have the same coordinate type and
the dimension of <sym>T1</sym> is less than the dimension <sym>T2</sym>,
then <sym>T1</sym> precedes <sym>T2</sym> in <sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

<comment>WG3:CMN-043</comment>
<item>For each pair of different closed material list value types <symdef>T1</symdef> and 
<symdef>T2</symdef> from <sym>TS</sym>:

<olist>

<comment>WG3:UTC-123R2</comment>
<item>If <sym>T1</sym> is a group list value type and <sym>T2</sym> is a regular list value type,
then <sym>T1</sym> precedes <sym>T2</sym> in <sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

<comment>WG3:CMN-043</comment>
<item>If <sym>T1</sym> and <sym>T2</sym> are either both group list values or regular list values, 
then:

<olist>

<item>If the maximum cardinality of <sym>T1</sym> is less than the maximum cardinality of 
<sym>T2</sym>, then <sym>T1</sym> precedes <sym>T2</sym> in <sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

<item>If <sym>T1</sym> and <sym>T2</sym> have the same maximum cardinality and the element type 
<symdef>E1</symdef> of <sym>T1</sym> precedes the element type <symdef>E2</symdef> of <sym>T2</sym>
in <sym>NTSEQ</sym>({<sym>E1</sym>, <sym>E2</sym>}), then 
<sym>T1</sym> precedes <sym>T2</sym> in <sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:CMN-043</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-15 Wording</comment>
<item>For each pair of different closed material record types <symdef>T1</symdef> and 
<symdef>T2</symdef> from <sym>TS</sym>, if <sym>T1</sym> and <sym>T2</sym> have the same set of 
field type names <symdef>FNS</symdef> and for each name <symdef>FN</symdef> in <sym>FNS</sym>, 
the value type <symdef>FVT1</symdef> of the field type with name <sym>FN</sym> of 
<sym>T1</sym> precedes the value type <symdef>FVT2</symdef> of the field type
with name <sym>FN</sym> of <sym>T2</sym> in <sym>NTSEQ</sym>({<sym>FVT1</sym>, <sym>FVT2</sym>}),
then <sym>T1</sym> precedes <sym>T2</sym> in <sym>NTSEQ</sym>(<sym>TS</sym>).

<comment>WG3:W26-026R2</comment>
<note>This provides depth-subtyping of records but does not provide width-subtyping of records. 
Record fields can be discarded by casting to an appropriately chosen record type that 
excludes them.
</note>
</item>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<comment>WG3:CMN-043</comment>
<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<item>For each pair of different closed material node reference value types <symdef>T1</symdef> and 
<symdef>T2</symdef> from <sym>TS</sym> whose constraining GQL-object types are the node types 
<symdef>O1</symdef> and <symdef>O2</symdef>, respectively:

<olist>

<item>If the node type label set of <sym>O2</sym> is a proper subset of the node type label set of
<sym>O1</sym>, then <sym>T1</sym> precedes <sym>T2</sym> in <sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

<comment>WG3:CMN-043</comment>
<item>If the node type label sets of <sym>O1</sym> and <sym>O2</sym> are either partially 
overlapping or disjoint and the closed material record type <symdef>R1</symdef> corresponding to 
the node type property type set of <sym>O1</sym> precedes the closed material record type 
<symdef>R2</symdef> corresponding to the node type property type set of <sym>O2</sym> in 
<sym>NTSEQ</sym>({<sym>R1</sym>, <sym>R2</sym>}), then <sym>T1</sym> precedes <sym>T2</sym> in 
<sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

</olist>

</item>

<comment>WG3:UTC-086R1</comment>
<comment>WG3:CMN-019 P00-USA-025</comment>
<comment>WG3:CMN-043</comment>
<item>For each pair of different closed material edge reference value types <symdef>T1</symdef> and 
<symdef>T2</symdef> from <sym>TS</sym> whose constraining GQL-object types are the edge types 
<symdef>O1</symdef> and <symdef>O2</symdef>, respectively:

<olist>

<item>If the edge type label set of <sym>O2</sym> is a proper subset of the edge type label set of
<sym>O1</sym>, then <sym>T1</sym> precedes <sym>T2</sym> in <sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

<comment>WG3:CMN-043</comment>
<item>If the edge type label sets of <sym>O1</sym> and <sym>O2</sym> are either partially 
overlapping or disjoint and <sym>O1</sym> is directed and <sym>O2</sym> is undirected, then 
<sym>T1</sym> precedes <sym>T2</sym> in <sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

<comment>WG3:CMN-043</comment>
<item>If the edge type label sets of <sym>O1</sym> and <sym>O2</sym> are either partially 
overlapping or disjoint, both <sym>O1</sym> and <sym>O2</sym> have the same directionality, and 
the closed material record type <symdef>R1</symdef> corresponding to the edge type property type
set of <sym>O1</sym> precedes the closed material record type <symdef>R2</symdef> corresponding to 
the edge type property type set of <sym>O2</sym> in 
<sym>NTSEQ</sym>({<sym>R1</sym>, <sym>R2</sym>}), then 
<sym>T1</sym> precedes <sym>T2</sym> in <sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

<comment>WG3:CMN-043</comment>
<item>If the edge type label sets of <sym>O1</sym> and <sym>O2</sym> are either partially 
overlapping or disjoint, both <sym>O1</sym> and <sym>O2</sym> have the same directionality, 
none of the closed material record types <sym>R1</sym> and <sym>R2</sym> corresponding to the 
edge type property type sets of <sym>O1</sym> and <sym>O2</sym>, respectively, precedes the other 
in NTSEQ({R1, R2}), then:

<olist>

<item>Let <symdef>S1</symdef> and <symdef>D1</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>O1</sym> is directed, then <sym>S1</sym> is the source node type of <sym>O1</sym> and
<sym>D1</sym> is the destination node type of <sym>O2</sym>.
</item>

<item>Otherwise, <sym>O1</sym> is undirected with endpoint node types <symdef>E1</symdef> and 
<symdef>E1<prime/></symdef> and

<para>Case:
</para>

<olist>

<item>If <sym>REF</sym>(<sym>E1</sym>) precedes <sym>REF</sym>(<sym>E1<prime/></sym>) in 
<sym>NTSEQ</sym>({<sym>REF</sym>(<sym>E1</sym>), <sym>REF</sym>(<sym>E1<prime/></sym>)}),
then <sym>S1</sym> is <sym>E1</sym> and <sym>D1</sym> is <sym>E1<prime/></sym>.
</item>

<item>Otherwise, <sym>S1</sym> is <sym>E1<prime/></sym> and <sym>D1</sym> is <sym>E1</sym>.
</item>

</olist>

</item>

</olist>

</item>

<item>Let <symdef>S2</symdef> and <symdef>D2</symdef> be defined as follows.

<para>Case:
</para>

<olist>

<item>If <sym>O2</sym> is directed, then <sym>S2</sym> is the source node type of <sym>O2</sym> 
and <sym>D2</sym> is the destination node type of <sym>O2</sym>.
</item>

<item>Otherwise, <sym>O2</sym> is undirected with endpoint node types <symdef>E2</symdef> and 
<symdef>E2<prime/></symdef> and

<para>Case:
</para>

<olist>

<item>If <sym>REF</sym>(<sym>E2</sym>) precedes <sym>REF</sym>(<sym>E2<prime/></sym>) in 
<sym>NTSEQ</sym>({<sym>REF</sym>(<sym>E2</sym>), <sym>REF</sym>(<sym>E2<prime/></sym>)}),
then <sym>S2</sym> is <sym>E2</sym> and <sym>D2</sym> is <sym>E2<prime/></sym>.
</item>

<item>Otherwise, <sym>S2</sym> is <sym>E2<prime/></sym> and <sym>D2</sym> is <sym>E2</sym>.
</item>

</olist>

</item>

</olist>

</item>

<item>If <sym>REF</sym>(<sym>S1</sym>) precedes <sym>REF</sym>(<sym>S2</sym>) in 
<sym>NTSEQ</sym>({<sym>REF</sym>(<sym>S1</sym>), <sym>REF</sym>(<sym>S2</sym>)}), then 
<sym>T1</sym> precedes <sym>T2</sym> in <sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

<item>If neither <sym>REF</sym>(<sym>S1</sym>) precedes <sym>REF</sym>(<sym>S2</sym>) nor 
<sym>REF</sym>(<sym>S2</sym>) precedes <sym>REF</sym>(<sym>S1</sym>) in
<sym>NTSEQ</sym>({<sym>REF</sym>(<sym>S1</sym>), <sym>REF</sym>(<sym>S2</sym>)}) and 
<sym>REF</sym>(<sym>D1</sym>) precedes <sym>REF</sym>(<sym>D2</sym>) in 
<sym>NTSEQ</sym>({<sym>REF</sym>(<sym>D1</sym>), <sym>REF</sym>(<sym>D2</sym>)}), then 
<sym>T1</sym> precedes <sym>T2</sym> in <sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

</olist>

</item>

</olist>

</item>

<item>For each pair of different binding table reference value types <symdef>T1</symdef> and 
<symdef>T2</symdef> from <sym>TS</sym>, if the record type <symdef>R1</symdef> of <sym>T1</sym> 
precedes the record type <symdef>R2</symdef> of <sym>T2</sym> in 
<sym>NTSEQ</sym>({<sym>R1</sym>, <sym>R2</sym>}), then <sym>T1</sym> precedes <sym>T2</sym> in 
<sym>NTSEQ</sym>(<sym>T1</sym>, <sym>T2</sym>).
</item>

<item>For each pair of different closed graph reference value types <symdef>T1</symdef> and 
<symdef>T2</symdef> from <sym>TS</sym> whose constraining graph types are <symdef>G1</symdef> and 
<symdef>G2</symdef>, if the set of graph element types of <sym>G1</sym> is a proper subset of the 
set of graph element types of <sym>G2</sym>, then <sym>T1</sym> precedes <sym>T2</sym> in
<sym>NTSEQ</sym>(<sym>T1</sym>, <sym>T2</sym>).
</item>

<comment>WG3:CMN-043</comment>
<item>For each pair of material static value types <symdef>T1</symdef> from <sym>TS</sym> and 
the open material dynamic union type <symdef>T2</symdef> from <sym>TS</sym>, it holds that 
<sym>T1</sym> precedes <sym>T2</sym> in <sym>NTSEQ</sym>(<sym>T1</sym>, <sym>T2</sym>).
</item>

<comment>WG3:CMN-043</comment>
<comment>WG3:CMN-057R1</comment>
<item>Any two value types <symdef>T1</symdef> and <symdef>T2</symdef> are called 
<newterm>standard precedence-ordered</newterm> if and only if it holds that <sym>T1</sym> and 
<sym>T2</sym> have the same primary base type or it holds that <sym>T1</sym> and <sym>T2</sym> 
are both numeric types.
</item>

<comment>WG3:CMN-043</comment>
<item>For each pair of closed material dynamic union types <symdef>T1</symdef> from <sym>TS</sym> 
and material static value types <symdef>T2</symdef> from <sym>TS</sym>:

<olist>

<item>Let <symdef>CTS1</symdef> be the component types of <sym>T1</sym>.
</item>

<item>Let <symdef>BEFORE</symdef> be the proposition that there is <symdef>CT1</symdef> in 
<sym>CTS1</sym> such that <sym>CT1</sym> and <sym>T2</sym> are standard precedence-ordered and 
<sym>CT1</sym> precedes <sym>T2</sym> in <sym>NTSEQ</sym>(<sym>CT1</sym>, <sym>T2</sym>).
</item>

<item>Let <symdef>AFTER</symdef> be the proposition that there is <symdef>CT1</symdef> in 
<sym>CTS1</sym> such that <sym>CT1</sym> and <sym>T2</sym> are standard precedence-ordered and 
<sym>T2</sym> precedes <sym>CT1</sym> in <sym>NTSEQ</sym>(<sym>CT1</sym>, <sym>T2</sym>).
</item>

<item>If <sym>BEFORE</sym> but not <sym>AFTER</sym> holds, then <sym>T1</sym> precedes 
<sym>T2</sym> in <sym>NTSEQ</sym>(<sym>T1</sym>, <sym>T2</sym>).
</item>

</olist>

</item>

<comment>WG3:CMN-043</comment>
<item>For each pair of different closed material dynamic union types <symdef>T1</symdef> and 
<symdef>T2</symdef> from <sym>TS</sym>:

<olist>

<item>Let <symdef>CTS1</symdef> and <symdef>CTS2</symdef> be the component types of <sym>T1</sym>
and <sym>T2</sym>, respectively.
</item>

<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<item>Let <symdef>BEFORE</symdef> be the proposition that there are standard precedence-ordered 
<symdef>CT1</symdef> in <sym>CTS1</sym> and <symdef>CT2</symdef> in <sym>CTS2</sym> such that 
<sym>CT1</sym> precedes <sym>CT2</sym> in <sym>NTSEQ</sym>(<sym>CT1</sym>, <sym>CT2</sym>).
</item>

<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<item>Let <symdef>AFTER</symdef> be the proposition that there are standard precedence-ordered 
<symdef>CT1</symdef> in <sym>CTS1</sym> and <symdef>CT2</symdef> in <sym>CTS2</sym> such that 
<sym>CT2</sym> precedes <sym>CT1</sym> in <sym>NTSEQ</sym>(<sym>CT1</sym>, <sym>CT2</sym>).
</item>

<comment>Email from: Stefan Plantikow, 2023-10-30 1420</comment>
<item>If <sym>BEFORE</sym> but not <sym>AFTER</sym> holds, then <sym>T1</sym> precedes 
<sym>T2</sym> in <sym>NTSEQ</sym>({<sym>T1</sym>, <sym>T2</sym>}).
</item>

</olist>

</item>

<item>If <sym>T1</sym> precedes <sym>T2</sym> in <sym>NTSEQ</sym>(<sym>TS</sym>), then for every 
finite set of types <symdef>TS<prime/></symdef> that contains <sym>T1</sym> and <sym>T2</sym>, it 
holds that <sym>T1</sym> precedes <sym>T2</sym> in <sym>NTSEQ</sym>(<sym>TS<prime/></sym>).
</item>

<comment>WG3:CMN-043</comment>
<item><sym>NTSEQ</sym>(<sym>NTSEQ</sym>(<sym>TS</sym>)) = <sym>NTSEQ</sym>(<sym>TS</sym>).
</item>

<comment>WG3:CMN-043</comment>
<item>The results of all invocations of <sym>NTSEQ</sym>(<sym>TS</sym>) are the same.

<note>This ensures that all invocations of the <impDef code="IW021"/> mechanism for determining 
a permutation of value types, which is used in the definition of <sym>NTSEQ</sym> are deterministic.
</note>

</item>

</olist>

</item>

<item><SCreturn>
<SCretval name="NDTLIST"><sym>NTSEQ</sym>(<sym>IDTSET</sym>)</SCretval>
</SCreturn>
</item>

</olist>

</SyntaxRules>

<comment>Editorial: Stefan Plantikow, 2023-08-22 Add missing section</comment>
<GeneralRules>

<olist>

<None/>

</olist>

</GeneralRules>


<comment>Editorial: Stefan Plantikow, 2023-08-22 Add missing section</comment>
<ConformanceRules>

<olist>

<None/>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>

</clause>


<comment>Editorial: Stefan Plantikow, 2022-11-11 Renamed for clarity</comment>
<clause id="gql_diagrepr">
<clauseHeading>GQLSTATUS and diagnostic records</clauseHeading>

<subClause id="gql_diagrepr_gqlstatus">
<clauseHeading>GQLSTATUS</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow 2023-03-23 Link digital artifacts</comment>
<comment>Editorial: Stefan Plantikow, 2024-05-03 Adjusted for WG3:BGI-033 related changes</comment>
<para>The GQLSTATUS codes of all conditions that are raised by specifications contained in this
document are shown in <specref ref="gql_gqlstatevals"/>. 
<digitalArtifact type="Conditions"/>
</para>

<comment>Editorial: Stefan Plantikow, 2022-05-04 Wording</comment>
<para>A character string returned as GQLSTATUS is the concatenation of
a 2-character class code followed by a 3-character subclass code, each restricted to
<BNF name="standard digit"/>s and <BNF name="simple Latin upper-case letter"/>s, respectively.
<specref ref="gql_gqlstatevals"/>, categorizes and specifies the class code for each condition and
the subclass code or codes for each subcondition defined in this document.
</para>

<para>Class codes that begin with one of the <BNF name="standard digit"/>s <string>0</string>,
<string>1</string>, <string>2</string>, <string>3</string>, or <string>4</string> or one of the
<BNF name="simple Latin upper-case letter"/>s <string>A</string>, <string>B</string>,
<string>C</string>, <string>D</string>, <string>E</string>, <string>F</string>, <string>G</string>,
or <string>H</string> are returned only for conditions defined in this document or some other
International Standard.
The range of such class codes is called <newterm>standard-defined classes</newterm>.
Some such class codes are reserved for use by specific International Standards, as specified
elsewhere in this Clause.
Subclass codes associated with such classes that also begin with one of those 13 characters are
returned only for conditions defined in this document or some other International Standard.
The range of such subclass codes is called <newterm>standard-defined subclasses</newterm>.
Subclass codes associated with such classes that begin with one of the
<BNF name="standard digit"/>s <string>5</string>, <string>6</string>, <string>7</string>,
<string>8</string>, or <string>9</string> or one of the 
<BNF name="simple Latin upper-case letter"/>s <string>I</string>, <string>J</string>,
<string>K</string>, <string>L</string>, <string>M</string>, <string>N</string>, <string>O</string>,
<string>P</string>, <string>Q</string>, <string>R</string>, <string>S</string>, <string>T</string>, 
<string>U</string>, <string>V</string>, <string>W</string>, <string>X</string>, <string>Y</string>,
or <string>Z</string> are reserved for <impDef annex="no" code="None"/> conditions and are called
<emph><impDef annex="no" code="None"/> subclasses</emph>.
</para>

<para> Class codes that begin with one of the <BNF name="standard digit"/>s <string>5</string>,
<string>6</string>, <string>7</string>, <string>8</string>, or <string>9</string> or one of the
<BNF name="simple Latin upper-case letter"/>s <string>I</string>, <string>J</string>, 
<string>K</string>, <string>L</string>, <string>M</string>, <string>N</string>, <string>O</string>,
<string>P</string>, <string>Q</string>, <string>R</string>, <string>S</string>, <string>T</string>,
<string>U</string>, <string>V</string>, <string>W</string>, <string>X</string>, <string>Y</string>,
or <string>Z</string> are reserved for <impDef annex="no" code="None"/> exception conditions and
are called <emph><impDef annex="no" code="None"/> classes</emph>.
All subclass codes except <string>000</string>, which means <emph>no subclass</emph>, associated
with such classes are reserved for <impDef annex="no" code="None"/> conditions and are called
<emph><impDef annex="no" code="None"/> subclasses</emph>.
An <impDef annex="no" code="None"/> completion condition shall be indicated by returning 
an <impDef annex="no" code="None"/> subclass in conjunction with one of the classes
<raise class="00"/>, <raise class="01"/>, or <raise class="02"/>.
</para>

<para>If a subclass code is not specified for a condition, then either subclass
<string>000</string> or an <impDef annex="no" code="None"/> subclass is returned.
</para>

<comment>Editorial: Stefan Plantikow, 2022-05-04 Reword</comment>
<comment>WG3:CMN-078</comment>
<para>The <quote>Category</quote> column has the following meanings:
<string>S</string> means that the class code given corresponds to a completion condition that
indicates successful completion and;
<string>W</string> means that the class code given corresponds to a completion condition that
indicates successful completion but with a warning;
<string>N</string> means that the class code given corresponds to a completion condition that
indicates a no-data situation;
<string>I</string> means that the class code given corresponds to additional information returned in
the nested GQL-status objects;
<string>X</string> means that the class code given corresponds to an exception condition.
</para>

<comment>Editor overhaul of how conditions are raised and summarized, 2020-06-08</comment>
<conditionsTable id="gql_gqlstatevals">
<tableTitle>GQLSTATUS class and subclass codes</tableTitle>
</conditionsTable>

</bodyMatter>

</subClause>


<subClause id="gql_diagrepr_rec" newpage="true">
<comment>Editorial: Stefan Plantikow, 2022-11-11 Renamed for clarity</comment>
<clauseHeading>Diagnostic records</clauseHeading>

<bodyMatter>

<comment>WG3:W23-032</comment>
<Function>

<para>Define a record with diagnostic information.
</para>

</Function>

<GeneralRules>

<olist>

<comment>WG3:W23-032</comment>
<item>When a completion condition is raised an empty record, <symdef>DIAGNOSTICS</symdef>,
is created.
</item>

<comment>WG3:W10-010R1</comment>
<comment>WG3:W22-036</comment>
<comment>WG3:W23-032</comment>
<item>When an exception condition is raised the following record, <symdef>DIAGNOSTICS</symdef>,
is created:

<comment>WG3:DCA-032</comment>
<comment>WG3:CMN-039</comment>
<code>
<kw>RECORD</kw> { 
  OPERATION: <symdef>OP</symdef>,
  OPERATION_CODE: <symdef>OPC</symdef>,
  <kw>CURRENT_SCHEMA</kw>: <symdef>CS</symdef>
}
</code>

<para>where:
</para>

<olist>

<comment>WG3:CMN-039</comment>
<item><sym>OP</sym> is a character string identifying the operation executed.
<specref ref="gql_diagcodes"/>, specifies the identifier of the operation.
</item>

<comment>WG3:CMN-039</comment>
<item><sym>OPC</sym> is an integer identifying the code of the operation executed.
<specref ref="gql_diagcodes"/>, identifies the code of the operation.
Positive values are reserved for operations defined in this document.
Negative values are reserved for <impDef annex="no" code="None"/> commands.
</item>

<comment>WG3:W23-032</comment>
<comment>WG3:UTC-096R1</comment>
<comment>WG3:DCA-032</comment>
<item>Let <symdef>CS</symdef> be defined as follows:

<olist>

<comment>WG3:CMN-042</comment>
<item>Let <symdef>NT</symdef> be the innermost BNF non-terminal instance the application of
whose rules raise the exception condition for which <sym>DIAGNOSTICS</sym> was created.
</item>

<item>Case:

<olist>

<comment>WG3:UTC-096R1</comment>
<comment>WG3:CMN-019 P00-USA-186</comment>
<comment>WG3:CMN-042</comment>
<item>If the current working schema reference of <sym>NT</sym> is defined, then <sym>CS</sym> is
the current working schema reference of <sym>NT</sym>.
</item>

<comment>WG3:UTC-096R1</comment>
<comment>WG3:DCA-032</comment>
<item>Otherwise, <sym>CS</sym> is the null value.
</item>

</olist>

</item>

</olist>

</item>

<comment>Editorial: Stefan Plantikow, 2022-05-04 Reword</comment>
<comment>WG3:W22-036</comment>
<comment>WG3:W23-032</comment>

</olist>

</item>

</olist>

<comment>WG3:DCA-028 and related editorial adjustments</comment>
<comment>WG3:CMN-039</comment>
<table id="gql_diagcodes">
<tableTitle>Operation codes</tableTitle>

<table-common>

<table-setup numcols="3">
<table-coldef colnum="1" colwidth="3.3in"/>
<table-coldef colnum="2" colwidth="2.5in"/>
<table-coldef colnum="3" colwidth="0.7in"/>
</table-setup>

<table-notations>

<comment>WG3:DCA-028 related editorial adjustments</comment>
<comment>WG3:CMN-039</comment>
<comment>Editorial: Stephen Cannan, 2023-10-13</comment>
<table-note note-char="1"><sym>x</sym> is an <impDef annex="no" code="None"/> negative number 
different from the value associated with any other statement or command in the GQL language.
</table-note>

</table-notations>

<comment>WG3:DCA-028 related editorial adjustments</comment>
<table-heads>
<comment>WG3:CMN-039</comment>
<table-head> Operation </table-head>
<table-head> Identifier </table-head>
<table-head> Code </table-head>
</table-heads>

</table-common>

<comment>WG3:W15-018</comment>
<comment>WG3:DCA-028</comment>
<table-body>

<comment>Editorial: Stefan Plantikow, 2020-07-27 WG3:MMX-055</comment>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell span="3">&nbsp;<linebreak/>
<emph>Session commands</emph>
</table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="session set command"/> with <linebreak/>
a <BNF name="session set schema clause"/> 
</table-cell>
<table-cell> SESSION SET SCHEMA COMMAND </table-cell>
<table-cell> 1 (one) </table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="session set command"/> simply containing <linebreak/>
a <BNF name="session set graph clause"/> 
</table-cell>
<table-cell> SESSION SET PROPERTY GRAPH COMMAND </table-cell>
<table-cell> 2 </table-cell>
</table-row>

<comment>WG3:W08-014</comment>
<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="session set command"/> simply containing <linebreak/>
a <BNF name="session set time zone clause"/> 
</table-cell>
<table-cell> SESSION SET TIME ZONE COMMAND </table-cell>
<table-cell> 3 </table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="session set command"/> simply containing <linebreak/>
a <BNF name="session set graph parameter clause"/> </table-cell>
<table-cell> SESSION SET PROPERTY GRAPH PARAMETER COMMAND </table-cell>
<table-cell> 4 </table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="session set command"/> simply containing <linebreak/> 
a <BNF name="session set binding table parameter clause"/> </table-cell>
<table-cell> SESSION SET BINDING TABLE PARAMETER COMMAND </table-cell>
<table-cell> 5 </table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="session set command"/> simply containing <linebreak/>
a <BNF name="session set value parameter clause"/> </table-cell>
<table-cell> SESSION SET VALUE PARAMETER COMMAND </table-cell>
<table-cell> 6 </table-cell>
</table-row>

<comment>WG3:UTC-045R1</comment>
<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="session reset command"/> </table-cell>
<table-cell> SESSION RESET COMMAND </table-cell>
<table-cell> 7 </table-cell>
</table-row>

<comment>Editorial: Stefan Plantikow, 2022-11-10 Removed spurious box element</comment>
<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="session close command"/> </table-cell>
<table-cell> SESSION CLOSE COMMAND </table-cell>
<table-cell> 8 </table-cell>
</table-row>

<comment>WG3:DCA-028 related editorial adjustments</comment>
<table-row>
<table-cell span="3">&nbsp;<linebreak/>
<emph>Transaction commands</emph>
</table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="start transaction command"/> </table-cell>
<table-cell> START TRANSACTION COMMAND </table-cell>
<table-cell> 50 </table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="rollback command"/> </table-cell>
<table-cell> ROLLBACK COMMAND </table-cell>
<table-cell> 51 </table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="commit command"/> </table-cell>
<table-cell> COMMIT COMMAND </table-cell>
<table-cell> 52 </table-cell>
</table-row>

<comment>WG3:DCA-028 related editorial adjustments</comment>
<table-row>
<table-cell span="3">&nbsp;<linebreak/>
<emph>Catalog-modifying statements</emph>
</table-cell>
</table-row>

<comment>WG3:OHD-035</comment>
<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="create schema statement"/> </table-cell>
<table-cell> CREATE SCHEMA STATEMENT </table-cell>
<table-cell> 100 </table-cell>
</table-row>

<comment>WG3:OHD-035</comment>
<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="drop schema statement"/> </table-cell>
<table-cell> DROP SCHEMA STATEMENT </table-cell>
<table-cell> 101 </table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell span="3">&nbsp;<linebreak/>
</table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="create graph statement"/> </table-cell>
<table-cell> CREATE GRAPH STATEMENT </table-cell>
<table-cell> 200 </table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="drop graph statement"/> </table-cell>
<table-cell> DROP GRAPH STATEMENT </table-cell>
<table-cell> 201 </table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell span="3">&nbsp;<linebreak/>
</table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="create graph type statement"/> </table-cell>
<table-cell> CREATE GRAPH TYPE STATEMENT </table-cell>
<table-cell> 300 </table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="drop graph type statement"/> </table-cell>
<table-cell> DROP GRAPH TYPE STATEMENT </table-cell>
<table-cell> 301 </table-cell>
</table-row>

<comment>WG3:DCA-028 related editorial adjustments</comment>
<table-row>
<table-cell span="3">&nbsp;<linebreak/>
<emph>Data-modifying statements</emph>
</table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="insert statement"/> </table-cell>
<table-cell> INSERT STATEMENT </table-cell>
<table-cell> 500 </table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="set statement"/> </table-cell>
<table-cell> SET STATEMENT </table-cell>
<table-cell> 501 </table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="remove statement"/> </table-cell>
<table-cell> REMOVE STATEMENT </table-cell>
<table-cell> 502 </table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="delete statement"/> </table-cell>
<table-cell> DELETE STATEMENT </table-cell>
<table-cell> 503 </table-cell>
</table-row>

<comment>WG3:DCA-028 related editorial adjustments</comment>
<table-row>
<table-cell span="3">&nbsp;<linebreak/>
<emph>Query statements</emph>
</table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="match statement"/> </table-cell>
<table-cell> MATCH STATEMENT </table-cell>
<table-cell> 600 </table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="filter statement"/> </table-cell>
<table-cell> FILTER STATEMENT </table-cell>
<table-cell> 601 </table-cell>
</table-row>

<comment>WG3:W23-015 Two rows removed</comment>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="let statement"/> </table-cell>
<table-cell> LET STATEMENT </table-cell>
<table-cell> 602 </table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="for statement"/> </table-cell>
<table-cell> FOR STATEMENT </table-cell>
<table-cell> 603 </table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="order by and page statement"/> </table-cell>
<table-cell> ORDER BY AND PAGE STATEMENT </table-cell>
<table-cell> 604 </table-cell>
</table-row>

<comment>WG3:W23-032</comment>
<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="return statement"/> </table-cell>
<table-cell> RETURN STATEMENT </table-cell>
<table-cell> 605 </table-cell>
</table-row>

<comment>WG3:W23-032</comment>
<comment>WG3:DCA-028</comment>
<table-row>
<comment>WG3:UTC-064</comment>
<table-cell> <BNF name="select statement"/> </table-cell>
<table-cell> SELECT STATEMENT </table-cell>
<table-cell> 606 </table-cell>
</table-row>

<comment>WG3:DCA-028 related editorial adjustments</comment>
<table-row>
<table-cell span="3">&nbsp;<linebreak/>
<emph>Common statements</emph>
</table-cell>
</table-row>

<comment>WG3:DCA-028</comment>
<table-row>
<table-cell> <BNF name="call procedure statement"/> </table-cell>
<table-cell> CALL PROCEDURE STATEMENT </table-cell>
<comment>WG3:DCA-028 related editorial adjustments</comment>
<table-cell> 800 </table-cell>
</table-row>

<comment>WG3:DCA-028 related editorial adjustments</comment>
<table-row>
<table-cell span="3">&nbsp;<linebreak/>
<emph>Other statements and commands</emph>
</table-cell>
</table-row>

<comment>WG3:DCA-028 related editorial adjustments</comment>
<comment>WG3:CMN-039</comment>
<table-row>
<table-cell> <impDef annex="no" code="None" cap="yes"/> statements and <linebreak/>
commands </table-cell>
<table-cell> An <impDef annex="no" code="None"/> character string value different
from the value associated with any other statement or command </table-cell>
<table-cell> <symdef>x</symdef><table-noteref note-char="1"/> </table-cell>
</table-row>

<comment>WG3:DCA-028 related editorial adjustments</comment>
<comment>Editorial: Stephen Cannan, 2021-05-27 Standardize terms</comment>
<comment>WG3:W14-014: Stefan Plantikow, 2021-08-10 Standardize terms</comment>
<comment>WG3:CMN-039</comment>
<table-row>
<table-cell> Unrecognized statements and commands </table-cell>
<table-cell> A zero-length character string </table-cell>
<table-cell> 0 (zero) </table-cell>
</table-row>

</table-body>

</table>

</GeneralRules>


<ConformanceRules>

<olist>

<comment>WG3:W26-033</comment>
<item>Without <feature code="GA08"/>, a GQL-status object in a conforming GQL-implementation
shall not contain a diagnostic record.
</item>

</olist>

</ConformanceRules>

</bodyMatter>

</subClause>

</clause>


<clause id="gql_conform">
<clauseHeading>Conformance</clauseHeading>

<subClause id="gql_conform_intro" newpage="false">
<clauseHeading>Introduction to conformance</clauseHeading>

<bodyMatter>

<comment>WG3:SXM-065</comment>
<comment>WG3:OHD-015</comment>
<para>Conformance may be claimed by a GQL-program or a GQL-implementation.
</para>

</bodyMatter>

</subClause>


<subClause id="gql_min_conform" newpage="false">
<clauseHeading>Minimum conformance</clauseHeading>

<bodyMatter>

<comment>WG3:SXM-065</comment>
<comment>Editorial: Stephen Cannan, 2025-03-19 Correct the definition and use of features</comment>
<para>Every claim of conformance shall include a <newterm>claim of minimum conformance</newterm>, 
which is defined as a claim to support the mandatory functionality defined in this document.
</para>

<para>A claim of minimum conformance shall also include:
</para>

<olist>

<comment>WG3:OHD-020</comment>
<item>A claim of conformance to at least one of:

<olist>

<comment>WG3:POS-023R1</comment>
<item><feature code="GC00"/>.
</item>

<comment>WG3:W26-022R2</comment>
<item><feature code="GC04"/>.
</item>

</olist>

</item>

<item>A claim of conformance to a specific version of <docref ref="Unicode"/> and the synchronous 
versions of <docref ref="Unicode10"/>, <docref ref="Unicode15"/>, and <docref ref="Unicode31"/>.
The claimed version of <docref ref="Unicode"/> shall not be less than <quote>13.0.0</quote>.
</item>

<comment>WG3:W23-037</comment>
<item>A claim of conformance to the set of all value types that are supported as the types of
property values. 
At minimum, this set shall include:

<ulist>

<comment>Editorial: Stefan Plantikow, 2022-11-25 Remove invalid use of variable-length</comment>
<item>The character string type specified by <kw>STRING</kw> or <kw>VARCHAR</kw>.
</item>

<item>The Boolean type specified by <kw>BOOLEAN</kw> or <kw>BOOL</kw>.
</item>

<item>The signed regular integer type specified by <kw>SIGNED</kw> <kw>INTEGER</kw>, 
<kw>INTEGER</kw>, or <kw>INT</kw>.
</item>

<comment>WG3:UTC-065</comment>
<item>The approximate numeric type specified by <kw>FLOAT</kw>.
</item>

</ulist>

<note>See <specref ref="gql_conc_vt_predef"/> for the definitions of these data types.
</note>

</item>

</olist>

</bodyMatter>

</subClause>


<comment>WG3:SXM-065</comment>
<comment>Editorial: Stephen Cannan, 2025-03-19 Correct the definition and use of features</comment>
<subClause id="gql_feature_conform" newpage="false">
<clauseHeading>Conformance to optional features</clauseHeading>

<bodyMatter>

<comment>WG3:SXM-065</comment>
<comment>Editorial: Stephen Cannan, 2025-03-19 Correct the definition and use of features</comment>
<para>Optional features are identified by Feature ID, see <specref ref="gql_featuredescr"/>.
</para>

<comment>WG3:SXM-065</comment>
<comment>Editorial: Stephen Cannan, 2025-03-19 Correct the definition and use of features</comment>
<para>An optional feature <symdef>FEAT</symdef> is defined by relaxing those Conformance
Requirements, whose Feature ID is <sym>FEAT</sym>.
</para>

<comment>Editorial: Stephen Cannan, 2025-03-19 Correct the definition and use of features</comment>
<para>An application designates a set of optional features that the application requires; 
the GQL language of the application shall observe the restrictions of all Conformance Requirements
except those explicitly relaxed for the required features.
</para>

<comment>Editorial: Stephen Cannan, 2025-03-19 Correct the definition and use of features</comment>
<para>Conversely, conforming GQL-implementations shall identify which optional features the
GQL-implementation supports.
A GQL-implementation shall process any application whose required features are a subset of the
GQL-implementations supported features.
</para>

<comment>WG3:SXM-065</comment>
<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<para>An optional feature <symdef>FEAT1</symdef> may imply another optional feature 
<symdef>FEAT2</symdef>.
A GQL-implementation that claims to support <sym>FEAT1</sym> shall also support each feature
<sym>FEAT2</sym> implied by <sym>FEAT1</sym>.
Conversely, an application need only designate that it requires <sym>FEAT1</sym>, and can assume
that this includes each optional feature <sym>FEAT2</sym> implied by <sym>FEAT1</sym>.
</para>

<comment>Editorial: Stephen Cannan, 2025-03-19 Correct the definition and use of features</comment>
<para>An optional feature <sym>FEAT1</sym> may imply support for at least one of a set of optional
features <symdef>FEAT2</symdef>, <symdef>FEAT3</symdef>, <etc/>
A GQL-implementation that claims to support <sym>FEAT1</sym> shall also support at least one of 
the optional features <sym>FEAT2</sym>, <sym>FEAT3</sym>, <etc/>, implied by <sym>FEAT1</sym>. 
Conversely, an application need only designate that it requires one or more of the optional 
features <sym>FEAT2</sym>, <sym>FEAT3</sym>, <etc/>, and may assume that this includes the 
optional feature <sym>FEAT1</sym> which implies them.
</para>

<comment>Editorial: Stephen Cannan, 2025-03-19 Correct the definition and use of features</comment>
<para>Sometimes the optional features in a set of <quote>at least one of</quote> implications may 
also have the reverse implication, <eg/> <sym>FEAT2</sym> implies <sym>FEAT1</sym>. 
This occurs when <sym>FEAT2</sym> cannot be specified without the support of <sym>FEAT1</sym>. 
In other cases, <sym>FEAT2</sym> may not need the support of <sym>FEAT1</sym>.
</para>

<comment>Editorial: Stephen Cannan, 2025-03-19 Correct the definition and use of features</comment>
<para>The list of optional  features that are implied by other features is shown in
<specref ref="gql_implied_features"/>.
Note that some optional features imply multiple other optional features.
</para>

<comment>WG3:SXM-065</comment>
<comment>Editorial: Stephen Cannan, 2025-03-19 Correct the definition and use of features</comment>
<para>The Syntax Rules and General Rules may define one GQL syntax in terms of another.
Such transformations are presented to define the semantics of the transformed syntax and are
effectively performed after checking the applicable Conformance Requirements, unless otherwise 
noted in a Syntax Rule that defines a transformation.
Transformations may use GQL syntax of one GQL feature to define another GQL feature.
These transformations serve to define the behavior of the syntax, and do not have any
implications for the feature syntax that is permitted or forbidden by the features so defined,
except as otherwise noted in a Syntax Rule that defines a transformation.
A conforming GQL-implementation need only process the untransformed syntax defined by the
Conformance Rules that are applicable for the set of features that the GQL-implementation claims
to support, though with the semantics implied by the transformation.
</para>

<comment>WG3:UTC-101</comment>
<comment>WG3:CMN-019 P00-ISO-036</comment>

</bodyMatter>

</subClause>


<comment>WG3:SXM-065</comment>
<subClause id="gql_pgm_requirements" newpage="false">
<clauseHeading>Requirements for GQL-programs</clauseHeading>

<subClause2 id="gql_pgm_requirements_intro">
<clauseHeading>Introduction to requirements for GQL-programs</clauseHeading>

<bodyMatter>

<para>A conforming GQL-program shall be processed without syntax error by a conforming
GQL-implementation if all of the following are satisfied:
</para>

<ulist>

<item>Every command or procedure invoked by the GQL-program is syntactically correct in
accordance with this document.
</item>

<item>The GQL-implementation claims conformance to all the optional features to which the
GQL-program claims conformance.
</item>

<item>The graph or graphs being processed are conforming and the conformance claims of these
graphs do not include any features not included in the GQL-program<apos/>s claim of conformance.
</item>

</ulist>

<para>A conforming GQL application shall not use any additional features beyond the level of
conformance claimed.
</para>

</bodyMatter>

</subClause2>


<subClause2 id="gql_pgm_conformance_claims">
<clauseHeading>Claims of conformance for GQL-programs</clauseHeading>

<bodyMatter>
<para>A claim of conformance by a GQL-program to this document shall include all of the following:
</para>

<ulist>

<item>A claim of minimum conformance.
</item>

<item>Zero or more additional claims of conformance to optional features (Optional features are
summarized in <specref ref="gql_taxonomy"/>).
</item>

<item>A list of the <impDef annex="no" code="None"/> elements and actions that are relied on 
for correct performance.
</item>

</ulist>

</bodyMatter>

</subClause2>

</subClause>


<subClause id="gql_impl_requirements" newpage="false">
<clauseHeading>Requirements for GQL-implementations</clauseHeading>

<subClause2 id="gql_impl_requirements_intro">
<clauseHeading>Introduction to requirements for GQL-implementations</clauseHeading>

<bodyMatter>

<para>A conforming GQL-implementation shall correctly translate and execute all GQL-programs
conforming to both the GQL language and the <impDef annex="no" code="None"/> features of the
GQL-implementation.
</para>

<para>A conforming GQL-implementation shall reject all GQL-programs that contain errors whose
detection is required by this document.
</para>

<para>A conforming GQL-implementation that provides optional features or that provides
facilities beyond those specified in this document shall provide a GQL Flagger.
See <specref ref="gql_conform_flagger"/>.
</para>

</bodyMatter>

</subClause2>


<subClause2 id="gql_impl_conformance_claims">
<clauseHeading>Claims of conformance for GQL-implementations</clauseHeading>

<bodyMatter>

<para>A claim of conformance by a GQL-implementation to this document shall include all of the 
following:
</para>

<olist>

<item>A claim of minimum conformance.
</item>

<item>Zero or more additional claims of conformance to optional features.
</item>

<item>The definition for every element and action, within the scope of the claim,
that this document specifies to be <impDef annex="no" code="None"/>.
</item>

</olist>

</bodyMatter>

</subClause2>


<subClause2 id="gql_extensions_options">
<clauseHeading>Extensions and options</clauseHeading>

<bodyMatter>

<para>A GQL-implementation may provide <impDef annex="no" code="None"/> features that are 
additional to those specified in this document, and may add to the list of reserved words.
</para>

<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>WG3:UTC-009 P00-USA-169</comment>
<comment>Editorial: Stephen Cannan 2023-01-29 Align with Directives Part 2</comment>
<note id="gql_note_reservewords">If additional words are reserved, then it is possible that 
a conforming statement will be processed incorrectly.
</note>

<para>A GQL-implementation may provide user options to process non-conforming statements.
A GQL-implementation may provide user options to process statements so as to produce 
a result different from that specified in this document.
</para>

<para>It shall produce such results only when explicitly required by the user option.
</para>

<para>It is <impDef code="IA012"/> whether a GQL Flagger flags <impDef annex="no" code="None"/> 
features.
</para>

<comment>Editorial: Stephen Cannan 2023-01-29 Align with Directives Part 2</comment>
<note>A GQL Flagger can flag <impDef annex="no" code="None"/> features using any Feature ID not 
defined in this document.
However, there is no guarantee that some future edition of this document will not use such 
a Feature ID for a standard-defined feature.
</note>

<comment>Editorial: Stephen Cannan 2023-01-29 Align with Directives Part 2</comment>
<note>The <impDef annex="no" code="None"/> features flagged by a GQL Flagger can include
<impDef annex="no" code="None"/> features from more than one GQL-implementation.
</note>

<comment>Editorial: Stephen Cannan 2023-01-29 Align with Directives Part 2</comment>
<note>The allocation of a Feature ID to an <impDef annex="no" code="None"/> feature possibly differ
between GQL Flaggers.
</note>

</bodyMatter>

</subClause2>

</subClause>


<subClause id="gql_conform_flagger" newpage="false">
<clauseHeading>GQL Flagger</clauseHeading>

<bodyMatter>

<para>A GQL Flagger is a facility provided by a GQL-implementation that is able to identify 
GQL language extensions, or other GQL processing alternatives, that may be provided by a conforming
GQL-implementation (see <specref ref="gql_extensions_options"/>).
</para>

<para>A GQL Flagger is intended to assist in the production of GQL language that is both portable
and interoperable among different conforming GQL-implementations operating under different levels
of this document.
</para>

<para>A GQL Flagger is intended to effect a static check of GQL language.
There is no requirement to detect extensions that cannot be determined until the
General Rules are applied.
</para>

<comment>Editorial: Stephen Cannan 2021-12-08 Standardize on GQL-implementation</comment>
<para>A GQL-implementation need only flag GQL language that is not otherwise in error as far as
that GQL-implementation is concerned.
</para>

<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<comment>Editorial: Stephen Cannan 2023-01-29 Align with Directives Part 2</comment>
<note id="gql_note_gqlerrors">If a system is processing GQL language that contains errors, then
it can be very difficult within a single statement to determine what is an error and what is 
an extension.
As one possibility, a GQL-implementation is able to check GQL language in two steps;
first through its normal syntax analyzer and secondly through the GQL Flagger.
The first step produces error messages for non-standard GQL language that the GQL-implementation
cannot process or recognize.
The second step processes GQL language that contains no errors as far as that GQL-implementation
is concerned; it detects and flags at one time all non-standard GQL language that could be
processed by that GQL-implementation.
Preferably, any such two-step process will be transparent to the end user.
</note>

<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<para>The GQL Flagger assists identification of conforming GQL language that may perform
differently in alternative processing environments provided by a conforming GQL-implementation.
It also provides a tool in identifying GQL elements that possibly have to be modified if 
GQL language is moved from a non-conforming to a conforming GQL processing environment.
</para>

</bodyMatter>

</subClause>


<comment>WG3:SXM-065</comment>
<subClause id="gql_implied_featurerelations" newpage="false">
<clauseHeading>Implied feature relationships</clauseHeading>

<comment>WG3:POS-010</comment>
<impliedFeatureSummary id="gql_implied_features"/>

</subClause>
<comment>WG3:UTC-048R1 Deleted 1 (one) Subclause</comment>

</clause>

</standardPartBody>


<backMatter>

<annex id="gql_conform_summary" normative="informative">
<clauseHeading>GQL conformance summary</clauseHeading>

<bodyMatter>

<comment>WG3:SXM-065</comment>
<para>The contents of this Annex summarizes all the Conformance Rules.
</para>

<comment>WG3:SXM-065</comment>
<para>Most optional Features of this document are specified by Conformance Rules in Subclauses,
however some are specified by implicit Conformance Rules in other text.
These are summarized first.
</para>

<ednote>The following list needs to be regularly checked.
Either the new fully automated generation mechanism must be implemented or this list must be 
completed/corrected before the document goes out to ballot.
All features for this section identified as of 2023-11-14.
</ednote>

<olist>
<comment>WG3:W22-034R1 deleted two features</comment>
<comment>WG3:CMN-026 deleted one item</comment>
<comment>A consequence of WG3:W22-034R1 deleted six items</comment>
<comment>A consequence of WG3:W24-027 deleted two items</comment>

<comment>WG3:UTC-063</comment>
<item>Specifications for <feature code="GA01"></feature>.

<olist>

<item><specref ref="gql_conc_numeric_approximate"/>.

<olist>

<comment>WG3:CMN-019 P00-ISO-003</comment>
<item>If a GQL-implementation supports the <feature code="GA01"/>, 
<BNF name="numeric value expression"/>s on approximate numeric types that would otherwise result 
in exceptions may return additional values as defined by <docref ref="IEEE754"/>.
Any additional value returned shall be one defined by <docref ref="IEEE754"/>.
</item>

</olist>

</item>

<item><specref ref="gql_numexp"/>.

<olist>

<comment>WG3:CMN-019 P00-ISO-003</comment>
<item>If a GQL-implementation supports the <feature code="GA01"/>, then the result of a division by 
zero may return additional values instead of causing an exception condition to be raised.
Any additional value returned shall be one defined by <docref ref="IEEE754"/>.
</item>

<comment>WG3:CMN-019 P00-ISO-003</comment>
<item>If a GQL-implementation supports the <feature code="GA01"/>, then a mathematical result of 
an operation that is not within the exponent range for the declared type of the result may return 
additional values instead of causing an exception condition to be raised.
Any additional value returned shall be one defined by <docref ref="IEEE754"/>.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:UTC-047</comment>
<item>Specifications for <feature code="GP18"></feature>.

<olist>

<item><specref ref="gql_procspec"/>.

<olist>

<item>Without <feature code="GP18"/>, a GQL-transaction shall not contain both 
a <BNF name="data-modifying procedure specification"/> and 
a <BNF name="catalog-modifying procedure specification"/>.
</item>

</olist>

</item>

</olist>

</item>


<comment>Editorial: Stefan Plantikow, 2023-11-15 </comment>
<item>Specifications for <feature code="GG22"/>.

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-15 </comment>
<item>Without <feature code="GG22"/>, <specref ref="gql_node_type_defn"/> defines
the effective key label set of a node type to be the same as the label set of that node type.
</item>

<comment>Editorial: Stefan Plantikow, 2023-11-15 </comment>
<item>Without <feature code="GG22"/>, <specref ref="gql_edge_type_defn"/> defines
the effective key label set of an edge type to be the same as the label set of that edge type.
</item>

</olist>

</item>

<comment>Editorial: Stephen Cannan, 2023-11-14</comment>
<item>Specifications for <feature code="GG26"/>.

<olist>

<item><specref ref="gql_gts_combo_vts"/>.

<olist>

<comment>Editorial: Stefan Plantikow, 2023-11-14 Adjust Annex A text</comment>
<item>If <feature code="GG26"/> is supported, then property types with the same name are not
required to have the same value type.
Instead, their value types are required to be supported property value types that combine
with all value types of property types of the same name of implying element types to themselves
under general combination of value types.
</item>

</olist>

</item>

</olist>

</item>

<comment>Editorial: Stephen Cannan, 2023-11-14</comment>
<item>Specifications for <feature code="GV65"/>.

<olist>

<item><specref ref="gql_gen_combo_vts"/>.

<olist>

<item>Without <feature code="GV65"/>, only static combinations of value types are permitted.
</item>

</olist>

</item>

</olist>

</item>
<comment>Editorial: Stephen Cannan, 2023-11-14</comment>

<comment>Editorial: Stephen Cannan, 2023-11-14</comment>
<item>Specifications for <feature code="GV67"></feature>.

<olist>

<item><specref ref="gql_gen_combo_vts"/>.

<olist>

<item>Without <feature code="GV67"/>, combinations of value types that cannot be statically 
combined are open dynamic union types.
</item>

<item>See also the specification of <feature code="GV67"/> later in this Annex.
</item>

</olist>

</item>

</olist>

</item>

<comment>Editorial: Stephen Cannan, 2023-11-14</comment>
<item>Specifications for <feature code="GV70"></feature>.

<olist>

<item><specref ref="gql_immat_null_empty_dts"/>.

<olist>

<item>Without <feature code="GV70"/>, conforming GQL language shall not contain either 
a <BNF name="null type"/> or an <BNF name="empty type"/>.
</item>

</olist>

</item>

</olist>

</item>

<comment>Editorial: Stephen Cannan, 2023-11-14</comment>
<item>Specifications for <feature code="GV72"></feature>.

<olist>

<item><specref ref="gql_listvalconst"/>.

<olist>

<item>If the GQL-implementation supports <feature code="GV72"/>, then the declared type of 
<sym>LVCE</sym> is the list value type whose list element type is the empty type.
</item>

<item>See also the specification of <feature code="GV72"/> later in this Annex.
</item>

</olist>

</item>

</olist>

</item>

<comment>WG3:UTC-047</comment>
<item>Specifications for <feature code="GT03"/>.

<olist>

<item><specref ref="gql_procspec"/>.

<olist>

<item>Without <feature code="GT03"/>, a GQL-transaction shall not contain two 
<BNF name="use graph clause"/>s that have different <BNF name="graph expression"/>s.
</item>

</olist>

</item>

</olist>

</item>

</olist>

<comment>WG3:SXM-065</comment>
<comment>Editorial: Stephen Cannan, 2025-03-27 Use consistent terminology</comment>
<para>The remainder of this Annex recapitulates the Conformance Rules specified in Subclauses
throughout this document, organized by optional feature name and Subclause.
</para>

</bodyMatter>


<conformanceSummary/>


</annex>


<annex id="gql_impdef" normative="informative">
<clauseHeading><impDef annex="no" code="None" cap="yes"/> elements</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow 2023-03-23 Link digital artifacts</comment>
<para>This Annex references those features that are identified in the body of this document as
<impDef annex="no" code="None"/>.
<digitalArtifact type="ImpDef"/>
</para>

<comment>Editorial: Stephen Cannan 2021-12-08 Standardize on GQL-implementation</comment>
<comment>WG3:CMN-019 P00-USA-007</comment>
<para>The term <impDef annex="no" code="None"/> is used to identify characteristics that may 
differ between GQL-implementations, but that shall be defined for each particular 
GQL-implementation.
</para>

</bodyMatter>

<impDefSummary/>

</annex>


<annex id="gql_undef" normative="informative">
<clauseHeading><unDef annex="no" code="None" cap="yes"/> elements</clauseHeading>

<bodyMatter>

<comment>Editorial: Stefan Plantikow 2023-03-23 Link digital artifacts</comment>
<para>This Annex references those places where this document states explicitly that the actions of
a conforming GQL-implementation are <unDef annex="no" code="None"/>.
<digitalArtifact type="UnDef"/>
</para>

<comment>Editorial: Stephen Cannan 2021-12-08 Standardize on GQL-implementation</comment>
<comment>WG3:CMN-019 P00-USA-007</comment>
<para>The term <unDef annex="no" code="None"/> is used to identify characteristics that may 
differ between GQL-implementations, but that are not necessarily specified for any particular 
GQL-implementation.
</para>

</bodyMatter>

<unDefSummary/>

</annex>


<annex id="gql_taxonomy" normative="informative">
<clauseHeading>GQL optional feature taxonomy</clauseHeading>

<bodyMatter>

<comment>WG3:CMN-049</comment>
<para>This Annex describes a taxonomy of optional features defined in this document.
</para>

<comment>Editorial: Stefan Plantikow 2023-03-23 Link digital artifacts</comment>
<para><specref ref="gql_taxonomy_table"/>, contains a taxonomy of the optional features of the
GQL language.
<digitalArtifact type="Features"/>
</para>

<comment>Editorial: Stephen Cannan, 2021-07-06 Align with Directives Part 2:2021</comment>
<para>In this table, the first column contains a counter that can be used to quickly locate rows
of the table; these values otherwise have no use and are not stable &mdash; that is, they are
subject to change in future editions of or even Technical Corrigenda to this document without
notice.
</para>

<para>The <quote>Feature ID</quote> column of this table specifies the formal identification of
each optional feature contained in the table.
</para>

<comment>Editorial: Stephen Cannan, 2025-03-27 Use consistent terminology</comment>
<para>The <quote>Feature Name</quote> column of this table contains a brief description of the
optional feature associated with the Feature ID value.
</para>

<para><specref ref="gql_taxonomy_table"/>, does not provide definitions of the features; the
definition of those features is found in the Conformance Rules that are further summarized in
<specref ref="gql_conform_summary"/>.
</para>

<comment>Editorial: to use the featuresTable mark-up</comment>
<featuresTable id="gql_taxonomy_table">
<tableTitle>Feature taxonomy for optional features</tableTitle>
</featuresTable>

</bodyMatter>

</annex>


<comment>Editorial: Stephen Cannan, 2025-04-07 Prepare for second edition</comment>
<annex id="gql_deprcat" normative="informative">
<bar note="Editorial: Stephen Cannan, 2025-04-07 Prepare for second edition"/>
<clauseHeading>Deprecated features</clauseHeading>

<bodyMatter>

<para>It is intended that the following features will be removed at a later
date from a revised version of this document:
</para>

<olist>

<None/>

</olist>
<endbar/>

</bodyMatter>

</annex>


<comment>Editorial: Stephen Cannan, 2025-04-07 Prepare for second edition</comment>
<annex id="gql_incompat" normative="informative">
<bar note="Editorial: Stephen Cannan, 2025-04-07 Prepare for second edition"/>
<clauseHeading>Incompatibilities with ISO/IEC 39075:2024</clauseHeading>

<bodyMatter>

<comment>WG3:POS-011R1</comment>
<comment>Editorial: Stephen Cannan, 2025-04-07 Prepare for second edition</comment>
<para>This document introduces some incompatibilities with the earlier version of Database Language
GQL as specified in ISO/IEC 39075:2024.
</para>

<comment>WG3:POS-011R1</comment>
<comment>Editorial: Stephen Cannan, 2025-04-07 Prepare for second edition</comment>
<para>Except as specified in this Annex, features and capabilities of Database Language GQL are
compatible with ISO/IEC 39075:2024.
</para>
<endbar/>

<olist>

<comment>WG3:POS-011R1</comment>
<item>A number of additional <BNF name="reserved word"/>s have been added to the language.
These <BNF name="reserved word"/>s are:

<ulist>

<comment>WG3:POS-011R1</comment>
<item><kw>VECTOR</kw>
</item>

<comment>WG3:POS-011R1</comment>
<item><kw>VECTOR_DIMENSION_COUNT</kw>
</item>

<comment>WG3:POS-011R1</comment>
<item><kw>VECTOR_DISTANCE</kw>
</item>

<comment>WG3:POS-011R1</comment>
<item><kw>VECTOR_NORM</kw>
</item>

<comment>WG3:POS-011R1</comment>
<item><kw>VECTOR_SERIALIZE</kw>
</item>

</ulist>

</item>

</olist>

</bodyMatter>

</annex>


<!-- To be uncommented when unresolved defects still exist at the time of publication of a ballot
document.
<annex normative="informative" id="gql_defects">
<clauseHeading>Defect Reports not addressed in this edition of this document</clauseHeading>

<bodyMatter>

<para>Each entry in this Annex describes a reported defect in the previous edition of this
document that remains in this edition.
</para>

<olist>

<None/>

</olist>

</bodyMatter>

</annex>
-->


<comment>Editorially moved Annex in order to align order of Annexes with SQL</comment>
<annex id="gql_maint" normative="informative">
<clauseHeading>Maintenance and interpretation of GQL</clauseHeading>

<bodyMatter>

<comment>Editorial: Stephen Cannan, 2021-08-06</comment>
<para>ISO/IEC JTC 1 provides formal procedures for revision, maintenance, and
interpretation of JTC 1 Standards, including creation and processing of
<quote>Defect Reports</quote>.
Defect reports may result in technical corrigenda, amendments, interpretations,
or other commentary on an existing International Standard.
</para>

<comment>Editorial: Stephen Cannan, 2021-08-06</comment>
<para>A defect report may be submitted by a national standards body that is a P-member or O-member,
a Liaison Organization, a member of the defect editing group for the subject document,
or a working group of the committee responsible for the document. 
A defect identified by the user of the standard, or someone external to the committee,
shall be processed via one of the official channels listed above.
The submitter shall complete part 2 of the defect report form
(see the Defect Report form in the Templates folder at the JTC 1 web site,
as well as its attachment 1)
and shall send the form to the Convenor or WG Secretariat with which
the relevant defect editing group is associated.
</para>

<comment>Editorial: Stephen Cannan, 2021-08-06</comment>
<comment>Editorial: Stefan Plantikow, 2023-11-08 GQL not SeeQL</comment>
<ednote>Every time we republish GQL, we must consult the ISO Directives and/or
JTC 1 Standing Document 21 to see whether the instructions have changed. 
</ednote>

<para>Potential new questions or new defect reports addressing the specifications of this document
should be communicated to:
</para>

<slist>

<item>Secretariat, ISO/IEC JTC1/SC32
</item>
<item>American National Standards Institute
</item>
<item>11 West 42nd Street
</item>
<item>New York, NT 10036
</item>
<item>USA
</item>

</slist>

</bodyMatter>

</annex>
<comment>WG3:OHD-033 One annex deleted</comment>
<comment>WG3:OHD-033 One annex deleted</comment>


<comment>WG3:POS-023R1</comment>
<comment>Editorial: Stephen Cannan, 2025-03-19 Correct the definition and use of features</comment>
<annex id="gql_mand" normative="informative">
<clauseHeading>Mandatory functionality</clauseHeading>

<bodyMatter>

<para>This Annex identifies the mandatory syntax defined in this document.
</para>

<para>Some of the syntax elements, whilst in themselves mandatory, contain aspects which are 
optional but which are not expressed via the syntax tree.
The optional features that impose additional restrictions on otherwise mandatory syntax are noted
at the appropriate point in the syntax tree.
</para>

<grammar discussion="yes">

<bar note="WG3:XRH-035"/>
<comment>WG3:XRH-035</comment>
   <BNFdef name="GQL-program">
      <rhs>
        <BNF name="program activity"/>
      </rhs>
   </BNFdef>
<endbar/>   
   <BNFdef name="program activity">
      <rhs>
         <alt>
            <BNF name="transaction activity"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="transaction activity">
      <rhs>
        <BNF name="procedure specification"/>
      </rhs>
   </BNFdef>
<delbar note="WG3:XRH-035 deleted one production"/>
   <BNFdef name="procedure specification">
      <rhs>
         <alt>
            <BNF name="query specification"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="nested query specification">
      <rhs>
         <BNF name="left brace"/>
         <BNF name="query specification"/>
         <BNF name="right brace"/>
      </rhs>
   </BNFdef>
   <BNFdef name="query specification">
      <rhs>
         <BNF name="procedure body"/>
      </rhs>
   </BNFdef>
   <BNFdef name="procedure body">
      <rhs>
         <BNF name="statement block"/>
      </rhs>
   </BNFdef>
   <BNFdef name="statement block">
      <rhs>
         <BNF name="statement"/>
      </rhs>
   </BNFdef>
   <BNFdef name="statement">
      <rhs>
         <alt>
            <BNF name="composite query statement"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="composite query statement">
      <rhs>
         <BNF name="composite query expression"/>
      </rhs>
   </BNFdef>
   <BNFdef name="composite query expression">
      <rhs>
         <alt>
            <BNF name="composite query primary"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="composite query primary">
      <rhs>
         <BNF name="linear query statement"/>
      </rhs>
   </BNFdef>
   <BNFdef name="linear query statement">
      <rhs>
         <alt>
            <BNF name="ambient linear query statement"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="ambient linear query statement">
      <rhs>
         <alt>
            <opt>
               <BNF name="simple linear query statement"/>
            </opt>
            <BNF name="primitive result statement"/>
         </alt>
         <alt>
            <BNF name="nested query specification"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="simple linear query statement">
      <rhs>
         <BNF name="simple query statement"/>
         <repeat/>
      </rhs>
   </BNFdef>
   <BNFdef name="simple query statement">
      <rhs>
         <alt>
            <BNF name="primitive query statement"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="primitive query statement">
      <rhs>
         <alt>
            <BNF name="match statement"/>
         </alt>
         <alt>
            <BNF name="order by and page statement"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="match statement">
      <rhs>
         <alt>
            <BNF name="simple match statement"/>
         </alt>
         <alt>
            <BNF name="optional match statement"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="simple match statement">
      <rhs>
         <kw>MATCH</kw>
         <BNF name="graph pattern binding table"/>
      </rhs>
   </BNFdef>
   <BNFdef name="optional match statement">
      <rhs>
         <kw>OPTIONAL</kw>
         <BNF name="optional operand"/>
      </rhs>
   </BNFdef>
   <BNFdef name="optional operand">
      <rhs>
         <alt>
            <BNF name="simple match statement"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="order by and page statement">
      <rhs>
         <alt>
            <BNF name="order by clause"/>
         </alt>
      </rhs>
   </BNFdef>
<bar note="WG3:XRH-035"/>
<comment>WG3:XRH-035</comment>
   <BNFdef name="primitive result statement">
      <rhs>
        <BNF name="return statement"/>
          <opt>
            <BNF name="order by and page statement"/>
          </opt>
      </rhs>
   </BNFdef>
<endbar/>
   <BNFdef name="return statement">
      <rhs>
         <kw>RETURN</kw>
         <BNF name="return statement body"/>
      </rhs>
   </BNFdef>
   <BNFdef name="return statement body">
      <rhs>
         <alt>
            <opt>
               <BNF name="set quantifier"/>
            </opt>
            <group>
               <alt>
                  <BNF name="asterisk"/>
               </alt>
               <alt>
                  <BNF name="return item list"/>
               </alt>
            </group>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="return item list">
      <rhs>
         <BNF name="return item"/>
         <opt>
            <group>
               <BNF name="comma"/>
               <BNF name="return item"/>
            </group>
            <repeat/>
         </opt>
      </rhs>
   </BNFdef>
   <BNFdef name="return item">
      <rhs>
         <BNF name="aggregating value expression"/>
         <opt>
            <BNF name="return item alias"/>
         </opt>
      </rhs>
   </BNFdef>
   <BNFdef name="return item alias">
      <rhs>
         <kw>AS</kw>
         <BNF name="identifier"/>
      </rhs>
   </BNFdef>
   <BNFdef name="graph pattern binding table">
      <rhs>
         <BNF name="graph pattern"/>
      </rhs>
   </BNFdef>
   <BNFdef name="graph pattern">
      <rhs>
         <BNF name="path pattern list"/>
         <opt>
            <BNF name="graph pattern where clause"/>
         </opt>
      </rhs>
   </BNFdef>
   <BNFdef name="path pattern list">
      <rhs>
         <BNF name="path pattern"/>
         <opt>
            <group>
               <BNF name="comma"/>
               <BNF name="path pattern"/>
            </group>
            <repeat/>
         </opt>
      </rhs>
   </BNFdef>
   <BNFdef name="path pattern">
      <rhs>
         <BNF name="path pattern expression"/>
      </rhs>
   </BNFdef>
   <BNFdef name="graph pattern where clause">
      <rhs>
         <kw>WHERE</kw>
         <BNF name="search condition"/>
      </rhs>
   </BNFdef>
   <BNFdef name="path pattern expression">
      <rhs>
         <alt>
            <BNF name="path term"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="path term">
      <rhs>
         <alt>
            <BNF name="path factor"/>
         </alt>
         <alt>
            <BNF name="path concatenation"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="path concatenation">
      <rhs>
         <BNF name="path term"/>
         <BNF name="path factor"/>
      </rhs>
   </BNFdef>
   <BNFdef name="path factor">
      <rhs>
         <alt>
            <BNF name="path primary"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="path primary">
      <rhs>
         <alt>
            <BNF name="element pattern"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="element pattern">
      <rhs>
         <alt>
            <BNF name="node pattern"/>
         </alt>
         <alt>
            <BNF name="edge pattern"/>
         </alt>
      </rhs>
   </BNFdef>
<note><feature code="G046"/> and <feature code="G047"/> provide additional constraints on the 
mandatory aspects of <BNF name="element pattern"/>.
</note>
   <BNFdef name="node pattern">
      <rhs>
         <BNF name="left paren"/>
         <BNF name="element pattern filler"/>
         <BNF name="right paren"/>
      </rhs>
   </BNFdef>
   <BNFdef name="element pattern filler">
      <rhs>
         <opt>
            <BNF name="element variable declaration"/>
         </opt>
         <opt>
            <BNF name="is label expression"/>
         </opt>
         <opt>
            <BNF name="element pattern predicate"/>
         </opt>
      </rhs>
   </BNFdef>
   <BNFdef name="element variable declaration">
      <rhs>
         <BNF name="element variable"/>
      </rhs>
   </BNFdef>
   <BNFdef name="is label expression">
      <rhs>
         <BNF name="is or colon"/>
         <BNF name="label expression"/>
      </rhs>
   </BNFdef>
   <BNFdef name="is or colon">
      <rhs>
         <alt>
            <kw>IS</kw>
         </alt>
         <alt>
            <BNF name="colon"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="element pattern predicate">
      <rhs>
         <alt>
            <BNF name="element pattern where clause"/>
         </alt>
         <alt>
            <BNF name="element property specification"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="element pattern where clause">
      <rhs>
         <kw>WHERE</kw>
         <BNF name="search condition"/>
      </rhs>
   </BNFdef>
<note><feature code="G041"/> provides additional constraints on the mandatory aspects of 
<BNF name="element pattern where clause"/>.
</note>
   <BNFdef name="element property specification">
      <rhs>
         <BNF name="left brace"/>
         <BNF name="property key value pair list"/>
         <BNF name="right brace"/>
      </rhs>
   </BNFdef>
   <BNFdef name="property key value pair list">
      <rhs>
         <BNF name="property key value pair"/>
         <opt>
            <group>
               <BNF name="comma"/>
               <BNF name="property key value pair"/>
            </group>
            <repeat/>
         </opt>
      </rhs>
   </BNFdef>
   <BNFdef name="property key value pair">
      <rhs>
         <BNF name="property name"/>
         <BNF name="colon"/>
         <BNF name="value expression"/>
      </rhs>
   </BNFdef>
   <BNFdef name="edge pattern">
      <rhs>
         <alt>
            <BNF name="full edge pattern"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="full edge pattern">
      <rhs>
         <alt>
            <BNF name="full edge pointing left"/>
         </alt>
         <alt>
            <BNF name="full edge pointing right"/>
         </alt>
         <alt>
            <BNF name="full edge any direction"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="full edge pointing left">
      <rhs>
         <BNF name="left arrow bracket"/>
         <BNF name="element pattern filler"/>
         <BNF name="right bracket minus"/>
      </rhs>
   </BNFdef>
   <BNFdef name="full edge pointing right">
      <rhs>
         <BNF name="minus left bracket"/>
         <BNF name="element pattern filler"/>
         <BNF name="bracket right arrow"/>
      </rhs>
   </BNFdef>
   <BNFdef name="full edge any direction">
      <rhs>
         <BNF name="minus left bracket"/>
         <BNF name="element pattern filler"/>
         <BNF name="right bracket minus"/>
      </rhs>
   </BNFdef>
   <BNFdef name="label expression">
      <rhs>
         <alt>
            <BNF name="label term"/>
         </alt>
         <alt>
            <BNF name="label disjunction"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="label disjunction">
      <rhs>
         <BNF name="label expression"/>
         <BNF name="vertical bar"/>
         <BNF name="label term"/>
      </rhs>
   </BNFdef>
   <BNFdef name="label term">
      <rhs>
         <alt>
            <BNF name="label factor"/>
         </alt>
         <alt>
            <BNF name="label conjunction"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="label conjunction">
      <rhs>
         <BNF name="label term"/>
         <BNF name="ampersand"/>
         <BNF name="label factor"/>
      </rhs>
   </BNFdef>
   <BNFdef name="label factor">
      <rhs>
         <alt>
            <BNF name="label primary"/>
         </alt>
         <alt>
            <BNF name="label negation"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="label negation">
      <rhs>
         <BNF name="exclamation mark"/>
         <BNF name="label primary"/>
      </rhs>
   </BNFdef>
   <BNFdef name="label primary">
      <rhs>
         <alt>
            <BNF name="label name"/>
         </alt>
         <alt>
            <BNF name="parenthesized label expression"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="parenthesized label expression">
      <rhs>
         <BNF name="left paren"/>
         <BNF name="label expression"/>
         <BNF name="right paren"/>
      </rhs>
   </BNFdef>
   <BNFdef name="element variable reference">
      <rhs>
         <BNF name="binding variable reference"/>
      </rhs>
   </BNFdef>
   <BNFdef name="order by clause">
      <rhs>
         <kw>ORDER</kw>
         <kw>BY</kw>
         <BNF name="sort specification list"/>
      </rhs>
   </BNFdef>
<note><feature code="GA07"/> provides additional constraints on the mandatory aspects of 
<BNF name="sort specification list"/>.
</note>
   <BNFdef name="sort specification list">
      <rhs>
         <BNF name="sort specification"/>
         <opt>
            <group>
               <BNF name="comma"/>
               <BNF name="sort specification"/>
            </group>
            <repeat/>
         </opt>
      </rhs>
   </BNFdef>
   <BNFdef name="sort specification">
      <rhs>
         <BNF name="sort key"/>
         <opt>
            <BNF name="ordering specification"/>
         </opt>
      </rhs>
   </BNFdef>
   <BNFdef name="sort key">
      <rhs>
         <BNF name="aggregating value expression"/>
      </rhs>
   </BNFdef>
<note><feature code="GA03"/>, <feature code="GQ14"/>, <feature code="GQ16"/>, and
<feature code="GQ20"/> provide additional constraints on the mandatory aspects of 
<BNF name="aggregating value expression"/>.
</note>
   <BNFdef name="ordering specification">
      <rhs>
         <alt>
            <kw>ASC</kw>
         </alt>
         <alt>
            <kw>ASCENDING</kw>
         </alt>
         <alt>
            <kw>DESC</kw>
         </alt>
         <alt>
            <kw>DESCENDING</kw>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="value type">
      <rhs>
         <alt>
            <BNF name="predefined type"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="typed">
      <rhs>
         <alt>
            <BNF name="double colon"/>
         </alt>
         <alt>
            <kw>TYPED</kw>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="predefined type">
      <rhs>
         <alt>
            <BNF name="boolean type"/>
         </alt>
         <alt>
            <BNF name="character string type"/>
         </alt>
         <alt>
            <BNF name="numeric type"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="boolean type">
      <rhs>
            <alt>
               <kw>BOOL</kw>
            </alt>
            <alt>
               <kw>BOOLEAN</kw>
            </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="character string type">
      <rhs>
         <alt>
            <kw>STRING</kw>
         </alt>
         <alt>
            <kw>CHAR</kw>
         </alt>
         <alt>
            <kw>VARCHAR</kw>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="numeric type">
      <rhs>
         <alt>
            <BNF name="exact numeric type"/>
         </alt>
         <alt>
            <BNF name="approximate numeric type"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="exact numeric type">
      <rhs>
         <alt>
            <BNF name="binary exact numeric type"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="binary exact numeric type">
      <rhs>
         <alt>
            <BNF name="signed binary exact numeric type"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="signed binary exact numeric type">
      <rhs>
         <alt>
            <kw>INT</kw>
         </alt>
         <alt> 
           <opt> <kw>SIGNED</kw> </opt> <BNF name="verbose binary exact numeric type"/> 
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="verbose binary exact numeric type">
     <rhs>
       <kw>INTEGER</kw>
     </rhs>
   </BNFdef>
   <BNFdef name="approximate numeric type">
      <rhs>
         <alt>
            <kw>FLOAT</kw>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="search condition">
      <rhs>
         <BNF name="boolean value expression"/>
      </rhs>
   </BNFdef>
   <BNFdef name="predicate">
      <rhs>
         <alt>
            <BNF name="comparison predicate"/>
         </alt>
         <alt>
            <BNF name="exists predicate"/>
         </alt>
         <alt>
            <BNF name="null predicate"/>
         </alt>
         <alt>
            <BNF name="normalized predicate"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="comparison predicate">
      <rhs>
         <BNF name="comparison predicand"/>
         <BNF name="comparison predicate part 2"/>
      </rhs>
   </BNFdef>
   <BNFdef name="comparison predicate part 2">
      <rhs>
         <BNF name="comp op"/>
         <BNF name="comparison predicand"/>
      </rhs>
   </BNFdef>
   <BNFdef name="comp op">
      <rhs>
         <alt>
            <BNF name="equals operator"/>
         </alt>
         <alt>
            <BNF name="not equals operator"/>
         </alt>
         <alt>
            <BNF name="less than operator"/>
         </alt>
         <alt>
            <BNF name="greater than operator"/>
         </alt>
         <alt>
            <BNF name="less than or equals operator"/>
         </alt>
         <alt>
            <BNF name="greater than or equals operator"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="comparison predicand">
      <rhs>
         <alt>
            <BNF name="common value expression"/>
         </alt>
         <alt>
            <BNF name="boolean predicand"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="exists predicate">
      <rhs>
         <kw>EXISTS</kw>
         <group>
            <alt>
               <BNF name="left brace"/>
               <BNF name="graph pattern"/>
               <BNF name="right brace"/>
            </alt>
            <alt>
               <BNF name="left paren"/>
               <BNF name="graph pattern"/>
               <BNF name="right paren"/>
            </alt>
            <alt>
               <BNF name="nested query specification"/>
            </alt>
         </group>
      </rhs>
   </BNFdef>
<note><feature code="GQ22"/> provides additional constraints on the mandatory aspects of 
<BNF name="exists predicate"/>.
</note>
   <BNFdef name="null predicate">
      <rhs>
         <BNF name="value expression primary"/>
         <BNF name="null predicate part 2"/>
      </rhs>
   </BNFdef>
   <BNFdef name="null predicate part 2">
      <rhs>
         <kw>IS</kw>
         <opt>
            <kw>NOT</kw>
         </opt>
         <kw>NULL</kw>
      </rhs>
   </BNFdef>
   <BNFdef name="normalized predicate">
      <rhs>
         <BNF name="string value expression"/>
         <BNF name="normalized predicate part 2"/>
      </rhs>
   </BNFdef>
   <BNFdef name="normalized predicate part 2">
      <rhs>
         <kw>IS</kw>
         <opt>
            <kw>NOT</kw>
         </opt>
         <opt>
            <BNF name="normal form"/>
         </opt>
         <kw>NORMALIZED</kw>
      </rhs>
   </BNFdef>
   <BNFdef name="value expression">
      <rhs>
         <alt>
            <BNF name="common value expression"/>
         </alt>
         <alt>
            <BNF name="boolean value expression"/>
         </alt>
      </rhs>
   </BNFdef>
<note><feature code="GE09"/> provides additional constraints on the mandatory aspects of 
<BNF name="value expression"/>.
</note>
   <BNFdef name="common value expression">
      <rhs>
         <alt>
            <BNF name="numeric value expression"/>
         </alt>
         <alt>
            <BNF name="string value expression"/>
         </alt>
         <alt>
            <BNF name="reference value expression"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="reference value expression">
      <rhs>
         <alt>
            <BNF name="node reference value expression"/>
         </alt>
         <alt>
            <BNF name="edge reference value expression"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="node reference value expression">
      <rhs>
         <BNF name="value expression primary"/>
      </rhs>
   </BNFdef>
   <BNFdef name="edge reference value expression">
      <rhs>
         <BNF name="value expression primary"/>
      </rhs>
   </BNFdef>
   <BNFdef name="aggregating value expression">
      <rhs>
         <BNF name="value expression"/>
      </rhs>
   </BNFdef>
   <BNFdef name="value expression primary">
      <rhs>
         <alt>
            <BNF name="parenthesized value expression"/>
         </alt>
         <alt>
            <BNF name="non-parenthesized value expression primary"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="parenthesized value expression">
      <rhs>
         <BNF name="left paren"/>
         <BNF name="value expression"/>
         <BNF name="right paren"/>
      </rhs>
   </BNFdef>
   <BNFdef name="non-parenthesized value expression primary">
      <rhs>
         <alt>
            <BNF name="non-parenthesized value expression primary special case"/>
         </alt>
         <alt>
            <BNF name="binding variable reference"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="non-parenthesized value expression primary special case"
          >
      <rhs>
         <alt>
            <BNF name="aggregate function"/>
         </alt>
         <alt>
            <BNF name="unsigned value specification"/>
         </alt>
         <alt>
            <BNF name="property reference"/>
         </alt>
         <alt>
            <BNF name="case expression"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="unsigned value specification">
      <rhs>
         <alt>
            <BNF name="unsigned literal"/>
         </alt>
         <alt>
            <BNF name="general value specification"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="general value specification">
      <rhs>
         <alt>
            <BNF name="dynamic parameter specification"/>
         </alt>
         <alt>
            <kw>SESSION_USER</kw>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="dynamic parameter specification">
      <rhs>
         <BNF name="general parameter reference"/>
      </rhs>
   </BNFdef>
<note><feature code="GE04"/> and <feature code="GE05"/> provide additional constraints on the 
mandatory aspects of <BNF name="dynamic parameter specification"/>.
</note>
   <BNFdef name="case expression">
      <rhs>
         <alt>
            <BNF name="case abbreviation"/>
         </alt>
         <alt>
            <BNF name="case specification"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="case abbreviation">
      <rhs>
         <alt>
            <kw>NULLIF</kw>
            <BNF name="left paren"/>
            <BNF name="value expression"/>
            <BNF name="comma"/>
            <BNF name="value expression"/>
            <BNF name="right paren"/>
         </alt>
         <alt>
            <kw>COALESCE</kw>
            <BNF name="left paren"/>
            <BNF name="value expression"/>
            <group>
               <BNF name="comma"/>
               <BNF name="value expression"/>
            </group>
            <repeat/>
            <BNF name="right paren"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="case specification">
      <rhs>
         <alt>
            <BNF name="simple case"/>
         </alt>
         <alt>
            <BNF name="searched case"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="simple case">
      <rhs>
         <kw>CASE</kw>
         <BNF name="case operand"/>
         <BNF name="simple when clause"/>
         <repeat/>
         <opt>
            <BNF name="else clause"/>
         </opt>
         <kw>END</kw>
      </rhs>
   </BNFdef>
   <BNFdef name="searched case">
      <rhs>
         <kw>CASE</kw>
         <BNF name="searched when clause"/>
         <repeat/>
         <opt>
            <BNF name="else clause"/>
         </opt>
         <kw>END</kw>
      </rhs>
   </BNFdef>
   <BNFdef name="simple when clause">
      <rhs>
         <kw>WHEN</kw>
         <BNF name="when operand list"/>
         <kw>THEN</kw>
         <BNF name="result"/>
      </rhs>
   </BNFdef>
   <BNFdef name="searched when clause">
      <rhs>
         <kw>WHEN</kw>
         <BNF name="search condition"/>
         <kw>THEN</kw>
         <BNF name="result"/>
      </rhs>
   </BNFdef>
   <BNFdef name="else clause">
      <rhs>
         <kw>ELSE</kw>
         <BNF name="result"/>
      </rhs>
   </BNFdef>
   <BNFdef name="case operand">
      <rhs>
         <alt>
            <BNF name="non-parenthesized value expression primary"/>
         </alt>
         <alt>
            <BNF name="element variable reference"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="when operand list">
      <rhs>
         <BNF name="when operand"/>
         <opt>
            <group>
               <BNF name="comma"/>
               <BNF name="when operand"/>
            </group>
            <repeat/>
         </opt>
      </rhs>
   </BNFdef>
   <BNFdef name="when operand">
      <rhs>
         <alt>
            <BNF name="non-parenthesized value expression primary"/>
         </alt>
         <alt>
            <BNF name="comparison predicate part 2"/>
         </alt>
         <alt>
            <BNF name="null predicate part 2"/>
         </alt>
         <alt>
            <BNF name="normalized predicate part 2"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="result">
      <rhs>
         <alt>
            <BNF name="result expression"/>
         </alt>
         <alt>
            <BNF name="null literal"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="result expression">
      <rhs>
         <BNF name="value expression"/>
      </rhs>
   </BNFdef>
   <BNFdef name="aggregate function">
      <rhs>
         <alt>
            <kw>COUNT</kw>
            <BNF name="left paren"/>
            <BNF name="asterisk"/>
            <BNF name="right paren"/>
         </alt>
         <alt>
            <BNF name="general set function"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="general set function">
      <rhs>
         <BNF name="general set function type"/>
         <BNF name="left paren"/>
         <opt>
            <BNF name="set quantifier"/>
         </opt>
         <BNF name="value expression"/>
         <BNF name="right paren"/>
      </rhs>
   </BNFdef>
   <BNFdef name="general set function type">
      <rhs>
         <alt>
            <kw>AVG</kw>
         </alt>
         <alt>
            <kw>COUNT</kw>
         </alt>
         <alt>
            <kw>MAX</kw>
         </alt>
         <alt>
            <kw>MIN</kw>
         </alt>
         <alt>
            <kw>SUM</kw>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="set quantifier">
      <rhs>
         <alt>
            <kw>DISTINCT</kw>
         </alt>
         <alt>
            <kw>ALL</kw>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="property reference">
      <rhs>
         <BNF name="property source"/>
         <BNF name="period"/>
         <BNF name="property name"/>
      </rhs>
   </BNFdef>
   <BNFdef name="property source">
      <rhs>
         <alt>
            <BNF name="node reference value expression"/>
         </alt>
         <alt>
            <BNF name="edge reference value expression"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="binding variable reference">
      <rhs>
         <BNF name="binding variable"/>
      </rhs>
   </BNFdef>
<note><feature code="GP08"/> and <feature code="GP11"/> provide additional constraints on the 
mandatory aspects of <BNF name="binding variable reference"/>.
</note>
   <BNFdef name="boolean value expression">
      <rhs>
         <alt>
            <BNF name="boolean term"/>
         </alt>
         <alt>
            <BNF name="boolean value expression"/>
            <kw>OR</kw>
            <BNF name="boolean term"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="boolean term">
      <rhs>
         <alt>
            <BNF name="boolean factor"/>
         </alt>
         <alt>
            <BNF name="boolean term"/>
            <kw>AND</kw>
            <BNF name="boolean factor"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="boolean factor">
      <rhs>
         <opt>
            <kw>NOT</kw>
         </opt>
         <BNF name="boolean test"/>
      </rhs>
   </BNFdef>
   <BNFdef name="boolean test">
      <rhs>
         <BNF name="boolean primary"/>
         <opt>
            <kw>IS</kw>
            <opt>
               <kw>NOT</kw>
            </opt>
            <BNF name="truth value"/>
         </opt>
      </rhs>
   </BNFdef>
   <BNFdef name="truth value">
      <rhs>
         <alt>
            <kw>TRUE</kw>
         </alt>
         <alt>
            <kw>FALSE</kw>
         </alt>
         <alt>
            <kw>UNKNOWN</kw>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="boolean primary">
      <rhs>
         <alt>
            <BNF name="predicate"/>
         </alt>
         <alt>
            <BNF name="boolean predicand"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="boolean predicand">
      <rhs>
         <alt>
            <BNF name="parenthesized boolean value expression"/>
         </alt>
         <alt>
            <BNF name="non-parenthesized value expression primary"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="parenthesized boolean value expression">
      <rhs>
         <BNF name="left paren"/>
         <BNF name="boolean value expression"/>
         <BNF name="right paren"/>
      </rhs>
   </BNFdef>
   <BNFdef name="numeric value expression">
      <rhs>
         <alt>
            <BNF name="term"/>
         </alt>
         <alt>
            <BNF name="numeric value expression"/>
            <BNF name="plus sign"/>
            <BNF name="term"/>
         </alt>
         <alt>
            <BNF name="numeric value expression"/>
            <BNF name="minus sign"/>
            <BNF name="term"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="term">
      <rhs>
         <alt>
            <BNF name="factor"/>
         </alt>
         <alt>
            <BNF name="term"/>
            <BNF name="asterisk"/>
            <BNF name="factor"/>
         </alt>
         <alt>
            <BNF name="term"/>
            <BNF name="solidus"/>
            <BNF name="factor"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="factor">
      <rhs>
         <opt>
            <BNF name="sign"/>
         </opt>
         <BNF name="numeric primary"/>
      </rhs>
   </BNFdef>
   <BNFdef name="numeric primary">
      <rhs>
         <alt>
            <BNF name="value expression primary"/>
         </alt>
         <alt>
            <BNF name="numeric value function"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="numeric value function">
      <rhs>
         <alt>
            <BNF name="length expression"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="length expression">
      <rhs>
         <alt>
            <BNF name="char length expression"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="char length expression">
      <rhs>
         <group>
            <alt>
               <kw>CHAR_LENGTH</kw>
            </alt>
            <alt>
               <kw>CHARACTER_LENGTH</kw>
            </alt>
         </group>
         <BNF name="left paren"/>
         <BNF name="character string value expression"/>
         <BNF name="right paren"/>
      </rhs>
   </BNFdef>
   <BNFdef name="string value expression">
      <rhs>
         <alt>
            <BNF name="character string value expression"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="character string value expression">
      <rhs>
         <alt>
            <BNF name="character string concatenation"/>
         </alt>
         <alt>
            <BNF name="character string primary"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="character string concatenation">
      <rhs>
         <BNF name="character string value expression"/>
         <BNF name="concatenation operator"/>
         <BNF name="character string primary"/>
      </rhs>
   </BNFdef>
   <BNFdef name="character string primary">
      <rhs>
         <alt>
            <BNF name="value expression primary"/>
         </alt>
         <alt>
            <BNF name="character string function"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="character string function">
      <rhs>
         <alt>
            <BNF name="substring function"/>
         </alt>
         <alt>
            <BNF name="fold"/>
         </alt>
         <alt>
            <BNF name="trim function"/>
         </alt>
         <alt>
            <BNF name="normalize function"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="substring function">
      <rhs>
         <group>
            <alt>
               <kw>LEFT</kw>
            </alt>
            <alt>
               <kw>RIGHT</kw>
            </alt>
         </group>
         <BNF name="left paren"/>
         <BNF name="character string value expression"/>
         <BNF name="comma"/>
         <BNF name="string length"/>
         <BNF name="right paren"/>
      </rhs>
   </BNFdef>
   <BNFdef name="fold">
      <rhs>
         <group>
            <alt>
               <kw>UPPER</kw>
            </alt>
            <alt>
               <kw>LOWER</kw>
            </alt>
         </group>
         <BNF name="left paren"/>
         <BNF name="character string value expression"/>
         <BNF name="right paren"/>
      </rhs>
   </BNFdef>
   <BNFdef name="trim function">
      <rhs>
         <alt>
            <BNF name="single-character trim function"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="single-character trim function">
      <rhs>
         <kw>TRIM</kw>
         <BNF name="left paren"/>
         <BNF name="trim operands"/>
         <BNF name="right paren"/>
      </rhs>
   </BNFdef>
   <BNFdef name="trim operands">
      <rhs>
         <BNF name="trim source"/>
      </rhs>
   </BNFdef>
   <BNFdef name="trim source">
      <rhs>
         <BNF name="character string value expression"/>
      </rhs>
   </BNFdef>
   <BNFdef name="trim specification">
      <rhs>
         <alt>
            <kw>LEADING</kw>
         </alt>
         <alt>
            <kw>TRAILING</kw>
         </alt>
         <alt>
            <kw>BOTH</kw>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="trim character string">
      <rhs>
         <BNF name="character string value expression"/>
      </rhs>
   </BNFdef>
   <BNFdef name="normalize function">
      <rhs>
         <kw>NORMALIZE</kw>
         <BNF name="left paren"/>
         <BNF name="character string value expression"/>
         <opt>
            <BNF name="comma"/>
            <BNF name="normal form"/>
         </opt>
         <BNF name="right paren"/>
      </rhs>
   </BNFdef>
   <BNFdef name="normal form">
      <rhs>
         <alt>
            <kw>NFC</kw>
         </alt>
         <alt>
            <kw>NFD</kw>
         </alt>
         <alt>
            <kw>NFKC</kw>
         </alt>
         <alt>
            <kw>NFKD</kw>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="string length">
      <rhs>
         <BNF name="numeric value expression"/>
      </rhs>
   </BNFdef>
   <BNFdef name="authorization identifier">
      <rhs>
         <BNF name="identifier"/>
      </rhs>
   </BNFdef>
   <BNFdef name="object name">
      <rhs>
         <BNF name="identifier"/>
      </rhs>
   </BNFdef>
   <BNFdef name="object name or binding variable">
      <rhs>
         <BNF name="regular identifier"/>
      </rhs>
   </BNFdef>
   <BNFdef name="directory name">
      <rhs>
         <BNF name="identifier"/>
      </rhs>
   </BNFdef>
   <BNFdef name="schema name">
      <rhs>
         <BNF name="identifier"/>
      </rhs>
   </BNFdef>
   <BNFdef name="graph name">
      <rhs>
         <alt>
            <BNF name="regular identifier"/>
         </alt>
         <alt>
            <BNF name="delimited graph name"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="delimited graph name">
      <rhs>
         <BNF name="delimited identifier"/>
      </rhs>
   </BNFdef>
   <BNFdef name="label name">
      <rhs>
         <BNF name="identifier"/>
      </rhs>
   </BNFdef>
   <BNFdef name="property name">
      <rhs>
         <BNF name="identifier"/>
      </rhs>
   </BNFdef>
   <BNFdef name="parameter name">
      <rhs>
         <BNF name="separated identifier"/>
      </rhs>
   </BNFdef>
   <BNFdef name="graph pattern variable">
      <rhs>
         <alt>
            <BNF name="element variable"/>
         </alt>
         <alt>
            <BNF name="path or subpath variable"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="path or subpath variable">
      <rhs>
         <alt>
            <BNF name="path variable"/>
         </alt>
         <alt>
            <BNF name="subpath variable"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="element variable">
      <rhs>
         <BNF name="binding variable"/>
      </rhs>
   </BNFdef>
   <BNFdef name="path variable">
      <rhs>
         <BNF name="binding variable"/>
      </rhs>
   </BNFdef>
   <BNFdef name="subpath variable">
      <rhs>
         <BNF name="regular identifier"/>
      </rhs>
   </BNFdef>
   <BNFdef name="binding variable">
      <rhs>
         <BNF name="regular identifier"/>
      </rhs>
   </BNFdef>
   <BNFdef name="literal">
      <rhs>
         <alt>
            <BNF name="signed numeric literal"/>
         </alt>
         <alt>
            <BNF name="general literal"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="unsigned literal">
      <rhs>
         <alt>
            <BNF name="unsigned numeric literal"/>
         </alt>
         <alt>
            <BNF name="general literal"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="general literal">
      <rhs>
         <alt>
            <BNF name="boolean literal"/>
         </alt>
         <alt>
            <BNF name="character string literal"/>
         </alt>
         <alt>
            <BNF name="null literal"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="boolean literal">
      <rhs>
         <alt>
            <kw>TRUE</kw>
         </alt>
         <alt>
            <kw>FALSE</kw>
         </alt>
         <alt>
            <kw>UNKNOWN</kw>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="character string literal">
      <rhs>
         <alt>
            <BNF name="single quoted character sequence"/>
         </alt>
         <alt>
            <BNF name="double quoted character sequence"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="single quoted character sequence">
      <rhs>
         <BNF name="unbroken single quoted character sequence"/>
      </rhs>
   </BNFdef>
   <BNFdef name="double quoted character sequence">
      <rhs>
         <BNF name="unbroken double quoted character sequence"/>
      </rhs>
   </BNFdef>
   <BNFdef name="accent quoted character sequence">
      <rhs>
         <BNF name="unbroken accent quoted character sequence"/>
      </rhs>
   </BNFdef>
   <BNFdef name="unbroken single quoted character sequence">
      <rhs>
         <BNF name="quote"/>
         <opt>
            <BNF name="single quoted character representation"/>
            <repeat/>
         </opt>
         <BNF name="quote"/>
      </rhs>
   </BNFdef>
   <BNFdef name="unbroken double quoted character sequence">
      <rhs>
         <BNF name="double quote"/>
         <opt>
            <BNF name="double quoted character representation"/>
            <repeat/>
         </opt>
         <BNF name="double quote"/>
      </rhs>
   </BNFdef>
   <BNFdef name="unbroken accent quoted character sequence">
      <rhs>
         <BNF name="grave accent"/>
         <opt>
            <BNF name="accent quoted character representation"/>
            <repeat/>
         </opt>
         <BNF name="grave accent"/>
      </rhs>
   </BNFdef>
   <BNFdef name="single quoted character representation">
      <rhs>
         <alt>
            <BNF name="character representation"/>
         </alt>
         <alt>
            <BNF name="double single quote"/>
         </alt>
         <seeTheRules><specref ref="gql_literals"/><itemref ref="gql_lit_sqcr" type="SR"/>
         </seeTheRules>
      </rhs>
   </BNFdef>
   <BNFdef name="double quoted character representation">
      <rhs>
         <alt>
            <BNF name="character representation"/>
         </alt>
         <alt>
            <BNF name="double double quote"/>
         </alt>
         <seeTheRules><specref ref="gql_literals"/><itemref ref="gql_lit_dqcr" type="SR"/>
         </seeTheRules>
      </rhs>
   </BNFdef>
   <BNFdef name="accent quoted character representation">
      <rhs>
         <alt>
            <BNF name="character representation"/>
         </alt>
         <alt>
            <BNF name="double grave accent"/>
         </alt>
         <seeTheRules><specref ref="gql_literals"/><itemref ref="gql_lit_aqcr" type="SR"/>
         </seeTheRules>
      </rhs>
   </BNFdef>
   <BNFdef name="character representation">
      <rhs>
         <seeTheRules><specref ref="gql_literals"/><itemref ref="gql_lit_cr" type="SR"/>
         </seeTheRules>
      </rhs>
   </BNFdef>
   <BNFdef name="double single quote">
      <rhs>
         <BNF name="quote"/>
         <BNF name="quote"/>
         <seeTheRules><specref ref="gql_literals"/><itemref ref="gql_lit_dsq" type="SR"/>
         </seeTheRules>
      </rhs>
   </BNFdef>
   <BNFdef name="double double quote">
      <rhs>
         <BNF name="double quote"/>
         <BNF name="double quote"/>
         <seeTheRules><specref ref="gql_literals"/><itemref ref="gql_lit_ddq" type="SR"/>
         </seeTheRules>
      </rhs>
   </BNFdef>
   <BNFdef name="double grave accent">
      <rhs>
         <BNF name="grave accent"/>
         <BNF name="grave accent"/>
         <seeTheRules><specref ref="gql_literals"/><itemref ref="gql_lit_dga" type="SR"/>
         </seeTheRules>
      </rhs>
   </BNFdef>
   <BNFdef name="string literal character">
      <rhs>
         <seeTheRules><specref ref="gql_literals"/><itemref ref="gql_lit_slc" type="SR"/>
         </seeTheRules>
      </rhs>
   </BNFdef>
   <BNFdef name="escaped character">
      <rhs>
         <alt>
            <BNF name="escaped reverse solidus"/>
         </alt>
         <alt>
            <BNF name="escaped quote"/>
         </alt>
         <alt>
            <BNF name="escaped double quote"/>
         </alt>
         <alt>
            <BNF name="escaped grave accent"/>
         </alt>
         <alt>
            <BNF name="escaped tab"/>
         </alt>
         <alt>
            <BNF name="escaped backspace"/>
         </alt>
         <alt>
            <BNF name="escaped newline"/>
         </alt>
         <alt>
            <BNF name="escaped carriage return"/>
         </alt>
         <alt>
            <BNF name="escaped form feed"/>
         </alt>
         <alt>
            <BNF name="unicode escape value"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="escaped reverse solidus">
      <rhs>
         <BNF name="reverse solidus"/>
         <BNF name="reverse solidus"/>
      </rhs>
   </BNFdef>
   <BNFdef name="escaped quote">
      <rhs>
         <BNF name="reverse solidus"/>
         <BNF name="quote"/>
      </rhs>
   </BNFdef>
   <BNFdef name="escaped double quote">
      <rhs>
         <BNF name="reverse solidus"/>
         <BNF name="double quote"/>
      </rhs>
   </BNFdef>
   <BNFdef name="escaped grave accent">
      <rhs>
         <BNF name="reverse solidus"/>
         <BNF name="grave accent"/>
      </rhs>
   </BNFdef>
   <BNFdef name="escaped tab">
      <rhs>
         <BNF name="reverse solidus"/>
         <terminalsymbol>t</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="escaped backspace">
      <rhs>
         <BNF name="reverse solidus"/>
         <terminalsymbol>b</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="escaped newline">
      <rhs>
         <BNF name="reverse solidus"/>
         <terminalsymbol>n</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="escaped carriage return">
      <rhs>
         <BNF name="reverse solidus"/>
         <terminalsymbol>r</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="escaped form feed">
      <rhs>
         <BNF name="reverse solidus"/>
         <terminalsymbol>f</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="unicode escape value">
      <rhs>
         <alt>
            <BNF name="unicode 4 digit escape value"/>
         </alt>
         <alt>
            <BNF name="unicode 6 digit escape value"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="unicode 4 digit escape value">
      <rhs>
         <BNF name="reverse solidus"/>
         <terminalsymbol>u</terminalsymbol>
         <BNF name="hex digit"/>
         <BNF name="hex digit"/>
         <BNF name="hex digit"/>
         <BNF name="hex digit"/>
      </rhs>
   </BNFdef>
   <BNFdef name="unicode 6 digit escape value">
      <rhs>
         <BNF name="reverse solidus"/>
         <terminalsymbol>U</terminalsymbol>
         <BNF name="hex digit"/>
         <BNF name="hex digit"/>
         <BNF name="hex digit"/>
         <BNF name="hex digit"/>
         <breakindent/>
         <BNF name="hex digit"/>
         <BNF name="hex digit"/>
      </rhs>
   </BNFdef>
   <BNFdef name="signed numeric literal">
      <rhs>
         <opt>
            <BNF name="sign"/>
         </opt>
         <BNF name="unsigned numeric literal"/>
      </rhs>
   </BNFdef>
   <BNFdef name="sign">
      <rhs>
         <alt>
            <BNF name="plus sign"/>
         </alt>
         <alt>
            <BNF name="minus sign"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="unsigned numeric literal">
      <rhs>
         <alt>
            <BNF name="exact numeric literal"/>
         </alt>
         <alt>
            <BNF name="approximate numeric literal"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="exact numeric literal">
      <rhs>
         <alt>
            <BNF name="unsigned decimal in scientific notation"/>
         </alt>
         <alt>
            <BNF name="unsigned decimal integer"/>
         </alt>
         <alt>
            <BNF name="unsigned integer"/>
         </alt>
      </rhs>
   </BNFdef>
<bar note="WG3:XRH-037"/>
<comment>WG3:XRH-037</comment>
   <BNFdef name="unsigned decimal in scientific notation">
      <rhs>
         <BNF name="mantissa"/>
         <BNF name="exponent introducer"/>
         <BNF name="exponent"/>
      </rhs>
   </BNFdef>
<endbar/>
   <BNFdef name="mantissa">
      <rhs>
         <alt>
            <BNF name="unsigned decimal in common notation"/>
         </alt>
         <alt>
            <BNF name="unsigned decimal integer"/>
         </alt>
      </rhs>
   </BNFdef>
<bar note="WG3:XRH-037"/>
<comment>WG3:XRH-037</comment>
   <BNFdef name="exponent introducer">
      <rhs>
         <alt br="no"><terminalsymbol>E</terminalsymbol></alt>
         <alt br="no"><terminalsymbol>e</terminalsymbol></alt>
      </rhs>
   </BNFdef>
<endbar/>
   <BNFdef name="exponent">
      <rhs>
         <BNF name="signed decimal integer"/>
      </rhs>
   </BNFdef>
   <BNFdef name="unsigned decimal in common notation">
      <rhs>
         <alt>
            <BNF name="unsigned decimal integer"/>
            <BNF name="period"/>
            <opt>
               <BNF name="unsigned decimal integer"/>
            </opt>
         </alt>
         <alt>
            <BNF name="period"/>
            <BNF name="unsigned decimal integer"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="unsigned integer">
      <rhs>
         <alt>
            <BNF name="unsigned decimal integer"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="signed decimal integer">
      <rhs>
         <opt>
            <BNF name="sign"/>
         </opt>
         <BNF name="unsigned decimal integer"/>
      </rhs>
   </BNFdef>
   <BNFdef name="unsigned decimal integer">
      <rhs>
         <BNF name="digit"/>
         <opt>
            <group>
               <opt>
                  <BNF name="underscore"/>
               </opt>
               <BNF name="digit"/>
            </group>
            <repeat/>
         </opt>
      </rhs>
   </BNFdef>
   <BNFdef name="approximate numeric literal">
      <rhs>
         <alt>
            <BNF name="unsigned decimal in scientific notation"/>
         </alt>
         <alt>
            <BNF name="unsigned decimal in common notation"/>
         </alt>
         <alt>
            <BNF name="unsigned decimal integer"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="null literal">
      <rhs>
         <kw>NULL</kw>
      </rhs>
   </BNFdef>
   <BNFdef name="token">
      <rhs>
         <alt>
            <BNF name="non-delimiter token"/>
         </alt>
         <alt>
            <BNF name="delimiter token"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="non-delimiter token">
      <rhs>
         <alt>
            <BNF name="regular identifier"/>
         </alt>
         <alt>
            <BNF name="substituted parameter reference"/>
         </alt>
         <alt>
            <BNF name="general parameter reference"/>
         </alt>
         <alt>
            <BNF name="keyword"/>
         </alt>
         <alt>
            <BNF name="unsigned numeric literal"/>
         </alt>
         <alt>
            <BNF name="multiset alternation operator"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="identifier">
      <rhs>
         <alt>
            <BNF name="regular identifier"/>
         </alt>
         <alt>
            <BNF name="delimited identifier"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="separated identifier">
      <rhs>
         <alt>
            <BNF name="extended identifier"/>
         </alt>
         <alt>
            <BNF name="delimited identifier"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="non-delimited identifier">
      <rhs>
         <alt>
            <BNF name="regular identifier"/>
         </alt>
         <alt>
            <BNF name="extended identifier"/>
         </alt>
      </rhs>
   </BNFdef>
<note><feature code="GB01"/> provides additional constraints on the mandatory aspects of 
<BNF name="non-delimited identifier"/>.
</note>
   <BNFdef name="regular identifier">
      <rhs>
         <BNF name="identifier start"/>
         <opt>
            <BNF name="identifier extend"/>
            <repeat/>
         </opt>
      </rhs>
   </BNFdef>
   <BNFdef name="extended identifier">
      <rhs>
         <BNF name="identifier extend"/>
         <repeat/>
      </rhs>
   </BNFdef>
   <BNFdef name="delimited identifier">
      <rhs>
         <alt>
            <BNF name="double quoted character sequence"/>
         </alt>
         <alt>
            <BNF name="accent quoted character sequence"/>
         </alt>
      </rhs>
   </BNFdef>
<note><feature code="GB01"/> provides additional constraints on the mandatory aspects of 
<BNF name="delimited identifier"/>.
</note>
   <BNFdef name="identifier start">
      <rhs>
         <seeTheRules><specref ref="gql_token"/><itemref ref="gql_tok_is" type="SR"/></seeTheRules>
      </rhs>
   </BNFdef>
   <BNFdef name="identifier extend">
      <rhs>
         <seeTheRules><specref ref="gql_token"/><itemref ref="gql_tok_ie" type="SR"/></seeTheRules>
      </rhs>
   </BNFdef>
   <BNFdef name="substituted parameter reference">
      <rhs>
         <BNF name="double dollar sign"/>
         <BNF name="parameter name"/>
      </rhs>
   </BNFdef>
   <BNFdef name="general parameter reference">
      <rhs>
         <BNF name="dollar sign"/>
         <BNF name="parameter name"/>
      </rhs>
   </BNFdef>
   <BNFdef name="keyword">
      <rhs>
         <alt>
            <BNF name="reserved word"/>
         </alt>
         <alt>
            <BNF name="non-reserved word"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="reserved word" predicative="no">
      <rhs>
         <alt>
            <BNF name="pre-reserved word"/>
         </alt>
         <alt>
            <kw>ABS</kw>
         </alt>
         <alt>
            <kw>ACOS</kw>
         </alt>
         <alt>
            <kw>ALL</kw>
         </alt>
         <alt>
            <kw>ALL_DIFFERENT</kw>
         </alt>
         <alt>
            <kw>AND</kw>
         </alt>
         <alt>
            <kw>ANY</kw>
         </alt>
         <alt>
            <kw>ARRAY</kw>
         </alt>
         <alt>
            <kw>AS</kw>
         </alt>
         <alt>
            <kw>ASC</kw>
         </alt>
         <alt>
            <kw>ASCENDING</kw>
         </alt>
         <alt>
            <kw>ASIN</kw>
         </alt>
         <alt>
            <kw>AT</kw>
         </alt>
         <alt>
            <kw>ATAN</kw>
         </alt>
         <alt>
            <kw>AVG</kw>
         </alt>
         <alt>
            <kw>BIG</kw>
         </alt>
         <alt>
            <kw>BIGINT</kw>
         </alt>
         <alt>
            <kw>BINARY</kw>
         </alt>
         <alt>
            <kw>BOOL</kw>
         </alt>
         <alt>
            <kw>BOOLEAN</kw>
         </alt>
         <alt>
            <kw>BOTH</kw>
         </alt>
         <alt>
            <kw>BTRIM</kw>
         </alt>
         <alt>
            <kw>BY</kw>
         </alt>
         <alt>
            <kw>BYTE_LENGTH</kw>
         </alt>
         <alt>
            <kw>BYTES</kw>
         </alt>
         <alt>
            <kw>CALL</kw>
         </alt>
         <alt>
            <kw>CARDINALITY</kw>
         </alt>
         <alt>
            <kw>CASE</kw>
         </alt>
         <alt>
            <kw>CAST</kw>
         </alt>
         <alt>
            <kw>CEIL</kw>
         </alt>
         <alt>
            <kw>CEILING</kw>
         </alt>
         <alt>
            <kw>CHAR</kw>
         </alt>
         <alt>
            <kw>CHAR_LENGTH</kw>
         </alt>
         <alt>
            <kw>CHARACTER_LENGTH</kw>
         </alt>
         <alt>
            <kw>CHARACTERISTICS</kw>
         </alt>
         <alt>
            <kw>CLOSE</kw>
         </alt>
         <alt>
            <kw>COALESCE</kw>
         </alt>
         <alt>
            <kw>COLLECT_LIST</kw>
         </alt>
         <alt>
            <kw>COMMIT</kw>
         </alt>
         <alt>
            <kw>COPY</kw>
         </alt>
         <alt>
            <kw>COS</kw>
         </alt>
         <alt>
            <kw>COSH</kw>
         </alt>
         <alt>
            <kw>COT</kw>
         </alt>
         <alt>
            <kw>COUNT</kw>
         </alt>
         <alt>
            <kw>CREATE</kw>
         </alt>
         <alt>
            <kw>CURRENT_DATE</kw>
         </alt>
         <alt>
            <kw>CURRENT_GRAPH</kw>
         </alt>
         <alt>
            <kw>CURRENT_PROPERTY_GRAPH</kw>
         </alt>
         <alt>
            <kw>CURRENT_SCHEMA</kw>
         </alt>
         <alt>
            <kw>CURRENT_TIME</kw>
         </alt>
         <alt>
            <kw>CURRENT_TIMESTAMP</kw>
         </alt>
         <alt>
            <kw>DATE</kw>
         </alt>
         <alt>
            <kw>DATETIME</kw>
         </alt>
         <alt>
            <kw>DAY</kw>
         </alt>
         <alt>
            <kw>DEC</kw>
         </alt>
         <alt>
            <kw>DECIMAL</kw>
         </alt>
         <alt>
            <kw>DEGREES</kw>
         </alt>
         <alt>
            <kw>DELETE</kw>
         </alt>
         <alt>
            <kw>DESC</kw>
         </alt>
         <alt>
            <kw>DESCENDING</kw>
         </alt>
         <alt>
            <kw>DETACH</kw>
         </alt>
         <alt>
            <kw>DISTINCT</kw>
         </alt>
         <alt>
            <kw>DOUBLE</kw>
         </alt>
         <alt>
            <kw>DROP</kw>
         </alt>
         <alt>
            <kw>DURATION</kw>
         </alt>
         <alt>
            <kw>DURATION_BETWEEN</kw>
         </alt>
         <alt>
            <kw>ELEMENT_ID</kw>
         </alt>
         <alt>
            <kw>ELSE</kw>
         </alt>
         <alt>
            <kw>END</kw>
         </alt>
         <alt>
            <kw>EXCEPT</kw>
         </alt>
         <alt>
            <kw>EXISTS</kw>
         </alt>
         <alt>
            <kw>EXP</kw>
         </alt>
         <alt>
            <kw>FALSE</kw>
         </alt>
         <alt>
            <kw>FILTER</kw>
         </alt>
         <alt>
            <kw>FINISH</kw>
         </alt>
         <alt>
            <kw>FLOAT</kw>
         </alt>
         <alt>
            <kw>FLOAT16</kw>
         </alt>
         <alt>
            <kw>FLOAT32</kw>
         </alt>
         <alt>
            <kw>FLOAT64</kw>
         </alt>
         <alt>
            <kw>FLOAT128</kw>
         </alt>
         <alt>
            <kw>FLOAT256</kw>
         </alt>
         <alt>
            <kw>FLOOR</kw>
         </alt>
         <alt>
            <kw>FOR</kw>
         </alt>
         <alt>
            <kw>FROM</kw>
         </alt>
         <alt>
            <kw>GROUP</kw>
         </alt>
         <alt>
            <kw>HAVING</kw>
         </alt>
         <alt>
            <kw>HOME_GRAPH</kw>
         </alt>
         <alt>
            <kw>HOME_PROPERTY_GRAPH</kw>
         </alt>
         <alt>
            <kw>HOME_SCHEMA</kw>
         </alt>
         <alt>
            <kw>HOUR</kw>
         </alt>
         <alt>
            <kw>IF</kw>
         </alt>
         <alt>
            <kw>IMPLIES</kw>
         </alt>
         <alt>
            <kw>IN</kw>
         </alt>
         <alt>
            <kw>INSERT</kw>
         </alt>
         <alt>
            <kw>INT</kw>
         </alt>
         <alt>
            <kw>INTEGER</kw>
         </alt>
         <alt>
            <kw>INT8</kw>
         </alt>
         <alt>
            <kw>INTEGER8</kw>
         </alt>
         <alt>
            <kw>INT16</kw>
         </alt>
         <alt>
            <kw>INTEGER16</kw>
         </alt>
         <alt>
            <kw>INT32</kw>
         </alt>
         <alt>
            <kw>INTEGER32</kw>
         </alt>
         <alt>
            <kw>INT64</kw>
         </alt>
         <alt>
            <kw>INTEGER64</kw>
         </alt>
         <alt>
            <kw>INT128</kw>
         </alt>
         <alt>
            <kw>INTEGER128</kw>
         </alt>
         <alt>
            <kw>INT256</kw>
         </alt>
         <alt>
            <kw>INTEGER256</kw>
         </alt>
         <alt>
            <kw>INTERSECT</kw>
         </alt>
         <alt>
            <kw>INTERVAL</kw>
         </alt>
         <alt>
            <kw>IS</kw>
         </alt>
         <alt>
            <kw>LEADING</kw>
         </alt>
         <alt>
            <kw>LEFT</kw>
         </alt>
         <alt>
            <kw>LET</kw>
         </alt>
         <alt>
            <kw>LIKE</kw>
         </alt>
         <alt>
            <kw>LIMIT</kw>
         </alt>
         <alt>
            <kw>LIST</kw>
         </alt>
         <alt>
            <kw>LN</kw>
         </alt>
         <alt>
            <kw>LOCAL</kw>
         </alt>
         <alt>
            <kw>LOCAL_DATETIME</kw>
         </alt>
         <alt>
            <kw>LOCAL_TIME</kw>
         </alt>
         <alt>
            <kw>LOCAL_TIMESTAMP</kw>
         </alt>
         <alt>
            <kw>LOG</kw>
         </alt>
         <alt>
            <kw>LOG10</kw>
         </alt>
         <alt>
            <kw>LOWER</kw>
         </alt>
         <alt>
            <kw>LTRIM</kw>
         </alt>
         <alt>
            <kw>MATCH</kw>
         </alt>
         <alt>
            <kw>MAX</kw>
         </alt>
         <alt>
            <kw>MIN</kw>
         </alt>
         <alt>
            <kw>MINUTE</kw>
         </alt>
         <alt>
            <kw>MOD</kw>
         </alt>
         <alt>
            <kw>MONTH</kw>
         </alt>
         <alt>
            <kw>NEXT</kw>
         </alt>
         <alt>
            <kw>NODETACH</kw>
         </alt>
         <alt>
            <kw>NORMALIZE</kw>
         </alt>
         <alt>
            <kw>NOT</kw>
         </alt>
         <alt>
            <kw>NOTHING</kw>
         </alt>
         <alt>
            <kw>NULL</kw>
         </alt>
         <alt>
            <kw>NULLS</kw>
         </alt>
         <alt>
            <kw>NULLIF</kw>
         </alt>
         <alt>
            <kw>OCTET_LENGTH</kw>
         </alt>
         <alt>
            <kw>OF</kw>
         </alt>
         <alt>
            <kw>OFFSET</kw>
         </alt>
         <alt>
            <kw>OPTIONAL</kw>
         </alt>
         <alt>
            <kw>OR</kw>
         </alt>
         <alt>
            <kw>ORDER</kw>
         </alt>
         <alt>
            <kw>OTHERWISE</kw>
         </alt>
         <alt>
            <kw>PARAMETER</kw>
         </alt>
         <alt>
            <kw>PARAMETERS</kw>
         </alt>
         <alt>
            <kw>PATH</kw>
         </alt>
         <alt>
            <kw>PATH_LENGTH</kw>
         </alt>
         <alt>
            <kw>PATHS</kw>
         </alt>
         <alt>
            <kw>PERCENTILE_CONT</kw>
         </alt>
         <alt>
            <kw>PERCENTILE_DISC</kw>
         </alt>
         <alt>
            <kw>POWER</kw>
         </alt>
         <alt>
            <kw>PRECISION</kw>
         </alt>
         <alt>
            <kw>PROPERTY_EXISTS</kw>
         </alt>
         <alt>
            <kw>RADIANS</kw>
         </alt>
         <alt>
            <kw>REAL</kw>
         </alt>
         <alt>
            <kw>RECORD</kw>
         </alt>
         <alt>
            <kw>REMOVE</kw>
         </alt>
         <alt>
            <kw>REPLACE</kw>
         </alt>
         <alt>
            <kw>RESET</kw>
         </alt>
         <alt>
            <kw>RETURN</kw>
         </alt>
         <alt>
            <kw>RIGHT</kw>
         </alt>
         <alt>
            <kw>ROLLBACK</kw>
         </alt>
         <alt>
            <kw>RTRIM</kw>
         </alt>
         <alt>
            <kw>SAME</kw>
         </alt>
         <alt>
            <kw>SCHEMA</kw>
         </alt>
         <alt>
            <kw>SECOND</kw>
         </alt>
         <alt>
            <kw>SELECT</kw>
         </alt>
         <alt>
            <kw>SESSION</kw>
         </alt>
         <alt>
            <kw>SESSION_USER</kw>
         </alt>
         <alt>
            <kw>SET</kw>
         </alt>
         <alt>
            <kw>SIGNED</kw>
         </alt>
         <alt>
            <kw>SIN</kw>
         </alt>
         <alt>
            <kw>SINH</kw>
         </alt>
         <alt>
            <kw>SIZE</kw>
         </alt>
         <alt>
            <kw>SKIP</kw>
         </alt>
         <alt>
            <kw>SMALL</kw>
         </alt>
         <alt>
            <kw>SMALLINT</kw>
         </alt>
         <alt>
            <kw>SQRT</kw>
         </alt>
         <alt>
            <kw>START</kw>
         </alt>
         <alt>
            <kw>STDDEV_POP</kw>
         </alt>
         <alt>
            <kw>STDDEV_SAMP</kw>
         </alt>
         <alt>
            <kw>STRING</kw>
         </alt>
         <alt>
            <kw>SUM</kw>
         </alt>
         <alt>
            <kw>TAN</kw>
         </alt>
         <alt>
            <kw>TANH</kw>
         </alt>
         <alt>
            <kw>THEN</kw>
         </alt>
         <alt>
            <kw>TIME</kw>
         </alt>
         <alt>
            <kw>TIMESTAMP</kw>
         </alt>
         <alt>
            <kw>TRAILING</kw>
         </alt>
         <alt>
            <kw>TRIM</kw>
         </alt>
         <alt>
            <kw>TRUE</kw>
         </alt>
         <alt>
            <kw>TYPED</kw>
         </alt>
         <alt>
            <kw>UBIGINT</kw>
         </alt>
         <alt>
            <kw>UINT</kw>
         </alt>
         <alt>
            <kw>UINT8</kw>
         </alt>
         <alt>
            <kw>UINT16</kw>
         </alt>
         <alt>
            <kw>UINT32</kw>
         </alt>
         <alt>
            <kw>UINT64</kw>
         </alt>
         <alt>
            <kw>UINT128</kw>
         </alt>
         <alt>
            <kw>UINT256</kw>
         </alt>
         <alt>
            <kw>UNION</kw>
         </alt>
         <alt>
            <kw>UNKNOWN</kw>
         </alt>
         <alt>
            <kw>UNSIGNED</kw>
         </alt>
         <alt>
            <kw>UPPER</kw>
         </alt>
         <alt>
            <kw>USE</kw>
         </alt>
         <alt>
            <kw>USMALLINT</kw>
         </alt>
         <alt>
            <kw>VALUE</kw>
         </alt>
         <alt>
            <kw>VARBINARY</kw>
         </alt>
         <alt>
            <kw>VARCHAR</kw>
         </alt>
         <alt>
            <kw>VARIABLE</kw>
         </alt>
         <alt>
            <kw>WHEN</kw>
         </alt>
         <alt>
            <kw>WHERE</kw>
         </alt>
         <alt>
            <kw>WITH</kw>
         </alt>
         <alt>
            <kw>XOR</kw>
         </alt>
         <alt>
            <kw>YEAR</kw>
         </alt>
         <alt>
            <kw>YIELD</kw>
         </alt>
         <alt>
            <kw>ZONED</kw>
         </alt>
         <alt>
            <kw>ZONED_DATETIME</kw>
         </alt>
         <alt>
            <kw>ZONED_TIME</kw>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="pre-reserved word" predicative="no">
      <rhs>
         <alt>
            <kw>ABSTRACT</kw>
         </alt>
         <alt>
            <kw>AGGREGATE</kw>
         </alt>
         <alt>
            <kw>AGGREGATES</kw>
         </alt>
         <alt>
            <kw>ALTER</kw>
         </alt>
         <alt>
            <kw>CATALOG</kw>
         </alt>
         <alt>
            <kw>CLEAR</kw>
         </alt>
         <alt>
            <kw>CLONE</kw>
         </alt>
         <alt>
            <kw>CONSTRAINT</kw>
         </alt>
         <alt>
            <kw>CURRENT_ROLE</kw>
         </alt>
         <alt>
            <kw>CURRENT_USER</kw>
         </alt>
         <alt>
            <kw>DATA</kw>
         </alt>
         <alt>
            <kw>DIRECTORY</kw>
         </alt>
         <alt>
            <kw>DRYRUN</kw>
         </alt>
         <comment>WG3:XRH-021R1 EXACT</comment>      
         <alt>
            <kw>EXISTING</kw>
         </alt>
         <alt>
            <kw>FUNCTION</kw>
         </alt>
         <alt>
            <kw>GQLSTATUS</kw>
         </alt>
         <alt>
            <kw>GRANT</kw>
         </alt>
         <alt>
            <kw>INSTANT</kw>
         </alt>
         <alt>
            <kw>INFINITY</kw>
         </alt>
         <alt>
            <kw>NUMBER</kw>
         </alt>
         <alt>
            <kw>NUMERIC</kw>
         </alt>
         <alt>
            <kw>ON</kw>
         </alt>
         <alt>
            <kw>OPEN</kw>
         </alt>
         <alt>
            <kw>PARTITION</kw>
         </alt>
         <alt>
            <kw>PROCEDURE</kw>
         </alt>
         <alt>
            <kw>PRODUCT</kw>
         </alt>
         <alt>
            <kw>PROJECT</kw>
         </alt>
         <alt>
            <kw>QUERY</kw>
         </alt>
         <alt>
            <kw>RECORDS</kw>
         </alt>
         <alt>
            <kw>REFERENCE</kw>
         </alt>
         <alt>
            <kw>RENAME</kw>
         </alt>
         <alt>
            <kw>REVOKE</kw>
         </alt>
         <alt>
            <kw>SUBSTRING</kw>
         </alt>
         <alt>
            <kw>SYSTEM_USER</kw>
         </alt>
         <alt>
            <kw>TEMPORAL</kw>
         </alt>
         <alt>
            <kw>UNIQUE</kw>
         </alt>
         <alt>
            <kw>UNIT</kw>
         </alt>
         <alt>
            <kw>VALUES</kw>
         </alt>
         <alt>
            <kw>WHITESPACE</kw>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="non-reserved word" predicative="no">
      <rhs>
         <alt>
            <kw>ACYCLIC</kw>
         </alt>
         <alt>
            <kw>BINDING</kw>
         </alt>
         <alt>
            <kw>BINDINGS</kw>
         </alt>
         <alt>
            <kw>CONNECTING</kw>
         </alt>
         <alt>
            <kw>DESTINATION</kw>
         </alt>
         <alt>
            <kw>DIFFERENT</kw>
         </alt>
         <alt>
            <kw>DIRECTED</kw>
         </alt>
         <alt>
            <kw>EDGE</kw>
         </alt>
         <alt>
            <kw>EDGES</kw>
         </alt>
         <alt>
            <kw>ELEMENT</kw>
         </alt>
         <alt>
            <kw>ELEMENTS</kw>
         </alt>
         <alt>
            <kw>FIRST</kw>
         </alt>
         <alt>
            <kw>GRAPH</kw>
         </alt>
         <alt>
            <kw>GROUPS</kw>
         </alt>
         <alt>
            <kw>KEEP</kw>
         </alt>
         <alt>
            <kw>LABEL</kw>
         </alt>
         <alt>
            <kw>LABELED</kw>
         </alt>
         <alt>
            <kw>LABELS</kw>
         </alt>
         <alt>
            <kw>LAST</kw>
         </alt>
         <alt>
            <kw>NFC</kw>
         </alt>
         <alt>
            <kw>NFD</kw>
         </alt>
         <alt>
            <kw>NFKC</kw>
         </alt>
         <alt>
            <kw>NFKD</kw>
         </alt>
         <alt>
            <kw>NO</kw>
         </alt>
         <alt>
            <kw>NODE</kw>
         </alt>
         <alt>
            <kw>NORMALIZED</kw>
         </alt>
         <alt>
            <kw>ONLY</kw>
         </alt>
         <alt>
            <kw>ORDINALITY</kw>
         </alt>
         <alt>
            <kw>PROPERTY</kw>
         </alt>
         <alt>
            <kw>READ</kw>
         </alt>
         <alt>
            <kw>RELATIONSHIP</kw>
         </alt>
         <alt>
            <kw>RELATIONSHIPS</kw>
         </alt>
         <alt>
            <kw>REPEATABLE</kw>
         </alt>
         <alt>
            <kw>SHORTEST</kw>
         </alt>
         <alt>
            <kw>SIMPLE</kw>
         </alt>
         <alt>
            <kw>SOURCE</kw>
         </alt>
         <alt>
            <kw>TABLE</kw>
         </alt>
         <alt>
            <kw>TEMP</kw>
         </alt>
         <alt>
            <kw>TO</kw>
         </alt>
         <alt>
            <kw>TRAIL</kw>
         </alt>
         <alt>
            <kw>TRANSACTION</kw>
         </alt>
         <alt>
            <kw>TYPE</kw>
         </alt>
         <alt>
            <kw>UNDIRECTED</kw>
         </alt>
         <alt>
            <kw>VERTEX</kw>
         </alt>
         <alt>
            <kw>WALK</kw>
         </alt>
         <alt>
            <kw>WITHOUT</kw>
         </alt>
         <alt>
            <kw>WRITE</kw>
         </alt>
         <alt>
            <kw>ZONE</kw>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="multiset alternation operator">
      <rhs>
         <terminalsymbol unicode="007C,002B,007C">|+|</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="delimiter token">
      <rhs>
         <alt>
            <BNF name="GQL special character"/>
         </alt>
         <alt>
            <BNF name="bracket right arrow"/>
         </alt>
         <alt>
            <BNF name="bracket tilde right arrow"/>
         </alt>
         <alt>
            <BNF name="character string literal"/>
         </alt>
         <alt>
            <BNF name="concatenation operator"/>
         </alt>
         <alt>
            <BNF name="delimited identifier"/>
         </alt>
         <alt>
            <BNF name="double colon"/>
         </alt>
         <alt>
            <BNF name="double period"/>
         </alt>
         <alt>
            <BNF name="greater than operator"/>
         </alt>
         <alt>
            <BNF name="greater than or equals operator"/>
         </alt>
         <alt>
            <BNF name="left arrow"/>
         </alt>
         <alt>
            <BNF name="left arrow bracket"/>
         </alt>
         <alt>
            <BNF name="left arrow tilde"/>
         </alt>
         <alt>
            <BNF name="left arrow tilde bracket"/>
         </alt>
         <alt>
            <BNF name="left minus right"/>
         </alt>
         <alt>
            <BNF name="left minus slash"/>
         </alt>
         <alt>
            <BNF name="left tilde slash"/>
         </alt>
         <alt>
            <BNF name="less than operator"/>
         </alt>
         <alt>
            <BNF name="less than or equals operator"/>
         </alt>
         <alt>
            <BNF name="minus left bracket"/>
         </alt>
         <alt>
            <BNF name="minus slash"/>
         </alt>
         <alt>
            <BNF name="not equals operator"/>
         </alt>
         <alt>
            <BNF name="right arrow"/>
         </alt>
         <alt>
            <BNF name="right bracket minus"/>
         </alt>
         <alt>
            <BNF name="right bracket tilde"/>
         </alt>
         <alt>
            <BNF name="right double arrow"/>
         </alt>
         <alt>
            <BNF name="slash minus"/>
         </alt>
         <alt>
            <BNF name="slash minus right"/>
         </alt>
         <alt>
            <BNF name="slash tilde"/>
         </alt>
         <alt>
            <BNF name="slash tilde right"/>
         </alt>
         <alt>
            <BNF name="tilde left bracket"/>
         </alt>
         <alt>
            <BNF name="tilde right arrow"/>
         </alt>
         <alt>
            <BNF name="tilde slash"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="bracket right arrow">
      <rhs>
         <terminalsymbol unicode="005D, 002D, 003E">]-&gt;</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="bracket tilde right arrow">
      <rhs>
         <terminalsymbol unicode="005D, 007E, 003E">]~&gt;</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="concatenation operator">
      <rhs>
         <terminalsymbol unicode="007C, 007C">||</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="double colon">
      <rhs>
         <terminalsymbol unicode="003A, 003A">::</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="double dollar sign">
      <rhs>
         <terminalsymbol unicode="0024, 0024">$$</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="double minus sign">
      <rhs>
         <terminalsymbol unicode="002D, 002D">--</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="double period">
      <rhs>
         <terminalsymbol unicode="002E, 002E">..</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="greater than operator">
      <rhs>
         <BNF name="right angle bracket"/>
      </rhs>
   </BNFdef>
   <BNFdef name="greater than or equals operator">
      <rhs>
         <terminalsymbol unicode="003E, 003D">&gt;=</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="left arrow">
      <rhs>
         <terminalsymbol unicode="003C, 002D">&lt;-</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="left arrow tilde">
      <rhs>
         <terminalsymbol unicode="003C, 007E">&lt;~</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="left arrow bracket">
      <rhs>
         <terminalsymbol unicode="003C, 002D, 005B">&lt;-[</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="left arrow tilde bracket">
      <rhs>
         <terminalsymbol unicode="003C, 007E, 005B">&lt;~[</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="left minus right">
      <rhs>
         <terminalsymbol unicode="003C, 002D, 003E">&lt;-&gt;</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="left minus slash">
      <rhs>
         <terminalsymbol unicode="003C, 002D, 002F">&lt;-/</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="left tilde slash">
      <rhs>
         <terminalsymbol unicode="003C, 007E, 002F">&lt;~/</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="less than operator">
      <rhs>
         <BNF name="left angle bracket"/>
      </rhs>
   </BNFdef>
   <BNFdef name="less than or equals operator">
      <rhs>
         <terminalsymbol unicode="003C, 003D">&lt;=</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="minus left bracket">
      <rhs>
         <terminalsymbol unicode="002D, 005B">-[</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="minus slash">
      <rhs>
         <terminalsymbol unicode="002D, 002F">-/</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="not equals operator">
      <rhs>
         <terminalsymbol unicode="003C, 003E">&lt;&gt;</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="right arrow">
      <rhs>
         <terminalsymbol unicode="002D, 003E">-&gt;</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="right bracket minus">
      <rhs>
         <terminalsymbol unicode="005D, 002D">]-</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="right bracket tilde">
      <rhs>
         <terminalsymbol unicode="005D, 007E">]~</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="right double arrow">
      <rhs>
         <terminalsymbol unicode="003D, 003E">=&gt;</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="slash minus">
      <rhs>
         <terminalsymbol unicode="002F, 002D">/-</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="slash minus right">
      <rhs>
         <terminalsymbol unicode="002F, 002D, 003E">/-&gt;</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="slash tilde">
      <rhs>
         <terminalsymbol unicode="002F, 007E">/~</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="slash tilde right">
      <rhs>
         <terminalsymbol unicode="002F, 007E, 003E">/~&gt;</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="tilde left bracket">
      <rhs>
         <terminalsymbol unicode="007E,005B">~[</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="tilde right arrow">
      <rhs>
         <terminalsymbol unicode="007E,003E">~&gt;</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="tilde slash">
      <rhs>
         <terminalsymbol unicode="007E, 002F">~/</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="double solidus">
      <rhs>
         <terminalsymbol unicode="002F, 002F">//</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="separator">
      <rhs>
         <group>
            <alt>
               <BNF name="comment"/>
            </alt>
            <alt>
               <BNF name="whitespace"/>
            </alt>
         </group>
         <repeat/>
      </rhs>
   </BNFdef>
   <BNFdef name="whitespace">
      <rhs>
         <seeTheRules><specref ref="gql_literals"/><itemref ref="gql_tok_ws" type="SR"/>
         </seeTheRules>
      </rhs>
   </BNFdef>
   <BNFdef name="truncating whitespace">
      <rhs>
         <seeTheRules><specref ref="gql_literals"/><itemref ref="gql_tok_tws" type="SR"/>
         </seeTheRules>
      </rhs>
   </BNFdef>
   <BNFdef name="bidirectional control character">
      <rhs>
         <seeTheRules><specref ref="gql_literals"/><itemref ref="gql_tok_bdcc" type="SR"/>
         </seeTheRules>
      </rhs>
   </BNFdef>
   <BNFdef name="comment">
      <rhs>
        <BNF name="bracketed comment"/>
      </rhs>
   </BNFdef>
   <BNFdef name="bracketed comment">
      <rhs>
         <BNF name="bracketed comment introducer"/>
         <BNF name="bracketed comment contents"/>
         <BNF name="bracketed comment terminator"/>
      </rhs>
   </BNFdef>
   <BNFdef name="bracketed comment introducer">
      <rhs>
         <terminalsymbol unicode="002F, 002A">/*</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="bracketed comment terminator">
      <rhs>
         <terminalsymbol unicode="002A, 002F">*/</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="bracketed comment contents">
      <rhs>
         <seeTheRules><specref ref="gql_literals"/><itemref ref="gql_tok_bcc" type="SR"/>
         </seeTheRules>
      </rhs>
   </BNFdef>
   <BNFdef name="newline">
      <rhs>
         <seeTheRules><specref ref="gql_literals"/><itemref ref="gql_tok_nl" type="SR"/>
         </seeTheRules>
      </rhs>
   </BNFdef>
   <BNFdef name="edge synonym">
      <rhs>
         <alt>
            <kw>EDGE</kw>
         </alt>
         <alt>
            <kw>RELATIONSHIP</kw>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="edges synonym">
      <rhs>
         <alt>
            <kw>EDGES</kw>
         </alt>
         <alt>
            <kw>RELATIONSHIPS</kw>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="node synonym">
      <rhs>
         <alt>
            <kw>NODE</kw>
         </alt>
         <alt>
            <kw>VERTEX</kw>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="implies">
      <rhs>
         <alt>
            <BNF name="right double arrow"/>
         </alt>
         <alt>
            <kw>IMPLIES</kw>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="GQL terminal character">
      <rhs>
         <alt>
            <BNF name="GQL language character"/>
         </alt>
         <alt>
            <BNF name="other language character"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="GQL language character">
      <rhs>
         <alt>
            <BNF name="simple Latin letter"/>
         </alt>
         <alt>
            <BNF name="digit"/>
         </alt>
         <alt>
            <BNF name="GQL special character"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="simple Latin letter">
      <rhs>
         <alt>
            <BNF name="simple Latin lower-case letter"/>
         </alt>
         <alt>
            <BNF name="simple Latin upper-case letter"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="simple Latin lower-case letter">
      <rhs>
         <alt>
            <terminalsymbol>a</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>b</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>c</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>d</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>e</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>f</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>g</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>h</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>i</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>j</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>k</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>l</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>m</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>n</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>o</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>p</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>q</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>r</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>s</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>t</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>u</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>v</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>w</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>x</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>y</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>z</terminalsymbol>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="simple Latin upper-case letter">
      <rhs>
         <alt>
            <terminalsymbol>A</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>B</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>C</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>D</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>E</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>F</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>G</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>H</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>I</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>J</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>K</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>L</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>M</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>N</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>O</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>P</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>Q</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>R</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>S</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>T</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>U</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>V</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>W</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>X</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>Y</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>Z</terminalsymbol>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="hex digit">
      <rhs>
         <alt>
            <BNF name="standard digit"/>
         </alt>
         <alt>
            <terminalsymbol>A</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>B</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>C</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>D</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>E</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>F</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>a</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>b</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>c</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>d</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>e</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>f</terminalsymbol>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="digit">
      <rhs>
         <alt>
            <BNF name="standard digit"/>
         </alt>
         <alt>
            <BNF name="other digit"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="standard digit">
      <rhs>
         <alt>
            <BNF name="octal digit"/>
         </alt>
         <alt>
            <terminalsymbol>8</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>9</terminalsymbol>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="octal digit">
      <rhs>
         <alt>
            <BNF name="binary digit"/>
         </alt>
         <alt>
            <terminalsymbol>2</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>3</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>4</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>5</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>6</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>7</terminalsymbol>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="binary digit">
      <rhs>
         <alt>
            <terminalsymbol>0</terminalsymbol>
         </alt>
         <alt>
            <terminalsymbol>1</terminalsymbol>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="other digit">
      <rhs>
         <seeTheRules><specref ref="gql_character"/><itemref ref="gql_GQLc_od" type="SR"/>
         </seeTheRules>
      </rhs>
   </BNFdef>
   <BNFdef name="GQL special character">
      <rhs>
         <alt>
            <BNF name="space"/>
         </alt>
         <alt>
            <BNF name="ampersand"/>
         </alt>
         <alt>
            <BNF name="asterisk"/>
         </alt>
         <alt>
            <BNF name="colon"/>
         </alt>
         <alt>
            <BNF name="equals operator"/>
         </alt>
         <alt>
            <BNF name="comma"/>
         </alt>
         <alt>
            <BNF name="commercial at"/>
         </alt>
         <alt>
            <BNF name="dollar sign"/>
         </alt>
         <alt>
            <BNF name="double quote"/>
         </alt>
         <alt>
            <BNF name="exclamation mark"/>
         </alt>
         <alt>
            <BNF name="grave accent"/>
         </alt>
         <alt>
            <BNF name="right angle bracket"/>
         </alt>
         <alt>
            <BNF name="left brace"/>
         </alt>
         <alt>
            <BNF name="left bracket"/>
         </alt>
         <alt>
            <BNF name="left paren"/>
         </alt>
         <alt>
            <BNF name="left angle bracket"/>
         </alt>
         <alt>
            <BNF name="minus sign"/>
         </alt>
         <alt>
            <BNF name="period"/>
         </alt>
         <alt>
            <BNF name="plus sign"/>
         </alt>
         <alt>
            <BNF name="question mark"/>
         </alt>
         <alt>
            <BNF name="quote"/>
         </alt>
         <alt>
            <BNF name="reverse solidus"/>
         </alt>
         <alt>
            <BNF name="right brace"/>
         </alt>
         <alt>
            <BNF name="right bracket"/>
         </alt>
         <alt>
            <BNF name="right paren"/>
         </alt>
         <alt>
            <BNF name="solidus"/>
         </alt>
         <alt>
            <BNF name="underscore"/>
         </alt>
         <alt>
            <BNF name="vertical bar"/>
         </alt>
         <alt>
            <BNF name="percent"/>
         </alt>
         <alt>
            <BNF name="tilde"/>
         </alt>
      </rhs>
   </BNFdef>
   <BNFdef name="space">
      <rhs>
         <terminalsymbol unicode="0020">&nbsp;</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="ampersand">
      <rhs>
         <terminalsymbol unicode="0026">&amp;</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="asterisk">
      <rhs>
         <terminalsymbol unicode="002A">*</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="colon">
      <rhs>
         <terminalsymbol unicode="003A">:</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="comma">
      <rhs>
         <terminalsymbol unicode="002C">,</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="commercial at">
      <rhs>
         <terminalsymbol unicode="0040">@</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="dollar sign">
      <rhs>
         <terminalsymbol unicode="0024">$</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="double quote">
      <rhs>
         <terminalsymbol unicode="0022">"</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="equals operator">
      <rhs>
         <terminalsymbol unicode="003D">=</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="exclamation mark">
      <rhs>
         <terminalsymbol unicode="0021">!</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="right angle bracket">
      <rhs>
         <terminalsymbol unicode="003E">&gt;</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="grave accent">
      <rhs>
         <terminalsymbol unicode="0060">`</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="left brace">
      <rhs>
         <terminalsymbol unicode="007B">{</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="left bracket">
      <rhs>
         <terminalsymbol unicode="005B">[</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="left paren">
      <rhs>
         <terminalsymbol unicode="0028">(</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="left angle bracket">
      <rhs>
         <terminalsymbol unicode="003C">&lt;</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="minus sign">
      <rhs>
         <terminalsymbol unicode="002D">-</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="percent">
      <rhs>
         <terminalsymbol unicode="0025">%</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="period">
      <rhs>
         <terminalsymbol unicode="002E">.</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="plus sign">
      <rhs>
         <terminalsymbol unicode="002B">+</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="question mark">
      <rhs>
         <terminalsymbol unicode="003F">?</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="quote">
      <rhs>
         <terminalsymbol unicode="0027">&apos;</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="reverse solidus">
      <rhs>
         <terminalsymbol unicode="005C">\</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="right brace">
      <rhs>
         <terminalsymbol unicode="007D">}</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="right bracket">
      <rhs>
         <terminalsymbol unicode="005D">]</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="right paren">
      <rhs>
         <terminalsymbol unicode="0029">)</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="solidus">
      <rhs>
         <terminalsymbol unicode="002F">/</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="tilde">
      <rhs>
         <terminalsymbol unicode="007E">~</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="underscore">
      <rhs>
         <terminalsymbol unicode="005F">_</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="vertical bar">
      <rhs>
         <terminalsymbol unicode="007C">|</terminalsymbol>
      </rhs>
   </BNFdef>
   <BNFdef name="other language character">
      <rhs>
         <seeTheRules><specref ref="gql_character"/><itemref ref="gql_GQLc_olc" type="SR"/>
         </seeTheRules>
      </rhs>
   </BNFdef>
</grammar>

</bodyMatter>

</annex>


<bibliography id="gql_bibliography">

<comment>WG3:W23-014</comment>
<referencedDocument id="Unicode36"/>

<comment>WG3:W23-014</comment>
<referencedDocument id="CVE-2021-42574"/>

</bibliography>

</backMatter>

<index/>

<!-- Include the Editor Notes file here -->
&ednotes;

</standard>